{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364",
    "id": 53087534,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTMwODc1MzQ=",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/364.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/364.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/364",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/364/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
    "number": 364,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "JNI rebased",
    "user": {
      "login": "greenaddress",
      "id": 5269298,
      "node_id": "MDQ6VXNlcjUyNjkyOTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/greenaddress",
      "html_url": "https://github.com/greenaddress",
      "followers_url": "https://api.github.com/users/greenaddress/followers",
      "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
      "organizations_url": "https://api.github.com/users/greenaddress/orgs",
      "repos_url": "https://api.github.com/users/greenaddress/repos",
      "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/greenaddress/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is another continuation of #64 and #248 implementing JNI library for secp256k1, rebased to master.\n\nAlso it includes a fix for a bug we noticed while including it in GreenBits - buffers were overflowing if two different functions were called consecutively with the second one needing more buffer space.\n",
    "labels": [],
    "created_at": "2015-12-09T08:04:22Z",
    "updated_at": "2016-04-27T10:14:01Z",
    "closed_at": "2016-02-16T19:34:35Z",
    "mergeable_state": "unknown",
    "merged_at": "2016-02-16T19:34:35Z",
    "merge_commit_sha": "daf7063856fefd2ac984eb720cce8ea249f4506c",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "greenaddress:jni-rebased",
      "ref": "jni-rebased",
      "sha": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "user": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 44805627,
        "node_id": "MDEwOlJlcG9zaXRvcnk0NDgwNTYyNw==",
        "name": "secp256k1",
        "full_name": "greenaddress/secp256k1",
        "owner": {
          "login": "greenaddress",
          "id": 5269298,
          "node_id": "MDQ6VXNlcjUyNjkyOTg=",
          "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/greenaddress",
          "html_url": "https://github.com/greenaddress",
          "followers_url": "https://api.github.com/users/greenaddress/followers",
          "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
          "organizations_url": "https://api.github.com/users/greenaddress/orgs",
          "repos_url": "https://api.github.com/users/greenaddress/repos",
          "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/greenaddress/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/greenaddress/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/greenaddress/secp256k1",
        "archive_url": "https://api.github.com/repos/greenaddress/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/greenaddress/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/greenaddress/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/greenaddress/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/greenaddress/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/greenaddress/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/greenaddress/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/greenaddress/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/greenaddress/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/greenaddress/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/greenaddress/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/greenaddress/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/greenaddress/secp256k1/events",
        "forks_url": "https://api.github.com/repos/greenaddress/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/greenaddress/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/greenaddress/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/greenaddress/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/greenaddress/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/greenaddress/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/greenaddress/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/greenaddress/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/greenaddress/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/greenaddress/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/greenaddress/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/greenaddress/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/greenaddress/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/greenaddress/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/greenaddress/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/greenaddress/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:greenaddress/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/greenaddress/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/greenaddress/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/greenaddress/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/greenaddress/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/greenaddress/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/greenaddress/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/greenaddress/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/greenaddress/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/greenaddress/secp256k1/hooks",
        "svn_url": "https://github.com/greenaddress/secp256k1",
        "language": "C",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 1698,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2016-05-08T23:52:26Z",
        "created_at": "2015-10-23T10:14:56Z",
        "updated_at": "2016-04-22T16:21:51Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "bd2895fdd92d4dcb0360181082a8d7d078518162",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 962,
        "stargazers_count": 1802,
        "watchers_count": 1802,
        "size": 10374,
        "default_branch": "master",
        "open_issues_count": 145,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-01T01:00:35Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2023-08-01T08:52:35Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 1490,
    "deletions": 46,
    "changed_files": 13,
    "commits": 2,
    "review_comments": 11,
    "comments": 6
  },
  "events": [
    {
      "event": "commented",
      "id": 163391215,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2MzM5MTIxNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/163391215",
      "actor": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-09T21:04:10Z",
      "updated_at": "2015-12-09T21:04:10Z",
      "author_association": "NONE",
      "body": "Thanks for pulling this forward and testing. It looks like Travis is still having a few problems in picking up the jni object, but I'm going to close my original PR in favor of this, as its rebased and tests are passing (running make check-java) locally at least\n",
      "user": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#issuecomment-163391215",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/364"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-09T21:05:06Z",
      "updated_at": "2015-12-09T21:05:06Z",
      "source": {
        "issue": {
          "id": 74245156,
          "node_id": "MDExOlB1bGxSZXF1ZXN0MzQ5ODI2NDY=",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/248",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/248/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/248/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/248/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/pull/248",
          "number": 248,
          "state": "closed",
          "state_reason": null,
          "title": "libsecp256k1_jni shared lib (continued)",
          "body": "This is a continuation of #64 where @theuni proposed expansions to the JNI shared lib, several improvements have been added to the PR. With @theuni 's efforts, we've expanded the original featureset to include:\n\n*Makefile support for the JNI library\n*Tests + harness\n*sign/verify/create support\n*Travis buildbot support\n\nA note: I'm still working on expanding this, with several function implementations listed `TODO` and support for thread synchronization needed as well. I'm opening this here to keep the discussion moving from #64 and to be able to close that stale thread.\n\nFrom the latter part of #64, I was addressing concerns on ignoring the retValue which I believe are now fixed by passing a jObjectArray (a 2d byte array) into the Java side, extracting the hex value and performing a final assert (never exposing this to the user) @ https://github.com/bitcoin/secp256k1/commit/3ce6181d94bae5984cc53fe40bc4629cb0087ec0\n\nedit: I haven't squashed this yet since its a WIP, technically, but I could do that once things settle a bit more and we get closer to a merge.\n",
          "user": {
            "login": "ghost",
            "id": 10137,
            "node_id": "MDQ6VXNlcjEwMTM3",
            "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ghost",
            "html_url": "https://github.com/ghost",
            "followers_url": "https://api.github.com/users/ghost/followers",
            "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
            "organizations_url": "https://api.github.com/users/ghost/orgs",
            "repos_url": "https://api.github.com/users/ghost/repos",
            "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/ghost/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones/1",
            "html_url": "https://github.com/bitcoin-core/secp256k1/milestone/1",
            "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones/1/labels",
            "id": 1276306,
            "node_id": "MDk6TWlsZXN0b25lMTI3NjMwNg==",
            "number": 1,
            "state": "open",
            "title": "stable release (1.0.0-rc.1)",
            "description": "Motivation: libsecp is already widely used today, but often in a terribly outdated version. It's likely that a release process would help with that. Moreover, it simplifies using libsecp which may prevent developers from using less well tested alternatives. Lastly, without releases it's difficult to update the library in an organized fashion and communicate these updates.\r\n\r\nRelease Goals:\r\n\r\n- Stabilize API and documentation for functionality that exist today.\r\n- Fix a few known bugs.\r\n- Make ECDH non-experimental.\r\n\r\nThis milestone can be discussed in issue https://github.com/bitcoin-core/secp256k1/issues/286.",
            "creator": {
              "login": "gmaxwell",
              "id": 858454,
              "node_id": "MDQ6VXNlcjg1ODQ1NA==",
              "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/gmaxwell",
              "html_url": "https://github.com/gmaxwell",
              "followers_url": "https://api.github.com/users/gmaxwell/followers",
              "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
              "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
              "repos_url": "https://api.github.com/users/gmaxwell/repos",
              "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 12,
            "closed_issues": 26,
            "created_at": "2015-08-27T18:21:31Z",
            "updated_at": "2023-04-10T15:36:41Z"
          },
          "locked": false,
          "comments": 17,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/248",
            "html_url": "https://github.com/bitcoin-core/secp256k1/pull/248",
            "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/248.diff",
            "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/248.patch"
          },
          "closed_at": "2015-12-09T21:05:06Z",
          "created_at": "2015-05-08T06:04:27Z",
          "updated_at": "2015-12-09T21:05:06Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 164198719,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDE5ODcxOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/164198719",
      "actor": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-12T22:20:17Z",
      "updated_at": "2015-12-12T22:20:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "@faizkhan00 thank you and @theuni (and anyone else involved I missed) for the work done thus far.\n\ntests are passing locally but there seems to be a race condition in make where by the shared library is not fully linked by the time the test starts (but strangely only in travis, we can't reproduce locally) - looks like we need to fix the dependency\n\nwe tried to fix that and failed (we are not too strong on makefiles) so we asked @theuni and he suggested he may have a look at this at some point but anyone with any input is welcome\n",
      "user": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#issuecomment-164198719",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/364"
    },
    {
      "event": "mentioned",
      "id": 490215869,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDkwMjE1ODY5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/490215869",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-12T22:20:17Z"
    },
    {
      "event": "subscribed",
      "id": 490215870,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ5MDIxNTg3MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/490215870",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-12T22:20:17Z"
    },
    {
      "event": "mentioned",
      "id": 490215871,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDkwMjE1ODcx",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/490215871",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-12T22:20:17Z"
    },
    {
      "event": "subscribed",
      "id": 490215872,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ5MDIxNTg3Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/490215872",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-12T22:20:17Z"
    },
    {
      "event": "commented",
      "id": 164607573,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDYwNzU3Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/164607573",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-15T00:56:35Z",
      "updated_at": "2015-12-15T00:56:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "@greenaddress Sorry for not getting to this at the meetup as promised, I kept getting pulled away.\n\nAnyway, that's probably for the best. This turned out to be non-trivial to track down, and not build-system related at all.\n\nSee the top few commits here for the fix: https://github.com/theuni/secp256k1/commits/jni-test\n\ntl;dr: JNIEXPORT on some Java versions (the one Travis uses by default, at least) is busted wrt symbol visibility.\n",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#issuecomment-164607573",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/364"
    },
    {
      "event": "mentioned",
      "id": 491684664,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDkxNjg0NjY0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/491684664",
      "actor": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-15T00:56:35Z"
    },
    {
      "event": "subscribed",
      "id": 491684665,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ5MTY4NDY2NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/491684665",
      "actor": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-15T00:56:35Z"
    },
    {
      "event": "commented",
      "id": 164713080,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDcxMzA4MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/164713080",
      "actor": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-15T10:15:41Z",
      "updated_at": "2015-12-15T10:15:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "@theuni no worries! Cheers for finding the actual source of the problem! \n",
      "user": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#issuecomment-164713080",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/364"
    },
    {
      "event": "mentioned",
      "id": 492042357,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDkyMDQyMzU3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/492042357",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-15T10:15:41Z"
    },
    {
      "event": "subscribed",
      "id": 492042358,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ5MjA0MjM1OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/492042358",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-15T10:15:41Z"
    },
    {
      "event": "commented",
      "id": 164906811,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDkwNjgxMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/164906811",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-15T21:44:39Z",
      "updated_at": "2015-12-15T21:44:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK, but can you rebase and squash the fixups?\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#issuecomment-164906811",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/364"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 493361502,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDkzMzYxNTAy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/493361502",
      "actor": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-16T11:37:42Z"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNzQ4OTE6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNzQ4OTM6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNzQ4OTU6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNzQ4OTc6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNzQ4OTg6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNzQ4OTk6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNzQ5MDA6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "mentioned",
      "id": 494015216,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDk0MDE1MjE2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/494015216",
      "actor": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-16T21:38:27Z"
    },
    {
      "event": "subscribed",
      "id": 494015218,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ5NDAxNTIxOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/494015218",
      "actor": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-16T21:38:27Z"
    },
    {
      "event": "mentioned",
      "id": 494050954,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDk0MDUwOTU0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/494050954",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-16T22:11:14Z"
    },
    {
      "event": "subscribed",
      "id": 494050955,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ5NDA1MDk1NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/494050955",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-16T22:11:14Z"
    },
    {
      "event": "mentioned",
      "id": 494050956,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDk0MDUwOTU2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/494050956",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-16T22:11:14Z"
    },
    {
      "event": "subscribed",
      "id": 494050957,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ5NDA1MDk1Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/494050957",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-16T22:11:14Z"
    },
    {
      "event": "mentioned",
      "id": 494050958,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDk0MDUwOTU4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/494050958",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-16T22:11:14Z"
    },
    {
      "event": "subscribed",
      "id": 494050959,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ5NDA1MDk1OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/494050959",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-16T22:11:14Z"
    },
    {
      "event": "mentioned",
      "id": 528671914,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NTI4NjcxOTE0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/528671914",
      "actor": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-01-27T20:00:26Z"
    },
    {
      "event": "subscribed",
      "id": 528671916,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDUyODY3MTkxNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/528671916",
      "actor": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-01-27T20:00:26Z"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNzQ5MDM6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MzA5MzU3NmFhNDVhZmYwNzJjMTUwYWNkODE5OWM0MWQyMGMxMGQ1NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3093576aa45aff072c150acd8199c41d20c10d54",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3093576aa45aff072c150acd8199c41d20c10d54",
      "tree": {
        "sha": "e43e8e3d5563d90735de238cc84d3e613be117e1",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e43e8e3d5563d90735de238cc84d3e613be117e1"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/bd2895fdd92d4dcb0360181082a8d7d078518162",
          "sha": "bd2895fdd92d4dcb0360181082a8d7d078518162",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/bd2895fdd92d4dcb0360181082a8d7d078518162"
        }
      ],
      "message": "JNI library\n\nSquashed and rebased. Thanks to @theuni and @faizkhan00 for doing\nthe majority of work here! Also thanks to @btchip for help with debugging\nand review.",
      "committer": {
        "name": "Jerzy Kozera",
        "email": "jerzy.kozera@gmail.com",
        "date": "2016-02-01T13:07:18Z"
      },
      "author": {
        "name": "GreenAddress",
        "email": "info@greenaddress.it",
        "date": "2014-12-17T03:23:17Z"
      },
      "sha": "3093576aa45aff072c150acd8199c41d20c10d54"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6ODZlMmQwN2U0YzFmNDVjMWEyZTU5NGZmNWQ1ZTc0YjA0YmM4MDg3ZA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "tree": {
        "sha": "5f8bf9974727cfb148db4b2679171da2732e55e6",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/5f8bf9974727cfb148db4b2679171da2732e55e6"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3093576aa45aff072c150acd8199c41d20c10d54",
          "sha": "3093576aa45aff072c150acd8199c41d20c10d54",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3093576aa45aff072c150acd8199c41d20c10d54"
        }
      ],
      "message": "JNI library: cleanup, removed unimplemented code",
      "committer": {
        "name": "Jerzy Kozera",
        "email": "jerzy.kozera@gmail.com",
        "date": "2016-02-01T13:07:29Z"
      },
      "author": {
        "name": "GreenAddress",
        "email": "info@greenaddress.it",
        "date": "2016-02-01T12:37:33Z"
      },
      "sha": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 534151315,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NTM0MTUxMzE1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/534151315",
      "actor": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-02-01T13:09:57Z"
    },
    {
      "event": "commented",
      "id": 177966795,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE3Nzk2Njc5NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/177966795",
      "actor": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-02-01T13:10:01Z",
      "updated_at": "2016-02-01T13:10:01Z",
      "author_association": "CONTRIBUTOR",
      "body": "`secp256k1_ecdsa_recover` was not implemented in org_bitcoin_NativeSecp256k1.c, hence the TODO and commented out code.\n\nI've now removed the unimplemented and commented parts and cleaned it up in general. I think it's reasonable to keep these two commits for future reference, in case someone wants to look up the incomplete implementations in git history.\n",
      "user": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#issuecomment-177966795",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/364"
    },
    {
      "event": "merged",
      "id": 552535698,
      "node_id": "MDExOk1lcmdlZEV2ZW50NTUyNTM1Njk4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/552535698",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "created_at": "2016-02-16T19:34:35Z"
    },
    {
      "event": "closed",
      "id": 552535699,
      "node_id": "MDExOkNsb3NlZEV2ZW50NTUyNTM1Njk5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/552535699",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-02-16T19:34:35Z"
    },
    {
      "event": "referenced",
      "id": 552535711,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDU1MjUzNTcxMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/552535711",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "e4570184ffba0794dee0dd6f5d76d4edeb50fa0d",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/e4570184ffba0794dee0dd6f5d76d4edeb50fa0d",
      "created_at": "2016-02-16T19:34:36Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-03-02T13:06:47Z",
      "updated_at": "2016-03-02T13:06:47Z",
      "source": {
        "issue": {
          "id": 137869125,
          "node_id": "MDU6SXNzdWUxMzc4NjkxMjU=",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/379",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/379/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/379/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/379/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/issues/379",
          "number": 379,
          "state": "closed",
          "state_reason": "completed",
          "title": "Minor issue in automatic enabling of JNI build",
          "body": "I came across this last night and it took a little tracking down. Since introducing #364, the build system will automatically determine whether JNI can be built. If the environment supports it, the java library is built, but without checking if the necessary modules are also being compiled. \n\nMy situation was: only build the library with the pubkey recovery module and install it, compile my bindings for another language.. I ran into a `configure` error that no usable version of libsecp256k1 could be found. I could coax things to compile all the same (run configure first against bd2895fd - the commit before JNI) but  using my bindings resulted in an error that `secp256k1_schnorr` wasn't found. \n\nMy bindings didn't have this dependency previously, nor did the default install presume that all modules were to be compiled, so something about JNI building/requiring everything seemed to lead to this. \n\nTo fix this, I had to disable JNI, or enable every module to satisfy the JNI libraries dependencies. \n",
          "user": {
            "login": "afk11",
            "id": 5617245,
            "node_id": "MDQ6VXNlcjU2MTcyNDU=",
            "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/afk11",
            "html_url": "https://github.com/afk11",
            "followers_url": "https://api.github.com/users/afk11/followers",
            "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
            "organizations_url": "https://api.github.com/users/afk11/orgs",
            "repos_url": "https://api.github.com/users/afk11/repos",
            "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/afk11/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 0,
          "closed_at": "2020-02-10T11:01:30Z",
          "created_at": "2016-03-02T13:06:47Z",
          "updated_at": "2020-02-10T11:01:30Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-11-28T05:18:18Z",
      "updated_at": "2016-11-28T05:18:18Z",
      "source": {
        "issue": {
          "id": 42941267,
          "node_id": "MDU6SXNzdWU0Mjk0MTI2Nw==",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/63",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/63/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/63/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/63/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/issues/63",
          "number": 63,
          "state": "closed",
          "state_reason": "completed",
          "title": "Is there an option to create a shared library for Java applications?",
          "body": "It seems there used to be a make target to create a shared library for native use in Bitcoinj (make libjavasecp256k1.so) some time ago, but the latest repo seems to only create a static library. Is there a way to create a shared library that can be used for Java applications?\n",
          "user": {
            "login": "fatefree",
            "id": 1325467,
            "node_id": "MDQ6VXNlcjEzMjU0Njc=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1325467?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/fatefree",
            "html_url": "https://github.com/fatefree",
            "followers_url": "https://api.github.com/users/fatefree/followers",
            "following_url": "https://api.github.com/users/fatefree/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/fatefree/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/fatefree/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/fatefree/subscriptions",
            "organizations_url": "https://api.github.com/users/fatefree/orgs",
            "repos_url": "https://api.github.com/users/fatefree/repos",
            "events_url": "https://api.github.com/users/fatefree/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/fatefree/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 6,
          "closed_at": "2016-11-28T05:18:18Z",
          "created_at": "2014-09-16T22:26:47Z",
          "updated_at": "2016-11-28T05:18:18Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "subscribed",
      "id": 8123633661,
      "node_id": "SE_lADOAP4Jqs4HORylzwAAAAHkNM_9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8123633661",
      "actor": {
        "login": "Yeti978",
        "id": 109617884,
        "node_id": "U_kgDOBoii3A",
        "avatar_url": "https://avatars.githubusercontent.com/u/109617884?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Yeti978",
        "html_url": "https://github.com/Yeti978",
        "followers_url": "https://api.github.com/users/Yeti978/followers",
        "following_url": "https://api.github.com/users/Yeti978/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Yeti978/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Yeti978/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Yeti978/subscriptions",
        "organizations_url": "https://api.github.com/users/Yeti978/orgs",
        "repos_url": "https://api.github.com/users/Yeti978/repos",
        "events_url": "https://api.github.com/users/Yeti978/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Yeti978/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-28T23:54:41Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827360",
      "pull_request_review_id": null,
      "id": 47827360,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3MzYw",
      "diff_hunk": "@@ -12,49 +15,737 @@\n  * https://github.com/sipa/secp256k1\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * recover the given secp256k1 pubkey in native code.\n+     *\n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param compressed whether to recover a compressed pubkey\n+     * @param pub The public key which did the signing\n+     */\n+    //TODO recoverCompact()\n+    public static byte[] recoverCompact(byte[] data, byte[] signature,int compressed, int recID) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && signature.length == 64 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 64) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 64);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(signature);\n+\n+        byte[][] retByteArray = null;//secp256k1_ecdsa_recover_compact(byteBuff, Secp256k1Context, compressed, recID);\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad signature length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");",
      "path": "src/java/org/bitcoin/NativeSecp256k1.java",
      "position": null,
      "original_position": 102,
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "original_commit_id": "0a30103b1e7c8aceacadeecdd1e90b4759a2acbb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This function can legitimately return 0, if the passed signature's R coordinate does not correspond to a point on the curve (around 50% chance for arbitrary byte arrays).\n",
      "created_at": "2015-12-16T20:11:49Z",
      "updated_at": "2016-02-01T13:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#discussion_r47827360",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827590",
      "pull_request_review_id": null,
      "id": 47827590,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3NTkw",
      "diff_hunk": "@@ -12,49 +15,737 @@\n  * https://github.com/sipa/secp256k1\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * recover the given secp256k1 pubkey in native code.\n+     *\n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param compressed whether to recover a compressed pubkey\n+     * @param pub The public key which did the signing\n+     */\n+    //TODO recoverCompact()\n+    public static byte[] recoverCompact(byte[] data, byte[] signature,int compressed, int recID) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && signature.length == 64 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 64) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 64);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(signature);\n+\n+        byte[][] retByteArray = null;//secp256k1_ecdsa_recover_compact(byteBuff, Secp256k1Context, compressed, recID);\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad signature length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     * @param compressed 1 to return compressed key, 0 for uncompressed",
      "path": "src/java/org/bitcoin/NativeSecp256k1.java",
      "position": null,
      "original_position": 179,
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "original_commit_id": "0a30103b1e7c8aceacadeecdd1e90b4759a2acbb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Seems unimplemented.\n",
      "created_at": "2015-12-16T20:13:50Z",
      "updated_at": "2016-02-01T13:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#discussion_r47827590",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827656",
      "pull_request_review_id": null,
      "id": 47827656,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3NjU2",
      "diff_hunk": "@@ -12,49 +15,737 @@\n  * https://github.com/sipa/secp256k1\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * recover the given secp256k1 pubkey in native code.\n+     *\n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param compressed whether to recover a compressed pubkey\n+     * @param pub The public key which did the signing\n+     */\n+    //TODO recoverCompact()\n+    public static byte[] recoverCompact(byte[] data, byte[] signature,int compressed, int recID) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && signature.length == 64 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 64) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 64);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(signature);\n+\n+        byte[][] retByteArray = null;//secp256k1_ecdsa_recover_compact(byteBuff, Secp256k1Context, compressed, recID);\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad signature length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     * @param compressed 1 to return compressed key, 0 for uncompressed\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+\n+    //TODO support 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Secret Key Import - Import a secret key in DER format.\n+     *\n+     * @param seckey DER Sec key\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] secKeyImport(byte[] seckey) throws AssertFailException{\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_import(byteBuff,Secp256k1Context.getContext(), seckey.length);",
      "path": "src/java/org/bitcoin/NativeSecp256k1.java",
      "position": null,
      "original_position": 250,
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "original_commit_id": "0a30103b1e7c8aceacadeecdd1e90b4759a2acbb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think that function still exists.\n",
      "created_at": "2015-12-16T20:14:16Z",
      "updated_at": "2016-02-01T13:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#discussion_r47827656",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827853",
      "pull_request_review_id": null,
      "id": 47827853,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3ODUz",
      "diff_hunk": "@@ -12,49 +15,737 @@\n  * https://github.com/sipa/secp256k1\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * recover the given secp256k1 pubkey in native code.\n+     *\n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param compressed whether to recover a compressed pubkey\n+     * @param pub The public key which did the signing\n+     */\n+    //TODO recoverCompact()\n+    public static byte[] recoverCompact(byte[] data, byte[] signature,int compressed, int recID) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && signature.length == 64 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 64) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 64);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(signature);\n+\n+        byte[][] retByteArray = null;//secp256k1_ecdsa_recover_compact(byteBuff, Secp256k1Context, compressed, recID);\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad signature length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     * @param compressed 1 to return compressed key, 0 for uncompressed\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+\n+    //TODO support 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Secret Key Import - Import a secret key in DER format.\n+     *\n+     * @param seckey DER Sec key\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] secKeyImport(byte[] seckey) throws AssertFailException{\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_import(byteBuff,Secp256k1Context.getContext(), seckey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Private Key Export - Export a private key in DER format.\n+     *\n+     * @param seckey ECDSA Sec key, 33 or 65 bytes\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] privKeyExport(byte[] privkey, int compressed) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_export(byteBuff, Secp256k1Context.getContext(), privkey.length, compressed);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, compressed == 1 ? 214 : 279, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");",
      "path": "src/java/org/bitcoin/NativeSecp256k1.java",
      "position": 236,
      "original_position": 385,
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "original_commit_id": "0a30103b1e7c8aceacadeecdd1e90b4759a2acbb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This function can legitimately fail (though only in adverserial or very unlikely conditions).\n",
      "created_at": "2015-12-16T20:15:57Z",
      "updated_at": "2016-02-01T13:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#discussion_r47827853",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827853"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 253,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827945",
      "pull_request_review_id": null,
      "id": 47827945,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3OTQ1",
      "diff_hunk": "@@ -12,49 +15,737 @@\n  * https://github.com/sipa/secp256k1\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * recover the given secp256k1 pubkey in native code.\n+     *\n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param compressed whether to recover a compressed pubkey\n+     * @param pub The public key which did the signing\n+     */\n+    //TODO recoverCompact()\n+    public static byte[] recoverCompact(byte[] data, byte[] signature,int compressed, int recID) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && signature.length == 64 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 64) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 64);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(signature);\n+\n+        byte[][] retByteArray = null;//secp256k1_ecdsa_recover_compact(byteBuff, Secp256k1Context, compressed, recID);\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad signature length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     * @param compressed 1 to return compressed key, 0 for uncompressed\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+\n+    //TODO support 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Secret Key Import - Import a secret key in DER format.\n+     *\n+     * @param seckey DER Sec key\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] secKeyImport(byte[] seckey) throws AssertFailException{\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_import(byteBuff,Secp256k1Context.getContext(), seckey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Private Key Export - Export a private key in DER format.\n+     *\n+     * @param seckey ECDSA Sec key, 33 or 65 bytes\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] privKeyExport(byte[] privkey, int compressed) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_export(byteBuff, Secp256k1Context.getContext(), privkey.length, compressed);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, compressed == 1 ? 214 : 279, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 create ECDH secret - constant time ECDH calculation",
      "path": "src/java/org/bitcoin/NativeSecp256k1.java",
      "position": 359,
      "original_position": 469,
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "original_commit_id": "0a30103b1e7c8aceacadeecdd1e90b4759a2acbb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Does not match the name of the function below.\n",
      "created_at": "2015-12-16T20:16:31Z",
      "updated_at": "2016-02-01T13:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#discussion_r47827945",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827945"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 337,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827975",
      "pull_request_review_id": null,
      "id": 47827975,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3OTc1",
      "diff_hunk": "@@ -12,49 +15,737 @@\n  * https://github.com/sipa/secp256k1\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * recover the given secp256k1 pubkey in native code.\n+     *\n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param compressed whether to recover a compressed pubkey\n+     * @param pub The public key which did the signing\n+     */\n+    //TODO recoverCompact()\n+    public static byte[] recoverCompact(byte[] data, byte[] signature,int compressed, int recID) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && signature.length == 64 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 64) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 64);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(signature);\n+\n+        byte[][] retByteArray = null;//secp256k1_ecdsa_recover_compact(byteBuff, Secp256k1Context, compressed, recID);\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad signature length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     * @param compressed 1 to return compressed key, 0 for uncompressed\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+\n+    //TODO support 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Secret Key Import - Import a secret key in DER format.\n+     *\n+     * @param seckey DER Sec key\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] secKeyImport(byte[] seckey) throws AssertFailException{\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_import(byteBuff,Secp256k1Context.getContext(), seckey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Private Key Export - Export a private key in DER format.\n+     *\n+     * @param seckey ECDSA Sec key, 33 or 65 bytes\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] privKeyExport(byte[] privkey, int compressed) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_export(byteBuff, Secp256k1Context.getContext(), privkey.length, compressed);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, compressed == 1 ? 214 : 279, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n+     *\n+     * @param seckey byte array of secret key used in exponentiaion\n+     * @param pubkey byte array of public key used in exponentiaion\n+     */\n+    //TODO schnorrSign, schnoorVerify, schnorrRecover()\n+    public static byte[] schnoorOps(byte[] pubkey, byte[] msg32) throws AssertFailException{",
      "path": "src/java/org/bitcoin/NativeSecp256k1.java",
      "position": null,
      "original_position": 475,
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "original_commit_id": "0a30103b1e7c8aceacadeecdd1e90b4759a2acbb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Name is wrong (Schnorr, nor Schnoor).\n",
      "created_at": "2015-12-16T20:16:46Z",
      "updated_at": "2016-02-01T13:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#discussion_r47827975",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47827975"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47828014",
      "pull_request_review_id": null,
      "id": 47828014,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4MDE0",
      "diff_hunk": "@@ -12,49 +15,737 @@\n  * https://github.com/sipa/secp256k1\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * recover the given secp256k1 pubkey in native code.\n+     *\n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param compressed whether to recover a compressed pubkey\n+     * @param pub The public key which did the signing\n+     */\n+    //TODO recoverCompact()\n+    public static byte[] recoverCompact(byte[] data, byte[] signature,int compressed, int recID) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && signature.length == 64 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 64) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 64);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(signature);\n+\n+        byte[][] retByteArray = null;//secp256k1_ecdsa_recover_compact(byteBuff, Secp256k1Context, compressed, recID);\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad signature length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     * @param compressed 1 to return compressed key, 0 for uncompressed\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+\n+    //TODO support 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Secret Key Import - Import a secret key in DER format.\n+     *\n+     * @param seckey DER Sec key\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] secKeyImport(byte[] seckey) throws AssertFailException{\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_import(byteBuff,Secp256k1Context.getContext(), seckey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Private Key Export - Export a private key in DER format.\n+     *\n+     * @param seckey ECDSA Sec key, 33 or 65 bytes\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] privKeyExport(byte[] privkey, int compressed) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_export(byteBuff, Secp256k1Context.getContext(), privkey.length, compressed);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, compressed == 1 ? 214 : 279, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n+     *\n+     * @param seckey byte array of secret key used in exponentiaion\n+     * @param pubkey byte array of public key used in exponentiaion\n+     */\n+    //TODO schnorrSign, schnoorVerify, schnorrRecover()\n+    public static byte[] schnoorOps(byte[] pubkey, byte[] msg32) throws AssertFailException{\n+/*\n+        Preconditions.checkArgument(msg32.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkeys.length * 65) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkeys.length * 65);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_recover(byteBuff,Secp256k1Context.getContext(), pubkey.length);",
      "path": "src/java/org/bitcoin/NativeSecp256k1.java",
      "position": null,
      "original_position": 491,
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "original_commit_id": "0a30103b1e7c8aceacadeecdd1e90b4759a2acbb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why all this commented-out code?\n",
      "created_at": "2015-12-16T20:17:09Z",
      "updated_at": "2016-02-01T13:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#discussion_r47828014",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47828014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47837581",
      "pull_request_review_id": null,
      "id": 47837581,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3NTgx",
      "diff_hunk": "@@ -12,49 +15,737 @@\n  * https://github.com/sipa/secp256k1\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * recover the given secp256k1 pubkey in native code.\n+     *\n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param compressed whether to recover a compressed pubkey\n+     * @param pub The public key which did the signing\n+     */\n+    //TODO recoverCompact()\n+    public static byte[] recoverCompact(byte[] data, byte[] signature,int compressed, int recID) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && signature.length == 64 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 64) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 64);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(signature);\n+\n+        byte[][] retByteArray = null;//secp256k1_ecdsa_recover_compact(byteBuff, Secp256k1Context, compressed, recID);\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad signature length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     * @param compressed 1 to return compressed key, 0 for uncompressed\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+\n+    //TODO support 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Secret Key Import - Import a secret key in DER format.\n+     *\n+     * @param seckey DER Sec key\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] secKeyImport(byte[] seckey) throws AssertFailException{\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_import(byteBuff,Secp256k1Context.getContext(), seckey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Private Key Export - Export a private key in DER format.\n+     *\n+     * @param seckey ECDSA Sec key, 33 or 65 bytes\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] privKeyExport(byte[] privkey, int compressed) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_export(byteBuff, Secp256k1Context.getContext(), privkey.length, compressed);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, compressed == 1 ? 214 : 279, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n+     *\n+     * @param seckey byte array of secret key used in exponentiaion\n+     * @param pubkey byte array of public key used in exponentiaion\n+     */\n+    //TODO schnorrSign, schnoorVerify, schnorrRecover()\n+    public static byte[] schnoorOps(byte[] pubkey, byte[] msg32) throws AssertFailException{\n+/*\n+        Preconditions.checkArgument(msg32.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkeys.length * 65) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkeys.length * 65);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_recover(byteBuff,Secp256k1Context.getContext(), pubkey.length);",
      "path": "src/java/org/bitcoin/NativeSecp256k1.java",
      "position": null,
      "original_position": 491,
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "original_commit_id": "0a30103b1e7c8aceacadeecdd1e90b4759a2acbb",
      "in_reply_to_id": null,
      "user": null,
      "body": "When @greenaddress opened the PR, I definitely can say it was unfinished (not covering 100% of the secp256k1 headers) but I had intended to cover that. Depending on if @greenaddress was planning on completeing the coverage, I'd be happy to contribute the rest of the code as well (as a patch if desired)\n",
      "created_at": "2015-12-16T21:38:27Z",
      "updated_at": "2016-02-01T13:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#discussion_r47837581",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47837581"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47841590",
      "pull_request_review_id": null,
      "id": 47841590,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQxNTkw",
      "diff_hunk": "@@ -12,49 +15,737 @@\n  * https://github.com/sipa/secp256k1\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * recover the given secp256k1 pubkey in native code.\n+     *\n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param compressed whether to recover a compressed pubkey\n+     * @param pub The public key which did the signing\n+     */\n+    //TODO recoverCompact()\n+    public static byte[] recoverCompact(byte[] data, byte[] signature,int compressed, int recID) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && signature.length == 64 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 64) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 64);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(signature);\n+\n+        byte[][] retByteArray = null;//secp256k1_ecdsa_recover_compact(byteBuff, Secp256k1Context, compressed, recID);\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad signature length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     * @param compressed 1 to return compressed key, 0 for uncompressed\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+\n+    //TODO support 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Secret Key Import - Import a secret key in DER format.\n+     *\n+     * @param seckey DER Sec key\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] secKeyImport(byte[] seckey) throws AssertFailException{\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_import(byteBuff,Secp256k1Context.getContext(), seckey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Private Key Export - Export a private key in DER format.\n+     *\n+     * @param seckey ECDSA Sec key, 33 or 65 bytes\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] privKeyExport(byte[] privkey, int compressed) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_export(byteBuff, Secp256k1Context.getContext(), privkey.length, compressed);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, compressed == 1 ? 214 : 279, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n+     *\n+     * @param seckey byte array of secret key used in exponentiaion\n+     * @param pubkey byte array of public key used in exponentiaion\n+     */\n+    //TODO schnorrSign, schnoorVerify, schnorrRecover()\n+    public static byte[] schnoorOps(byte[] pubkey, byte[] msg32) throws AssertFailException{\n+/*\n+        Preconditions.checkArgument(msg32.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkeys.length * 65) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkeys.length * 65);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_recover(byteBuff,Secp256k1Context.getContext(), pubkey.length);",
      "path": "src/java/org/bitcoin/NativeSecp256k1.java",
      "position": null,
      "original_position": 491,
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "original_commit_id": "0a30103b1e7c8aceacadeecdd1e90b4759a2acbb",
      "in_reply_to_id": null,
      "user": {
        "login": "greenaddress",
        "id": 5269298,
        "node_id": "MDQ6VXNlcjUyNjkyOTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5269298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/greenaddress",
        "html_url": "https://github.com/greenaddress",
        "followers_url": "https://api.github.com/users/greenaddress/followers",
        "following_url": "https://api.github.com/users/greenaddress/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/greenaddress/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/greenaddress/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/greenaddress/subscriptions",
        "organizations_url": "https://api.github.com/users/greenaddress/orgs",
        "repos_url": "https://api.github.com/users/greenaddress/repos",
        "events_url": "https://api.github.com/users/greenaddress/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/greenaddress/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": " @sipa as you say the work is not complete, it doesn't cover all functions yet but the aim is to have all of them.\n\nwe plan to do more towards completing coverage but would be great to work together with @faizkhan00 (and @theuni) to finish it.\n\nwe currently have pedersen_blind_sum, pedersen_commit and rangeproof_sign in the works\n",
      "created_at": "2015-12-16T22:11:14Z",
      "updated_at": "2016-02-01T13:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#discussion_r47841590",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/47841590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/51041222",
      "pull_request_review_id": null,
      "id": 51041222,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMjIy",
      "diff_hunk": "@@ -12,49 +15,737 @@\n  * https://github.com/sipa/secp256k1\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * recover the given secp256k1 pubkey in native code.\n+     *\n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param compressed whether to recover a compressed pubkey\n+     * @param pub The public key which did the signing\n+     */\n+    //TODO recoverCompact()\n+    public static byte[] recoverCompact(byte[] data, byte[] signature,int compressed, int recID) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && signature.length == 64 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 64) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 64);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(signature);\n+\n+        byte[][] retByteArray = null;//secp256k1_ecdsa_recover_compact(byteBuff, Secp256k1Context, compressed, recID);\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad signature length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     * @param compressed 1 to return compressed key, 0 for uncompressed\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+\n+    //TODO support 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Secret Key Import - Import a secret key in DER format.\n+     *\n+     * @param seckey DER Sec key\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] secKeyImport(byte[] seckey) throws AssertFailException{\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_import(byteBuff,Secp256k1Context.getContext(), seckey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Private Key Export - Export a private key in DER format.\n+     *\n+     * @param seckey ECDSA Sec key, 33 or 65 bytes\n+     * @param compressed Compressed format\n+     */\n+    public static byte[] privKeyExport(byte[] privkey, int compressed) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32 && (compressed == 0 || compressed == 1));\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_privkey_export(byteBuff, Secp256k1Context.getContext(), privkey.length, compressed);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, compressed == 1 ? 214 : 279, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n+     *\n+     * @param seckey byte array of secret key used in exponentiaion\n+     * @param pubkey byte array of public key used in exponentiaion\n+     */\n+    //TODO schnorrSign, schnoorVerify, schnorrRecover()\n+    public static byte[] schnoorOps(byte[] pubkey, byte[] msg32) throws AssertFailException{\n+/*\n+        Preconditions.checkArgument(msg32.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkeys.length * 65) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkeys.length * 65);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_recover(byteBuff,Secp256k1Context.getContext(), pubkey.length);",
      "path": "src/java/org/bitcoin/NativeSecp256k1.java",
      "position": null,
      "original_position": 491,
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "original_commit_id": "0a30103b1e7c8aceacadeecdd1e90b4759a2acbb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@greenaddress I'm very interested in that work, but it shouldn't go into the main library's commit history. Please clean things up.\n",
      "created_at": "2016-01-27T20:00:26Z",
      "updated_at": "2016-02-01T13:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#discussion_r51041222",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/51041222"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/51041885",
      "pull_request_review_id": null,
      "id": 51041885,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxODg1",
      "diff_hunk": "@@ -12,49 +15,737 @@\n  * https://github.com/sipa/secp256k1\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * recover the given secp256k1 pubkey in native code.\n+     *\n+     * @param data The data which was signed, must be exactly 32 bytes\n+     * @param signature The signature\n+     * @param compressed whether to recover a compressed pubkey\n+     * @param pub The public key which did the signing\n+     */\n+    //TODO recoverCompact()",
      "path": "src/java/org/bitcoin/NativeSecp256k1.java",
      "position": null,
      "original_position": 80,
      "commit_id": "86e2d07e4c1f45c1a2e594ff5d5e74b04bc8087d",
      "original_commit_id": "0a30103b1e7c8aceacadeecdd1e90b4759a2acbb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What's TODO about it?\n",
      "created_at": "2016-01-27T20:05:41Z",
      "updated_at": "2016-02-01T13:09:57Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/364#discussion_r51041885",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/51041885"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/364"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    }
  ]
}