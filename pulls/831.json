{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831",
    "id": 501259702,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTAxMjU5NzAy",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/831.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/831.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/24ad04fc064e71abdf973e061c30eb1f3f78db39",
    "number": 831,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Safegcd inverses, drop Jacobi symbols, remove libgmp",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is a rebased and squashed version of #767, adding safegcd-based implementations of constant-time and variable-time modular inverses for scalars and field elements, by Peter Dettman. The PR is organized as follows:\r\n* **Add secp256k1_ctz{32,64}_var functions** Introduction of ctz functions to util.h (which use `__builtin_ctz` on recent GCC and Clang, but fall back to using a software emulation using de Bruijn on other platforms). This isn't used anywhere in this commit, but does include tests.\r\n* **Add safegcd based modular inverse modules** Add Peter Dettman's safegcd code from #767 (without some of his optimizations, which are moved to later commits), turned into separate modules by me.\r\n* **Add extensive comments on the safegcd algorithm and implementation** Add a long description of the algorithm and optimizations to `doc/safegcd_implementation.md`, as well as additional comments to the code itself. It is probably best to review this together with the previous commit (they're separated to keep authorship).\r\n* **Add tests for modinv modules** Adds tests on the modinv interface directly, for arbitrary moduli.\r\n* **Improve bounds checks in modinv modules** Adds a lot of sanity checking to the modinv modules.\r\n* **Move secp256k1_scalar_{inverse{_var},is_even} to per-impl files** A pure refactor to prepare for switching the field and scalar code to modinv.\r\n* **Make field/scalar code use the new modinv modules for inverses** Actually switch over.\r\n* **Add extra modular inverse tests** This adds modular inverse tests through the field/scalar interface, now that those use modinv.\r\n* **Remove unused Jacobi symbol support** No longer needed.\r\n* **Remove num/gmp support** Bye-bye.\r\n* 3 commits with further optimizations.\r\n",
    "labels": [],
    "created_at": "2020-10-12T02:37:19Z",
    "updated_at": "2021-03-18T00:04:27Z",
    "closed_at": "2021-03-18T00:04:27Z",
    "mergeable_state": "unknown",
    "merged_at": "2021-03-18T00:04:26Z",
    "merge_commit_sha": "26de4dfeb1f1436dae1fcf17f57bdaa43540f940",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "sipa:202010_pr767",
      "ref": "202010_pr767",
      "sha": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 16648672,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODY3Mg==",
        "name": "secp256k1",
        "full_name": "sipa/secp256k1",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/secp256k1",
        "archive_url": "https://api.github.com/repos/sipa/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/sipa/secp256k1/events",
        "forks_url": "https://api.github.com/repos/sipa/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/sipa/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/sipa/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/sipa/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/sipa/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/sipa/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/sipa/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/sipa/secp256k1/hooks",
        "svn_url": "https://github.com/sipa/secp256k1",
        "language": "C",
        "forks_count": 20,
        "stargazers_count": 43,
        "watchers_count": 43,
        "size": 11649,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-07-09T03:46:04Z",
        "created_at": "2014-02-08T17:33:30Z",
        "updated_at": "2023-05-11T11:08:51Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "4c3ba88c3a869ae3f45990286c79860539a5bff8",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 962,
        "stargazers_count": 1802,
        "watchers_count": 1802,
        "size": 10374,
        "default_branch": "master",
        "open_issues_count": 145,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-01T01:00:35Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2023-08-01T08:52:35Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 3049,
    "deletions": 1650,
    "changed_files": 34,
    "commits": 16,
    "review_comments": 129,
    "comments": 55
  },
  "events": [
    {
      "event": "commented",
      "id": 706822638,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwNjgyMjYzOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/706822638",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-12T02:38:24Z",
      "updated_at": "2020-10-12T03:05:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "Ping @peterdettman \r\n\r\nI made the following change to avoid signed overflow:\r\n\r\n```patch\r\ndiff --git a/src/field_10x26_impl.h b/src/field_10x26_impl.h\r\nindex d5ff75c..a2c16a6 100644\r\n--- a/src/field_10x26_impl.h\r\n+++ b/src/field_10x26_impl.h\r\n@@ -1362,7 +1362,7 @@ static void secp256k1_fe_update_de_30(int32_t *d, int32_t *e, const int32_t *t)\r\n     /* P == 2^256 - 2^32 - C30 */\r\n     const int64_t C30 = 0x3D1L;\r\n     /* I30 == -P^-1 mod 2^30 */\r\n-    const int32_t I30 = 0x12253531L;\r\n+    const uint32_t I30 = 0x12253531L;\r\n     const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\r\n     const int32_t u = t[0], v = t[1], q = t[2], r = t[3];\r\n     int32_t di, ei, md, me;\r\n@@ -1377,8 +1377,8 @@ static void secp256k1_fe_update_de_30(int32_t *d, int32_t *e, const int32_t *t)\r\n \r\n     /* Calculate the multiples of P to add, to zero the 30 bottom bits. We choose md, me\r\n      * from the centred range [-2^29, 2^29) to keep d, e within [-2^256, 2^256). */\r\n-    md = (I30 * 4 * (int32_t)cd) >> 2;\r\n-    me = (I30 * 4 * (int32_t)ce) >> 2;\r\n+    md = ((int32_t)(I30 * 4 * (uint32_t)cd)) >> 2;\r\n+    me = ((int32_t)(I30 * 4 * (uint32_t)ce)) >> 2;\r\n \r\n     cd -= (int64_t)C30 * md;\r\n     ce -= (int64_t)C30 * me;\r\ndiff --git a/src/field_5x52_impl.h b/src/field_5x52_impl.h\r\nindex 2e81fc2..8f7d290 100644\r\n--- a/src/field_5x52_impl.h\r\n+++ b/src/field_5x52_impl.h\r\n@@ -663,7 +663,7 @@ static void secp256k1_fe_update_de_62(int64_t *d, int64_t *e, const int64_t *t)\r\n     /* P == 2^256 - C62 */\r\n     const int64_t C62 = 0x1000003D1LL;\r\n     /* I62 == -P^-1 mod 2^62 */\r\n-    const int64_t I62 = 0x1838091DD2253531LL;\r\n+    const uint64_t I62 = 0x1838091DD2253531LL;\r\n     const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\r\n     const int64_t d0 = d[0], d1 = d[1], d2 = d[2], d3 = d[3], d4 = d[4];\r\n     const int64_t e0 = e[0], e1 = e[1], e2 = e[2], e3 = e[3], e4 = e[4];\r\n@@ -676,8 +676,8 @@ static void secp256k1_fe_update_de_62(int64_t *d, int64_t *e, const int64_t *t)\r\n \r\n     /* Calculate the multiples of P to add, to zero the 62 bottom bits. We choose md, me\r\n      * from the centred range [-2^61, 2^61) to keep d, e within [-2^256, 2^256). */\r\n-    md = (I62 * 4 * (int64_t)cd) >> 2;\r\n-    me = (I62 * 4 * (int64_t)ce) >> 2;\r\n+    md = ((int64_t)(I62 * 4 * (uint64_t)cd)) >> 2;\r\n+    me = ((int64_t)(I62 * 4 * (uint64_t)ce)) >> 2;\r\n \r\n     cd -= (int128_t)C62 * md;\r\n     ce -= (int128_t)C62 * me;\r\ndiff --git a/src/scalar_4x64_impl.h b/src/scalar_4x64_impl.h\r\nindex 5dfa742..b649928 100644\r\n--- a/src/scalar_4x64_impl.h\r\n+++ b/src/scalar_4x64_impl.h\r\n@@ -1113,7 +1113,7 @@ static uint64_t secp256k1_scalar_divsteps_62_var(uint64_t eta, uint64_t f0, uint\r\n static void secp256k1_scalar_update_de_62(int64_t *d, int64_t *e, const int64_t *t) {\r\n \r\n     /* I62 == -P^-1 mod 2^62 */\r\n-    const int64_t I62 = 0x0B0DFF665588B13FLL;\r\n+    const uint64_t I62 = 0x0B0DFF665588B13FLL;\r\n     const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\r\n     const int64_t P[5] = { 0x3FD25E8CD0364141LL, 0x2ABB739ABD2280EELL, -0x15LL, 0, 256 };\r\n     const int64_t d0 = d[0], d1 = d[1], d2 = d[2], d3 = d[3], d4 = d[4];\r\n@@ -1127,8 +1127,8 @@ static void secp256k1_scalar_update_de_62(int64_t *d, int64_t *e, const int64_t\r\n \r\n     /* Calculate the multiples of P to add, to zero the 62 bottom bits. We choose md, me\r\n      * from the centred range [-2^61, 2^61) to keep d, e within [-2^256, 2^256). */\r\n-    md = (I62 * 4 * (int64_t)cd) >> 2;\r\n-    me = (I62 * 4 * (int64_t)ce) >> 2;\r\n+    md = ((int64_t)(I62 * 4 * (uint64_t)cd)) >> 2;\r\n+    me = ((int64_t)(I62 * 4 * (uint64_t)ce)) >> 2;\r\n \r\n     cd += (int128_t)P[0] * md;\r\n     ce += (int128_t)P[0] * me;\r\ndiff --git a/src/scalar_8x32_impl.h b/src/scalar_8x32_impl.h\r\nindex 40fcaf7..66c4494 100644\r\n--- a/src/scalar_8x32_impl.h\r\n+++ b/src/scalar_8x32_impl.h\r\n@@ -914,7 +914,7 @@ static uint32_t secp256k1_scalar_divsteps_30_var(uint32_t eta, uint32_t f0, uint\r\n static void secp256k1_scalar_update_de_30(int32_t *d, int32_t *e, const int32_t *t) {\r\n \r\n     /* I30 == -P^-1 mod 2^30 */\r\n-    const int32_t I30 = 0x1588B13FL;\r\n+    const uint32_t I30 = 0x1588B13FL;\r\n     const int32_t P[9] = { 0x10364141L, 0x3F497A33L, 0x348A03BBL, 0x2BB739ABL, -0x146L,\r\n         0, 0, 0, 65536 };\r\n     const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\r\n@@ -930,8 +930,8 @@ static void secp256k1_scalar_update_de_30(int32_t *d, int32_t *e, const int32_t\r\n \r\n     /* Calculate the multiples of P to add, to zero the 30 bottom bits. We choose md, me\r\n      * from the centred range [-2^29, 2^29) to keep d, e within [-2^256, 2^256). */\r\n-    md = (I30 * 4 * (int32_t)cd) >> 2;\r\n-    me = (I30 * 4 * (int32_t)ce) >> 2;\r\n+    md = ((int32_t)(I30 * 4 * (uint32_t)cd)) >> 2;\r\n+    me = ((int32_t)(I30 * 4 * (uint32_t)ce)) >> 2;\r\n \r\n     cd += (int64_t)P[0] * md;\r\n     ce += (int64_t)P[0] * me;\r\n```\r\n\r\nWith that, all tests pass when compiled with `-ftrapv` or `-fsanitize=undefined`.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-706822638",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 3864437436,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50Mzg2NDQzNzQzNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3864437436",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-12T02:38:24Z"
    },
    {
      "event": "subscribed",
      "id": 3864437439,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM4NjQ0Mzc0Mzk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3864437439",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-12T02:38:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3864472032,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg2NDQ3MjAzMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3864472032",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-12T02:59:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3864479779,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg2NDQ3OTc3OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3864479779",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-12T03:03:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3865101440,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg2NTEwMTQ0MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3865101440",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-12T07:13:57Z"
    },
    {
      "event": "renamed",
      "id": 3865184376,
      "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50Mzg2NTE4NDM3Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3865184376",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-12T07:33:00Z",
      "rename": {
        "from": "Safegcd inverses, drop Jacobi symbols, remove libgmp dependency",
        "to": "Safegcd inverses, drop Jacobi symbols, remove libgmp"
      }
    },
    {
      "event": "convert_to_draft",
      "id": 3865194916,
      "node_id": "MDE5OkNvbnZlcnRUb0RyYWZ0RXZlbnQzODY1MTk0OTE2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3865194916",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-12T07:35:36Z"
    },
    {
      "event": "commented",
      "id": 706937961,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwNjkzNzk2MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/706937961",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-12T07:38:11Z",
      "updated_at": "2020-10-12T07:38:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "I want to rework this a bit still, introducing structs for the signed-limb and transformation-matrix for clarify, and adding comments to explain my own understanding. Marking as draft for now, but it can be built/benchmarked/tested already.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-706937961",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-12T07:39:02Z",
      "updated_at": "2020-10-12T07:39:02Z",
      "source": {
        "issue": {
          "id": 657151921,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NDQ5MzE4NDIx",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/767",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/767/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/767/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/767/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/pull/767",
          "number": 767,
          "state": "closed",
          "state_reason": null,
          "title": "WIP: \"safegcd\" field and scalar inversion",
          "body": "- see \"Fast constant-time gcd computation and modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang https://gcd.cr.yp.to\r\n\r\nImplements constant-time field and scalar inversion using a Euclidean-style algorithm operating on the least-significant bits. It follows the curve25519 case study as outlined in section 12 of the above paper, with some small tweaks. ~~I do not have the actual curve25519 code to compare to, but this PR appears to be already 15-20% faster than their reported 10050 haswell cycles for field inversion.~~ Actually, this initial measurement was in error, but we did reach 5-10% faster in the end, without any asm.\r\n\r\nPerformance comparison (gcc 10.1.0, -O3, haswell, endo=yes, asm=no, field=64bit scalar=64bit):\r\n\r\nmaster:\r\nscalar_inverse: min 12.4us\r\nfield_inverse: min 5.04us\r\necdh: min 59.7us\r\necdsa_sign: min 47.9us\r\n\r\nsafegcd_inv:\r\nscalar_inverse: min 3.45us\r\nfield_inverse: min 3.23us\r\necdh: min 56.2us \r\necdsa_sign: min 37.7us\r\n\r\nI've not done a 32bit version yet, although it is mostly analogous and should have an even greater relative advantage over Fermat. The field and scalar implementations have substantial common code that is duplicated here for simplicity.",
          "user": {
            "login": "peterdettman",
            "id": 3423981,
            "node_id": "MDQ6VXNlcjM0MjM5ODE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/peterdettman",
            "html_url": "https://github.com/peterdettman",
            "followers_url": "https://api.github.com/users/peterdettman/followers",
            "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
            "organizations_url": "https://api.github.com/users/peterdettman/orgs",
            "repos_url": "https://api.github.com/users/peterdettman/repos",
            "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/peterdettman/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 159,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/767",
            "html_url": "https://github.com/bitcoin-core/secp256k1/pull/767",
            "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/767.diff",
            "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/767.patch"
          },
          "closed_at": "2021-01-30T08:05:02Z",
          "created_at": "2020-07-15T08:08:12Z",
          "updated_at": "2021-01-30T13:29:00Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 507221672,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MjIxNjcy",
      "url": null,
      "actor": null,
      "commit_id": "4ad49c8aab9afba2a6f3aba3f311fd6c27642bb5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-507221672",
      "submitted_at": "2020-10-13T09:04:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3874750471,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg3NDc1MDQ3MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3874750471",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-14T05:28:39Z"
    },
    {
      "event": "commented",
      "id": 708166698,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwODE2NjY5OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/708166698",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-14T05:31:27Z",
      "updated_at": "2020-10-14T05:31:27Z",
      "author_association": "CONTRIBUTOR",
      "body": "I added a commit that introduces shared modinv* files with the bulk of the algorithm, which is then used by both scalar and field code. I measure around a 1% slowdown for the variable-time versions, but a 2% speedup for the constant-time version with this (?!).\r\n\r\nI'd be interested to hear what benchmarks others see with/without the last commit.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-708166698",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 708191845,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwODE5MTg0NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/708191845",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-14T06:35:16Z",
      "updated_at": "2020-10-14T06:35:16Z",
      "author_association": "CONTRIBUTOR",
      "body": "(only testing 64bit) I see very little change apart from field_inverse getting noticeably slower (4%), which is presumably down to no longer having the nice prime shape baked in to _update_de_62.",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-708191845",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "reviewed",
      "id": 508034302,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MDM0MzAy",
      "url": null,
      "actor": null,
      "commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-508034302",
      "submitted_at": "2020-10-14T06:37:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "reviewed",
      "id": 508040738,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MDQwNzM4",
      "url": null,
      "actor": null,
      "commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-508040738",
      "submitted_at": "2020-10-14T06:49:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "commented",
      "id": 708231937,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwODIzMTkzNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/708231937",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-14T08:00:22Z",
      "updated_at": "2020-10-14T08:00:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "@peterdettman Oh, I see - you're saying that these aren't invariants that hold for all signed62 values; of course. This _verify function is a bit of a leftover - it should just be inlined back into the _from_signedXX functions, as that's where this strict condition is required. An internal _verify function may be helpful too, but would need to be less strict.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-708231937",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 3875238532,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50Mzg3NTIzODUzMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3875238532",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-14T08:00:22Z"
    },
    {
      "event": "subscribed",
      "id": 3875238544,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM4NzUyMzg1NDQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/3875238544",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-14T08:00:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4044604780,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA0NDYwNDc4MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4044604780",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-27T05:15:34Z"
    },
    {
      "event": "ready_for_review",
      "id": 4044605690,
      "node_id": "MDE5OlJlYWR5Rm9yUmV2aWV3RXZlbnQ0MDQ0NjA1Njkw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4044605690",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-27T05:16:03Z"
    },
    {
      "event": "commented",
      "id": 734649330,
      "node_id": "MDEyOklzc3VlQ29tbWVudDczNDY0OTMzMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/734649330",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-27T05:19:43Z",
      "updated_at": "2020-11-27T05:19:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased on top of the endomorphism changes, included the recent fixes from https://github.com/sipa/secp256k1/pull/6, squashed the implementation commits, removed the `_verify` functions that were misleading, and marked as ready for review.\r\n\r\nI'd like to make a few more changes, adding checks for the ranges of variables and additional comments, but if someone is interested I think this is pretty close to done otherwise.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-734649330",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 734995721,
      "node_id": "MDEyOklzc3VlQ29tbWVudDczNDk5NTcyMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/734995721",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-27T21:40:54Z",
      "updated_at": "2020-11-27T21:44:09Z",
      "author_association": "CONTRIBUTOR",
      "body": "@peterdettman I had to make these additional changes to satisfy ubsan (they were actually invoking UB, I believe):\r\n\r\n```diff\r\ndiff --git a/src/modinv32.h b/src/modinv32.h\r\nindex 74fc3fd8..d46447b1 100644\r\n--- a/src/modinv32.h\r\n+++ b/src/modinv32.h\r\n@@ -22,7 +22,7 @@ typedef struct {\r\n     secp256k1_modinv32_signed30 modulus;\r\n \r\n     /* modulus^{-1} mod 2^30 */\r\n-    int32_t modulus_inv30;\r\n+    uint32_t modulus_inv30;\r\n } secp256k1_modinv32_modinfo;\r\n \r\n static void secp256k1_modinv32(secp256k1_modinv32_signed30 *x, const secp256k1_modinv32_modinfo *modinfo);\r\ndiff --git a/src/modinv32_impl.h b/src/modinv32_impl.h\r\nindex 2cd65557..a15bd2f9 100644\r\n--- a/src/modinv32_impl.h\r\n+++ b/src/modinv32_impl.h\r\n@@ -201,8 +201,8 @@ static void secp256k1_modinv32_update_de_30(secp256k1_modinv32_signed30 *d, secp\r\n      * the range (-2.P, P), consistent with the input constraint.\r\n      */\r\n \r\n-    md -= (modinfo->modulus_inv30 * (int32_t)cd + md) & M30;\r\n-    me -= (modinfo->modulus_inv30 * (int32_t)ce + me) & M30;\r\n+    md -= (modinfo->modulus_inv30 * (uint32_t)cd + md) & M30;\r\n+    me -= (modinfo->modulus_inv30 * (uint32_t)ce + me) & M30;\r\n \r\n     /* The modulus has to be odd, so we can assume it is nonzero. */\r\n     cd += (int64_t)modinfo->modulus.v[0] * md;\r\n@@ -380,8 +380,8 @@ static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256\r\n         cond |= gn ^ (gn >> 31);\r\n \r\n         if (cond == 0) {\r\n-            f.v[len - 2] |= fn << 30;\r\n-            g.v[len - 2] |= gn << 30;\r\n+            f.v[len - 2] |= (uint32_t)fn << 30;\r\n+            g.v[len - 2] |= (uint32_t)gn << 30;\r\n             --len;\r\n         }\r\n     }\r\ndiff --git a/src/modinv64.h b/src/modinv64.h\r\nindex caff6f5a..6fea9651 100644\r\n--- a/src/modinv64.h\r\n+++ b/src/modinv64.h\r\n@@ -26,7 +26,7 @@ typedef struct {\r\n     secp256k1_modinv64_signed62 modulus;\r\n \r\n     /* modulus^{-1} mod 2^62 */\r\n-    int64_t modulus_inv62;\r\n+    uint64_t modulus_inv62;\r\n } secp256k1_modinv64_modinfo;\r\n \r\n static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo);\r\ndiff --git a/src/modinv64_impl.h b/src/modinv64_impl.h\r\nindex ebf1fe7f..7ce6c909 100644\r\n--- a/src/modinv64_impl.h\r\n+++ b/src/modinv64_impl.h\r\n@@ -177,8 +177,8 @@ static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp\r\n      * the range (-2.P, P), consistent with the input constraint.\r\n...skipping...\r\nindex 2cd65557..a15bd2f9 100644\r\n--- a/src/modinv32_impl.h\r\n+++ b/src/modinv32_impl.h\r\n@@ -201,8 +201,8 @@ static void secp256k1_modinv32_update_de_30(secp256k1_modinv32_signed30 *d, secp\r\n      * the range (-2.P, P), consistent with the input constraint.\r\n      */\r\n \r\n-    md -= (modinfo->modulus_inv30 * (int32_t)cd + md) & M30;\r\n-    me -= (modinfo->modulus_inv30 * (int32_t)ce + me) & M30;\r\n+    md -= (modinfo->modulus_inv30 * (uint32_t)cd + md) & M30;\r\n+    me -= (modinfo->modulus_inv30 * (uint32_t)ce + me) & M30;\r\n \r\n     /* The modulus has to be odd, so we can assume it is nonzero. */\r\n     cd += (int64_t)modinfo->modulus.v[0] * md;\r\n@@ -380,8 +380,8 @@ static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256\r\n         cond |= gn ^ (gn >> 31);\r\n \r\n         if (cond == 0) {\r\n-            f.v[len - 2] |= fn << 30;\r\n-            g.v[len - 2] |= gn << 30;\r\n+            f.v[len - 2] |= (uint32_t)fn << 30;\r\n+            g.v[len - 2] |= (uint32_t)gn << 30;\r\n             --len;\r\n         }\r\n     }\r\ndiff --git a/src/modinv64.h b/src/modinv64.h\r\nindex caff6f5a..6fea9651 100644\r\n--- a/src/modinv64.h\r\n+++ b/src/modinv64.h\r\n@@ -26,7 +26,7 @@ typedef struct {\r\n     secp256k1_modinv64_signed62 modulus;\r\n \r\n     /* modulus^{-1} mod 2^62 */\r\n-    int64_t modulus_inv62;\r\n+    uint64_t modulus_inv62;\r\n } secp256k1_modinv64_modinfo;\r\n \r\n static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo);\r\ndiff --git a/src/modinv64_impl.h b/src/modinv64_impl.h\r\nindex ebf1fe7f..7ce6c909 100644\r\n--- a/src/modinv64_impl.h\r\n+++ b/src/modinv64_impl.h\r\n@@ -177,8 +177,8 @@ static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp\r\n      * the range (-2.P, P), consistent with the input constraint.\r\n      */\r\n \r\n-    md -= (modinfo->modulus_inv62 * (int64_t)cd + md) & M62;\r\n-    me -= (modinfo->modulus_inv62 * (int64_t)ce + me) & M62;\r\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\r\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\r\n \r\n     /* The modulus has to be odd, so we can assume it is nonzero. */\r\n     cd += (int128_t)modinfo->modulus.v[0] * md;\r\n@@ -388,8 +388,8 @@ static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256\r\n         cond |= gn ^ (gn >> 63);\r\n \r\n         if (cond == 0) {\r\n-            f.v[len - 2] |= fn << 62;\r\n-            g.v[len - 2] |= gn << 62;\r\n+            f.v[len - 2] |= (uint64_t)fn << 62;\r\n+            g.v[len - 2] |= (uint64_t)gn << 62;\r\n             --len;\r\n         }\r\n     }\r\n```\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-734995721",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4047354418,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDA0NzM1NDQxOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4047354418",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-27T21:40:54Z"
    },
    {
      "event": "subscribed",
      "id": 4047354421,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQwNDczNTQ0MjE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4047354421",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-27T21:40:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4047522245,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA0NzUyMjI0NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4047522245",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-28T00:40:26Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4047522987,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA0NzUyMjk4Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4047522987",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-28T00:41:28Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4047555498,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA0NzU1NTQ5OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4047555498",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-28T01:30:41Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4047557277,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA0NzU1NzI3Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4047557277",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-28T01:33:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4048429604,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA0ODQyOTYwNA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4048429604",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-28T20:46:14Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4048446879,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA0ODQ0Njg3OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4048446879",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-28T21:13:31Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4048558570,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA0ODU1ODU3MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4048558570",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-29T00:15:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4049496127,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA0OTQ5NjEyNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4049496127",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-11-29T22:23:55Z"
    },
    {
      "event": "reviewed",
      "id": 543505816,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNTA1ODE2",
      "url": null,
      "actor": null,
      "commit_id": "b4721dc00a528df68edd5ccb50d080442e2dd799",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-543505816",
      "submitted_at": "2020-12-03T05:22:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4069720249,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA2OTcyMDI0OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4069720249",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-03T21:12:44Z"
    },
    {
      "event": "commented",
      "id": 738494996,
      "node_id": "MDEyOklzc3VlQ29tbWVudDczODQ5NDk5Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/738494996",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-04T01:32:59Z",
      "updated_at": "2020-12-04T01:43:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "@peterdettman It seems that the bounds on (u,v,q,r) after N divsteps are:\r\n\r\n* u in [-2^(N-2),2^N]\r\n* v in [2-2^(N-2),2^N]\r\n* q in [-2^(N-1),2^N-1]\r\n* r in [1-2^(N-1),2^N-1]\r\n\r\nIf we'd negate those coefficients, 31/63 fit in a single int{32,64}_t transformation matrix. Is there any reason why 30/62 are preferable? For the 32-bit constant time version this gains us one big step. For the variable-time version it may mean doing a group less in some cases.\r\n\r\nSome additional bounds that may help reasoning about ranges:\r\n* u+v in [-2^(N-2),2^N]\r\n* u-v in [-2^N,2^N]\r\n* q+r in [-2^(N-1),2^N]\r\n* q-r in [-2^(N-1),2^N-2]",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-738494996",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4070571057,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDA3MDU3MTA1Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4070571057",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-04T01:32:59Z"
    },
    {
      "event": "subscribed",
      "id": 4070571060,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQwNzA1NzEwNjA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4070571060",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-04T01:32:59Z"
    },
    {
      "event": "commented",
      "id": 738601443,
      "node_id": "MDEyOklzc3VlQ29tbWVudDczODYwMTQ0Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/738601443",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-04T06:46:57Z",
      "updated_at": "2020-12-04T06:46:57Z",
      "author_association": "CONTRIBUTOR",
      "body": "@sipa I personally prefer to start u,v,q,r as -1,0,0,-1 for the nicer bound that it gives (in terms of 2's complement bit length). The original code did this, but we have since put it back to the way the paper presents it. The original code was also attempting to use 31 divsteps in order to save the 1 big step, but I think in several places, particularly _update_de there are going to be overflow problems as the code stands. For myself I'd prefer to bed down the current version and explore that option later, but if anyone can show 31/63-based code that's faster and correct I'm not opposed.",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-738601443",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4071252022,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDA3MTI1MjAyMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4071252022",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-04T06:46:58Z"
    },
    {
      "event": "subscribed",
      "id": 4071252023,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQwNzEyNTIwMjM=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4071252023",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-04T06:46:58Z"
    },
    {
      "event": "commented",
      "id": 738604612,
      "node_id": "MDEyOklzc3VlQ29tbWVudDczODYwNDYxMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/738604612",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-04T06:54:44Z",
      "updated_at": "2020-12-04T07:06:34Z",
      "author_association": "CONTRIBUTOR",
      "body": "@peterdettman Sounds good. The new normalize code also relies on having one slack bit.\r\n\r\nI'm currently working on adding more explicit bounds checking (mostly to convince myself, but I'll try to also document it).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-738604612",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4071273397,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDA3MTI3MzM5Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4071273397",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-04T06:54:44Z"
    },
    {
      "event": "subscribed",
      "id": 4071273401,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQwNzEyNzM0MDE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4071273401",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-04T06:54:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4082316798,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA4MjMxNjc5OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4082316798",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-08T00:41:09Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-08T00:42:03Z",
      "updated_at": "2020-12-08T00:42:03Z",
      "source": {
        "issue": {
          "id": 755857939,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTMxNDk1MzU5",
          "url": "https://api.github.com/repos/sipa/secp256k1/issues/7",
          "repository_url": "https://api.github.com/repos/sipa/secp256k1",
          "labels_url": "https://api.github.com/repos/sipa/secp256k1/issues/7/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/sipa/secp256k1/issues/7/comments",
          "events_url": "https://api.github.com/repos/sipa/secp256k1/issues/7/events",
          "html_url": "https://github.com/sipa/secp256k1/pull/7",
          "number": 7,
          "state": "closed",
          "state_reason": null,
          "title": "Rework _normalize_30/62 methods",
          "body": "",
          "user": {
            "login": "peterdettman",
            "id": 3423981,
            "node_id": "MDQ6VXNlcjM0MjM5ODE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/peterdettman",
            "html_url": "https://github.com/peterdettman",
            "followers_url": "https://api.github.com/users/peterdettman/followers",
            "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
            "organizations_url": "https://api.github.com/users/peterdettman/orgs",
            "repos_url": "https://api.github.com/users/peterdettman/repos",
            "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/peterdettman/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 1,
          "pull_request": {
            "url": "https://api.github.com/repos/sipa/secp256k1/pulls/7",
            "html_url": "https://github.com/sipa/secp256k1/pull/7",
            "diff_url": "https://github.com/sipa/secp256k1/pull/7.diff",
            "patch_url": "https://github.com/sipa/secp256k1/pull/7.patch"
          },
          "closed_at": "2020-12-08T00:42:05Z",
          "created_at": "2020-12-03T05:18:02Z",
          "updated_at": "2020-12-08T00:42:05Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4082919708,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA4MjkxOTcwOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4082919708",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-08T05:22:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4083135200,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA4MzEzNTIwMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4083135200",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-08T06:41:52Z"
    },
    {
      "event": "commented",
      "id": 740448068,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc0MDQ0ODA2OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/740448068",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-08T07:50:15Z",
      "updated_at": "2020-12-08T17:15:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "@peterdettman I've added a commit that adds lots of range checks on the signed62 numbers (just the 64-bit version for now), plus additional comments to explain my understanding of why these bounds hold. I plan on adding more comments, but feel free to see if it's correct so far.\r\n\r\nEDIT: ran 40 million iterations of the unit tests with this, no problem.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-740448068",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4083387954,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDA4MzM4Nzk1NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4083387954",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-08T07:50:15Z"
    },
    {
      "event": "subscribed",
      "id": 4083387960,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQwODMzODc5NjA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4083387960",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-08T07:50:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4088402997,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA4ODQwMjk5Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4088402997",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-09T07:06:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4098492574,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDA5ODQ5MjU3NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4098492574",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-11T05:03:39Z"
    },
    {
      "event": "reviewed",
      "id": 550153531,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMTUzNTMx",
      "url": null,
      "actor": null,
      "commit_id": "cea64c0e8e32997037cab393fdfec0246eb07a71",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "I just looked at the comment explaining the algorithm and with some aid from the paper I am able to (roughly)convince myself that is correct and if it terminates will produce a gcd. \r\n\r\nI still completely grasp why it should terminate, but I think that is outside of the scope of this comment/PR. Your analysis in the convex hull method offers a nice empirical guarantee that it should terminate for all inputs that we care about and it is enough to convince me. \r\n\r\nMaybe I will try to understand the termination proof one day!",
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-550153531",
      "submitted_at": "2020-12-11T15:44:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4105395502,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDEwNTM5NTUwMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4105395502",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-13T02:51:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4105402646,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDEwNTQwMjY0Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4105402646",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-13T02:58:01Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4107142084,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDEwNzE0MjA4NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4107142084",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-14T05:03:22Z"
    },
    {
      "event": "reviewed",
      "id": 551297274,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMjk3Mjc0",
      "url": null,
      "actor": null,
      "commit_id": "96cb1cba4e119a2a99f72a5fcdb6e9725ba81216",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-551297274",
      "submitted_at": "2020-12-14T11:52:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "reviewed",
      "id": 551327322,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMzI3MzIy",
      "url": null,
      "actor": null,
      "commit_id": "96cb1cba4e119a2a99f72a5fcdb6e9725ba81216",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "Reviewed the Avoiding modulus section comment section. \r\n\r\nI wonder how much is it really that expensive to compute `f*d % modulus` compared to other operations in the algorithm? I agree that the current normalization is better than the modulus one, but the description describes that step as \"relatively expensive\" when done generically. \r\n\r\nThe only reason I ask this is that it introduces some reasoning that is not a part of the paper( at least I could not find it). That being said, I am convinced that the values of `d` are indeed in the range as mentioned and the analysis is correct. \r\n\r\nJust curious if our reliance on the extra analysis and (very slight) complexity, but additional complexity compared to the paper is worth it? Or maybe while writing low-level primitives like `modinv`, we should really care about every small-time cost that we can optimize. ",
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-551327322",
      "submitted_at": "2020-12-14T12:57:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4116979255,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDExNjk3OTI1NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4116979255",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-15T22:41:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4116984923,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDExNjk4NDkyMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4116984923",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-15T22:42:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4117560855,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDExNzU2MDg1NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4117560855",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-16T02:44:06Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4117981333,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDExNzk4MTMzMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4117981333",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-16T06:03:24Z"
    },
    {
      "event": "commented",
      "id": 745787733,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc0NTc4NzczMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/745787733",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-16T06:07:23Z",
      "updated_at": "2020-12-21T03:47:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "I think this is ready for review.\r\n\r\nI've significantly expanded the explanation of the algorithm and implementation (see big comment in modinv64_impl.h), including working Python code that demonstrates the full algorithm with all optimizations, except those that depend on number representation.\r\n\r\n@sanket1729 The implementation here differs significantly from the one in the paper in many ways:\r\n* The whole computation of d and e is done very differently, but the approach here is simpler and appears faster. \r\n* All the variable-time code (including the multi-step updates in the matrix computation)\r\n* Eta instead of delta\r\n* The specific bit fiddling logic in the constant-time matrix computation\r\n\r\nI've expanded the explanation a bit to highlight the differences.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-745787733",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4117991886,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDExNzk5MTg4Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4117991886",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-16T06:07:23Z"
    },
    {
      "event": "subscribed",
      "id": 4117991888,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQxMTc5OTE4ODg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4117991888",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-16T06:07:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4117994465,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDExNzk5NDQ2NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4117994465",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-16T06:08:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4121217441,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDEyMTIxNzQ0MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4121217441",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-16T18:42:58Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4123143864,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDEyMzE0Mzg2NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4123143864",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-17T03:49:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4127618774,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDEyNzYxODc3NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4127618774",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-18T00:29:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4128060757,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDEyODA2MDc1Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4128060757",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-18T04:16:58Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4131050223,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDEzMTA1MDIyMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4131050223",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-18T18:51:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4131069099,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDEzMTA2OTA5OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4131069099",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-18T18:56:56Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-22T11:05:51Z",
      "updated_at": "2020-12-22T11:05:51Z",
      "source": {
        "issue": {
          "id": 471416133,
          "node_id": "MDExOlB1bGxSZXF1ZXN0MzAwMDgzODMy",
          "url": "https://api.github.com/repos/rust-bitcoin/rust-secp256k1/issues/132",
          "repository_url": "https://api.github.com/repos/rust-bitcoin/rust-secp256k1",
          "labels_url": "https://api.github.com/repos/rust-bitcoin/rust-secp256k1/issues/132/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/rust-bitcoin/rust-secp256k1/issues/132/comments",
          "events_url": "https://api.github.com/repos/rust-bitcoin/rust-secp256k1/issues/132/events",
          "html_url": "https://github.com/rust-bitcoin/rust-secp256k1/pull/132",
          "number": 132,
          "state": "closed",
          "state_reason": null,
          "title": "Detecting and linking against libgmp",
          "body": "Hi,\r\nI hope this can solve #118\r\n\r\nI try to link against all the default paths I could think of, not sure how important is this but I wanted to try and make it as robust as possible.\r\n\r\n\r\nWould love if people can try and run it on their machines and hopefully also machines *without* gmp to make sure it works correctly.\r\n\r\n\r\nFYI I ran some benchmarks:\r\nwithout gmp:\r\n```\r\ntest benches::bench_sign       ... bench:      37,741 ns/iter (+/- 2,715)\r\ntest benches::bench_verify     ... bench:      56,191 ns/iter (+/- 1,943)\r\ntest benches::generate         ... bench:      22,192 ns/iter (+/- 1,482)\r\ntest ecdh::benches::bench_ecdh ... bench:      61,198 ns/iter (+/- 3,360)\r\n\r\n\r\ntest benches::bench_sign       ... bench:      37,081 ns/iter (+/- 4,044)\r\ntest benches::bench_verify     ... bench:      58,233 ns/iter (+/- 2,599)\r\ntest benches::generate         ... bench:      22,114 ns/iter (+/- 946)\r\ntest ecdh::benches::bench_ecdh ... bench:      61,475 ns/iter (+/- 3,203)\r\n```\r\n\r\nwith gmp:\r\n```\r\ntest benches::bench_sign       ... bench:      39,418 ns/iter (+/- 2,815)\r\ntest benches::bench_verify     ... bench:      49,183 ns/iter (+/- 1,411)\r\ntest benches::generate         ... bench:      22,517 ns/iter (+/- 390)\r\ntest ecdh::benches::bench_ecdh ... bench:      61,905 ns/iter (+/- 1,251)\r\n\r\ntest benches::bench_sign       ... bench:      38,450 ns/iter (+/- 3,045)\r\ntest benches::bench_verify     ... bench:      49,546 ns/iter (+/- 1,447)\r\ntest benches::generate         ... bench:      22,758 ns/iter (+/- 3,818)\r\ntest ecdh::benches::bench_ecdh ... bench:      61,198 ns/iter (+/- 1,918)\r\n\r\ntest benches::bench_sign       ... bench:      38,054 ns/iter (+/- 3,151)\r\ntest benches::bench_verify     ... bench:      48,028 ns/iter (+/- 738)\r\ntest benches::generate         ... bench:      22,130 ns/iter (+/- 901)\r\ntest ecdh::benches::bench_ecdh ... bench:      61,243 ns/iter (+/- 741)\r\n```\r\n\r\nlooks like ~15% improvement in verification time.\r\n\r\ncc @apoelstra ",
          "user": {
            "login": "elichai",
            "id": 2167860,
            "node_id": "MDQ6VXNlcjIxNjc4NjA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/elichai",
            "html_url": "https://github.com/elichai",
            "followers_url": "https://api.github.com/users/elichai/followers",
            "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
            "organizations_url": "https://api.github.com/users/elichai/orgs",
            "repos_url": "https://api.github.com/users/elichai/repos",
            "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/elichai/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 12,
          "pull_request": {
            "url": "https://api.github.com/repos/rust-bitcoin/rust-secp256k1/pulls/132",
            "html_url": "https://github.com/rust-bitcoin/rust-secp256k1/pull/132",
            "diff_url": "https://github.com/rust-bitcoin/rust-secp256k1/pull/132.diff",
            "patch_url": "https://github.com/rust-bitcoin/rust-secp256k1/pull/132.patch"
          },
          "closed_at": "2020-12-22T11:05:56Z",
          "created_at": "2019-07-23T00:15:04Z",
          "updated_at": "2020-12-22T11:05:56Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4142660951,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE0MjY2MDk1MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4142660951",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-23T04:50:06Z"
    },
    {
      "event": "commented",
      "id": 749931358,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc0OTkzMTM1OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/749931358",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-23T04:53:29Z",
      "updated_at": "2020-12-23T04:53:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "Added an extra commit that adds tests of the modinv functions themselves (as opposed to the existing tests that only exercise the field_inv and scalar_inv interface). Also added more bounds checking (it now deals with variable-length numbers correctly, and verifies f=+-1 and g=0).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-749931358",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4142799411,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE0Mjc5OTQxMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4142799411",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-23T06:03:20Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4145313937,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE0NTMxMzkzNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4145313937",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-23T19:38:23Z"
    },
    {
      "event": "comment_deleted",
      "id": 4147163076,
      "node_id": "MDE5OkNvbW1lbnREZWxldGVkRXZlbnQ0MTQ3MTYzMDc2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4147163076",
      "actor": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-24T10:56:56Z"
    },
    {
      "event": "commented",
      "id": 751297148,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1MTI5NzE0OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/751297148",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-25T22:47:40Z",
      "updated_at": "2020-12-25T22:47:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "@peterdettman I added a commit that makes f and g variable-length in the constant-time code, using bounds derived using my convex hull approach. When the input x=0, this does throw away significant bits of f, but that doesn't matter because g=0 all the time, and thus all divsteps will still do the same.\r\n\r\nOn my Ryzen 2950X it seems like a slight speedup + less code. I'll benchmark more.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-751297148",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4149281733,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDE0OTI4MTczMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4149281733",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-25T22:47:40Z"
    },
    {
      "event": "subscribed",
      "id": 4149281734,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQxNDkyODE3MzQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4149281734",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-25T22:47:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4149807263,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE0OTgwNzI2Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4149807263",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-26T19:53:27Z"
    },
    {
      "event": "commented",
      "id": 751390402,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1MTM5MDQwMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/751390402",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-26T19:54:46Z",
      "updated_at": "2020-12-26T19:54:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "It doesn't seem to be a big win in any case and it critically relies on rather hastily written convex hull analysis code. I've removed it again, but we could pick it up after this is merged.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-751390402",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4149808057,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE0OTgwODA1Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4149808057",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-26T19:55:26Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4149809687,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE0OTgwOTY4Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4149809687",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-26T19:58:34Z"
    },
    {
      "event": "commented",
      "id": 751437142,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1MTQzNzE0Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/751437142",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-27T07:49:46Z",
      "updated_at": "2020-12-27T07:49:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "@sipa I was going to say essentially that I would prefer no more changes. I think we have robust code now with solid proofs and relatively wide margins of error (as these things go) - and already some big wins for performance. It's also still simple enough to keep the bar at a reasonable level for reviewers. All in all, it's in a great position to focus on review and merge.",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-751437142",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4150094216,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDE1MDA5NDIxNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4150094216",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-27T07:49:47Z"
    },
    {
      "event": "subscribed",
      "id": 4150094217,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQxNTAwOTQyMTc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4150094217",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-27T07:49:47Z"
    },
    {
      "event": "commented",
      "id": 751440823,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1MTQ0MDgyMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/751440823",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-27T08:39:24Z",
      "updated_at": "2020-12-27T08:39:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "@peterdettman Yeah, fair. Also, feel like having a look at the writeup I added to modinv64_impl.h? Perhaps I got some reasonings wrong, or things are missing.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-751440823",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4150118209,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDE1MDExODIwOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4150118209",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-27T08:39:24Z"
    },
    {
      "event": "subscribed",
      "id": 4150118210,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQxNTAxMTgyMTA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4150118210",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-27T08:39:24Z"
    },
    {
      "event": "reviewed",
      "id": 558985722,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4OTg1NzIy",
      "url": null,
      "actor": null,
      "commit_id": "1e30f79c3807a9c63c6c6f6ae07e7c9445b0f37c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-558985722",
      "submitted_at": "2020-12-28T03:40:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4158287110,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE1ODI4NzExMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4158287110",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-30T20:30:06Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4158386546,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE1ODM4NjU0Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4158386546",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-30T21:30:01Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4158433950,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE1ODQzMzk1MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4158433950",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-30T21:59:29Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4158473478,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE1ODQ3MzQ3OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4158473478",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-30T22:27:46Z"
    },
    {
      "event": "commented",
      "id": 752993408,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1Mjk5MzQwOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/752993408",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-12-31T15:54:47Z",
      "updated_at": "2020-12-31T15:54:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "FWIW https://twitter.com/hashbreaker/status/1344620536249212933",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-752993408",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 753235668,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1MzIzNTY2OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/753235668",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-01T01:05:44Z",
      "updated_at": "2021-01-01T01:05:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "Added more unit tests, including specific test cases that trigger various extreme conditions.\r\n\r\n@gmaxwell has since also discovered that using a slightly different divstep operation (start with delta=0 instead of 1; branch based on delta>=0 rather than delta>0; in the first branch update delta=-delta instead of 1-delta) results in fewer steps on average, and convex bound analysis shows that this in fact reaches g=0 within 590 steps instead of 723 for 256-bit inputs. I've implemented that variant here https://github.com/sipa/secp256k1/tree/202012_safegcd_prime. As expected, it is measurably faster for constant-time operation (because it only needs 10 batches of 62 divsteps instead of 12), but surprisingly it is significantly slower for the variable-time version. My theory is that |delta| on average remains lower, and thus there are more transitions between g-halving and cancel-g-bits-out steps... and this somehow compensates for the reduced number of divsteps. Or I did something stupid. Comments welcome, but not going to include that in this PR for now.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-753235668",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4160517702,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDE2MDUxNzcwMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4160517702",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-01T01:05:44Z"
    },
    {
      "event": "subscribed",
      "id": 4160517703,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQxNjA1MTc3MDM=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4160517703",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-01T01:05:44Z"
    },
    {
      "event": "commented",
      "id": 753256752,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1MzI1Njc1Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/753256752",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-01T05:08:25Z",
      "updated_at": "2021-01-01T05:08:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "\r\nBroadwell-EP 2.4GHz\r\ndivstep\r\nscalar_inverse: min 4.00us / avg 4.01us / max 4.01us\r\nfield_inverse: min 3.92us / avg 3.92us / max 3.93us\r\ndivstep'\r\nscalar_inverse: min 3.36us / avg 3.37us / max 3.37us\r\nfield_inverse: min 3.32us / avg 3.32us / max 3.32us\r\n\r\n15.9% speedup for scalar.\r\n15.3% speedup for field.\r\n\r\n(I'd test 32-bit, but only 64-bit is implemented for now.)",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-753256752",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 753302939,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1MzMwMjkzOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/753302939",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-01T11:12:21Z",
      "updated_at": "2021-01-01T11:12:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "What wonderful news to start the year!\r\n\r\nIt's still worth sticking to 'eta' I think. The only change needed in divsteps is:\r\n```\r\n-        eta = (eta ^ c1) - (c1 + 1);\r\n+        eta = (eta ^ c1) - 1;\r\n```\r\n\r\n(eta' is now the one's complement of delta' in the new divstep' algorithm). Also changed the big step loop bounds of course.\r\n\r\n64-bit (haswell):\r\n\r\ndivstep\r\nscalar_inverse: min 2.42us / avg 2.55us / max 2.96us\r\nfield_inverse: min 2.39us / avg 2.44us / max 2.55us\r\ndivstep'\r\nscalar_inverse: min 1.95us / avg 2.00us / max 2.16us\r\nfield_inverse: min 1.93us / avg 1.96us / max 2.06us\r\n\r\n32-bit (FWIW - 64-bit hardware):\r\n\r\ndivstep\r\nscalar_inverse: min 2.87us / avg 2.97us / max 3.20us\r\nfield_inverse: min 2.88us / avg 2.90us / max 2.99us\r\ndivstep'\r\nscalar_inverse: min 2.25us / avg 2.33us / max 2.55us\r\nfield_inverse: min 2.26us / avg 2.30us / max 2.45us\r\n\r\nIt's not surprising that the variable-time version slows down (~14% for me). Recall that it still performs the exact sequence of divsteps that the constant-time one does, just compressing some of them into a single  loop iteration (and terminating the outer loop early). For the original algorithm, it almost always finished in 9 big steps anyway (I think it was <1% of inputs that need 10) - if you look at number of divsteps to send g to 0, I recall it being around 530-540 on average for random inputs.\r\n\r\nThe new divstep reduces the worst-case, but what was the effect on the average-case? I expect not much: what the new algorithm does do though is usually give 1 less possible compressible divstep per 'switch', which amounts to the same thing as what you said: more transitions. The impact can probably be softened by not trying to get 6 (then 4), but there's less opportunities in any case.\r\n\r\nSticking to the same divstep meant we could still rely on the safegcd termination proof, but with new proof tools available it's feasible to consider them separately, and it's natural to expect at least some divergence between what's optimal for each case.\r\n",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-753302939",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 753333310,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1MzMzMzMxMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/753333310",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-01T16:05:39Z",
      "updated_at": "2021-01-01T17:22:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "> The new divstep reduces the worst-case, but what was the effect on the average-case?\r\n\r\nOn uniformly random inputs with the field modulus the original divstep takes 531.054309 on average and the new one takes 516.852449, so 2.6% fewer. -- I had thought the difference was bigger, because I'd just eyeballed it before and not measured it.  Still I'm at least a little surprised by the big performance loss.\r\n\r\nAside, Great new results, over 20% now. :)\r\n\r\nThere are many other candidates I found which get fewer operations on average than the original (though not as few as divstep') that still might be faster due to whatever reason divstep' is slower.  For example take the original divstep use <= 0 and adjust the even case by 2 instead of 1. 527.84795 on average, 768 iterations provable bound .\r\n\r\nIt might be reasonable to just search the space of formulas based on average time then hull_bound them to prove convergence of whatever is fastest. Though almost all rules that differ in just delta/eta handling will still converge.\r\n",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-753333310",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 753370298,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1MzM3MDI5OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/753370298",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-01T19:16:56Z",
      "updated_at": "2021-01-01T19:16:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "@peterdettman Awesome, that makes it pretty clean to use the old divsteps for vartime, and the new one for consttime. I've updated my branch.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-753370298",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4161179526,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDE2MTE3OTUyNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4161179526",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-01T19:16:56Z"
    },
    {
      "event": "subscribed",
      "id": 4161179527,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQxNjExNzk1Mjc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4161179527",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-01T19:16:56Z"
    },
    {
      "event": "commented",
      "id": 753384839,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1MzM4NDgzOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/753384839",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-01T21:29:29Z",
      "updated_at": "2021-01-01T21:29:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "arm7 before\r\nscalar_inverse: min 42.5us / avg 42.6us / max 42.7us\r\nfield_inverse: min 42.5us / avg 42.5us / max 42.5us\r\narm7 after\r\nscalar_inverse: min 33.9us / avg 33.9us / max 34.0us\r\nfield_inverse: min 33.8us / avg 33.8us / max 33.8us\r\n\r\n20.4% speedup for the divstep' branch now on arm7.\r\n",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-753384839",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4181975070,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE4MTk3NTA3MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4181975070",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T22:29:26Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4181996390,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE4MTk5NjM5MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4181996390",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T22:36:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4182019926,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE4MjAxOTkyNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4182019926",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T22:44:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4182326269,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE4MjMyNjI2OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4182326269",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-08T00:34:53Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4182354621,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE4MjM1NDYyMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4182354621",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-08T00:50:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4182363021,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE4MjM2MzAyMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4182363021",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-08T00:54:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4182438055,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE4MjQzODA1NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4182438055",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-08T01:24:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4182717637,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE4MjcxNzYzNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4182717637",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-08T03:52:06Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4186152668,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE4NjE1MjY2OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4186152668",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-08T21:32:04Z"
    },
    {
      "event": "commented",
      "id": 758316322,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1ODMxNjMyMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/758316322",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-12T00:41:25Z",
      "updated_at": "2021-01-12T00:41:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "Added another optimization in https://github.com/sipa/secp256k1/tree/202012_safegcd_prime: do 10 iterations of 59 steps each (but still with a transformation matrix scaled by 2^62, so update_fg and update_de can be reused).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-758316322",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 758380493,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1ODM4MDQ5Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/758380493",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-12T03:55:28Z",
      "updated_at": "2021-01-12T03:55:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "I gave a quick benchmark to that additional optimization (technically another version that lowered the loop maximum instead of changing the start) and got an additional 3.6% (scalar) 2.7% (field) speedup.",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-758380493",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4198684473,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE5ODY4NDQ3Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4198684473",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-13T00:04:01Z"
    },
    {
      "event": "commented",
      "id": 759114858,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1OTExNDg1OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/759114858",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-13T00:04:44Z",
      "updated_at": "2021-01-13T00:04:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased after #862.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-759114858",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "reviewed",
      "id": 567716280,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NzE2Mjgw",
      "url": null,
      "actor": null,
      "commit_id": "b4e12d2679ed63c5e02b56a791e6f849a7c90f6a",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-567716280",
      "submitted_at": "2021-01-13T22:43:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4203610579,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIwMzYxMDU3OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4203610579",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-13T23:07:38Z"
    },
    {
      "event": "commented",
      "id": 759835380,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1OTgzNTM4MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/759835380",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-14T00:03:13Z",
      "updated_at": "2021-01-15T04:55:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "~~Markdown version of the explanation: https://gist.github.com/sipa/bddcf6434b25cf1ff03a277cd4927d73 (perhaps this should be included in the repo as a separate file instead of the comment in modinv64_impl.h?).~~\r\n\r\nIt's now part of this PR, see the doc/safegcd_implementation.md file. See https://github.com/sipa/secp256k1/blob/202010_pr767/doc/safegcd_implementation.md",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-759835380",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4204087979,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIwNDA4Nzk3OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4204087979",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-14T02:28:42Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4204468683,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIwNDQ2ODY4Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4204468683",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-14T05:46:57Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4204471732,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIwNDQ3MTczMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4204471732",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-14T05:48:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4204476812,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIwNDQ3NjgxMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4204476812",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-14T05:50:43Z"
    },
    {
      "event": "reviewed",
      "id": 568146729,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4MTQ2NzI5",
      "url": null,
      "actor": null,
      "commit_id": "504a007709d09b5231f1a4c94b0dea36f856f4dd",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Here's a nit that I noticed while skimming. I'm currently reading the markdown file. It's really awesome.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-568146729",
      "submitted_at": "2021-01-14T12:21:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4207720552,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIwNzcyMDU1Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4207720552",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-14T18:57:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4207933444,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIwNzkzMzQ0NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4207933444",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-14T19:53:26Z"
    },
    {
      "event": "reviewed",
      "id": 569111269,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5MTExMjY5",
      "url": null,
      "actor": null,
      "commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Let me say again that the Markdown file is very helpful!",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-569111269",
      "submitted_at": "2021-01-15T10:47:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "commented",
      "id": 760947494,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc2MDk0NzQ5NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/760947494",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-15T13:39:46Z",
      "updated_at": "2021-01-15T13:39:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "This should update the implementation section in README.md. \r\n\r\nTip for other reviewers: I'm trying to review this commit-by-commit, which is probably a good idea. But for this PR, it really makes sense to look at multiple commits at once.  (If you review on Github, see https://stackoverflow.com/a/50417336.) I was looking at the second commit and wanted to ask for more comments at many places just to figure out later that the third commit adds all of these comments! :D (@sipa Not saying you should change this, it's good to preserve authorship. :+1: )",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-760947494",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4211201636,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDIxMTIwMTYzNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4211201636",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-15T13:39:46Z"
    },
    {
      "event": "subscribed",
      "id": 4211201640,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQyMTEyMDE2NDA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4211201640",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-15T13:39:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4212772469,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIxMjc3MjQ2OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4212772469",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-15T20:10:01Z"
    },
    {
      "event": "commented",
      "id": 761179151,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc2MTE3OTE1MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/761179151",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-15T20:24:24Z",
      "updated_at": "2021-01-15T20:24:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "@real-or-random I think I've addressed your comments.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-761179151",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4212817902,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDIxMjgxNzkwMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4212817902",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-15T20:24:24Z"
    },
    {
      "event": "subscribed",
      "id": 4212817907,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQyMTI4MTc5MDc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4212817907",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-15T20:24:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4212823500,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIxMjgyMzUwMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4212823500",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-15T20:26:21Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4214720066,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIxNDcyMDA2Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4214720066",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-17T03:20:17Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4214730521,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIxNDczMDUyMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4214730521",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-17T03:44:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4214736186,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIxNDczNjE4Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4214736186",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-17T03:57:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4215475447,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIxNTQ3NTQ0Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4215475447",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-17T19:54:17Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4219694046,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIxOTY5NDA0Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4219694046",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-18T20:12:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4219776080,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIxOTc3NjA4MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4219776080",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-18T20:43:44Z"
    },
    {
      "event": "commented",
      "id": 762502985,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc2MjUwMjk4NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/762502985",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-18T22:51:32Z",
      "updated_at": "2021-01-18T22:51:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "An observation for people's idle amusement:  Almost (?) always after inverting we multiply the inverse with something.  If the inverse is run with the initial e equal to the value we'd like to multiply the inverse with, we save the multiply. Sounds kinda pointless but var time is so fast this should be roughly a 2% speedup.  Pieter pointed out to me though a that conversion to signed62 is needed and potentially a normalization of the incoming number, which would eat into the speedup.\r\n",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-762502985",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 762574550,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc2MjU3NDU1MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/762574550",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-19T03:14:59Z",
      "updated_at": "2021-01-19T03:14:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "This PR (x86_86 zen2):\r\nscalar_inverse_var: min 1.34us / avg 1.35us / max 1.35us\r\nfield_inverse_var: min 1.32us / avg 1.33us / max 1.33us\r\nMake w uint32_t:\r\nscalar_inverse_var: min 1.33us / avg 1.33us / max 1.34us\r\nfield_inverse_var: min 1.31us / avg 1.31us / max 1.31us\r\n\r\nThis PR (arm8):\r\nscalar_inverse_var: min 5.36us / avg 5.36us / max 5.37us\r\nfield_inverse_var: min 5.17us / avg 5.17us / max 5.17us\r\nMake w uint32_t:\r\nscalar_inverse_var: min 4.92us / avg 4.92us / max 4.92us\r\nfield_inverse_var: min 4.74us / avg 4.74us / max 4.74us\r\n",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-762574550",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4220610546,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIyMDYxMDU0Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4220610546",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-19T04:06:29Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4220636859,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIyMDYzNjg1OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4220636859",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-19T04:21:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4220640728,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIyMDY0MDcyOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4220640728",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-19T04:23:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4220678970,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIyMDY3ODk3MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4220678970",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-19T04:44:39Z"
    },
    {
      "event": "reviewed",
      "id": 570939553,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwOTM5NTUz",
      "url": null,
      "actor": null,
      "commit_id": "dd9b3812740bc59e8bd06d8cc9588edc850c6748",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-570939553",
      "submitted_at": "2021-01-19T06:34:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4221039628,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIyMTAzOTYyOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4221039628",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-19T07:15:13Z"
    },
    {
      "event": "commented",
      "id": 762650908,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc2MjY1MDkwOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/762650908",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-19T07:16:50Z",
      "updated_at": "2021-01-19T07:16:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "@gmaxwell Switched the `w` variable in divsteps_var from 64 to 32 bits, and from 32 to 16 bits. Sounds like that's a small win on most systems, and harmless. I first tried making the mask computation also restricted in width, but that doesn't work as eta may exceed 32 resp. 16 bits.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-762650908",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4221044629,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDIyMTA0NDYyOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4221044629",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-19T07:16:50Z"
    },
    {
      "event": "subscribed",
      "id": 4221044630,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQyMjEwNDQ2MzA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4221044630",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-19T07:16:50Z"
    },
    {
      "event": "commented",
      "id": 763330754,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc2MzMzMDc1NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/763330754",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-20T04:52:40Z",
      "updated_at": "2021-01-20T04:52:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "@peterdettman Is there a particular reason for representing `eta` as uint64_t everywhere, and casting to int64_t just when signed semantics are needed? I think everythink works fine if it's just always a signed int.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-763330754",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4225947962,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDIyNTk0Nzk2Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4225947962",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-20T04:52:41Z"
    },
    {
      "event": "subscribed",
      "id": 4225947970,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQyMjU5NDc5NzA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4225947970",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-20T04:52:41Z"
    },
    {
      "event": "reviewed",
      "id": 572381384,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyMzgxMzg0",
      "url": null,
      "actor": null,
      "commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-572381384",
      "submitted_at": "2021-01-20T17:10:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "reviewed",
      "id": 572446778,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNDQ2Nzc4",
      "url": null,
      "actor": null,
      "commit_id": "876b5d06ea65cb32038306db745244eefde08e22",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-572446778",
      "submitted_at": "2021-01-20T17:11:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "reviewed",
      "id": 572452352,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNDUyMzUy",
      "url": null,
      "actor": null,
      "commit_id": "62a4c359990ff60aec0d2c2d2da7fb233fc982fe",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-572452352",
      "submitted_at": "2021-01-20T17:17:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4230735269,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIzMDczNTI2OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4230735269",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-21T00:37:56Z"
    },
    {
      "event": "commented",
      "id": 764380632,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc2NDM4MDYzMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/764380632",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-21T05:29:11Z",
      "updated_at": "2021-01-21T05:29:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "> @peterdettman Is there a particular reason for representing `eta` as uint64_t everywhere, and casting to int64_t just when signed semantics are needed? I think everythink works fine if it's just always a signed int.\r\n\r\nHistorically the divsteps methods were unsigned everything because the project had no policy on signed arithmetic right shift. At this point quite a few variables in divsteps would more naturally be signed (which they are in the algorithm itself).",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-764380632",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4231524264,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDIzMTUyNDI2NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4231524264",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-21T05:29:11Z"
    },
    {
      "event": "subscribed",
      "id": 4231524274,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQyMzE1MjQyNzQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4231524274",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-21T05:29:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4231654412,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDIzMTY1NDQxMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4231654412",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-21T06:01:33Z"
    },
    {
      "event": "commented",
      "id": 764402223,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc2NDQwMjIyMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/764402223",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-21T06:02:17Z",
      "updated_at": "2021-01-21T06:02:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "@peterdettman Ok, switched eta everywhere to a signed type. All tests pass (including ubsan).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-764402223",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4231657905,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDIzMTY1NzkwNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4231657905",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-21T06:02:17Z"
    },
    {
      "event": "subscribed",
      "id": 4231657912,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQyMzE2NTc5MTI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4231657912",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-21T06:02:17Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4240384359,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDI0MDM4NDM1OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4240384359",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-22T21:00:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4240813919,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDI0MDgxMzkxOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4240813919",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-22T23:44:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4242129117,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDI0MjEyOTExNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4242129117",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-24T03:25:27Z"
    },
    {
      "event": "commented",
      "id": 766284587,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc2NjI4NDU4Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/766284587",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-24T03:26:22Z",
      "updated_at": "2021-01-24T03:26:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "Added a commit that removes `scalar_sqr` now that that's entirely unused outside of tests as well.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-766284587",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4247384022,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDI0NzM4NDAyMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4247384022",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-25T19:39:53Z"
    },
    {
      "event": "commented",
      "id": 767068598,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc2NzA2ODU5OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/767068598",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-25T19:45:07Z",
      "updated_at": "2021-01-25T19:45:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased now #878 is merged.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-767068598",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-27T13:46:55Z",
      "updated_at": "2021-01-27T13:46:55Z",
      "source": {
        "issue": {
          "id": 522582420,
          "node_id": "MDU6SXNzdWU1MjI1ODI0MjA=",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/694",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/694/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/694/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/694/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/issues/694",
          "number": 694,
          "state": "open",
          "state_reason": null,
          "title": "Use blinded instead of constant time inverse in secret gej->ge?",
          "body": "Currently the conversion from projective to affine in pubkey creation, signing, and ECDH use a constant time ladder inverse because the z value conceivably leaks information. This applies even in the pubkey and signing case where the resulting point is made public.\r\n\r\nThe constant time inverse is much slower than the best variable time inverse.\r\n\r\nIf the point is rescaled with a uniformly random value via secp256k1_gej_rescale (at the cost of four multiplies and a square) then z becomes uniformly random and thus inverting it cannot leak any information at all. Blinding in this way is arguably more secure against EMI/DPA sidechannels because the slow ladder inverse does a lot of operations and has more potential to leak than a couple used for blinding.\r\n\r\nBenchmarking schnorr signing using this and the GMP inverse gives me a speedup of 1.15x, though that isn't including the time to come up with a random value.\r\n",
          "user": {
            "login": "gmaxwell",
            "id": 858454,
            "node_id": "MDQ6VXNlcjg1ODQ1NA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/gmaxwell",
            "html_url": "https://github.com/gmaxwell",
            "followers_url": "https://api.github.com/users/gmaxwell/followers",
            "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
            "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
            "repos_url": "https://api.github.com/users/gmaxwell/repos",
            "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 6,
          "created_at": "2019-11-14T02:20:20Z",
          "updated_at": "2021-01-27T19:17:07Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 578681650,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4NjgxNjUw",
      "url": null,
      "actor": null,
      "commit_id": "45b553355bc861d12fb2ae794d4483fe72e53562",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "nit: commit 8a61a85ba3296dd3f12eb2d2e9f35f43689dfa6b does not build. ",
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-578681650",
      "submitted_at": "2021-01-28T19:43:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4268684452,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDI2ODY4NDQ1Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4268684452",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-30T02:38:14Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4268694016,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDI2ODY5NDAxNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4268694016",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-30T02:50:47Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4268696821,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDI2ODY5NjgyMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4268696821",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-30T02:54:45Z"
    },
    {
      "event": "commented",
      "id": 770144584,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc3MDE0NDU4NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/770144584",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-30T02:57:15Z",
      "updated_at": "2021-01-30T02:57:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased on top of #864 (and then on master), made the \"Remove unused scalar_sqr\" commit compile again, removed a stale libgmp leftover in build_aux/m4/bitcoin_secp.m4.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-770144584",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4268877956,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDI2ODg3Nzk1Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4268877956",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-30T07:41:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4269528036,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDI2OTUyODAzNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4269528036",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-30T19:52:46Z"
    },
    {
      "event": "commented",
      "id": 777864474,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc3Nzg2NDQ3NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/777864474",
      "actor": {
        "login": "mratsim",
        "id": 22738317,
        "node_id": "MDQ6VXNlcjIyNzM4MzE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mratsim",
        "html_url": "https://github.com/mratsim",
        "followers_url": "https://api.github.com/users/mratsim/followers",
        "following_url": "https://api.github.com/users/mratsim/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mratsim/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mratsim/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
        "organizations_url": "https://api.github.com/users/mratsim/orgs",
        "repos_url": "https://api.github.com/users/mratsim/repos",
        "events_url": "https://api.github.com/users/mratsim/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mratsim/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-02-11T23:29:32Z",
      "updated_at": "2021-02-11T23:29:32Z",
      "author_association": "NONE",
      "body": "Bernstein has a new release of its code which includes secp256k1 and it seems like there was a large improvement at the beginning of January: https://gcd.cr.yp.to/software.html\r\n\r\n![image](https://user-images.githubusercontent.com/22738317/107712220-5a0d9d00-6cc9-11eb-8c88-def28125c21c.png)\r\n",
      "user": {
        "login": "mratsim",
        "id": 22738317,
        "node_id": "MDQ6VXNlcjIyNzM4MzE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mratsim",
        "html_url": "https://github.com/mratsim",
        "followers_url": "https://api.github.com/users/mratsim/followers",
        "following_url": "https://api.github.com/users/mratsim/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mratsim/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mratsim/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
        "organizations_url": "https://api.github.com/users/mratsim/orgs",
        "repos_url": "https://api.github.com/users/mratsim/repos",
        "events_url": "https://api.github.com/users/mratsim/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mratsim/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-777864474",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 777864886,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc3Nzg2NDg4Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/777864886",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-02-11T23:30:35Z",
      "updated_at": "2021-02-11T23:46:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "@mratsim yes, that update is significantly a result of our contributions. https://twitter.com/hashbreaker/status/1348247397843968000  Also discussed in prior comments: https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-752993408\r\n\r\nThat code uses AVX2 to concurrently update F/G/D/E all at once. It's a great optimization, plus a lot of really impressive instruction scheduling.  Unfortunately it's also x86_64 AVX2 only code in hand code ASM.  It's perhaps 2x faster than this code.  But this code is infinity faster on non-x86/32-bit/non-avx2 hardware. :p ",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-777864886",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4322477071,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDMyMjQ3NzA3MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4322477071",
      "actor": {
        "login": "mratsim",
        "id": 22738317,
        "node_id": "MDQ6VXNlcjIyNzM4MzE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mratsim",
        "html_url": "https://github.com/mratsim",
        "followers_url": "https://api.github.com/users/mratsim/followers",
        "following_url": "https://api.github.com/users/mratsim/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mratsim/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mratsim/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
        "organizations_url": "https://api.github.com/users/mratsim/orgs",
        "repos_url": "https://api.github.com/users/mratsim/repos",
        "events_url": "https://api.github.com/users/mratsim/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mratsim/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-02-11T23:30:35Z"
    },
    {
      "event": "subscribed",
      "id": 4322477072,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQzMjI0NzcwNzI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4322477072",
      "actor": {
        "login": "mratsim",
        "id": 22738317,
        "node_id": "MDQ6VXNlcjIyNzM4MzE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/22738317?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mratsim",
        "html_url": "https://github.com/mratsim",
        "followers_url": "https://api.github.com/users/mratsim/followers",
        "following_url": "https://api.github.com/users/mratsim/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mratsim/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mratsim/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mratsim/subscriptions",
        "organizations_url": "https://api.github.com/users/mratsim/orgs",
        "repos_url": "https://api.github.com/users/mratsim/repos",
        "events_url": "https://api.github.com/users/mratsim/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mratsim/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-02-11T23:30:35Z"
    },
    {
      "event": "reviewed",
      "id": 595448725,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NDQ4NzI1",
      "url": null,
      "actor": null,
      "commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "Reviewed all the commits that deal with implementing/optimizing safegcd. Left some minor nits/typos. \r\n\r\nDid not review the commits that move the code or remove the code. They are better done by with more experience with the codebase.",
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-595448725",
      "submitted_at": "2021-03-01T10:02:21Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4391809083,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDM5MTgwOTA4Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4391809083",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-01T20:37:27Z"
    },
    {
      "event": "reviewed",
      "id": 601204699,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAxMjA0Njk5",
      "url": null,
      "actor": null,
      "commit_id": "1d2b20197660b7cd2053a0b0b7b40d0ee60beba3",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "reACK 1d2b20197660b7cd2053a0b0b7b40d0ee60beba3 ",
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-601204699",
      "submitted_at": "2021-03-01T21:58:33Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "reviewed",
      "id": 603358235,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzMzU4MjM1",
      "url": null,
      "actor": null,
      "commit_id": "a772bfba5380e96036650fb52005a8b9f58aefe3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-603358235",
      "submitted_at": "2021-03-03T23:17:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "reviewed",
      "id": 604567768,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA0NTY3NzY4",
      "url": null,
      "actor": null,
      "commit_id": "24f17be8f301d91ebd84caf7cf611e105a70a0e2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-604567768",
      "submitted_at": "2021-03-04T23:23:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4411453930,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDQxMTQ1MzkzMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4411453930",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-05T03:39:26Z"
    },
    {
      "event": "commented",
      "id": 791128999,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5MTEyODk5OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/791128999",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-05T03:40:36Z",
      "updated_at": "2021-03-05T03:47:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "Pushed the following diff (+ rebase) to address @real-or-random's comments:\r\n\r\n```diff\r\ndiff --git a/configure.ac b/configure.ac\r\nindex 7f118160..e84005ed 100644\r\ndiff --git a/src/modinv32_impl.h b/src/modinv32_impl.h\r\nindex 956cde20..e30c0ff9 100644\r\n--- a/src/modinv32_impl.h\r\n+++ b/src/modinv32_impl.h\r\n@@ -179,7 +179,13 @@ typedef struct {\r\n  * Implements the divsteps_n_matrix function from the explanation.\r\n  */\r\n static int32_t secp256k1_modinv32_divsteps_30(int32_t eta, uint32_t f0, uint32_t g0, secp256k1_modinv32_trans2x2 *t) {\r\n-    uint32_t u = 1, v = 0, q = 0, r = 1; /* start with the identity matrix */\r\n+    /* u,v,q,r are the elements of the transformation matrix being built up,\r\n+     * starting with the identity matrix. Semantically they are signed integers\r\n+     * in range [-2^30,2^30], but here represented as unsigned mod 2^32. This\r\n+     * permits left shifting (which is UB for negative numbers). The range\r\n+     * being inside [-2^31,2^31) means that casting to signed works correctly.\r\n+     */\r\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\r\n     uint32_t c1, c2, f = f0, g = g0, x, y, z;\r\n     int i;\r\n \r\n@@ -252,7 +258,8 @@ static int32_t secp256k1_modinv32_divsteps_30_var(int32_t eta, uint32_t f0, uint\r\n         0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\r\n     };\r\n \r\n-    uint32_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\r\n+    /* Transformation matrix; see comments in secp256k1_modinv32_divsteps_30. */\r\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\r\n     uint32_t f = f0, g = g0, m;\r\n     uint16_t w;\r\n     int i = 30, limit, zeros;\r\ndiff --git a/src/modinv64_impl.h b/src/modinv64_impl.h\r\nindex 66f06ff9..b0106311 100644\r\n--- a/src/modinv64_impl.h\r\n+++ b/src/modinv64_impl.h\r\n@@ -156,7 +156,13 @@ typedef struct {\r\n  * Implements the divsteps_n_matrix function from the explanation.\r\n  */\r\n static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\r\n-    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\r\n+    /* u,v,q,r are the elements of the transformation matrix being built up,\r\n+     * starting with the identity matrix. Semantically they are signed integers\r\n+     * in range [-2^62,2^62], but here represented as unsigned mod 2^64. This\r\n+     * permits left shifting (which is UB for negative numbers). The range\r\n+     * being inside [-2^63,2^63) means that casting to signed works correctly.\r\n+     */\r\n+    uint64_t u = 1, v = 0, q = 0, r = 1;\r\n     uint64_t c1, c2, f = f0, g = g0, x, y, z;\r\n     int i;\r\n \r\n@@ -214,7 +220,8 @@ static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t\r\n  * Implements the divsteps_n_matrix_var function from the explanation.\r\n  */\r\n static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\r\n-    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\r\n+    /* Transformation matrix; see comments in secp256k1_modinv64_divsteps_62. */\r\n+    uint64_t u = 1, v = 0, q = 0, r = 1;\r\n     uint64_t f = f0, g = g0, m;\r\n     uint32_t w;\r\n     int i = 62, limit, zeros;\r\ndiff --git a/src/tests.c b/src/tests.c\r\nindex bb77326c..ac020e3c 100644\r\n--- a/src/tests.c\r\n+++ b/src/tests.c\r\n@@ -429,11 +429,13 @@ void run_ctz_tests(void) {\r\n     unsigned i;\r\n     for (i = 0; i < sizeof(b32) / sizeof(b32[0]); ++i) {\r\n         for (shift = 0; shift < 32; ++shift) {\r\n+            CHECK(secp256k1_ctz32_var_debruijn(b32[i] << shift) == shift);\r\n             CHECK(secp256k1_ctz32_var(b32[i] << shift) == shift);\r\n         }\r\n     }\r\n     for (i = 0; i < sizeof(b64) / sizeof(b64[0]); ++i) {\r\n         for (shift = 0; shift < 64; ++shift) {\r\n+            CHECK(secp256k1_ctz64_var_debruijn(b64[i] << shift) == shift);\r\n             CHECK(secp256k1_ctz64_var(b64[i] << shift) == shift);\r\n         }\r\n     }\r\n@@ -636,7 +638,10 @@ void run_rand_int(void) {\r\n \r\n /***** MODINV TESTS *****/\r\n \r\n-/* compute out = (a*b) mod m; if b=NULL, treat b=1. */\r\n+/* compute out = (a*b) mod m; if b=NULL, treat b=1.\r\n+ *\r\n+ * Out is a 512-bit number (represented as 32 uint16_t's in LE order). The other\r\n+ * arguments are 256-bit numbers (represented as 16 uint16_t's in LE order). */\r\n void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16_t* m) {\r\n     uint16_t mul[32];\r\n     uint64_t c = 0;\r\n@@ -689,16 +694,18 @@ void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16\r\n         int64_t cs;\r\n \r\n         /* Compute mul2 = mul - m<<i. */\r\n-        cs = 0;\r\n-        for (j = (i >> 4); j < 32; ++j) { /* skip limbs before i/16 */\r\n+        cs = 0; /* accumulator */\r\n+        for (j = 0; j < 32; ++j) { /* j loops over the output limbs in mul2. */\r\n+            /* Compute sub: the 16 bits in m that will be subtracted from mul2[j]. */\r\n             uint16_t sub = 0;\r\n             int p;\r\n-            for (p = 0; p < 16; ++p) {\r\n-                int bitpos = j * 16 - i + p;\r\n+            for (p = 0; p < 16; ++p) { /* p loops over the bit positions in mul2[j]. */\r\n+                int bitpos = j * 16 - i + p; /* bitpos is the correspond bit position in m. */\r\n                 if (bitpos >= 0 && bitpos < 256) {\r\n                     sub |= ((m[bitpos >> 4] >> (bitpos & 15)) & 1) << p;\r\n                 }\r\n             }\r\n+            /* Add mul[j]-sub to accumulator, and shift bottom 16 bits out to mul2[j]. */\r\n             cs += mul[j];\r\n             cs -= sub;\r\n             mul2[j] = (cs & 0xFFFF);\r\n@@ -706,10 +713,10 @@ void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16\r\n         }\r\n         /* If remainder of subtraction is 0, set mul = mul2. */\r\n         if (cs == 0) {\r\n-            memcpy(mul + (i >> 4), mul2 + (i >> 4), sizeof(mul) - 2 * (i >> 4));\r\n+            memcpy(mul, mul2, sizeof(mul));\r\n         }\r\n     }\r\n-    /* Test that all limbs higher than m's highest are zero */\r\n+    /* Sanity check: test that all limbs higher than m's highest are zero */\r\n     for (i = (m_bitlen >> 4) + 1; i < 32; ++i) {\r\n         CHECK(mul[i] == 0);\r\n     }\r\n@@ -734,11 +741,11 @@ void signed30_to_uint16(uint16_t* out, const secp256k1_modinv32_signed30* in) {\r\n     }\r\n }\r\n \r\n-/* Randomly mutate the sign of limbs in signed62 representation. */\r\n+/* Randomly mutate the sign of limbs in signed30 representation, without changing the value. */\r\n void mutate_sign_signed30(secp256k1_modinv32_signed30* x) {\r\n     int i;\r\n     for (i = 0; i < 16; ++i) {\r\n-        int pos = secp256k1_testrand_int(7);\r\n+        int pos = secp256k1_testrand_int(8);\r\n         if (x->v[pos] > 0 && x->v[pos + 1] <= 0x3fffffff) {\r\n             x->v[pos] -= 0x40000000;\r\n             x->v[pos + 1] += 1;\r\n@@ -763,10 +770,9 @@ void test_modinv32_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod\r\n \r\n     /* compute 1/modulus mod 2^30 */\r\n     m.modulus_inv30 = m.modulus.v[0];\r\n-    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\r\n-    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\r\n-    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\r\n-    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\r\n+    for (i = 0; i < 4; ++i) {\r\n+        m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\r\n+    }\r\n     m.modulus_inv30 &= 0x3fffffff;\r\n     CHECK(((m.modulus_inv30 * m.modulus.v[0]) & 0x3fffffff) == 1);\r\n \r\n@@ -810,12 +816,12 @@ void signed62_to_uint16(uint16_t* out, const secp256k1_modinv64_signed62* in) {\r\n     }\r\n }\r\n \r\n-/* Randomly mutate the sign of limbs in signed62 representation. */\r\n+/* Randomly mutate the sign of limbs in signed62 representation, without changing the value. */\r\n void mutate_sign_signed62(secp256k1_modinv64_signed62* x) {\r\n     static const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\r\n     int i;\r\n     for (i = 0; i < 8; ++i) {\r\n-        int pos = secp256k1_testrand_int(3);\r\n+        int pos = secp256k1_testrand_int(4);\r\n         if (x->v[pos] > 0 && x->v[pos + 1] <= M62) {\r\n             x->v[pos] -= (M62 + 1);\r\n             x->v[pos + 1] += 1;\r\n@@ -841,11 +847,9 @@ void test_modinv64_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod\r\n \r\n     /* compute 1/modulus mod 2^62 */\r\n     m.modulus_inv62 = m.modulus.v[0];\r\n-    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\r\n-    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\r\n-    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\r\n-    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\r\n-    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\r\n+    for (i = 0; i < 5; ++i) {\r\n+        m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\r\n+    }\r\n     m.modulus_inv62 &= M62;\r\n     CHECK(((m.modulus_inv62 * m.modulus.v[0]) & M62) == 1);\r\n \r\n@@ -1044,7 +1048,7 @@ void run_modinv_tests(void) {\r\n             /* If modulus is 1, find another one. */\r\n             ok = md[0] != 1;\r\n             for (j = 1; j < 16; ++j) ok |= md[j] != 0;\r\n-            mulmod256(xd, xd, NULL, md); /* Make xd = xd mod m32 */\r\n+            mulmod256(xd, xd, NULL, md); /* Make xd = xd mod md */\r\n         } while (!(ok && coprime(xd, md)));\r\n \r\n         test_modinv32_uint16(id, xd, md);\r\ndiff --git a/src/util.h b/src/util.h\r\nindex a0b6f318..f7884683 100644\r\n--- a/src/util.h\r\n+++ b/src/util.h\r\n@@ -280,6 +280,31 @@ SECP256K1_GNUC_EXT typedef __int128 int128_t;\r\n #define __has_builtin(x) 0\r\n #endif\r\n \r\n+/* Determine the number of trailing zero bits in a (non-zero) 32-bit x.\r\n+ * This function is only intended to be used as fallback for\r\n+ * secp256k1_ctz32_var, but permits it to be tested separately. */\r\n+static SECP256K1_INLINE int secp256k1_ctz32_var_debruijn(uint32_t x) {\r\n+    static const uint8_t debruijn[32] = {\r\n+        0x00, 0x01, 0x02, 0x18, 0x03, 0x13, 0x06, 0x19, 0x16, 0x04, 0x14, 0x0A,\r\n+        0x10, 0x07, 0x0C, 0x1A, 0x1F, 0x17, 0x12, 0x05, 0x15, 0x09, 0x0F, 0x0B,\r\n+        0x1E, 0x11, 0x08, 0x0E, 0x1D, 0x0D, 0x1C, 0x1B\r\n+    };\r\n+    return debruijn[((x & -x) * 0x04D7651F) >> 27];\r\n+}\r\n+\r\n+/* Determine the number of trailing zero bits in a (non-zero) 64-bit x.\r\n+ * This function is only intended to be used as fallback for\r\n+ * secp256k1_ctz64_var, but permits it to be tested separately. */\r\n+static SECP256K1_INLINE int secp256k1_ctz64_var_debruijn(uint64_t x) {\r\n+    static const uint8_t debruijn[64] = {\r\n+        0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,\r\n+        62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,\r\n+        63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,\r\n+        51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12\r\n+    };\r\n+    return debruijn[((x & -x) * 0x022FDD63CC95386D) >> 58];\r\n+}\r\n+\r\n /* Determine the number of trailing zero bits in a (non-zero) 32-bit x. */\r\n static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\r\n     VERIFY_CHECK(x != 0);\r\n@@ -294,12 +319,7 @@ static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\r\n     return __builtin_ctzl(x);\r\n #else\r\n     /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\r\n-    static const uint8_t debruijn[32] = {\r\n-        0x00, 0x01, 0x02, 0x18, 0x03, 0x13, 0x06, 0x19, 0x16, 0x04, 0x14, 0x0A,\r\n-        0x10, 0x07, 0x0C, 0x1A, 0x1F, 0x17, 0x12, 0x05, 0x15, 0x09, 0x0F, 0x0B,\r\n-        0x1E, 0x11, 0x08, 0x0E, 0x1D, 0x0D, 0x1C, 0x1B\r\n-    };\r\n-    return debruijn[((x & -x) * 0x04D7651F) >> 27];\r\n+    return secp256k1_ctz32_var_debruijn(x);\r\n #endif\r\n }\r\n \r\n@@ -317,13 +337,7 @@ static SECP256K1_INLINE int secp256k1_ctz64_var(uint64_t x) {\r\n     return __builtin_ctzll(x);\r\n #else\r\n     /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\r\n-    static const uint8_t debruijn[64] = {\r\n-        0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,\r\n-        62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,\r\n-        63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,\r\n-        51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12\r\n-    };\r\n-    return debruijn[((x & -x) * 0x022FDD63CC95386D) >> 58];\r\n+    return secp256k1_ctz64_var_debruijn(x);\r\n #endif\r\n }\r\n ```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-791128999",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4411456257,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDQxMTQ1NjI1Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4411456257",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-05T03:40:36Z"
    },
    {
      "event": "subscribed",
      "id": 4411456259,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ0MTE0NTYyNTk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4411456259",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-05T03:40:36Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4411459767,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDQxMTQ1OTc2Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4411459767",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-05T03:42:28Z"
    },
    {
      "event": "commented",
      "id": 791352626,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5MTM1MjYyNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/791352626",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-05T11:12:23Z",
      "updated_at": "2021-03-05T11:12:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "Changes look good. :) In general, the PR is very clean. I believe I'm doing a pretty deep review, but all I have is some nits.\r\n\r\nI still need to go through commits \"Improve bounds checks in modinv modules\"..\"Improve field/scalar inverse tests\".\r\n\r\n\r\n> f8df286\r\n> Do you have some reference for that formula? Same below for 4 bits.\r\n\r\nYou marked this resolved but I don't see a reply or a change. I think what I'm actually asking for is some comment that says that \"this computes the inverse of ...\". Of course, a reference for the trick itself would still be neat.\r\n\r\nI guess this is the trick as used in the tests? It may be more self-documenting to give it a name (macro?) and reuse it. (I can't tell if that's appropriate, feel free to dismiss).\r\n\r\n(Posting here in main thread because Github threading is fucked up.)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-791352626",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4415775752,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDQxNTc3NTc1Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4415775752",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-05T22:09:46Z"
    },
    {
      "event": "commented",
      "id": 791744671,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5MTc0NDY3MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/791744671",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-05T22:11:50Z",
      "updated_at": "2021-03-05T22:11:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "Pushed a few more changes:\r\n\r\n```diff\r\ndiff --git a/doc/safegcd_implementation.md b/doc/safegcd_implementation.md\r\nindex 1a059912..8346d22e 100644\r\n--- a/doc/safegcd_implementation.md\r\n+++ b/doc/safegcd_implementation.md\r\n@@ -616,7 +616,9 @@ while True:\r\n \r\n By using a bigger table more bits can be cancelled at once. The table can also be implemented\r\n-as a formula:\r\n+as a formula. Several formulas are known for computing modular inverses modulo powers of two;\r\n+some can be found in Hacker's Delight second edition by Henry S. Warren, Jr. pages 245-247.\r\n+Here we need the negated modular inverse, which is a simple transformation of those:\r\n \r\n - Instead of a 3-bit table:\r\n   - *-f* or *f ^ 6*\r\ndiff --git a/src/modinv32_impl.h b/src/modinv32_impl.h\r\nindex e30c0ff9..3eba04fc 100644\r\n--- a/src/modinv32_impl.h\r\n+++ b/src/modinv32_impl.h\r\n@@ -511,12 +511,15 @@ static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256\r\n     secp256k1_modinv32_signed30 e = {{1, 0, 0, 0, 0, 0, 0, 0, 0}};\r\n     secp256k1_modinv32_signed30 f = modinfo->modulus;\r\n     secp256k1_modinv32_signed30 g = *x;\r\n-    int i, j, len = 9;\r\n+#ifdef VERIFY\r\n+    int i = 0;\r\n+#endif\r\n+    int j, len = 9;\r\n     int32_t eta = -1;\r\n     int32_t cond, fn, gn;\r\n \r\n-    /* Do up to 25 iterations of 30 divsteps each, or until g=0 (whichever comes first). */\r\n-    for (i = 0; i < 25; ++i) {\r\n+    /* Do iterations of 30 divsteps each until g=0. */\r\n+    while (1) {\r\n         /* Compute transition matrix and new eta after 30 divsteps. */\r\n         secp256k1_modinv32_trans2x2 t;\r\n         eta = secp256k1_modinv32_divsteps_30_var(eta, f.v[0], g.v[0], &t);\r\n@@ -554,6 +557,7 @@ static void secp256k1_modinv32_var(secp256k1_modinv32_signed30 *x, const secp256\r\n             --len;\r\n         }\r\n #ifdef VERIFY\r\n+        VERIFY_CHECK(++i < 25); /* We should never need more than 25*30 = 750 divsteps */\r\n         VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */\r\n         VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\r\n         VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */\r\ndiff --git a/src/modinv64_impl.h b/src/modinv64_impl.h\r\nindex b0106311..e1ba8b63 100644\r\n--- a/src/modinv64_impl.h\r\n+++ b/src/modinv64_impl.h\r\n@@ -513,12 +513,15 @@ static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256\r\n     secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\r\n     secp256k1_modinv64_signed62 f = modinfo->modulus;\r\n     secp256k1_modinv64_signed62 g = *x;\r\n-    int i, j, len = 5;\r\n+#ifdef VERIFY\r\n+    int i = 0;\r\n+#endif\r\n+    int j, len = 5;\r\n     int64_t eta = -1;\r\n     int64_t cond, fn, gn;\r\n \r\n-    /* Do up to 12 iterations of 62 divsteps each, or until g=0 (whichever comes first). */\r\n-    for (i = 0; i < 12; ++i) {\r\n+    /* Do iterations of 62 divsteps each until g=0. */\r\n+    while (1) {\r\n         /* Compute transition matrix and new eta after 62 divsteps. */\r\n         secp256k1_modinv64_trans2x2 t;\r\n         eta = secp256k1_modinv64_divsteps_62_var(eta, f.v[0], g.v[0], &t);\r\n@@ -556,6 +559,7 @@ static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256\r\n             --len;\r\n         }\r\n #ifdef VERIFY\r\n+        VERIFY_CHECK(++i < 12); /* We should never need more than 12*62 = 744 divsteps */\r\n         VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, -1) > 0); /* f > -modulus */\r\n         VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&f, len, &modinfo->modulus, 1) <= 0); /* f <= modulus */\r\n         VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(&g, len, &modinfo->modulus, -1) > 0); /* g > -modulus */\r\ndiff --git a/src/tests.c b/src/tests.c\r\nindex ac020e3c..ba645bbe 100644\r\n--- a/src/tests.c\r\n+++ b/src/tests.c\r\n@@ -638,6 +638,19 @@ void run_rand_int(void) {\r\n \r\n /***** MODINV TESTS *****/\r\n \r\n+/* Compute the modular inverse of (odd) x mod 2^64. */\r\n+uint64_t modinv2p64(uint64_t x) {\r\n+    /* If w = 1/x mod 2^(2^L), then w*(2 - w*x) = 1/x mod 2^(2^(L+1)). See\r\n+     * Hacker's Delight second edition, Henry S. Warren, Jr., pages 245-247 for\r\n+     * why. Start with L=0, for which it is true for every odd x that\r\n+     * 1/x=1 mod 2. Iterating 6 times gives us 1/x mod 2^64. */\r\n+    int l;\r\n+    uint64_t w = 1;\r\n+    CHECK(x & 1);\r\n+    for (l = 0; l < 6; ++l) w *= (2 - w*x);\r\n+    return w;\r\n+}\r\n+\r\n /* compute out = (a*b) mod m; if b=NULL, treat b=1.\r\n  *\r\n  * Out is a 512-bit number (represented as 32 uint16_t's in LE order). The other\r\n@@ -769,11 +782,7 @@ void test_modinv32_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod\r\n     mutate_sign_signed30(&m.modulus);\r\n \r\n     /* compute 1/modulus mod 2^30 */\r\n-    m.modulus_inv30 = m.modulus.v[0];\r\n-    for (i = 0; i < 4; ++i) {\r\n-        m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\r\n-    }\r\n-    m.modulus_inv30 &= 0x3fffffff;\r\n+    m.modulus_inv30 = modinv2p64(m.modulus.v[0]) & 0x3fffffff;\r\n     CHECK(((m.modulus_inv30 * m.modulus.v[0]) & 0x3fffffff) == 1);\r\n \r\n     for (vartime = 0; vartime < 2; ++vartime) {\r\n@@ -846,11 +855,7 @@ void test_modinv64_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod\r\n     mutate_sign_signed62(&m.modulus);\r\n \r\n     /* compute 1/modulus mod 2^62 */\r\n-    m.modulus_inv62 = m.modulus.v[0];\r\n-    for (i = 0; i < 5; ++i) {\r\n-        m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\r\n-    }\r\n-    m.modulus_inv62 &= M62;\r\n+    m.modulus_inv62 = modinv2p64(m.modulus.v[0]) & M62;\r\n     CHECK(((m.modulus_inv62 * m.modulus.v[0]) & M62) == 1);\r\n \r\n     for (vartime = 0; vartime < 2; ++vartime) {\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-791744671",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 791748133,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5MTc0ODEzMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/791748133",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-05T22:20:09Z",
      "updated_at": "2021-03-05T22:20:09Z",
      "author_association": "CONTRIBUTOR",
      "body": "@real-or-random I think I've addressed all your comments, including adding references for the modular inverse mod power of two formula (for some reason I can't comment where you actually mentioned it, i didn't mark it resolved...).\r\n\r\nRegarding the conditionals on the zero limbs in the modulus, I'm not sure that's the sort of thing we can and/or should care about. If any branch at all is a concern, I don't see how e.g. the various loops aren't a problem either. That said, I'm also perfectly fine with just dropping that commit, as the benefit is fairly small (and I'm not sure it's even observable on all platforms we tested).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-791748133",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4415827595,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDQxNTgyNzU5NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4415827595",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-05T22:20:09Z"
    },
    {
      "event": "subscribed",
      "id": 4415827602,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ0MTU4Mjc2MDI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4415827602",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-05T22:20:09Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6ZGUwYTY0M2MzZGMyYzQwYTQ0N2U2NzBjZmExYzE2ODNjNzljOTI5Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/de0a643c3dc2c40a447e670cfa1c1683c79c9297",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/de0a643c3dc2c40a447e670cfa1c1683c79c9297",
      "tree": {
        "sha": "c5a55e997e0bfc737981ee976847e0dcbf61bf02",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/c5a55e997e0bfc737981ee976847e0dcbf61bf02"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4c3ba88c3a869ae3f45990286c79860539a5bff8",
          "sha": "4c3ba88c3a869ae3f45990286c79860539a5bff8",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4c3ba88c3a869ae3f45990286c79860539a5bff8"
        }
      ],
      "message": "Add secp256k1_ctz{32,64}_var functions\n\nThese functions count the number of trailing zeroes in non-zero integers.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-08T17:56:07Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-12T02:10:58Z"
      },
      "sha": "de0a643c3dc2c40a447e670cfa1c1683c79c9297"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6OGU0MTVhY2JhMjU4MzBkYTljMjNhNGRkNTUzMWViZmM2YjY1YWFlNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8e415acba25830da9c23a4dd5531ebfc6b65aae7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8e415acba25830da9c23a4dd5531ebfc6b65aae7",
      "tree": {
        "sha": "b39d0a043070344bfdc0af3a7ace52b35ca50148",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/b39d0a043070344bfdc0af3a7ace52b35ca50148"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/de0a643c3dc2c40a447e670cfa1c1683c79c9297",
          "sha": "de0a643c3dc2c40a447e670cfa1c1683c79c9297",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/de0a643c3dc2c40a447e670cfa1c1683c79c9297"
        }
      ],
      "message": "Add safegcd based modular inverse modules\n\nRefactored by: Pieter Wuille <pieter@wuille.net>",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-08T17:56:07Z"
      },
      "author": {
        "name": "Peter Dettman",
        "email": "peter.dettman@gmail.com",
        "date": "2020-11-29T22:01:03Z"
      },
      "sha": "8e415acba25830da9c23a4dd5531ebfc6b65aae7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6ZDhhOTJmY2M0YzY1Y2YxODllYzdiZDUyOThkYWQ4NDc5MzQ3YzQ0Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/d8a92fcc4c65cf189ec7bd5298dad8479347c442",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/d8a92fcc4c65cf189ec7bd5298dad8479347c442",
      "tree": {
        "sha": "fd4641cba6c19f1a512a723ddd1dec2d9dab8239",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/fd4641cba6c19f1a512a723ddd1dec2d9dab8239"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8e415acba25830da9c23a4dd5531ebfc6b65aae7",
          "sha": "8e415acba25830da9c23a4dd5531ebfc6b65aae7",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8e415acba25830da9c23a4dd5531ebfc6b65aae7"
        }
      ],
      "message": "Add extensive comments on the safegcd algorithm and implementation\n\nThis adds a long comment explaining the algorithm and implementation choices by building\nit up step by step in Python.\n\nComments in the code are also reworked/added, with references to the long explanation.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-08T17:56:07Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-12-04T00:26:58Z"
      },
      "sha": "d8a92fcc4c65cf189ec7bd5298dad8479347c442"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MTUxYWFjMDBkMzFiYTVlOTQ4MDAzNzZmNmZkYTQxOTMwNzExNjhhZg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/151aac00d31ba5e94800376f6fda4193071168af",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/151aac00d31ba5e94800376f6fda4193071168af",
      "tree": {
        "sha": "719dfc5f73066877da6ff40610a043b7e6d0657f",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/719dfc5f73066877da6ff40610a043b7e6d0657f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/d8a92fcc4c65cf189ec7bd5298dad8479347c442",
          "sha": "d8a92fcc4c65cf189ec7bd5298dad8479347c442",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/d8a92fcc4c65cf189ec7bd5298dad8479347c442"
        }
      ],
      "message": "Add tests for modinv modules\n\nThis adds tests for the modinv{32,64}_impl.h directly (before the functions are used\ninside the field/scalar code). It uses a naive implementation of modular multiplication\nand gcds in order to verify the modular inverses themselves.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-08T17:56:07Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-12-23T02:24:36Z"
      },
      "sha": "151aac00d31ba5e94800376f6fda4193071168af"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4422708746,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDQyMjcwODc0Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4422708746",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-08T17:58:14Z"
    },
    {
      "event": "commented",
      "id": 792953766,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5Mjk1Mzc2Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/792953766",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-08T17:59:45Z",
      "updated_at": "2021-03-08T17:59:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased on top of merged #901.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-792953766",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "reviewed",
      "id": 608513620,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4NTEzNjIw",
      "url": null,
      "actor": null,
      "commit_id": "639769bee4799b4de7416255f22758aca4629f91",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I think all comments apply analogously to the 64 bit code.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-608513620",
      "submitted_at": "2021-03-10T10:21:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "reviewed",
      "id": 608626580,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4NjI2NTgw",
      "url": null,
      "actor": null,
      "commit_id": "a71a582c46fac1cff02a7855bb836ad2722e7dcc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "a71a582c46fac1cff02a7855bb836ad2722e7dcc\r\n\r\nsome of these comments apply to the other variants of the code (field vs scalar, 32 bits vs 64 bit, constant time vs `_var`...) ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-608626580",
      "submitted_at": "2021-03-10T12:29:26Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "reviewed",
      "id": 608688563,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4Njg4NTYz",
      "url": null,
      "actor": null,
      "commit_id": "7cda96e813454171ff6e85ecd9d986af6bd15b76",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK mod my comments",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-608688563",
      "submitted_at": "2021-03-10T13:23:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MDhkNTQ5NjRlNTFmMzE4ZWYwY2M0ZWYwOWQ2NGNmYTVlYzE0M2M1Yw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/08d54964e51f318ef0cc4ef09d64cfa5ec143c5c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/08d54964e51f318ef0cc4ef09d64cfa5ec143c5c",
      "tree": {
        "sha": "17db5007ed77f7de993e8a10c6095938c6651820",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/17db5007ed77f7de993e8a10c6095938c6651820"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/151aac00d31ba5e94800376f6fda4193071168af",
          "sha": "151aac00d31ba5e94800376f6fda4193071168af",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/151aac00d31ba5e94800376f6fda4193071168af"
        }
      ],
      "message": "Improve bounds checks in modinv modules\n\nThis commit adds functions to verify and compare numbers in signed{30,62} notation,\nand uses that to do more extensive bounds checking on various variables in the modinv\ncode.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-11T18:25:22Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-12-23T19:13:57Z"
      },
      "sha": "08d54964e51f318ef0cc4ef09d64cfa5ec143c5c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6YWE0MDRkNTNiZWYyMWQyNTJhMjMxNzEzODFkNGJmZGE2ZTdlMjVjNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/aa404d53bef21d252a23171381d4bfda6e7e25c6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/aa404d53bef21d252a23171381d4bfda6e7e25c6",
      "tree": {
        "sha": "76c30cd9bd1b579d7aaa0b72e14d4d5330eb533b",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/76c30cd9bd1b579d7aaa0b72e14d4d5330eb533b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/08d54964e51f318ef0cc4ef09d64cfa5ec143c5c",
          "sha": "08d54964e51f318ef0cc4ef09d64cfa5ec143c5c",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/08d54964e51f318ef0cc4ef09d64cfa5ec143c5c"
        }
      ],
      "message": "Move secp256k1_scalar_{inverse{_var},is_even} to per-impl files\n\nThis temporarily duplicates the inversion code across the 4x64 and 8x32\nimplementations. Those implementations will be replaced in a later commit.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-11T18:25:26Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-11T22:30:37Z"
      },
      "sha": "aa404d53bef21d252a23171381d4bfda6e7e25c6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6NDM2MjgxYWZkY2I2ODk5MTM5NWY5NzMzODE5N2QyMDgyMTI5NjVlMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/436281afdcb68991395f97338197d208212965e2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/436281afdcb68991395f97338197d208212965e2",
      "tree": {
        "sha": "fb848ad3d850a744c08e3aaebb35f5af3fa300ff",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/fb848ad3d850a744c08e3aaebb35f5af3fa300ff"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/aa404d53bef21d252a23171381d4bfda6e7e25c6",
          "sha": "aa404d53bef21d252a23171381d4bfda6e7e25c6",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/aa404d53bef21d252a23171381d4bfda6e7e25c6"
        }
      ],
      "message": "Move secp256k1_fe_inverse{_var} to per-impl files\n\nThis temporarily duplicates the inversion code across the 5x52 and 10x26\nimplementations. Those implementations will be replaced in a next commit.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-11T18:25:26Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-11T22:41:54Z"
      },
      "sha": "436281afdcb68991395f97338197d208212965e2"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4446826509,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDQ0NjgyNjUwOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4446826509",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-11T18:46:29Z"
    },
    {
      "event": "commented",
      "id": 796960231,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5Njk2MDIzMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/796960231",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-11T18:46:52Z",
      "updated_at": "2021-03-11T18:46:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "Addressed @real-or-random's comments:\r\n\r\n```patch\r\ndiff --git a/src/field_10x26_impl.h b/src/field_10x26_impl.h\r\nindex 1a33cd81..c2802514 100644\r\n--- a/src/field_10x26_impl.h\r\n+++ b/src/field_10x26_impl.h\r\n@@ -1230,43 +1230,27 @@ static const secp256k1_modinv32_modinfo secp256k1_const_modinfo_fe = {\r\n static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *x) {\r\n     secp256k1_fe tmp;\r\n     secp256k1_modinv32_signed30 s;\r\n-#ifdef VERIFY\r\n-    int zero_in;\r\n-#endif\r\n \r\n     tmp = *x;\r\n     secp256k1_fe_normalize(&tmp);\r\n-#ifdef VERIFY\r\n-    zero_in = secp256k1_fe_normalizes_to_zero(&tmp);\r\n-#endif\r\n     secp256k1_fe_to_signed30(&s, &tmp);\r\n     secp256k1_modinv32(&s, &secp256k1_const_modinfo_fe);\r\n     secp256k1_fe_from_signed30(r, &s);\r\n \r\n-#ifdef VERIFY\r\n-    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == zero_in);\r\n-#endif\r\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\r\n }\r\n \r\n static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\r\n     secp256k1_fe tmp;\r\n     secp256k1_modinv32_signed30 s;\r\n-#ifdef VERIFY\r\n-    int zero_in;\r\n-#endif\r\n \r\n     tmp = *x;\r\n     secp256k1_fe_normalize_var(&tmp);\r\n-#ifdef VERIFY\r\n-    zero_in = secp256k1_fe_normalizes_to_zero(&tmp);\r\n-#endif\r\n     secp256k1_fe_to_signed30(&s, &tmp);\r\n     secp256k1_modinv32_var(&s, &secp256k1_const_modinfo_fe);\r\n     secp256k1_fe_from_signed30(r, &s);\r\n \r\n-#ifdef VERIFY\r\n-    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == zero_in);\r\n-#endif\r\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\r\n }\r\n \r\n #endif /* SECP256K1_FIELD_REPR_IMPL_H */\r\ndiff --git a/src/field_5x52_impl.h b/src/field_5x52_impl.h\r\nindex b08a087f..56e71bc9 100644\r\n--- a/src/field_5x52_impl.h\r\n+++ b/src/field_5x52_impl.h\r\n@@ -548,43 +548,27 @@ static const secp256k1_modinv64_modinfo secp256k1_const_modinfo_fe = {\r\n static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *x) {\r\n     secp256k1_fe tmp;\r\n     secp256k1_modinv64_signed62 s;\r\n-#ifdef VERIFY\r\n-    int zero_in;\r\n-#endif\r\n \r\n     tmp = *x;\r\n     secp256k1_fe_normalize(&tmp);\r\n-#ifdef VERIFY\r\n-    zero_in = secp256k1_fe_normalizes_to_zero(&tmp);\r\n-#endif\r\n     secp256k1_fe_to_signed62(&s, &tmp);\r\n     secp256k1_modinv64(&s, &secp256k1_const_modinfo_fe);\r\n     secp256k1_fe_from_signed62(r, &s);\r\n \r\n-#ifdef VERIFY\r\n-    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == zero_in);\r\n-#endif\r\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\r\n }\r\n \r\n static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\r\n     secp256k1_fe tmp;\r\n     secp256k1_modinv64_signed62 s;\r\n-#ifdef VERIFY\r\n-    int zero_in;\r\n-#endif\r\n \r\n     tmp = *x;\r\n     secp256k1_fe_normalize_var(&tmp);\r\n-#ifdef VERIFY\r\n-    zero_in = secp256k1_fe_normalizes_to_zero(&tmp);\r\n-#endif\r\n     secp256k1_fe_to_signed62(&s, &tmp);\r\n     secp256k1_modinv64_var(&s, &secp256k1_const_modinfo_fe);\r\n     secp256k1_fe_from_signed62(r, &s);\r\n \r\n-#ifdef VERIFY\r\n-    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == zero_in);\r\n-#endif\r\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\r\n }\r\n \r\n #endif /* SECP256K1_FIELD_REPR_IMPL_H */\r\ndiff --git a/src/modinv32_impl.h b/src/modinv32_impl.h\r\nindex 3eba04fc..aa7988c4 100644\r\n--- a/src/modinv32_impl.h\r\n+++ b/src/modinv32_impl.h\r\n@@ -37,18 +37,18 @@ static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp\r\n     r->v[8] = (int32_t)c;\r\n }\r\n \r\n-/* Compare a with b*factor. */\r\n+/* Return -1 for a<b*factor, 0 for a==b*factor, 1 for a>b*factor. A consists of alen limbs; b has 9. */\r\n static int secp256k1_modinv32_mul_cmp_30(const secp256k1_modinv32_signed30 *a, int alen, const secp256k1_modinv32_signed30 *b, int32_t factor) {\r\n     int i;\r\n     secp256k1_modinv32_signed30 am, bm;\r\n     secp256k1_modinv32_mul_30(&am, a, alen, 1); /* Normalize all but the top limb of a. */\r\n     secp256k1_modinv32_mul_30(&bm, b, 9, factor);\r\n+    for (i = 0; i < 8; ++i) {\r\n+        /* Verify that all but the top limb of a and b are normalized. */\r\n+        VERIFY_CHECK(am.v[i] >> 30 == 0);\r\n+        VERIFY_CHECK(bm.v[i] >> 30 == 0);\r\n+    }\r\n     for (i = 8; i >= 0; --i) {\r\n-        if (i != 8) {\r\n-            /* Verify that all but the top limb of a and b are normalized. */\r\n-            VERIFY_CHECK(am.v[i] >> 30 == 0);\r\n-            VERIFY_CHECK(bm.v[i] >> 30 == 0);\r\n-        }\r\n         if (am.v[i] < bm.v[i]) return -1;\r\n         if (am.v[i] > bm.v[i]) return 1;\r\n     }\r\n@@ -155,7 +155,7 @@ static void secp256k1_modinv32_normalize_30(secp256k1_modinv32_signed30 *r, int3\r\n     VERIFY_CHECK(r7 >> 30 == 0);\r\n     VERIFY_CHECK(r8 >> 30 == 0);\r\n     VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, 9, &modinfo->modulus, 0) >= 0); /* r >= 0 */\r\n-    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, 9, &modinfo->modulus, 1) < 0); /* r < P */\r\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, 9, &modinfo->modulus, 1) < 0); /* r < modulus */\r\n #endif\r\n }\r\n \r\ndiff --git a/src/modinv64_impl.h b/src/modinv64_impl.h\r\nindex e1ba8b63..78505fa1 100644\r\n--- a/src/modinv64_impl.h\r\n+++ b/src/modinv64_impl.h\r\n@@ -43,18 +43,18 @@ static void secp256k1_modinv64_mul_62(secp256k1_modinv64_signed62 *r, const secp\r\n     r->v[4] = (int64_t)c;\r\n }\r\n \r\n-/* Compare a with b*bf. */\r\n+/* Return -1 for a<b*factor, 0 for a==b*factor, 1 for a>b*factor. A has alen limbs; b has 5. */\r\n static int secp256k1_modinv64_mul_cmp_62(const secp256k1_modinv64_signed62 *a, int alen, const secp256k1_modinv64_signed62 *b, int64_t factor) {\r\n     int i;\r\n     secp256k1_modinv64_signed62 am, bm;\r\n     secp256k1_modinv64_mul_62(&am, a, alen, 1); /* Normalize all but the top limb of a. */\r\n     secp256k1_modinv64_mul_62(&bm, b, 5, factor);\r\n+    for (i = 0; i < 4; ++i) {\r\n+        /* Verify that all but the top limb of a and b are normalized. */\r\n+        VERIFY_CHECK(am.v[i] >> 62 == 0);\r\n+        VERIFY_CHECK(bm.v[i] >> 62 == 0);\r\n+    }\r\n     for (i = 4; i >= 0; --i) {\r\n-        if (i != 4) {\r\n-            /* Verify that all but the top limb of a and b are normalized. */\r\n-            VERIFY_CHECK(am.v[i] >> 62 == 0);\r\n-            VERIFY_CHECK(bm.v[i] >> 62 == 0);\r\n-        }\r\n         if (am.v[i] < bm.v[i]) return -1;\r\n         if (am.v[i] > bm.v[i]) return 1;\r\n     }\r\n@@ -132,7 +132,7 @@ static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int6\r\n     VERIFY_CHECK(r3 >> 62 == 0);\r\n     VERIFY_CHECK(r4 >> 62 == 0);\r\n     VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 0) >= 0); /* r >= 0 */\r\n-    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < P */\r\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\r\n #endif\r\n }\r\n \r\ndiff --git a/src/scalar_4x64_impl.h b/src/scalar_4x64_impl.h\r\nindex a1def26f..f8f37ff8 100644\r\n--- a/src/scalar_4x64_impl.h\r\n+++ b/src/scalar_4x64_impl.h\r\n@@ -808,18 +808,14 @@ static void secp256k1_scalar_from_signed62(secp256k1_scalar *r, const secp256k1_\r\n     r->d[2] = a2 >> 4 | a3 << 58;\r\n     r->d[3] = a3 >> 6 | a4 << 56;\r\n \r\n-#ifdef VERIFY\r\n     VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\r\n-#endif\r\n }\r\n \r\n static void secp256k1_scalar_to_signed62(secp256k1_modinv64_signed62 *r, const secp256k1_scalar *a) {\r\n     const uint64_t M62 = UINT64_MAX >> 2;\r\n     const uint64_t a0 = a->d[0], a1 = a->d[1], a2 = a->d[2], a3 = a->d[3];\r\n \r\n-#ifdef VERIFY\r\n     VERIFY_CHECK(secp256k1_scalar_check_overflow(a) == 0);\r\n-#endif\r\n \r\n     r->v[0] =  a0                   & M62;\r\n     r->v[1] = (a0 >> 62 | a1 <<  2) & M62;\r\ndiff --git a/src/scalar_8x32_impl.h b/src/scalar_8x32_impl.h\r\nindex 62c7ae71..3282c68d 100644\r\n--- a/src/scalar_8x32_impl.h\r\n+++ b/src/scalar_8x32_impl.h\r\n@@ -670,9 +670,7 @@ static void secp256k1_scalar_from_signed30(secp256k1_scalar *r, const secp256k1_\r\n     r->d[6] = a6 >> 12 | a7 << 18;\r\n     r->d[7] = a7 >> 14 | a8 << 16;\r\n \r\n-#ifdef VERIFY\r\n     VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\r\n-#endif\r\n }\r\n \r\n static void secp256k1_scalar_to_signed30(secp256k1_modinv32_signed30 *r, const secp256k1_scalar *a) {\r\n@@ -680,9 +678,7 @@ static void secp256k1_scalar_to_signed30(secp256k1_modinv32_signed30 *r, const s\r\n     const uint32_t a0 = a->d[0], a1 = a->d[1], a2 = a->d[2], a3 = a->d[3],\r\n                    a4 = a->d[4], a5 = a->d[5], a6 = a->d[6], a7 = a->d[7];\r\n \r\n-#ifdef VERIFY\r\n     VERIFY_CHECK(secp256k1_scalar_check_overflow(a) == 0);\r\n-#endif\r\n \r\n     r->v[0] =  a0                   & M30;\r\n     r->v[1] = (a0 >> 30 | a1 <<  2) & M30;\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-796960231",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4446828037,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDQ0NjgyODAzNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4446828037",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-11T18:46:52Z"
    },
    {
      "event": "subscribed",
      "id": 4446828042,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ0NDY4MjgwNDI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4446828042",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-11T18:46:52Z"
    },
    {
      "event": "commented",
      "id": 796984889,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5Njk4NDg4OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/796984889",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-11T19:27:55Z",
      "updated_at": "2021-03-11T19:27:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "FWIW, ACK the parts of the code by @peterdettman here. I assume that's implied by it being my PR, but still - most of the non-test code isn't mine here.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-796984889",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4447002888,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDQ0NzAwMjg4OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4447002888",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-11T19:27:55Z"
    },
    {
      "event": "subscribed",
      "id": 4447002891,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ0NDcwMDI4OTE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4447002891",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-11T19:27:55Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MWUwZTg4NWM4YWM4MTRjMzYyMWQ5ZTQzZTY2ZDYwZjI1ZTMyNGU4ZQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1e0e885c8ac814c3621d9e43e66d60f25e324e8e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1e0e885c8ac814c3621d9e43e66d60f25e324e8e",
      "tree": {
        "sha": "a09708479d2cb1189e611a36e1310934903e4cc9",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/a09708479d2cb1189e611a36e1310934903e4cc9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/436281afdcb68991395f97338197d208212965e2",
          "sha": "436281afdcb68991395f97338197d208212965e2",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/436281afdcb68991395f97338197d208212965e2"
        }
      ],
      "message": "Make field/scalar code use the new modinv modules for inverses",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-12T18:06:14Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-11-29T22:02:01Z"
      },
      "sha": "1e0e885c8ac814c3621d9e43e66d60f25e324e8e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6YWE5Y2M1MjE4MDAxZjE0ZjQzMTJiZGUxMDU4NDE3ZDRiNzU1ZmQxMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/aa9cc5218001f14f4312bde1058417d4b755fd11",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/aa9cc5218001f14f4312bde1058417d4b755fd11",
      "tree": {
        "sha": "607354357a50cc0215d2edd1383b7799dd5d081a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/607354357a50cc0215d2edd1383b7799dd5d081a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1e0e885c8ac814c3621d9e43e66d60f25e324e8e",
          "sha": "1e0e885c8ac814c3621d9e43e66d60f25e324e8e",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1e0e885c8ac814c3621d9e43e66d60f25e324e8e"
        }
      ],
      "message": "Improve field/scalar inverse tests\n\nAdd a new run_inverse_tests that replaces all existing field/scalar inverse tests,\nand tests a few identities for fixed inputs, small numbers (-999...999), random\ninputs (structured and unstructured), as well as comparing with the output of\nsecp256k1_fe_inv_all_var.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-12T18:06:18Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-12T06:20:32Z"
      },
      "sha": "aa9cc5218001f14f4312bde1058417d4b755fd11"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6NTQzN2U3YmRmYmZmZGRmNjlmZGY3YjRhZjdlOTk3Yzc4ZjVkYWZiZg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/5437e7bdfbffddf69fdf7b4af7e997c78f5dafbf",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/5437e7bdfbffddf69fdf7b4af7e997c78f5dafbf",
      "tree": {
        "sha": "22f2c277532ca98a9cb09b9330c1a4a810b16824",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/22f2c277532ca98a9cb09b9330c1a4a810b16824"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/aa9cc5218001f14f4312bde1058417d4b755fd11",
          "sha": "aa9cc5218001f14f4312bde1058417d4b755fd11",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/aa9cc5218001f14f4312bde1058417d4b755fd11"
        }
      ],
      "message": "Remove unused scalar_sqr",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-12T18:06:18Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-01-24T03:24:33Z"
      },
      "sha": "5437e7bdfbffddf69fdf7b4af7e997c78f5dafbf"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MjA0NDhiOGQwOWE0OTJhZmNmY2FlNzcyMTAzM2MxM2E0NGE3NzZmZA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/20448b8d09a492afcfcae7721033c13a44a776fd",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/20448b8d09a492afcfcae7721033c13a44a776fd",
      "tree": {
        "sha": "60df3ea1166a621176987ef60dfa108dd9972ec1",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/60df3ea1166a621176987ef60dfa108dd9972ec1"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/5437e7bdfbffddf69fdf7b4af7e997c78f5dafbf",
          "sha": "5437e7bdfbffddf69fdf7b4af7e997c78f5dafbf",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/5437e7bdfbffddf69fdf7b4af7e997c78f5dafbf"
        }
      ],
      "message": "Remove unused Jacobi symbol support\n\nNo exposed functions rely on Jacobi symbol computation anymore. Remove it; it can always\nbe brough back later if needed.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-12T18:06:18Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-11T22:56:17Z"
      },
      "sha": "20448b8d09a492afcfcae7721033c13a44a776fd"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4452027514,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDQ1MjAyNzUxNA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4452027514",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-12T18:06:38Z"
    },
    {
      "event": "commented",
      "id": 797663651,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5NzY2MzY1MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/797663651",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-12T18:07:48Z",
      "updated_at": "2021-03-12T18:32:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "To make sure we the unused evaluations of expressions inside `VERIFY_CHECK`s don't affect runtime, I made this change:\r\n\r\n```patch\r\ndiff --git a/src/field_5x52_impl.h b/src/field_5x52_impl.h\r\nindex 56e71bc9..b73cfea2 100644\r\n--- a/src/field_5x52_impl.h\r\n+++ b/src/field_5x52_impl.h\r\n@@ -555,7 +555,9 @@ static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *x) {\r\n     secp256k1_modinv64(&s, &secp256k1_const_modinfo_fe);\r\n     secp256k1_fe_from_signed62(r, &s);\r\n \r\n+#ifdef VERIFY\r\n     VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\r\n+#endif\r\n }\r\n \r\n static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\r\n@@ -568,7 +570,9 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *x) {\r\n     secp256k1_modinv64_var(&s, &secp256k1_const_modinfo_fe);\r\n     secp256k1_fe_from_signed62(r, &s);\r\n \r\n+#ifdef VERIFY\r\n     VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == secp256k1_fe_normalizes_to_zero(&tmp));\r\n+#endif\r\n }\r\n \r\n #endif /* SECP256K1_FIELD_REPR_IMPL_H */\r\ndiff --git a/src/scalar_4x64_impl.h b/src/scalar_4x64_impl.h\r\nindex f8f37ff8..a1def26f 100644\r\n--- a/src/scalar_4x64_impl.h\r\n+++ b/src/scalar_4x64_impl.h\r\n@@ -808,14 +808,18 @@ static void secp256k1_scalar_from_signed62(secp256k1_scalar *r, const secp256k1_\r\n     r->d[2] = a2 >> 4 | a3 << 58;\r\n     r->d[3] = a3 >> 6 | a4 << 56;\r\n \r\n+#ifdef VERIFY\r\n     VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\r\n+#endif\r\n }\r\n \r\n static void secp256k1_scalar_to_signed62(secp256k1_modinv64_signed62 *r, const secp256k1_scalar *a) {\r\n     const uint64_t M62 = UINT64_MAX >> 2;\r\n     const uint64_t a0 = a->d[0], a1 = a->d[1], a2 = a->d[2], a3 = a->d[3];\r\n \r\n+#ifdef VERIFY\r\n     VERIFY_CHECK(secp256k1_scalar_check_overflow(a) == 0);\r\n+#endif\r\n \r\n     r->v[0] =  a0                   & M62;\r\n     r->v[1] = (a0 >> 62 | a1 <<  2) & M62;\r\ndiff --git a/src/scalar_8x32_impl.h b/src/scalar_8x32_impl.h\r\nindex 3282c68d..62c7ae71 100644\r\n--- a/src/scalar_8x32_impl.h\r\n+++ b/src/scalar_8x32_impl.h\r\n@@ -670,7 +670,9 @@ static void secp256k1_scalar_from_signed30(secp256k1_scalar *r, const secp256k1_\r\n     r->d[6] = a6 >> 12 | a7 << 18;\r\n     r->d[7] = a7 >> 14 | a8 << 16;\r\n \r\n+#ifdef VERIFY\r\n     VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\r\n+#endif\r\n }\r\n \r\n static void secp256k1_scalar_to_signed30(secp256k1_modinv32_signed30 *r, const secp256k1_scalar *a) {\r\n@@ -678,7 +680,9 @@ static void secp256k1_scalar_to_signed30(secp256k1_modinv32_signed30 *r, const s\r\n     const uint32_t a0 = a->d[0], a1 = a->d[1], a2 = a->d[2], a3 = a->d[3],\r\n                    a4 = a->d[4], a5 = a->d[5], a6 = a->d[6], a7 = a->d[7];\r\n \r\n+#ifdef VERIFY\r\n     VERIFY_CHECK(secp256k1_scalar_check_overflow(a) == 0);\r\n+#endif\r\n \r\n     r->v[0] =  a0                   & M30;\r\n     r->v[1] = (a0 >> 30 | a1 <<  2) & M30;\r\n```\r\n\r\nSee also #902.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-797663651",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 797686902,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5NzY4NjkwMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/797686902",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-12T18:59:52Z",
      "updated_at": "2021-03-12T18:59:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "@real-or-random, @sanket1729, maybe @peterdettman: feel like reviewing the final state things are in now?",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-797686902",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "mentioned",
      "id": 4452172336,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDQ1MjE3MjMzNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4452172336",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-12T18:59:52Z"
    },
    {
      "event": "subscribed",
      "id": 4452172340,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ0NTIxNzIzNDA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4452172340",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-12T18:59:52Z"
    },
    {
      "event": "mentioned",
      "id": 4452172345,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDQ1MjE3MjM0NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4452172345",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-12T18:59:52Z"
    },
    {
      "event": "subscribed",
      "id": 4452172353,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ0NTIxNzIzNTM=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4452172353",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-12T18:59:52Z"
    },
    {
      "event": "mentioned",
      "id": 4452172360,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDQ1MjE3MjM2MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4452172360",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-12T18:59:53Z"
    },
    {
      "event": "subscribed",
      "id": 4452172364,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ0NTIxNzIzNjQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4452172364",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-12T18:59:53Z"
    },
    {
      "event": "commented",
      "id": 799525688,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5OTUyNTY4OA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/799525688",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-15T15:46:33Z",
      "updated_at": "2021-03-15T15:46:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "Can you remove `libgmp-dev` and `libgmp-dev:i386` from `ci/linux-debian.Dockerfile`?",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-799525688",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 799567612,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5OTU2NzYxMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/799567612",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-15T16:41:05Z",
      "updated_at": "2021-03-15T16:41:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "Branch coverage looks good, by the way!\r\n![image](https://user-images.githubusercontent.com/1071625/111188623-89a81180-85b5-11eb-8111-4847105a9422.png)\r\n",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-799567612",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MWYyMzNiM2ZhMDVlYjI5YTc0NDQ4N2UwNjgyZDkyNTA1NWZiMGQ0Yw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1f233b3fa05eb29a744487e0682d925055fb0d4c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1f233b3fa05eb29a744487e0682d925055fb0d4c",
      "tree": {
        "sha": "37692cf1a33fa5cfa230c32b1f499babbc109eb5",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/37692cf1a33fa5cfa230c32b1f499babbc109eb5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/20448b8d09a492afcfcae7721033c13a44a776fd",
          "sha": "20448b8d09a492afcfcae7721033c13a44a776fd",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/20448b8d09a492afcfcae7721033c13a44a776fd"
        }
      ],
      "message": "Remove num/gmp support\n\nThe whole \"num\" API and its libgmp-based implementation are now unused. Remove them.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-15T20:01:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-11T23:04:58Z"
      },
      "sha": "1f233b3fa05eb29a744487e0682d925055fb0d4c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6OTE2NGExYjY1ODJlMmZjODMzYzc2MGEzNDAzZDI2YjliMGIzYjdiMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/9164a1b6582e2fc833c760a3403d26b9b0b3b7b3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/9164a1b6582e2fc833c760a3403d26b9b0b3b7b3",
      "tree": {
        "sha": "3927db7a33cf8830640fb2a82cdfe4ddf10afb1d",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/3927db7a33cf8830640fb2a82cdfe4ddf10afb1d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1f233b3fa05eb29a744487e0682d925055fb0d4c",
          "sha": "1f233b3fa05eb29a744487e0682d925055fb0d4c",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1f233b3fa05eb29a744487e0682d925055fb0d4c"
        }
      ],
      "message": "Optimization: special-case zero modulus limbs in modinv64\n\nBoth the field and scalar modulus can be written in signed{30,62} notation\nwith one or more zero limbs. Make use of this in the update_de function to\navoid a few wide multiplications when that is the case.\n\nThis doesn't appear to be a win in the 32-bit implementation, so only\ndo it for the 64-bit one.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-15T20:01:56Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-11-28T23:58:22Z"
      },
      "sha": "9164a1b6582e2fc833c760a3403d26b9b0b3b7b3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6YjMwNjkzNWFjMTJiYjI0ZmQ5MzFkNzM1YjRkZmMwN2Y3MDdlNzQ0Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b306935ac12bb24fd931d735b4dfc07f707e7447",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b306935ac12bb24fd931d735b4dfc07f707e7447",
      "tree": {
        "sha": "c00b5a6c8c40ba23a7ec325778c519b6d22de2bf",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/c00b5a6c8c40ba23a7ec325778c519b6d22de2bf"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/9164a1b6582e2fc833c760a3403d26b9b0b3b7b3",
          "sha": "9164a1b6582e2fc833c760a3403d26b9b0b3b7b3",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/9164a1b6582e2fc833c760a3403d26b9b0b3b7b3"
        }
      ],
      "message": "Optimization: use formulas instead of lookup tables for cancelling g bits\n\nThis only seems to be a win on 64-bit platforms, so only do it there.\n\nRefactored by: Pieter Wuille <pieter@wuille.net>",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-15T20:01:56Z"
      },
      "author": {
        "name": "Peter Dettman",
        "email": "peter.dettman@gmail.com",
        "date": "2020-12-16T00:19:08Z"
      },
      "sha": "b306935ac12bb24fd931d735b4dfc07f707e7447"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6ZWJjMWFmNzAwZjllYzZlOTY1ODYxNTJiNzA5MGEyYTY0OTQzMDhjMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/ebc1af700f9ec6e96586152b7090a2a6494308c3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/ebc1af700f9ec6e96586152b7090a2a6494308c3",
      "tree": {
        "sha": "150c6f141d117c3f86d6f3f9338164fcac486700",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/150c6f141d117c3f86d6f3f9338164fcac486700"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b306935ac12bb24fd931d735b4dfc07f707e7447",
          "sha": "b306935ac12bb24fd931d735b4dfc07f707e7447",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b306935ac12bb24fd931d735b4dfc07f707e7447"
        }
      ],
      "message": "Optimization: track f,g limb count and pass to new variable-time update_fg_var\n\nThe magnitude of the f and g variables generally goes down as the algorithm\nprogresses. Make use of this by keeping tracking how many limbs are used, and\nwhen the number becomes small enough, make use of this to reduce the complexity\nof arithmetic on them.\n\nRefactored by: Pieter Wuille <pieter@wuille.net>",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-15T20:01:56Z"
      },
      "author": {
        "name": "Peter Dettman",
        "email": "peter.dettman@gmail.com",
        "date": "2020-12-16T02:17:19Z"
      },
      "sha": "ebc1af700f9ec6e96586152b7090a2a6494308c3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MjRhZDA0ZmMwNjRlNzFhYmRmOTczZTA2MWMzMGViMWYzZjc4ZGIzOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "tree": {
        "sha": "80e278d7406f3255673d63042578af65ff129779",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/80e278d7406f3255673d63042578af65ff129779"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/ebc1af700f9ec6e96586152b7090a2a6494308c3",
          "sha": "ebc1af700f9ec6e96586152b7090a2a6494308c3",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/ebc1af700f9ec6e96586152b7090a2a6494308c3"
        }
      ],
      "message": "Make scalar_inverse{,_var} benchmark scale with SECP256K1_BENCH_ITERS",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-03-15T20:01:56Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-01-22T23:47:44Z"
      },
      "sha": "24ad04fc064e71abdf973e061c30eb1f3f78db39"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4460824374,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDQ2MDgyNDM3NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4460824374",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-15T20:02:06Z"
    },
    {
      "event": "commented",
      "id": 799713479,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc5OTcxMzQ3OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/799713479",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-15T20:02:18Z",
      "updated_at": "2021-03-15T20:02:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Can you remove `libgmp-dev` and `libgmp-dev:i386` from `ci/linux-debian.Dockerfile`?\r\n\r\nDone.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-799713479",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "reviewed",
      "id": 613265660,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEzMjY1NjYw",
      "url": null,
      "actor": null,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 24ad04fc064e71abdf973e061c30eb1f3f78db39 careful code review, some testing",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#pullrequestreview-613265660",
      "submitted_at": "2021-03-16T13:49:33Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
    },
    {
      "event": "commented",
      "id": 800535103,
      "node_id": "MDEyOklzc3VlQ29tbWVudDgwMDUzNTEwMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/800535103",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-16T19:13:59Z",
      "updated_at": "2021-03-16T19:13:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK 24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "user": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-800535103",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "commented",
      "id": 800617546,
      "node_id": "MDEyOklzc3VlQ29tbWVudDgwMDYxNzU0Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/800617546",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-16T21:27:09Z",
      "updated_at": "2021-03-16T21:27:09Z",
      "author_association": "NONE",
      "body": "ACK 24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#issuecomment-800617546",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/831"
    },
    {
      "event": "merged",
      "id": 4473115206,
      "node_id": "MDExOk1lcmdlZEV2ZW50NDQ3MzExNTIwNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4473115206",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "26de4dfeb1f1436dae1fcf17f57bdaa43540f940",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/26de4dfeb1f1436dae1fcf17f57bdaa43540f940",
      "created_at": "2021-03-18T00:04:26Z"
    },
    {
      "event": "closed",
      "id": 4473115216,
      "node_id": "MDExOkNsb3NlZEV2ZW50NDQ3MzExNTIxNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4473115216",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-18T00:04:27Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "dependabot[bot]",
        "id": 49699333,
        "node_id": "MDM6Qm90NDk2OTkzMzM=",
        "avatar_url": "https://avatars.githubusercontent.com/in/29110?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dependabot%5Bbot%5D",
        "html_url": "https://github.com/apps/dependabot",
        "followers_url": "https://api.github.com/users/dependabot%5Bbot%5D/followers",
        "following_url": "https://api.github.com/users/dependabot%5Bbot%5D/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dependabot%5Bbot%5D/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dependabot%5Bbot%5D/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dependabot%5Bbot%5D/subscriptions",
        "organizations_url": "https://api.github.com/users/dependabot%5Bbot%5D/orgs",
        "repos_url": "https://api.github.com/users/dependabot%5Bbot%5D/repos",
        "events_url": "https://api.github.com/users/dependabot%5Bbot%5D/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dependabot%5Bbot%5D/received_events",
        "type": "Bot",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-18T05:25:26Z",
      "updated_at": "2021-03-18T05:25:26Z",
      "source": {
        "issue": {
          "id": 834405552,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTk1MjI1OTA5",
          "url": "https://api.github.com/repos/GigaBitcoin/secp256k1.swift/issues/72",
          "repository_url": "https://api.github.com/repos/GigaBitcoin/secp256k1.swift",
          "labels_url": "https://api.github.com/repos/GigaBitcoin/secp256k1.swift/issues/72/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/GigaBitcoin/secp256k1.swift/issues/72/comments",
          "events_url": "https://api.github.com/repos/GigaBitcoin/secp256k1.swift/issues/72/events",
          "html_url": "https://github.com/GigaBitcoin/secp256k1.swift/pull/72",
          "number": 72,
          "state": "closed",
          "state_reason": null,
          "title": "Bump Sources/bindings/secp256k1 from `4c3ba88` to `26de4df`",
          "body": "Bumps [Sources/bindings/secp256k1](https://github.com/bitcoin-core/secp256k1) from `4c3ba88` to `26de4df`.\n<details>\n<summary>Commits</summary>\n<ul>\n<li><a href=\"https://github.com/bitcoin-core/secp256k1/commit/26de4dfeb1f1436dae1fcf17f57bdaa43540f940\"><code>26de4df</code></a> Merge <a href=\"https://github.com/bitcoin-core/secp256k1/issues/831\">#831</a>: Safegcd inverses, drop Jacobi symbols, remove libgmp</li>\n<li><a href=\"https://github.com/bitcoin-core/secp256k1/commit/24ad04fc064e71abdf973e061c30eb1f3f78db39\"><code>24ad04f</code></a> Make scalar_inverse{,_var} benchmark scale with SECP256K1_BENCH_ITERS</li>\n<li><a href=\"https://github.com/bitcoin-core/secp256k1/commit/ebc1af700f9ec6e96586152b7090a2a6494308c3\"><code>ebc1af7</code></a> Optimization: track f,g limb count and pass to new variable-time update_fg_var</li>\n<li><a href=\"https://github.com/bitcoin-core/secp256k1/commit/b306935ac12bb24fd931d735b4dfc07f707e7447\"><code>b306935</code></a> Optimization: use formulas instead of lookup tables for cancelling g bits</li>\n<li><a href=\"https://github.com/bitcoin-core/secp256k1/commit/9164a1b6582e2fc833c760a3403d26b9b0b3b7b3\"><code>9164a1b</code></a> Optimization: special-case zero modulus limbs in modinv64</li>\n<li><a href=\"https://github.com/bitcoin-core/secp256k1/commit/1f233b3fa05eb29a744487e0682d925055fb0d4c\"><code>1f233b3</code></a> Remove num/gmp support</li>\n<li><a href=\"https://github.com/bitcoin-core/secp256k1/commit/20448b8d09a492afcfcae7721033c13a44a776fd\"><code>20448b8</code></a> Remove unused Jacobi symbol support</li>\n<li><a href=\"https://github.com/bitcoin-core/secp256k1/commit/5437e7bdfbffddf69fdf7b4af7e997c78f5dafbf\"><code>5437e7b</code></a> Remove unused scalar_sqr</li>\n<li><a href=\"https://github.com/bitcoin-core/secp256k1/commit/aa9cc5218001f14f4312bde1058417d4b755fd11\"><code>aa9cc52</code></a> Improve field/scalar inverse tests</li>\n<li><a href=\"https://github.com/bitcoin-core/secp256k1/commit/1e0e885c8ac814c3621d9e43e66d60f25e324e8e\"><code>1e0e885</code></a> Make field/scalar code use the new modinv modules for inverses</li>\n<li>Additional commits viewable in <a href=\"https://github.com/bitcoin-core/secp256k1/compare/4c3ba88c3a869ae3f45990286c79860539a5bff8...26de4dfeb1f1436dae1fcf17f57bdaa43540f940\">compare view</a></li>\n</ul>\n</details>\n<br />\n\n\nDependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`.\n\n[//]: # (dependabot-automerge-start)\n[//]: # (dependabot-automerge-end)\n\n---\n\n<details>\n<summary>Dependabot commands and options</summary>\n<br />\n\nYou can trigger Dependabot actions by commenting on this PR:\n- `@dependabot rebase` will rebase this PR\n- `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it\n- `@dependabot merge` will merge this PR after your CI passes on it\n- `@dependabot squash and merge` will squash and merge this PR after your CI passes on it\n- `@dependabot cancel merge` will cancel a previously requested merge and block automerging\n- `@dependabot reopen` will reopen this PR if it is closed\n- `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually\n- `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)\n- `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)\n\n\n</details>",
          "user": {
            "login": "dependabot[bot]",
            "id": 49699333,
            "node_id": "MDM6Qm90NDk2OTkzMzM=",
            "avatar_url": "https://avatars.githubusercontent.com/in/29110?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dependabot%5Bbot%5D",
            "html_url": "https://github.com/apps/dependabot",
            "followers_url": "https://api.github.com/users/dependabot%5Bbot%5D/followers",
            "following_url": "https://api.github.com/users/dependabot%5Bbot%5D/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dependabot%5Bbot%5D/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dependabot%5Bbot%5D/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dependabot%5Bbot%5D/subscriptions",
            "organizations_url": "https://api.github.com/users/dependabot%5Bbot%5D/orgs",
            "repos_url": "https://api.github.com/users/dependabot%5Bbot%5D/repos",
            "events_url": "https://api.github.com/users/dependabot%5Bbot%5D/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dependabot%5Bbot%5D/received_events",
            "type": "Bot",
            "site_admin": false
          },
          "labels": [
            {
              "id": 2221984340,
              "node_id": "MDU6TGFiZWwyMjIxOTg0MzQw",
              "url": "https://api.github.com/repos/GigaBitcoin/secp256k1.swift/labels/dependencies",
              "name": "dependencies",
              "description": "Pull requests that update a dependency file",
              "color": "0366d6",
              "default": false
            },
            {
              "id": 2337382170,
              "node_id": "MDU6TGFiZWwyMzM3MzgyMTcw",
              "url": "https://api.github.com/repos/GigaBitcoin/secp256k1.swift/labels/submodules",
              "name": "submodules",
              "description": "Pull requests that update Submodules code",
              "color": "000000",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 0,
          "pull_request": {
            "url": "https://api.github.com/repos/GigaBitcoin/secp256k1.swift/pulls/72",
            "html_url": "https://github.com/GigaBitcoin/secp256k1.swift/pull/72",
            "diff_url": "https://github.com/GigaBitcoin/secp256k1.swift/pull/72.diff",
            "patch_url": "https://github.com/GigaBitcoin/secp256k1.swift/pull/72.patch"
          },
          "closed_at": "2021-03-18T05:54:24Z",
          "created_at": "2021-03-18T05:25:26Z",
          "updated_at": "2021-03-18T05:54:25Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-24T20:55:39Z",
      "updated_at": "2021-03-24T20:55:39Z",
      "source": {
        "issue": {
          "id": 840075940,
          "node_id": "MDU6SXNzdWU4NDAwNzU5NDA=",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/910",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/910/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/910/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/910/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/issues/910",
          "number": 910,
          "state": "closed",
          "state_reason": "completed",
          "title": "Randomly message \"core dumped\" on secp256k1_fe_inv_var",
          "body": "Hi, \r\nI try to implement a point addition in affine coordinate and to benchmark it.\r\nCompilation are ok:\r\n`gcc -o test2.exe -O2 -I secp256k1/src/ -I secp256k1/ test2.c -lgmp`\r\n\r\nbut i've sometimes  an error message on program execution (core dumped).\r\nNot on every execution.\r\n\r\nthis is my code :\r\n\r\n```c\r\n#include \"libsecp256k1-config.h\"\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#include <time.h>\r\n\r\n#include \"include/secp256k1.h\"\r\n#include \"assumptions.h\"\r\n#include \"group.h\"\r\n#include \"secp256k1.c\"\r\n\r\n\r\n#define ROUNDS 100000000`\r\n\r\nstatic void light_add(secp256k1_fe *xr,secp256k1_fe *yr,  const secp256k1_fe *x1, const secp256k1_fe *y1, const secp256k1_fe *x2, const secp256k1_fe *y2){\r\n        \r\n        secp256k1_fe xtmp,ytmp,x1neg,x2neg,y2neg,xinv,m;\r\n        xtmp = *x1;\r\n        ytmp = *y1;\r\n        int f;\r\n\r\n        secp256k1_fe_negate(&x2neg,x2,f); //x2neg=-x2\r\n        secp256k1_fe_negate(&y2neg,y2,f);//y2neg=-y2\r\n        secp256k1_fe_negate(&x1neg,x1,f);//x1neg=-x1\r\n\r\n        secp256k1_fe_add(&xtmp,&x2neg); //(x1-x2)\r\n        secp256k1_fe_add(&ytmp,&y2neg);//(y1-y2)\r\n     \r\n        secp256k1_fe_inv_var(&xinv,&xtmp); //inverse_mod(x1-x2,P) \r\n\r\n        secp256k1_fe_mul(&m,&ytmp,&xinv); //m=(y1-y2)*(x1-x2)^-1\r\n        secp256k1_fe_sqr(xr,&m);//m^2\r\n\r\n        secp256k1_fe_add(xr,&x1neg); //xr=m^2-x1\r\n        secp256k1_fe_add(xr,&x2neg); //xr=m^2-x1-x2\r\n\r\n        xtmp = *xr;\r\n        secp256k1_fe_add(&xtmp,&x1neg); //(xr-x1)\r\n        secp256k1_fe_mul(&xtmp,&m,&xtmp); //m*(xr-x1)\r\n        secp256k1_fe_add(&xtmp,y1); //y1+(xr-x1)\r\n        secp256k1_fe_negate(yr,&xtmp,f); //yr=-(y1+(xr-x1))\r\n\r\n}\r\n\r\nint main(int argc, char** argv) {\r\n\r\n\r\n    secp256k1_fe xr,yr;\r\n    secp256k1_ge pt1,pt2;\r\n    secp256k1_gej pt1j,pt2j;\r\n    time_t now;\r\n\r\n\r\n    secp256k1_gej_set_ge(&pt2j, &secp256k1_ge_const_g);\r\n\r\n    secp256k1_gej_double_var(&pt2j, &pt2j, NULL);\r\n    secp256k1_ge_set_gej(&pt2, &pt2j);               //pt2=2*G\r\n\r\n\r\n    time(&now);\r\n    printf(\"Today is : %s\", ctime(&now));\r\n\r\n    for (int i=0;i<ROUNDS;i++){\r\n\r\n        light_add(&pt2.x,&pt2.y,&pt2.x,&pt2.y,&secp256k1_ge_const_g.x,&secp256k1_ge_const_g.y);\r\n    }\r\n    time(&now);\r\n    printf(\"Today is : %s\", ctime(&now));\r\n}\r\n```\r\n\r\nThe issue is difficult to track on debug mode because it's happens maybe 1 per 1 billion times additions but it seems to comes from \r\nsecp256k1_fe_inv_var.\r\n\r\nDo you know why there can have is this issue?\r\nRegards\r\nCrunchy",
          "user": {
            "login": "CrunchyFanch",
            "id": 3426589,
            "node_id": "MDQ6VXNlcjM0MjY1ODk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/3426589?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/CrunchyFanch",
            "html_url": "https://github.com/CrunchyFanch",
            "followers_url": "https://api.github.com/users/CrunchyFanch/followers",
            "following_url": "https://api.github.com/users/CrunchyFanch/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/CrunchyFanch/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/CrunchyFanch/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/CrunchyFanch/subscriptions",
            "organizations_url": "https://api.github.com/users/CrunchyFanch/orgs",
            "repos_url": "https://api.github.com/users/CrunchyFanch/repos",
            "events_url": "https://api.github.com/users/CrunchyFanch/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/CrunchyFanch/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 28,
          "closed_at": "2021-03-24T22:10:59Z",
          "created_at": "2021-03-24T19:13:39Z",
          "updated_at": "2021-03-24T22:10:59Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-03-24T21:13:10Z",
      "updated_at": "2021-03-24T21:13:10Z",
      "source": {
        "issue": {
          "id": 102062873,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NDI4OTE4NTk=",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/290",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/290/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/290/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/290/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/pull/290",
          "number": 290,
          "state": "closed",
          "state_reason": null,
          "title": "Add native num implementation; modular inverse and Jacobi symbol without GMP",
          "body": "Implement `num.h` API without GMP backend; benchmarks show modular inversion taking about 65% longer than with GMP, but much faster than the constant-time version.\n\nI will update this PR with an implementation of the Jacobi symbol computation; for now I'm pushing it in the hopes that somebody will see some more perf improvements that will let us catch up with GMP. (In fact, since we don't require arbitrary size numbers or allocation we should in principle be able to beat them..). This has a modular inverse but no Jacobi symbol.\n\nThis is required for https://github.com/bitcoin/secp256k1/pull/262 because we do not want to require a GMP dependency.\n\n**Edit:** I have a <a href=\"http://www.jstor.org/stable/40234522\">paper</a> by the author of the GMP code which describes (mostly) what they are doing. With this I am able to read the GMP code; I think I see how to optimize it for our special case. So we should hold off any detailed review until I've written new gcd code.\n",
          "user": {
            "login": "apoelstra",
            "id": 1351933,
            "node_id": "MDQ6VXNlcjEzNTE5MzM=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/apoelstra",
            "html_url": "https://github.com/apoelstra",
            "followers_url": "https://api.github.com/users/apoelstra/followers",
            "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
            "organizations_url": "https://api.github.com/users/apoelstra/orgs",
            "repos_url": "https://api.github.com/users/apoelstra/repos",
            "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/apoelstra/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 28,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/290",
            "html_url": "https://github.com/bitcoin-core/secp256k1/pull/290",
            "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/290.diff",
            "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/290.patch"
          },
          "closed_at": "2021-03-24T21:13:10Z",
          "created_at": "2015-08-20T05:03:49Z",
          "updated_at": "2021-03-24T21:13:11Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-02T17:23:08Z",
      "updated_at": "2021-04-02T17:23:08Z",
      "source": {
        "issue": {
          "id": 849344843,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjA4MTM0OTcx",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21573",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21573/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21573/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21573/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21573",
          "number": 21573,
          "state": "closed",
          "state_reason": null,
          "title": "Update libsecp256k1 subtree to latest master",
          "body": "This updates our src/secp256k1 subtree to the latest upstream master. The changes include:\r\n\r\n* The introduction of safegcd-based modular inverses, reducing ECDSA signing time by 25%-30% and ECDSA verification time by 15%-17%.\r\n  * [Original paper](https://gcd.cr.yp.to/papers.html) by Daniel J. Bernstein and Bo-Yin Yang\r\n  * [Implementation](https://github.com/bitcoin-core/secp256k1/pull/767) by Peter Dettman; [final](https://github.com/bitcoin-core/secp256k1/pull/831) version\r\n  * [Explanation](https://github.com/bitcoin-core/secp256k1/blob/master/doc/safegcd_implementation.md) of the algorithm using Python snippets\r\n  * [Analysis](https://github.com/sipa/safegcd-bounds) of the maximum number of iterations the algorithm needs\r\n  * [Formal proof in Coq](https://medium.com/blockstream/a-formal-proof-of-safegcd-bounds-695e1735a348) by Russell O'Connor, for a high-level equivalent algorithm\r\n* Removal of libgmp as an (optional) dependency (which wasn't used in the Bitcoin Core build)\r\n* CI changes (Travis -> Cirrus)\r\n* Build system improvements\r\n\r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 118379652,
              "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
              "name": "Validation",
              "color": "6060aa",
              "default": false
            },
            {
              "id": 159815356,
              "node_id": "MDU6TGFiZWwxNTk4MTUzNTY=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Upstream",
              "name": "Upstream",
              "color": "bfd4f2",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 18,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21573",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21573",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21573.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21573.patch"
          },
          "closed_at": "2021-06-07T15:05:42Z",
          "created_at": "2021-04-02T17:12:43Z",
          "updated_at": "2022-08-18T18:24:41Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-04-04T04:26:05Z",
      "updated_at": "2021-04-04T04:26:05Z",
      "source": {
        "issue": {
          "id": 849794989,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjA4NDg0ODM5",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21590",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21590/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21590/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/21590/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/21590",
          "number": 21590,
          "state": "open",
          "state_reason": null,
          "title": "Safegcd-based modular inverses in MuHash3072",
          "body": "This implements a safegcd-based modular inverse for MuHash3072. It is a fairly straightforward translation of [the libsecp256k1 implementation](https://github.com/bitcoin-core/secp256k1/pull/831), with the following changes:\r\n* Generic for 32-bit and 64-bit\r\n* Specialized for the specific MuHash3072 modulus (2^3072 - 1103717).\r\n* A bit more C++ish\r\n* Far fewer sanity checks\r\n\r\nA benchmark is also included for MuHash3072::Finalize. The new implementation is around 100x faster on x86_64 for me (from 5.8 ms to 57 s); for 32-bit code the factor is likely even larger.\r\n\r\nFor more information:\r\n  * [Original paper](https://gcd.cr.yp.to/papers.html) by Daniel J. Bernstein and Bo-Yin Yang\r\n  * [Implementation](https://github.com/bitcoin-core/secp256k1/pull/767) for libsecp256k1 by Peter Dettman; and the [final](https://github.com/bitcoin-core/secp256k1/pull/831) version\r\n  * [Explanation](https://github.com/bitcoin-core/secp256k1/blob/master/doc/safegcd_implementation.md) of the algorithm using Python snippets\r\n  * [Analysis](https://github.com/sipa/safegcd-bounds) of the maximum number of iterations the algorithm needs\r\n   * [Formal proof in Coq](https://medium.com/blockstream/a-formal-proof-of-safegcd-bounds-695e1735a348) by Russell O'Connor (for the 256-bit version of the algorithm; here we use a 3072-bit one).\r\n\r\nTODO:\r\n* [ ] Add more tests\r\n",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 61889416,
              "node_id": "MDU6TGFiZWw2MTg4OTQxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Build%20system",
              "name": "Build system",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 5334691551,
              "node_id": "LA_kwDOABII588AAAABPfju3w",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
              "name": "CI failed",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 15,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/21590",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/21590",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/21590.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/21590.patch"
          },
          "created_at": "2021-04-04T04:26:05Z",
          "updated_at": "2023-04-26T14:21:59Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "referenced",
      "id": 4591721367,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTE3MjEzNjc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4591721367",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "b1267645a31adbcfe9def7569e40b62d794cdc1a",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/b1267645a31adbcfe9def7569e40b62d794cdc1a",
      "created_at": "2021-04-14T06:46:44Z"
    },
    {
      "event": "referenced",
      "id": 4591734259,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTE3MzQyNTk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4591734259",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "24b590d385444a06bae16e6f9ecf759d0a2c8291",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/24b590d385444a06bae16e6f9ecf759d0a2c8291",
      "created_at": "2021-04-14T06:50:08Z"
    },
    {
      "event": "referenced",
      "id": 4591734261,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTE3MzQyNjE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4591734261",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "76ecd0d3ed0e81a8091a5a0b99ba09a2f8751e3a",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/76ecd0d3ed0e81a8091a5a0b99ba09a2f8751e3a",
      "created_at": "2021-04-14T06:50:08Z"
    },
    {
      "event": "referenced",
      "id": 4591745935,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTE3NDU5MzU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4591745935",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "11d688e4ac57083d391fba333551b314932b544a",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/11d688e4ac57083d391fba333551b314932b544a",
      "created_at": "2021-04-14T06:53:11Z"
    },
    {
      "event": "referenced",
      "id": 4591757353,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTE3NTczNTM=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4591757353",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "1080f989e5b760190b1ba1d5e6b1a7231dfa96fd",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/1080f989e5b760190b1ba1d5e6b1a7231dfa96fd",
      "created_at": "2021-04-14T06:56:07Z"
    },
    {
      "event": "referenced",
      "id": 4591757361,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTE3NTczNjE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4591757361",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a49b5685e0ef32646fc752544bce1ade75e3a649",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/a49b5685e0ef32646fc752544bce1ade75e3a649",
      "created_at": "2021-04-14T06:56:07Z"
    },
    {
      "event": "referenced",
      "id": 4591757365,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTE3NTczNjU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4591757365",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "1faa18ac92317c7102acdfe9e54d078258813e8c",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/1faa18ac92317c7102acdfe9e54d078258813e8c",
      "created_at": "2021-04-14T06:56:08Z"
    },
    {
      "event": "referenced",
      "id": 4592252526,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTIyNTI1MjY=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592252526",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "4e1e6025ba5eebe9bbce7bc621525e55e1b0aac0",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/4e1e6025ba5eebe9bbce7bc621525e55e1b0aac0",
      "created_at": "2021-04-14T08:40:17Z"
    },
    {
      "event": "referenced",
      "id": 4592252533,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTIyNTI1MzM=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592252533",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "3ffb0677bfcb826ed89313575d9320871bda3786",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/3ffb0677bfcb826ed89313575d9320871bda3786",
      "created_at": "2021-04-14T08:40:17Z"
    },
    {
      "event": "referenced",
      "id": 4592252535,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTIyNTI1MzU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592252535",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "88fe47b0c50dd07bd9b6231d6733516ff535dc25",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/88fe47b0c50dd07bd9b6231d6733516ff535dc25",
      "created_at": "2021-04-14T08:40:17Z"
    },
    {
      "event": "referenced",
      "id": 4592252541,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTIyNTI1NDE=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592252541",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "1a964955941865d0bbfbc730dcd455fe1b5f7bc3",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/1a964955941865d0bbfbc730dcd455fe1b5f7bc3",
      "created_at": "2021-04-14T08:40:17Z"
    },
    {
      "event": "referenced",
      "id": 4592252547,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTIyNTI1NDc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592252547",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "1893050e04fecfb63489e02adbb0c57bbbf85acb",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/1893050e04fecfb63489e02adbb0c57bbbf85acb",
      "created_at": "2021-04-14T08:40:17Z"
    },
    {
      "event": "referenced",
      "id": 4592252552,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTIyNTI1NTI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592252552",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "f66a53cac783a5edd122b65d8d382a1bf1cba934",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/f66a53cac783a5edd122b65d8d382a1bf1cba934",
      "created_at": "2021-04-14T08:40:17Z"
    },
    {
      "event": "referenced",
      "id": 4592252560,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTIyNTI1NjA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592252560",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "c39b913ab70836bb4dd9a7b4edb1d64c17128b8b",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/c39b913ab70836bb4dd9a7b4edb1d64c17128b8b",
      "created_at": "2021-04-14T08:40:17Z"
    },
    {
      "event": "referenced",
      "id": 4592456959,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTI0NTY5NTk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592456959",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "6c967a512a3e1f0c66540072ac9f31ee9e5c0f62",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/6c967a512a3e1f0c66540072ac9f31ee9e5c0f62",
      "created_at": "2021-04-14T09:19:08Z"
    },
    {
      "event": "referenced",
      "id": 4592456967,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTI0NTY5Njc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592456967",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "6c3afe4619cae043f64d20ef58625144647c4dbe",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/6c3afe4619cae043f64d20ef58625144647c4dbe",
      "created_at": "2021-04-14T09:19:08Z"
    },
    {
      "event": "referenced",
      "id": 4592461774,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTI0NjE3NzQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592461774",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "fcf9750a5685a17b8b6202c90bb9a0937a9a1e06",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/fcf9750a5685a17b8b6202c90bb9a0937a9a1e06",
      "created_at": "2021-04-14T09:20:07Z"
    },
    {
      "event": "referenced",
      "id": 4592461782,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTI0NjE3ODI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592461782",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "24da9eb90f8b80f2c2ff1579ac7a327965ffbc02",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/24da9eb90f8b80f2c2ff1579ac7a327965ffbc02",
      "created_at": "2021-04-14T09:20:07Z"
    },
    {
      "event": "referenced",
      "id": 4592461785,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTI0NjE3ODU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4592461785",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "52b982a7df6e2e3797fe62cd0a4a0b5329d4ae00",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/52b982a7df6e2e3797fe62cd0a4a0b5329d4ae00",
      "created_at": "2021-04-14T09:20:07Z"
    },
    {
      "event": "referenced",
      "id": 4596994019,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTY5OTQwMTk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4596994019",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "9f5afc1921e59146421a7c091213ff4c317f55bb",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/9f5afc1921e59146421a7c091213ff4c317f55bb",
      "created_at": "2021-04-15T04:31:01Z"
    },
    {
      "event": "referenced",
      "id": 4596994022,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTY5OTQwMjI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4596994022",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "df7744ce121911fbe7950bc166801ddf7cdd4732",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/df7744ce121911fbe7950bc166801ddf7cdd4732",
      "created_at": "2021-04-15T04:31:02Z"
    },
    {
      "event": "referenced",
      "id": 4596994024,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTY5OTQwMjQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4596994024",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "df3124c6edd89aa7cd68ce5aac6447453c6ae5b6",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/df3124c6edd89aa7cd68ce5aac6447453c6ae5b6",
      "created_at": "2021-04-15T04:31:02Z"
    },
    {
      "event": "referenced",
      "id": 4596994026,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTY5OTQwMjY=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4596994026",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "332827cc823cd1ed013704103ac245d1740d4d35",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/332827cc823cd1ed013704103ac245d1740d4d35",
      "created_at": "2021-04-15T04:31:02Z"
    },
    {
      "event": "referenced",
      "id": 4596994029,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1OTY5OTQwMjk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4596994029",
      "actor": {
        "login": "deadalnix",
        "id": 854121,
        "node_id": "MDQ6VXNlcjg1NDEyMQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/854121?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/deadalnix",
        "html_url": "https://github.com/deadalnix",
        "followers_url": "https://api.github.com/users/deadalnix/followers",
        "following_url": "https://api.github.com/users/deadalnix/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/deadalnix/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/deadalnix/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/deadalnix/subscriptions",
        "organizations_url": "https://api.github.com/users/deadalnix/orgs",
        "repos_url": "https://api.github.com/users/deadalnix/repos",
        "events_url": "https://api.github.com/users/deadalnix/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/deadalnix/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "524ab786b23ae7b39040af15b7a10db207c69763",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/secp256k1/commits/524ab786b23ae7b39040af15b7a10db207c69763",
      "created_at": "2021-04-15T04:31:02Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-05-06T13:10:44Z",
      "updated_at": "2021-05-06T13:10:44Z",
      "source": {
        "issue": {
          "id": 876922471,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjMwOTc3ODc0",
          "url": "https://api.github.com/repos/google/oss-fuzz/issues/5717",
          "repository_url": "https://api.github.com/repos/google/oss-fuzz",
          "labels_url": "https://api.github.com/repos/google/oss-fuzz/issues/5717/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/google/oss-fuzz/issues/5717/comments",
          "events_url": "https://api.github.com/repos/google/oss-fuzz/issues/5717/events",
          "html_url": "https://github.com/google/oss-fuzz/pull/5717",
          "number": 5717,
          "state": "closed",
          "state_reason": null,
          "title": "[bitcoin-core] Add differential cryptography fuzzer",
          "body": "Please don't merge this yet..\r\n\r\nThis PR incorporates the changes submitted in https://github.com/google/oss-fuzz/pull/5716 so no merge conflicts should arise if this one is merged later..\r\n\r\nAt @MarcoFalke's request I'm submitting a separate PR for this, so it can be commented on separately by the Bitcoin Core devs.\r\n\r\nThis PR builds an extra fuzz target based using Cryptofuzz which tests the following:\r\n\r\nBitcoin Core `src/crypto` primitives:\r\n\r\n- MOD 2**256 bignums (arith_uint256.cpp)\r\n- Hashes: RIPEMD160, SHA1, SHA256, SHA512, SHA3\r\n- KDFs: SHA256 HKDF\r\n- MACs: SIPHASH, SHA256 HMAC\r\n- Symmetric ciphers: AES CBC, ChaCha20\r\n\r\nlibsecp256k1-specific:\r\n\r\n- Convert private key to public key\r\n- Test if given pubkey is valid (point on curve etc)\r\n- ECDSA signing (both explicit nonce and RFC6979 are supported)\r\n- ECDSA verification\r\n- ECDSA pubkey recovery\r\n\r\nBotan and Trezor firmware are used as oracles (e.g. used for comparing the output of Bitcoin/secp256k1 against).\r\n\r\n@sipa Do you have any suggestions as for additional secp256k1 compilation flags? E.g. particular `--with-ecmult-window` or `--with-ecmult-gen-precision` settings that would be useful to test?",
          "user": {
            "login": "guidovranken",
            "id": 6846644,
            "node_id": "MDQ6VXNlcjY4NDY2NDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6846644?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/guidovranken",
            "html_url": "https://github.com/guidovranken",
            "followers_url": "https://api.github.com/users/guidovranken/followers",
            "following_url": "https://api.github.com/users/guidovranken/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/guidovranken/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/guidovranken/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/guidovranken/subscriptions",
            "organizations_url": "https://api.github.com/users/guidovranken/orgs",
            "repos_url": "https://api.github.com/users/guidovranken/repos",
            "events_url": "https://api.github.com/users/guidovranken/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/guidovranken/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 9,
          "pull_request": {
            "url": "https://api.github.com/repos/google/oss-fuzz/pulls/5717",
            "html_url": "https://github.com/google/oss-fuzz/pull/5717",
            "diff_url": "https://github.com/google/oss-fuzz/pull/5717.diff",
            "patch_url": "https://github.com/google/oss-fuzz/pull/5717.patch"
          },
          "closed_at": "2021-05-19T04:12:50Z",
          "created_at": "2021-05-05T22:57:34Z",
          "updated_at": "2021-05-25T05:40:40Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "referenced",
      "id": 4852668569,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ4NTI2Njg1Njk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/4852668569",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "359f72105ba0184fbf998dfd84217c4229dc54ad",
      "commit_url": "https://api.github.com/repos/bitcoin-core/gui/commits/359f72105ba0184fbf998dfd84217c4229dc54ad",
      "created_at": "2021-06-07T15:05:24Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-06-14T20:29:11Z",
      "updated_at": "2021-06-14T20:29:11Z",
      "source": {
        "issue": {
          "id": 920749353,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NjY5ODUyMjEx",
          "url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp/issues/132",
          "repository_url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp",
          "labels_url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp/issues/132/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp/issues/132/comments",
          "events_url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp/issues/132/events",
          "html_url": "https://github.com/BlockstreamResearch/secp256k1-zkp/pull/132",
          "number": 132,
          "state": "closed",
          "state_reason": null,
          "title": "Upstream PRs 831, 907, 903, 889, 918, 906, 928, 922, 933, Merge bitcoin-core/secp256k1#936: Fix gen_context/ASM build on ARM, 925, 937, 926, Merge bitcoin-core/secp256k1#940: contrib: Explain explicit header guards, 850, 930, 941, 846, 947, 662, 950",
          "body": "[bitcoin-core/secp256k1#831]: Safegcd inverses, drop Jacobi symbols, remove libgmp\r\n[bitcoin-core/secp256k1#907]: changed import to use brackets <> for openssl\r\n[bitcoin-core/secp256k1#903]: Make argument of fe_normalizes_to_zero{_var} const\r\n[bitcoin-core/secp256k1#889]: fix uninitialized read in tests\r\n[bitcoin-core/secp256k1#918]: Clean up configuration in gen_context\r\n[bitcoin-core/secp256k1#906]: Use modified divsteps with initial delta=1/2 for constant-time\r\n[bitcoin-core/secp256k1#928]: Define SECP256K1_BUILD in secp256k1.c directly.\r\n[bitcoin-core/secp256k1#922]: Add mingw32-w64/wine CI build\r\n[bitcoin-core/secp256k1#933]: Avoids a missing brace warning in schnorrsig/tests_impl.h on old compilers\r\nMerge bitcoin-core/secp256k1#936: Fix gen_context/ASM build on ARM\r\n[bitcoin-core/secp256k1#925]: changed include statements without prefix 'include/'\r\n[bitcoin-core/secp256k1#937]: Have ge_set_gej_var, gej_double_var and ge_set_all_gej_var initialize all fields of their outputs.\r\n[bitcoin-core/secp256k1#926]: secp256k1.h: clarify that by default arguments must be != NULL\r\nMerge bitcoin-core/secp256k1#940: contrib: Explain explicit header guards\r\n[bitcoin-core/secp256k1#850]: add secp256k1_ec_pubkey_cmp method\r\n[bitcoin-core/secp256k1#930]: Add ARM32/ARM64 CI\r\n[bitcoin-core/secp256k1#941]: Clean up git tree\r\n[bitcoin-core/secp256k1#846]: ci: Run ASan/LSan and reorganize sanitizer and Valgrind jobs\r\n[bitcoin-core/secp256k1#947]: ci: Run PRs on merge result even for i686\r\n[bitcoin-core/secp256k1#662]: Add ecmult_gen, ecmult_const and ecmult to benchmark\r\n[bitcoin-core/secp256k1#950]: ci: Add ppc64le build\r\n\r\nThis PR can be recreated  with `./contrib/sync-upstream.sh range 1758a92f`.\r\n\r\n@jesseposner I had to change one of the test cases in the ECDSA adaptor sig module (see commit message). Does that still test what you wanted to test?",
          "user": {
            "login": "jonasnick",
            "id": 2582071,
            "node_id": "MDQ6VXNlcjI1ODIwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jonasnick",
            "html_url": "https://github.com/jonasnick",
            "followers_url": "https://api.github.com/users/jonasnick/followers",
            "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
            "organizations_url": "https://api.github.com/users/jonasnick/orgs",
            "repos_url": "https://api.github.com/users/jonasnick/repos",
            "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jonasnick/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 7,
          "pull_request": {
            "url": "https://api.github.com/repos/BlockstreamResearch/secp256k1-zkp/pulls/132",
            "html_url": "https://github.com/BlockstreamResearch/secp256k1-zkp/pull/132",
            "diff_url": "https://github.com/BlockstreamResearch/secp256k1-zkp/pull/132.diff",
            "patch_url": "https://github.com/BlockstreamResearch/secp256k1-zkp/pull/132.patch"
          },
          "closed_at": "2021-07-13T22:21:11Z",
          "created_at": "2021-06-14T20:29:11Z",
          "updated_at": "2021-07-13T22:21:11Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-06-21T23:35:43Z",
      "updated_at": "2021-06-21T23:35:43Z",
      "source": {
        "issue": {
          "id": 926692853,
          "node_id": "MDExOlB1bGxSZXF1ZXN0Njc0OTY0ODUz",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/955",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/955/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/955/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/955/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/pull/955",
          "number": 955,
          "state": "closed",
          "state_reason": null,
          "title": "Add random field multiply/square tests",
          "body": "Leverage the existing `modmul256` function (which was added in #831, performing generic 256-bit modular multiplications) to test our fe_mul and fe_sqr functions.",
          "user": {
            "login": "sipa",
            "id": 548488,
            "node_id": "MDQ6VXNlcjU0ODQ4OA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/sipa",
            "html_url": "https://github.com/sipa",
            "followers_url": "https://api.github.com/users/sipa/followers",
            "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
            "organizations_url": "https://api.github.com/users/sipa/orgs",
            "repos_url": "https://api.github.com/users/sipa/repos",
            "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/sipa/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 0,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/955",
            "html_url": "https://github.com/bitcoin-core/secp256k1/pull/955",
            "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/955.diff",
            "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/955.patch"
          },
          "closed_at": "2021-06-30T16:44:30Z",
          "created_at": "2021-06-21T23:35:43Z",
          "updated_at": "2021-06-30T16:44:30Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "AdamISZ",
        "id": 4278257,
        "node_id": "MDQ6VXNlcjQyNzgyNTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4278257?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/AdamISZ",
        "html_url": "https://github.com/AdamISZ",
        "followers_url": "https://api.github.com/users/AdamISZ/followers",
        "following_url": "https://api.github.com/users/AdamISZ/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/AdamISZ/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/AdamISZ/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/AdamISZ/subscriptions",
        "organizations_url": "https://api.github.com/users/AdamISZ/orgs",
        "repos_url": "https://api.github.com/users/AdamISZ/repos",
        "events_url": "https://api.github.com/users/AdamISZ/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/AdamISZ/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-07-27T15:57:38Z",
      "updated_at": "2021-07-27T15:57:38Z",
      "source": {
        "issue": {
          "id": 951311320,
          "node_id": "MDExOlB1bGxSZXF1ZXN0Njk1NzE5OTQw",
          "url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver/issues/938",
          "repository_url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver",
          "labels_url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver/issues/938/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver/issues/938/comments",
          "events_url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver/issues/938/events",
          "html_url": "https://github.com/JoinMarket-Org/joinmarket-clientserver/pull/938",
          "number": 938,
          "state": "closed",
          "state_reason": null,
          "title": "secp256k1 version bump",
          "body": "Argument why use specific commit of secp256k1 was to have the same version as coincurve uses (https://github.com/JoinMarket-Org/joinmarket-clientserver/pull/536/files#r418937166). [Since January coincurve uses](https://github.com/ofek/coincurve/commit/871fbbdf82190b0dfcc5d21259ad4c104f5348a1) `f2d9aeae6d5a7c7fbbba8bbb38b1849b784beef7`.\r\n\r\nRelated - https://github.com/fort-nix/nix-bitcoin/pull/371.",
          "user": {
            "login": "kristapsk",
            "id": 4500994,
            "node_id": "MDQ6VXNlcjQ1MDA5OTQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/4500994?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kristapsk",
            "html_url": "https://github.com/kristapsk",
            "followers_url": "https://api.github.com/users/kristapsk/followers",
            "following_url": "https://api.github.com/users/kristapsk/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/kristapsk/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/kristapsk/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/kristapsk/subscriptions",
            "organizations_url": "https://api.github.com/users/kristapsk/orgs",
            "repos_url": "https://api.github.com/users/kristapsk/repos",
            "events_url": "https://api.github.com/users/kristapsk/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/kristapsk/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 1,
          "pull_request": {
            "url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver/pulls/938",
            "html_url": "https://github.com/JoinMarket-Org/joinmarket-clientserver/pull/938",
            "diff_url": "https://github.com/JoinMarket-Org/joinmarket-clientserver/pull/938.diff",
            "patch_url": "https://github.com/JoinMarket-Org/joinmarket-clientserver/pull/938.patch"
          },
          "closed_at": "2021-08-04T11:23:33Z",
          "created_at": "2021-07-23T07:07:52Z",
          "updated_at": "2021-08-04T13:07:32Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "referenced",
      "id": 5138105099,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDUxMzgxMDUwOTk=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5138105099",
      "actor": {
        "login": "UdjinM6",
        "id": 1935069,
        "node_id": "MDQ6VXNlcjE5MzUwNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1935069?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/UdjinM6",
        "html_url": "https://github.com/UdjinM6",
        "followers_url": "https://api.github.com/users/UdjinM6/followers",
        "following_url": "https://api.github.com/users/UdjinM6/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/UdjinM6/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/UdjinM6/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/UdjinM6/subscriptions",
        "organizations_url": "https://api.github.com/users/UdjinM6/orgs",
        "repos_url": "https://api.github.com/users/UdjinM6/repos",
        "events_url": "https://api.github.com/users/UdjinM6/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/UdjinM6/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "bc61867454632aa84bec8234363b80e685e21acf",
      "commit_url": "https://api.github.com/repos/UdjinM6/dash/commits/bc61867454632aa84bec8234363b80e685e21acf",
      "created_at": "2021-08-10T22:22:01Z"
    },
    {
      "event": "referenced",
      "id": 5149897914,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDUxNDk4OTc5MTQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/5149897914",
      "actor": {
        "login": "5tefan",
        "id": 5855806,
        "node_id": "MDQ6VXNlcjU4NTU4MDY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5855806?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/5tefan",
        "html_url": "https://github.com/5tefan",
        "followers_url": "https://api.github.com/users/5tefan/followers",
        "following_url": "https://api.github.com/users/5tefan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/5tefan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/5tefan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/5tefan/subscriptions",
        "organizations_url": "https://api.github.com/users/5tefan/orgs",
        "repos_url": "https://api.github.com/users/5tefan/repos",
        "events_url": "https://api.github.com/users/5tefan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/5tefan/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "dd45c616b64de3a32bc03b5dc9ab22256e85a867",
      "commit_url": "https://api.github.com/repos/5tefan/dash/commits/dd45c616b64de3a32bc03b5dc9ab22256e85a867",
      "created_at": "2021-08-12T14:39:48Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-19T13:51:22Z",
      "updated_at": "2023-01-19T13:51:22Z",
      "source": {
        "issue": {
          "id": 1548816066,
          "node_id": "PR_kwDOAP4Jqs5IGzLI",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1196",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1196/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1196/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1196/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1196",
          "number": 1196,
          "state": "closed",
          "state_reason": null,
          "title": "Drop no longer used variables from the build system",
          "body": "`SECP_INCLUDES`, `SECP_LIBS`, `SECP_TEST_LIBS` and `SECP_TEST_INCLUDES` were introduced in 78cd96b15153e209cf4829a511f9efdfdcf7e4d0.\r\n\r\nThe last usage of the `SECP_TEST_{LIBS,INCLUDE}` variables was removed in https://github.com/bitcoin-core/secp256k1/pull/983.\r\n\r\nThe last usage of the `SECP_LIBS` variable was removed in https://github.com/bitcoin-core/secp256k1/pull/831.\r\n\r\nThe last usage of the `SECP_INCLUDE` variable was removed in https://github.com/bitcoin-core/secp256k1/pull/1169.",
          "user": {
            "login": "hebasto",
            "id": 32963518,
            "node_id": "MDQ6VXNlcjMyOTYzNTE4",
            "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/hebasto",
            "html_url": "https://github.com/hebasto",
            "followers_url": "https://api.github.com/users/hebasto/followers",
            "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
            "organizations_url": "https://api.github.com/users/hebasto/orgs",
            "repos_url": "https://api.github.com/users/hebasto/repos",
            "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/hebasto/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 1,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1196",
            "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1196",
            "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1196.diff",
            "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1196.patch"
          },
          "closed_at": "2023-01-19T15:57:55Z",
          "created_at": "2023-01-19T09:43:47Z",
          "updated_at": "2023-01-19T15:58:47Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "referenced",
      "id": 8313536851,
      "node_id": "REFE_lADOAP4Jqs4q2wCkzwAAAAHvhoFT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8313536851",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "ad7433b1409180c1e5eee259eff79ea99f699012",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/ad7433b1409180c1e5eee259eff79ea99f699012",
      "created_at": "2023-01-19T15:57:54Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/503787800",
      "pull_request_review_id": 507221672,
      "id": 503787800,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc4NzgwMA==",
      "diff_hunk": "@@ -252,4 +252,45 @@ SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n SECP256K1_GNUC_EXT typedef __int128 int128_t;\n #endif\n \n+#ifndef __has_builtin\n+#define __has_builtin(x) 0\n+#endif\n+\n+static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\n+#if (__has_builtin(__builtin_ctz) || SECP256K1_GNUC_PREREQ(3,4))\n+    if (((unsigned)UINT32_MAX) == UINT32_MAX) {",
      "path": "src/util.h",
      "position": 38,
      "original_position": 10,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "4ad49c8aab9afba2a6f3aba3f311fd6c27642bb5",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It may be simpler and more correct to use  `__builtin_types_compatible_p` here to check for equality of types, which existed before `__builtin_ctz` and friends.\r\n\r\nhttps://gcc.gnu.org/onlinedocs/gcc-3.1/gcc/Other-Builtins.html",
      "created_at": "2020-10-13T09:04:07Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r503787800",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/503787800"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 313,
      "original_line": 313,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504410435",
      "pull_request_review_id": 508005419,
      "id": 504410435,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQxMDQzNQ==",
      "diff_hunk": "@@ -252,4 +252,45 @@ SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n SECP256K1_GNUC_EXT typedef __int128 int128_t;\n #endif\n \n+#ifndef __has_builtin\n+#define __has_builtin(x) 0\n+#endif\n+\n+static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\n+#if (__has_builtin(__builtin_ctz) || SECP256K1_GNUC_PREREQ(3,4))\n+    if (((unsigned)UINT32_MAX) == UINT32_MAX) {",
      "path": "src/util.h",
      "position": 38,
      "original_position": 10,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "4ad49c8aab9afba2a6f3aba3f311fd6c27642bb5",
      "in_reply_to_id": 503787800,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In practice that would work, but it's not exactly what you want: if `unsigned` happens to be larger than 32 bits, we still want this branch to be taken.",
      "created_at": "2020-10-14T05:29:55Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r504410435",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504410435"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 313,
      "original_line": 313,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504434699",
      "pull_request_review_id": 508034302,
      "id": 504434699,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQzNDY5OQ==",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV32_IMPL_H\n+#define SECP256K1_MODINV32_IMPL_H\n+\n+#include \"modinv32.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv32_signed30_verify(const secp256k1_modinv32_signed30* a) {\n+    /* a must be in the range [-2^256, 2^256). */\n+    VERIFY_CHECK(a->v[0] >> 30 == 0);\n+    VERIFY_CHECK(a->v[1] >> 30 == 0);\n+    VERIFY_CHECK(a->v[2] >> 30 == 0);\n+    VERIFY_CHECK(a->v[3] >> 30 == 0);\n+    VERIFY_CHECK(a->v[4] >> 30 == 0);\n+    VERIFY_CHECK(a->v[5] >> 30 == 0);\n+    VERIFY_CHECK(a->v[6] >> 30 == 0);\n+    VERIFY_CHECK(a->v[7] >> 30 == 0);\n+    VERIFY_CHECK(a->v[8] >> 16 == 0 || a->v[8] >> 16 == -(int32_t)1);\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 30; ++i) {\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+\n+        c1 = (int32_t)eta >> 31;\n+        c2 = -(g & 1);\n+\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+\n+        c1 &= c2;\n+        eta = (eta ^ c1) - (c1 + 1);\n+\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30_var(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 30, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz32_var(g | (UINT32_MAX << i));\n+\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+\n+        if (i <= 0) {\n+            break;\n+        }\n+\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+\n+        if ((int32_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+\n+        /* Handle up to 8 divsteps at once, subject to eta and i. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        m = (UINT32_MAX >> (32 - limit)) & 255U;\n+\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static void secp256k1_modinv32_update_de_30(secp256k1_modinv32_signed30 *d, secp256k1_modinv32_signed30 *e, const int32_t *t, const secp256k1_modinv32_modinfo* modinfo) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int32_t u = t[0], v = t[1], q = t[2], r = t[3], di, ei, md, me;\n+    int64_t cd, ce;\n+    int i;\n+\n+    di = d->v[0];\n+    ei = e->v[0];\n+\n+    cd = (int64_t)u * di + (int64_t)v * ei;\n+    ce = (int64_t)q * di + (int64_t)r * ei;\n+\n+    /* Calculate the multiples of P to add, to zero the 30 bottom bits. We choose md, me\n+     * from the centred range [-2^29, 2^29) to keep d, e within [-2^256, 2^256). */\n+    md = ((int32_t)(modinfo->montmul4 * (uint32_t)cd)) >> 2;\n+    me = ((int32_t)(modinfo->montmul4 * (uint32_t)ce)) >> 2;\n+\n+    if (modinfo->modulus.v[0]) {",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 152,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Are these checks helpful? It would require deep inlining for the compiler to be able to constant-fold this away, and in that case it can remove the muladd just fine anyway.",
      "created_at": "2020-10-14T06:37:10Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r504434699",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504434699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504439843",
      "pull_request_review_id": 508040738,
      "id": 504439843,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQzOTg0Mw==",
      "diff_hunk": "@@ -0,0 +1,360 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv64_signed62_verify(const secp256k1_modinv64_signed62* a) {\n+    /* a must be in the range [-2^256, 2^256). */\n+    VERIFY_CHECK(a->v[0] >> 62 == 0);\n+    VERIFY_CHECK(a->v[1] >> 62 == 0);\n+    VERIFY_CHECK(a->v[2] >> 62 == 0);\n+    VERIFY_CHECK(a->v[3] >> 62 == 0);",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 20,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This isn't true of the field prime constants using this type. I suggest that the restriction is one that applies to d, e, f, g with respect to the _update methods, but not for all instances of the type.",
      "created_at": "2020-10-14T06:49:12Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r504439843",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504439843"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 17,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504471859",
      "pull_request_review_id": 508081033,
      "id": 504471859,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ3MTg1OQ==",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV32_IMPL_H\n+#define SECP256K1_MODINV32_IMPL_H\n+\n+#include \"modinv32.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv32_signed30_verify(const secp256k1_modinv32_signed30* a) {\n+    /* a must be in the range [-2^256, 2^256). */\n+    VERIFY_CHECK(a->v[0] >> 30 == 0);\n+    VERIFY_CHECK(a->v[1] >> 30 == 0);\n+    VERIFY_CHECK(a->v[2] >> 30 == 0);\n+    VERIFY_CHECK(a->v[3] >> 30 == 0);\n+    VERIFY_CHECK(a->v[4] >> 30 == 0);\n+    VERIFY_CHECK(a->v[5] >> 30 == 0);\n+    VERIFY_CHECK(a->v[6] >> 30 == 0);\n+    VERIFY_CHECK(a->v[7] >> 30 == 0);\n+    VERIFY_CHECK(a->v[8] >> 16 == 0 || a->v[8] >> 16 == -(int32_t)1);\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 30; ++i) {\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+\n+        c1 = (int32_t)eta >> 31;\n+        c2 = -(g & 1);\n+\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+\n+        c1 &= c2;\n+        eta = (eta ^ c1) - (c1 + 1);\n+\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30_var(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 30, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz32_var(g | (UINT32_MAX << i));\n+\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+\n+        if (i <= 0) {\n+            break;\n+        }\n+\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+\n+        if ((int32_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+\n+        /* Handle up to 8 divsteps at once, subject to eta and i. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        m = (UINT32_MAX >> (32 - limit)) & 255U;\n+\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static void secp256k1_modinv32_update_de_30(secp256k1_modinv32_signed30 *d, secp256k1_modinv32_signed30 *e, const int32_t *t, const secp256k1_modinv32_modinfo* modinfo) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int32_t u = t[0], v = t[1], q = t[2], r = t[3], di, ei, md, me;\n+    int64_t cd, ce;\n+    int i;\n+\n+    di = d->v[0];\n+    ei = e->v[0];\n+\n+    cd = (int64_t)u * di + (int64_t)v * ei;\n+    ce = (int64_t)q * di + (int64_t)r * ei;\n+\n+    /* Calculate the multiples of P to add, to zero the 30 bottom bits. We choose md, me\n+     * from the centred range [-2^29, 2^29) to keep d, e within [-2^256, 2^256). */\n+    md = ((int32_t)(modinfo->montmul4 * (uint32_t)cd)) >> 2;\n+    me = ((int32_t)(modinfo->montmul4 * (uint32_t)ce)) >> 2;\n+\n+    if (modinfo->modulus.v[0]) {",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 152,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "in_reply_to_id": 504434699,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I get a small but reproducible speedup by adding them (i7-7820HQ, 64 bit, gcc-9 -O2), for all 4 cases (_var and const, field and scalar).\r\n\r\nThis is -O2, so there shouldn't be any crazy inlining. The cost of the 5 conditionals could just be less than the 2 muladds that are saved in the scalar case.",
      "created_at": "2020-10-14T07:50:48Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r504471859",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504471859"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504472778",
      "pull_request_review_id": 508082202,
      "id": 504472778,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ3Mjc3OA==",
      "diff_hunk": "@@ -0,0 +1,360 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv64_signed62_verify(const secp256k1_modinv64_signed62* a) {\n+    /* a must be in the range [-2^256, 2^256). */\n+    VERIFY_CHECK(a->v[0] >> 62 == 0);\n+    VERIFY_CHECK(a->v[1] >> 62 == 0);\n+    VERIFY_CHECK(a->v[2] >> 62 == 0);\n+    VERIFY_CHECK(a->v[3] >> 62 == 0);",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 20,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "in_reply_to_id": 504439843,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What is special about the field prime constants? The tests seem to pass.",
      "created_at": "2020-10-14T07:52:20Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r504472778",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504472778"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 17,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504473208",
      "pull_request_review_id": 508082729,
      "id": 504473208,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ3MzIwOA==",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV32_IMPL_H\n+#define SECP256K1_MODINV32_IMPL_H\n+\n+#include \"modinv32.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv32_signed30_verify(const secp256k1_modinv32_signed30* a) {\n+    /* a must be in the range [-2^256, 2^256). */\n+    VERIFY_CHECK(a->v[0] >> 30 == 0);\n+    VERIFY_CHECK(a->v[1] >> 30 == 0);\n+    VERIFY_CHECK(a->v[2] >> 30 == 0);\n+    VERIFY_CHECK(a->v[3] >> 30 == 0);\n+    VERIFY_CHECK(a->v[4] >> 30 == 0);\n+    VERIFY_CHECK(a->v[5] >> 30 == 0);\n+    VERIFY_CHECK(a->v[6] >> 30 == 0);\n+    VERIFY_CHECK(a->v[7] >> 30 == 0);\n+    VERIFY_CHECK(a->v[8] >> 16 == 0 || a->v[8] >> 16 == -(int32_t)1);\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 30; ++i) {\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+\n+        c1 = (int32_t)eta >> 31;\n+        c2 = -(g & 1);\n+\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+\n+        c1 &= c2;\n+        eta = (eta ^ c1) - (c1 + 1);\n+\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30_var(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 30, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz32_var(g | (UINT32_MAX << i));\n+\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+\n+        if (i <= 0) {\n+            break;\n+        }\n+\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+\n+        if ((int32_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+\n+        /* Handle up to 8 divsteps at once, subject to eta and i. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        m = (UINT32_MAX >> (32 - limit)) & 255U;\n+\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static void secp256k1_modinv32_update_de_30(secp256k1_modinv32_signed30 *d, secp256k1_modinv32_signed30 *e, const int32_t *t, const secp256k1_modinv32_modinfo* modinfo) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int32_t u = t[0], v = t[1], q = t[2], r = t[3], di, ei, md, me;\n+    int64_t cd, ce;\n+    int i;\n+\n+    di = d->v[0];\n+    ei = e->v[0];\n+\n+    cd = (int64_t)u * di + (int64_t)v * ei;\n+    ce = (int64_t)q * di + (int64_t)r * ei;\n+\n+    /* Calculate the multiples of P to add, to zero the 30 bottom bits. We choose md, me\n+     * from the centred range [-2^29, 2^29) to keep d, e within [-2^256, 2^256). */\n+    md = ((int32_t)(modinfo->montmul4 * (uint32_t)cd)) >> 2;\n+    me = ((int32_t)(modinfo->montmul4 * (uint32_t)ce)) >> 2;\n+\n+    if (modinfo->modulus.v[0]) {",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 152,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "in_reply_to_id": 504434699,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps, but wouldn't that rely on the branch predictor, and does the benchmark reflect this well?",
      "created_at": "2020-10-14T07:53:03Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r504473208",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504473208"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504474015",
      "pull_request_review_id": 508083797,
      "id": 504474015,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ3NDAxNQ==",
      "diff_hunk": "@@ -0,0 +1,360 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv64_signed62_verify(const secp256k1_modinv64_signed62* a) {\n+    /* a must be in the range [-2^256, 2^256). */\n+    VERIFY_CHECK(a->v[0] >> 62 == 0);\n+    VERIFY_CHECK(a->v[1] >> 62 == 0);\n+    VERIFY_CHECK(a->v[2] >> 62 == 0);\n+    VERIFY_CHECK(a->v[3] >> 62 == 0);",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 20,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "in_reply_to_id": 504439843,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "They contain negative limbs (to maximise the number of zeros in their representation).",
      "created_at": "2020-10-14T07:54:30Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r504474015",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504474015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 17,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504528464",
      "pull_request_review_id": 508152986,
      "id": 504528464,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUyODQ2NA==",
      "diff_hunk": "@@ -252,4 +252,45 @@ SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n SECP256K1_GNUC_EXT typedef __int128 int128_t;\n #endif\n \n+#ifndef __has_builtin\n+#define __has_builtin(x) 0\n+#endif\n+\n+static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\n+#if (__has_builtin(__builtin_ctz) || SECP256K1_GNUC_PREREQ(3,4))\n+    if (((unsigned)UINT32_MAX) == UINT32_MAX) {",
      "path": "src/util.h",
      "position": 38,
      "original_position": 10,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "4ad49c8aab9afba2a6f3aba3f311fd6c27642bb5",
      "in_reply_to_id": 503787800,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh! I understand now. \r\n\r\nMy point was that this currently checks only one direction, namely if `unsigned` is wider or equal to `uint32_t` (and not the other way around). But I see that this is exactly what we want to check, at least if `x` is non-zero. Neat.\r\n\r\nCan you add a comment to this conditional? There should also be a comment that explains the semantics of the function (including that the result is undefined if `x` is 0, which is the case even for `__builtin_ctz`). \r\n\r\n(I know this is a draft PR, we can postpone all this to a more stable version.)",
      "created_at": "2020-10-14T09:18:50Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r504528464",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504528464"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 313,
      "original_line": 313,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504829630",
      "pull_request_review_id": 508545966,
      "id": 504829630,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyOTYzMA==",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV32_IMPL_H\n+#define SECP256K1_MODINV32_IMPL_H\n+\n+#include \"modinv32.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv32_signed30_verify(const secp256k1_modinv32_signed30* a) {\n+    /* a must be in the range [-2^256, 2^256). */\n+    VERIFY_CHECK(a->v[0] >> 30 == 0);\n+    VERIFY_CHECK(a->v[1] >> 30 == 0);\n+    VERIFY_CHECK(a->v[2] >> 30 == 0);\n+    VERIFY_CHECK(a->v[3] >> 30 == 0);\n+    VERIFY_CHECK(a->v[4] >> 30 == 0);\n+    VERIFY_CHECK(a->v[5] >> 30 == 0);\n+    VERIFY_CHECK(a->v[6] >> 30 == 0);\n+    VERIFY_CHECK(a->v[7] >> 30 == 0);\n+    VERIFY_CHECK(a->v[8] >> 16 == 0 || a->v[8] >> 16 == -(int32_t)1);\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 30; ++i) {\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+\n+        c1 = (int32_t)eta >> 31;\n+        c2 = -(g & 1);\n+\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+\n+        c1 &= c2;\n+        eta = (eta ^ c1) - (c1 + 1);\n+\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30_var(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 30, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz32_var(g | (UINT32_MAX << i));\n+\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+\n+        if (i <= 0) {\n+            break;\n+        }\n+\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+\n+        if ((int32_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+\n+        /* Handle up to 8 divsteps at once, subject to eta and i. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        m = (UINT32_MAX >> (32 - limit)) & 255U;\n+\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static void secp256k1_modinv32_update_de_30(secp256k1_modinv32_signed30 *d, secp256k1_modinv32_signed30 *e, const int32_t *t, const secp256k1_modinv32_modinfo* modinfo) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int32_t u = t[0], v = t[1], q = t[2], r = t[3], di, ei, md, me;\n+    int64_t cd, ce;\n+    int i;\n+\n+    di = d->v[0];\n+    ei = e->v[0];\n+\n+    cd = (int64_t)u * di + (int64_t)v * ei;\n+    ce = (int64_t)q * di + (int64_t)r * ei;\n+\n+    /* Calculate the multiples of P to add, to zero the 30 bottom bits. We choose md, me\n+     * from the centred range [-2^29, 2^29) to keep d, e within [-2^256, 2^256). */\n+    md = ((int32_t)(modinfo->montmul4 * (uint32_t)cd)) >> 2;\n+    me = ((int32_t)(modinfo->montmul4 * (uint32_t)ce)) >> 2;\n+\n+    if (modinfo->modulus.v[0]) {",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 152,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "in_reply_to_id": 504434699,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's a good question. Benchmarking with interleaved scalar and field inverses may be more representative.",
      "created_at": "2020-10-14T16:53:55Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r504829630",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/504829630"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/505108006",
      "pull_request_review_id": 508872463,
      "id": 505108006,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTEwODAwNg==",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV32_IMPL_H\n+#define SECP256K1_MODINV32_IMPL_H\n+\n+#include \"modinv32.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv32_signed30_verify(const secp256k1_modinv32_signed30* a) {\n+    /* a must be in the range [-2^256, 2^256). */\n+    VERIFY_CHECK(a->v[0] >> 30 == 0);\n+    VERIFY_CHECK(a->v[1] >> 30 == 0);\n+    VERIFY_CHECK(a->v[2] >> 30 == 0);\n+    VERIFY_CHECK(a->v[3] >> 30 == 0);\n+    VERIFY_CHECK(a->v[4] >> 30 == 0);\n+    VERIFY_CHECK(a->v[5] >> 30 == 0);\n+    VERIFY_CHECK(a->v[6] >> 30 == 0);\n+    VERIFY_CHECK(a->v[7] >> 30 == 0);\n+    VERIFY_CHECK(a->v[8] >> 16 == 0 || a->v[8] >> 16 == -(int32_t)1);\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 30; ++i) {\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+\n+        c1 = (int32_t)eta >> 31;\n+        c2 = -(g & 1);\n+\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+\n+        c1 &= c2;\n+        eta = (eta ^ c1) - (c1 + 1);\n+\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30_var(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 30, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz32_var(g | (UINT32_MAX << i));\n+\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+\n+        if (i <= 0) {\n+            break;\n+        }\n+\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+\n+        if ((int32_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+\n+        /* Handle up to 8 divsteps at once, subject to eta and i. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        m = (UINT32_MAX >> (32 - limit)) & 255U;\n+\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static void secp256k1_modinv32_update_de_30(secp256k1_modinv32_signed30 *d, secp256k1_modinv32_signed30 *e, const int32_t *t, const secp256k1_modinv32_modinfo* modinfo) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int32_t u = t[0], v = t[1], q = t[2], r = t[3], di, ei, md, me;\n+    int64_t cd, ce;\n+    int i;\n+\n+    di = d->v[0];\n+    ei = e->v[0];\n+\n+    cd = (int64_t)u * di + (int64_t)v * ei;\n+    ce = (int64_t)q * di + (int64_t)r * ei;\n+\n+    /* Calculate the multiples of P to add, to zero the 30 bottom bits. We choose md, me\n+     * from the centred range [-2^29, 2^29) to keep d, e within [-2^256, 2^256). */\n+    md = ((int32_t)(modinfo->montmul4 * (uint32_t)cd)) >> 2;\n+    me = ((int32_t)(modinfo->montmul4 * (uint32_t)ce)) >> 2;\n+\n+    if (modinfo->modulus.v[0]) {",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 152,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "in_reply_to_id": 504434699,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Note also that the lowest limb of the modulus can't ever be 0 (modulus has to be odd), and arguably if this implementation is for 256-bit moduli, then the highest limb couldn't ever be 0 either.",
      "created_at": "2020-10-15T01:15:17Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r505108006",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/505108006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/531692180",
      "pull_request_review_id": 540093899,
      "id": 531692180,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5MjE4MA==",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV32_IMPL_H\n+#define SECP256K1_MODINV32_IMPL_H\n+\n+#include \"modinv32.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv32_signed30_verify(const secp256k1_modinv32_signed30* a) {\n+    /* a must be in the range [-2^256, 2^256). */\n+    VERIFY_CHECK(a->v[0] >> 30 == 0);\n+    VERIFY_CHECK(a->v[1] >> 30 == 0);\n+    VERIFY_CHECK(a->v[2] >> 30 == 0);\n+    VERIFY_CHECK(a->v[3] >> 30 == 0);\n+    VERIFY_CHECK(a->v[4] >> 30 == 0);\n+    VERIFY_CHECK(a->v[5] >> 30 == 0);\n+    VERIFY_CHECK(a->v[6] >> 30 == 0);\n+    VERIFY_CHECK(a->v[7] >> 30 == 0);\n+    VERIFY_CHECK(a->v[8] >> 16 == 0 || a->v[8] >> 16 == -(int32_t)1);\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 30; ++i) {\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+\n+        c1 = (int32_t)eta >> 31;\n+        c2 = -(g & 1);\n+\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+\n+        c1 &= c2;\n+        eta = (eta ^ c1) - (c1 + 1);\n+\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30_var(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 30, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz32_var(g | (UINT32_MAX << i));\n+\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+\n+        if (i <= 0) {\n+            break;\n+        }\n+\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+\n+        if ((int32_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+\n+        /* Handle up to 8 divsteps at once, subject to eta and i. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        m = (UINT32_MAX >> (32 - limit)) & 255U;\n+\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static void secp256k1_modinv32_update_de_30(secp256k1_modinv32_signed30 *d, secp256k1_modinv32_signed30 *e, const int32_t *t, const secp256k1_modinv32_modinfo* modinfo) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int32_t u = t[0], v = t[1], q = t[2], r = t[3], di, ei, md, me;\n+    int64_t cd, ce;\n+    int i;\n+\n+    di = d->v[0];\n+    ei = e->v[0];\n+\n+    cd = (int64_t)u * di + (int64_t)v * ei;\n+    ce = (int64_t)q * di + (int64_t)r * ei;\n+\n+    /* Calculate the multiples of P to add, to zero the 30 bottom bits. We choose md, me\n+     * from the centred range [-2^29, 2^29) to keep d, e within [-2^256, 2^256). */\n+    md = ((int32_t)(modinfo->montmul4 * (uint32_t)cd)) >> 2;\n+    me = ((int32_t)(modinfo->montmul4 * (uint32_t)ce)) >> 2;\n+\n+    if (modinfo->modulus.v[0]) {",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 152,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "in_reply_to_id": 504434699,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this point still stands; the if should be removed for modulus.v[0] and v[4] (resp. v[8]).",
      "created_at": "2020-11-27T16:38:21Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r531692180",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/531692180"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/532094235",
      "pull_request_review_id": 540410815,
      "id": 532094235,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA5NDIzNQ==",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV32_IMPL_H\n+#define SECP256K1_MODINV32_IMPL_H\n+\n+#include \"modinv32.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv32_signed30_verify(const secp256k1_modinv32_signed30* a) {\n+    /* a must be in the range [-2^256, 2^256). */\n+    VERIFY_CHECK(a->v[0] >> 30 == 0);\n+    VERIFY_CHECK(a->v[1] >> 30 == 0);\n+    VERIFY_CHECK(a->v[2] >> 30 == 0);\n+    VERIFY_CHECK(a->v[3] >> 30 == 0);\n+    VERIFY_CHECK(a->v[4] >> 30 == 0);\n+    VERIFY_CHECK(a->v[5] >> 30 == 0);\n+    VERIFY_CHECK(a->v[6] >> 30 == 0);\n+    VERIFY_CHECK(a->v[7] >> 30 == 0);\n+    VERIFY_CHECK(a->v[8] >> 16 == 0 || a->v[8] >> 16 == -(int32_t)1);\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 30; ++i) {\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+\n+        c1 = (int32_t)eta >> 31;\n+        c2 = -(g & 1);\n+\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+\n+        c1 &= c2;\n+        eta = (eta ^ c1) - (c1 + 1);\n+\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static uint32_t secp256k1_modinv32_divsteps_30_var(uint32_t eta, uint32_t f0, uint32_t g0, int32_t *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint32_t u = 1, v = 0, q = 0, r = 1;\n+    uint32_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 30, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz32_var(g | (UINT32_MAX << i));\n+\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+\n+        if (i <= 0) {\n+            break;\n+        }\n+\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+\n+        if ((int32_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+\n+        /* Handle up to 8 divsteps at once, subject to eta and i. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        m = (UINT32_MAX >> (32 - limit)) & 255U;\n+\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+\n+    t[0] = (int32_t)u;\n+    t[1] = (int32_t)v;\n+    t[2] = (int32_t)q;\n+    t[3] = (int32_t)r;\n+\n+    return eta;\n+}\n+\n+static void secp256k1_modinv32_update_de_30(secp256k1_modinv32_signed30 *d, secp256k1_modinv32_signed30 *e, const int32_t *t, const secp256k1_modinv32_modinfo* modinfo) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int32_t u = t[0], v = t[1], q = t[2], r = t[3], di, ei, md, me;\n+    int64_t cd, ce;\n+    int i;\n+\n+    di = d->v[0];\n+    ei = e->v[0];\n+\n+    cd = (int64_t)u * di + (int64_t)v * ei;\n+    ce = (int64_t)q * di + (int64_t)r * ei;\n+\n+    /* Calculate the multiples of P to add, to zero the 30 bottom bits. We choose md, me\n+     * from the centred range [-2^29, 2^29) to keep d, e within [-2^256, 2^256). */\n+    md = ((int32_t)(modinfo->montmul4 * (uint32_t)cd)) >> 2;\n+    me = ((int32_t)(modinfo->montmul4 * (uint32_t)ce)) >> 2;\n+\n+    if (modinfo->modulus.v[0]) {",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 152,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "d5ee5592aa3894f1592a8660015b5f08ee7642f0",
      "in_reply_to_id": 504434699,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2020-11-28T18:56:49Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r532094235",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/532094235"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/534676681",
      "pull_request_review_id": 543505816,
      "id": 534676681,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY3NjY4MQ==",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t c, cond_add;\n+\n+    cond_add = r4 >> 63;\n+\n+    c  = r0 + (modinfo->modulus.v[0] & cond_add);\n+    r0 = c & M62; c >>= 62;\n+    c += r1 + (modinfo->modulus.v[1] & cond_add);\n+    r1 = c & M62; c >>= 62;\n+    c += r2 + (modinfo->modulus.v[2] & cond_add);\n+    r2 = c & M62; c >>= 62;\n+    c += r3 + (modinfo->modulus.v[3] & cond_add);\n+    r3 = c & M62; c >>= 62;\n+    c += r4 + (modinfo->modulus.v[4] & cond_add);\n+    r4 = c;\n+\n+    cond_add = (c >> 63) ^ cond_negate;",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 33,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "b4721dc00a528df68edd5ccb50d080442e2dd799",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is wrong if input `r` is 0 (or -P) and `cond_negate` is \"true\", although I don't think such a call can actually happen. I have created a PR to fix it, and add _var variants as well.",
      "created_at": "2020-12-03T05:22:27Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r534676681",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/534676681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/535626381",
      "pull_request_review_id": 544453879,
      "id": 535626381,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTYyNjM4MQ==",
      "diff_hunk": "@@ -0,0 +1,419 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                   *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t c, cond_add;\n+\n+    cond_add = r4 >> 63;\n+\n+    c  = r0 + (modinfo->modulus.v[0] & cond_add);\n+    r0 = c & M62; c >>= 62;\n+    c += r1 + (modinfo->modulus.v[1] & cond_add);\n+    r1 = c & M62; c >>= 62;\n+    c += r2 + (modinfo->modulus.v[2] & cond_add);\n+    r2 = c & M62; c >>= 62;\n+    c += r3 + (modinfo->modulus.v[3] & cond_add);\n+    r3 = c & M62; c >>= 62;\n+    c += r4 + (modinfo->modulus.v[4] & cond_add);\n+    r4 = c;\n+\n+    cond_add = (c >> 63) ^ cond_negate;",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 33,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "b4721dc00a528df68edd5ccb50d080442e2dd799",
      "in_reply_to_id": 534676681,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've squashed some of the changes from that commit in here. I can't measure a performance improvement from the `_var` version (not on x86_64, arm64, or arm32), so haven't included that.",
      "created_at": "2020-12-03T21:13:59Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r535626381",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/535626381"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/540993058",
      "pull_request_review_id": 550153531,
      "id": 540993058,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk5MzA1OA==",
      "diff_hunk": "@@ -12,33 +12,476 @@\n \n #include \"util.h\"\n \n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * Paper: https://gcd.cr.yp.to/papers.html. The references below are for the Date: 2019.04.13\n+ * version of the paper.\n+ *\n+ *\n+ * 1. Computing GCDs using divsteps\n+ * --------------------------------\n+ *\n+ * The general principle is based on repeated application of this function:\n+ *\n+ * def divstep(delta, f, g):\n+ *     \"\"\"Perform one divstep.\"\"\"\n+ *     assert f & 1\n+ *     if delta > 0 and g & 1:\n+ *         return 1 - delta, g, (g - f) // 2\n+ *     elif g & 1:\n+ *         return 1 + delta, f, (g + f) // 2\n+ *     else:\n+ *         return 1 + delta, f, (g    ) // 2\n+ *\n+ * Note that only even numbers are ever divided by 2.\n+ *\n+ * Repeated application, starting with (1, a, b) where a is odd, will eventually reach a state where",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 28,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "cea64c0e8e32997037cab393fdfec0246eb07a71",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do you have any intuition for the delta parameter? Why is this set to 1? I read the paper and in the edd255 curve example, they set this to 1. In the general x-adic case, this is set to be the difference in degrees between the polynomials. \r\n\r\nMy intuition says that maybe this should be the difference highest set bits of the two numbers. For example, a = 256 bit and b is 254 bit, we should set delta to 2?",
      "created_at": "2020-12-11T14:38:20Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r540993058",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/540993058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/540993577",
      "pull_request_review_id": 550153531,
      "id": 540993577,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk5MzU3Nw==",
      "diff_hunk": "@@ -12,33 +12,476 @@\n \n #include \"util.h\"\n \n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * Paper: https://gcd.cr.yp.to/papers.html. The references below are for the Date: 2019.04.13",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 7,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "cea64c0e8e32997037cab393fdfec0246eb07a71",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "link is broken for me. ",
      "created_at": "2020-12-11T14:39:13Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r540993577",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/540993577"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541006144",
      "pull_request_review_id": 550153531,
      "id": 541006144,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAwNjE0NA==",
      "diff_hunk": "@@ -12,33 +12,476 @@\n \n #include \"util.h\"\n \n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * Paper: https://gcd.cr.yp.to/papers.html. The references below are for the Date: 2019.04.13\n+ * version of the paper.\n+ *\n+ *\n+ * 1. Computing GCDs using divsteps\n+ * --------------------------------\n+ *\n+ * The general principle is based on repeated application of this function:\n+ *\n+ * def divstep(delta, f, g):\n+ *     \"\"\"Perform one divstep.\"\"\"\n+ *     assert f & 1\n+ *     if delta > 0 and g & 1:\n+ *         return 1 - delta, g, (g - f) // 2\n+ *     elif g & 1:\n+ *         return 1 + delta, f, (g + f) // 2\n+ *     else:\n+ *         return 1 + delta, f, (g    ) // 2\n+ *\n+ * Note that only even numbers are ever divided by 2.\n+ *\n+ * Repeated application, starting with (1, a, b) where a is odd, will eventually reach a state where\n+ * g=0, and |f| = gcd(a, b). See Theorem 11.2 in the paper for a proof.\n+ *\n+ * def gcd(a, b):\n+ *     \"\"\"Compute the GCD of an odd integer a and another integer b.\"\"\"\n+ *     assert a & 1\n+ *     delta, f, g = 1, a, b\n+ *     while g != 0:\n+ *         delta, f, g = divstep(delta, f, g)\n+ *     return abs(f)\n+ *\n+ *\n+ * 2. From GCDs to modular inverses\n+ * --------------------------------\n+ *\n+ * By tracking how f and g at every stage are written as a linear combination of a and b, similar to\n+ * the https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm, one can compute modular inverses.\n+ * As the modulus is typically an odd number, one can set a=modulus and b=x, to satisfy the\n+ * requirement that a is odd.\n+ *\n+ * Here specifically we keep track of d = f/x (mod modulus) and e = g/x (mod modulus). As f and g\n+ * are initialized to modulus and x respectively, d and e just start off being 0 and 1.\n+ *\n+ * def div2(modulus, x):\n+ *     \"\"\"Divide x by 2 mod odd modulus.\"\"\"\n+ *     assert modulus & 1\n+ *     if x & 1:\n+ *         x += modulus\n+ *     return x // 2\n+ *\n+ * def modinv(modulus, x):\n+ *     \"\"\"Compute the modular inverse of x mod modulus (assuming x is coprime with it).\"\"\"\n+ *     assert modulus & 1\n+ *     delta, f, g, d, e = 1, modulus, x, 0, 1\n+ *     while g != 0:\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(modulus, e - d)\n+ *         elif g & 1:\n+ *             delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(modulus, e + d)\n+ *         else:\n+ *             delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(modulus, e    )\n+ *         assert f % modulus == (d * x) % modulus\n+ *         assert g % modulus == (e * x) % modulus\n+ *     assert f == 1 or f == -1\n+ *     # As f = d*x (mod modulus), d/f = x^-1 (mod modulus). As |f|=1, d/f = d*f.\n+ *     return d * f",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 73,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "cea64c0e8e32997037cab393fdfec0246eb07a71",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Note that this method (and all the subsequent methods based on this) can return numbers negative numbers too. But it would still return them in the range `(-modulus, modulus)`.",
      "created_at": "2020-12-11T14:57:52Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r541006144",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541006144"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541025928",
      "pull_request_review_id": 550153531,
      "id": 541025928,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAyNTkyOA==",
      "diff_hunk": "@@ -12,33 +12,476 @@\n \n #include \"util.h\"\n \n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * Paper: https://gcd.cr.yp.to/papers.html. The references below are for the Date: 2019.04.13\n+ * version of the paper.\n+ *\n+ *\n+ * 1. Computing GCDs using divsteps\n+ * --------------------------------\n+ *\n+ * The general principle is based on repeated application of this function:\n+ *\n+ * def divstep(delta, f, g):\n+ *     \"\"\"Perform one divstep.\"\"\"\n+ *     assert f & 1\n+ *     if delta > 0 and g & 1:\n+ *         return 1 - delta, g, (g - f) // 2\n+ *     elif g & 1:\n+ *         return 1 + delta, f, (g + f) // 2\n+ *     else:\n+ *         return 1 + delta, f, (g    ) // 2\n+ *\n+ * Note that only even numbers are ever divided by 2.\n+ *\n+ * Repeated application, starting with (1, a, b) where a is odd, will eventually reach a state where\n+ * g=0, and |f| = gcd(a, b). See Theorem 11.2 in the paper for a proof.\n+ *\n+ * def gcd(a, b):\n+ *     \"\"\"Compute the GCD of an odd integer a and another integer b.\"\"\"\n+ *     assert a & 1\n+ *     delta, f, g = 1, a, b\n+ *     while g != 0:\n+ *         delta, f, g = divstep(delta, f, g)\n+ *     return abs(f)\n+ *\n+ *\n+ * 2. From GCDs to modular inverses\n+ * --------------------------------\n+ *\n+ * By tracking how f and g at every stage are written as a linear combination of a and b, similar to\n+ * the https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm, one can compute modular inverses.\n+ * As the modulus is typically an odd number, one can set a=modulus and b=x, to satisfy the\n+ * requirement that a is odd.\n+ *\n+ * Here specifically we keep track of d = f/x (mod modulus) and e = g/x (mod modulus). As f and g\n+ * are initialized to modulus and x respectively, d and e just start off being 0 and 1.\n+ *\n+ * def div2(modulus, x):\n+ *     \"\"\"Divide x by 2 mod odd modulus.\"\"\"\n+ *     assert modulus & 1\n+ *     if x & 1:\n+ *         x += modulus\n+ *     return x // 2\n+ *\n+ * def modinv(modulus, x):\n+ *     \"\"\"Compute the modular inverse of x mod modulus (assuming x is coprime with it).\"\"\"\n+ *     assert modulus & 1\n+ *     delta, f, g, d, e = 1, modulus, x, 0, 1\n+ *     while g != 0:\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(modulus, e - d)\n+ *         elif g & 1:\n+ *             delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(modulus, e + d)\n+ *         else:\n+ *             delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(modulus, e    )\n+ *         assert f % modulus == (d * x) % modulus\n+ *         assert g % modulus == (e * x) % modulus\n+ *     assert f == 1 or f == -1\n+ *     # As f = d*x (mod modulus), d/f = x^-1 (mod modulus). As |f|=1, d/f = d*f.\n+ *     return d * f\n+ *\n+ * Note that the inverse only exists if GCD(modulus,x)=1. This is always the case if 0 < x < modulus\n+ * and modulus is prime.\n+ *\n+ *\n+ * 3. Batching multiple divsteps\n+ * -----------------------------\n+ *\n+ * Every divstep can be seen as multiplying a transformation matrix t with [f, g], and the same\n+ * matrix with [d, e] (mod the modulus); see paragraph 8.1 in the paper:\n+ *\n+ *   [ out_f ] = (1/2 * [ u,  v ]) * [ in_f ]\n+ *   [ out_g ]   (      [ q,  r ])   [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2 * [ u,  v ]) * [ in_d ]  (mod modulus)\n+ *   [ out_e ]   (      [ q,  r ])   [ in_e ]\n+ *\n+ * where (u, v, q, r) is (0, 2, -1, 1), (2, 0, 1, 1), or (2, 0, 0, 1), depending on which branch is\n+ * taken.\n+ *\n+ * This can be generalized. Performing multiple divsteps corresponds with a multiplication with the\n+ * product of all the individual divsteps' transformation matrices. The coefficients of this combined\n+ * matrix for N steps are all multiples of 2^-N (see theorem 9.2 in the paper), and can be computed\n+ * (multiplied by 2^N) by generalizing the divstep operations to keep track of matrix coefficients:\n+ *\n+ * def divsteps_n_matrix(delta, f, g):\n+ *     \"\"\"Compute delta and transformation matrix after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+ *         elif g & 1:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+ *         else:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+ *     return delta, (u, v, q, r)\n+ *\n+ * It so happens that this function doesn't actually need the full f and g numbers; it only needs\n+ * their bottom N bits. Furthermore all intermediate results and outputs fit in (N+1)-bit numbers\n+ * (unsigned for f and g; signed for u, v, q, and r). This means that an implementation using\n+ * 64-bit integers could set N=62 and compute the full transition matrix for 62 steps at once\n+ * without any big integer arithmetic at all. This is the reason why this algorithm is efficient: it\n+ * only needs to update the actual f, g, d, and e numbers once every N steps. We need:\n+ *\n+ *   [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+ *   [ out_g ]   (        [ q,  r ])   [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod modulus)\n+ *   [ out_e ]   (        [ q,  r ])   [ in_e ]\n+ *\n+ * For f and g that's easy:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     fs, gs = u * f + v * g, q * f + r * g\n+ *     # (t / 2^N) should cleanly apply to [f, g] (because divsteps only divide even numbers by 2),\n+ *     # so the result of t * [f, g] should have N zero bottom bits.\n+ *     assert fs % (2**N) == 0\n+ *     assert gs % (2**N) == 0\n+ *     return fs >> N, gs >> N\n+ *\n+ * To do the same for d and e, we need an equivalent of the div2 function for division by 2^N mod\n+ * modulus. This is easy if we have precomputed modulus^-1 mod 2^N:\n+ *\n+ * def div2n(modulus, modulus_inv2n, x):\n+ *     \"\"\"Compute x/2^N mod modulus, given modulus_inv2n = modulus^-1 mod 2^N.\"\"\"\n+ *     assert (modulus * modulus_inv2n) % (2**N) == 1\n+ *     # Find a factor m such that m*modulus has the same bottom N bits as x. We want:\n+ *     #     (m * modulus) mod 2^N = x mod 2^N\n+ *     # <=> m mod 2^N = (x / modulus) mod 2^N\n+ *     # <=> m mod 2^N = (x * modulus_inv2n) mod 2^N\n+ *     m = (modulus_inv2n * x) % (2**N)\n+ *     # Subtract that multiple from x, cancelling its bottom N bits.\n+ *     x -= m * modulus\n+ *     # Now a clean division by 2^N is possible.\n+ *     assert x % (2**N) == 0\n+ *     return (x >> N) % modulus\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     ds, es = u * d + v * e, q * d + r * e\n+ *     return div2n(modulus, modulus_inv2n, ds), div2n(modulus, modulus_inv2n, es)\n+ *\n+ * With all of those, we can write a version of modinv that performs N divsteps at once:\n+ *\n+ * def modinv(modulus, modulus_inv2n, x):\n+ *     \"\"\"Compute the modular inverse of x mod modulus, given modulus^-1 mod 2^N.\"\"\"\n+ *     assert modulus & 1\n+ *     delta, f, g, d, e = 1, modulus, x, 0, 1\n+ *     while g != 0:\n+ *         # Compute the delta and transformation matrix t for the next N divsteps (this only needs\n+ *         # (N+1)-bit signed integer arithmetic).\n+ *         delta, t = divsteps_n_matrix(delta, f % (2**N), g % (2**N))\n+ *         # Apply the t transformation to [f, g]:\n+ *         f, g = update_fg(f, g, t)\n+ *         # Apply the t transformation to [d, e]:\n+ *         d, e = update_de(d, e, t, modulus, modulus_inv2n)\n+ *         assert f % modulus == (d * x) % modulus\n+ *         assert g % modulus == (e * x) % modulus\n+ *     assert f == 1 or f == -1\n+ *     # As f = d*x (mod modulus), d/f = x^-1 (mod modulus). As |f|=1, d/f = d*f.\n+ *     return d * f\n+ *\n+ * This means that in practice we'll always perform a multiple of N divsteps. This is not a problem\n+ * because once g=0, further divsteps do not affect f, g, d, or e anymore (only delta keeps\n+ * increasing). For variable time code such excess iterations will be mostly optimized away later.\n+ *\n+ *\n+ * 4. Constant-time operation\n+ * --------------------------\n+ *\n+ * The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+ * depends on the input data so far?\n+ *\n+ * - The number of iterations of the while g != 0 loop in modinv.\n+ * - The branches inside divsteps_n_matrix.\n+ *\n+ * To make the while loop in modinv constant time it can be replaced with a constant number of\n+ * iterations. The paper proves (Theorem 11.2) that 741 divsteps are sufficient for any 256-bit\n+ * inputs, and https://github.com/sipa/safegcd-bounds shows that the slightly better bound 724 is\n+ * sufficient even. Given that every loop iteration performs N divsteps, the loop needs to run\n+ * ceil(724/N) times.\n+ *\n+ * Dealing with the branches in divsteps_n_matrix requires replacing them with constant-time\n+ * bitwise operations (and hoping the C compiler isn't smart enough to turn them back into\n+ * branches; see valgrind_ctime_test.c for automated tests that this isn't the case). To do so,\n+ * observe that a divstep can be written instead as:\n+ *\n+ * def divstep(delta, f, g):\n+ *     if g & 1:\n+ *         g += -f if delta > 0 else f    # set g to (input) g-f or g+f\n+ *         if delta > 0:\n+ *             delta = -delta\n+ *             f += g                     # set f to (input) g (g is f-g here)\n+ *     delta += 1\n+ *     g >>= 1\n+ *     return delta, f, g\n+ *\n+ * To convert this into bitwise operations, we rely on this trick to implement conditional negation:\n+ * [-v = ~v + 1] is true for every v, so since [~v = v xor -1] we get [-v = (v xor -1) + 1]. Thus,\n+ * [(v xor mask) - mask] is v if mask=0 and -v if mask=-1. With that we just need a way to quickly\n+ * compute this mask from delta and g's parity. It turns out this is slightly easier if instead of\n+ * delta we track the equivalent eta = -delta. In that case a mask for eta < 0 (= delta > 0) is just\n+ * (eta >> 63) for int64_t. With that, we can write a constant-time divstep as:\n+ *\n+ * def divstep(eta, f, g):\n+ *     # Compute a mask c1 for eta < 0, and compute the conditional negation x of f:\n+ *     c1 = eta >> 63\n+ *     x = (f ^ c1) - c1\n+ *     # Compute a mask c2 for odd g, and conditionally add x to g:\n+ *     c2 = -(g & 1)\n+ *     g += x & c2\n+ *     # Compute a mask c for (eta < 0) and odd (input) g, and use it to conditionally negate eta,\n+ *     # and add g to f:\n+ *     c = c1 & c2\n+ *     eta = (eta ^ c) - c\n+ *     f += g & c\n+ *     # Unconditional operations:\n+ *     eta -= 1\n+ *     g >>= 1\n+ *     return eta, f, g\n+ *\n+ * By replacing the loop in divsteps_n_matrix with a variant of the divstep code above (extended to\n+ * also apply all f operations to u, v and all g operations to q, r), a constant-time version of\n+ * divsteps_n_matrix is obtained.\n+ *\n+ *\n+ * 5. Variable-time optimizations\n+ * ------------------------------\n+ *\n+ * If we don't want constant time code, the changes from the previous sections are unnecessary, and\n+ * we may instead see if it's possible to go in the other direction - making things (on average)\n+ * faster by introducing more variable-time steps.\n+ *\n+ * Here we start with yet another way of writing the (loop of) divstep operations, based on\n+ * paragraph 8.2 from the paper:\n+ *\n+ * for _ in range(N):\n+ *     if g & 1 and eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     if g & 1:\n+ *         g += f\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Observe that as long as g is even, all the loop does is shift it down and decrease eta. If we can\n+ * count the bottom 0 bits in g efficiently (as can be done on most platforms), we can do multiple\n+ * iterations at once:\n+ *\n+ * i = N\n+ * while True:\n+ *     # Get rid of all bottom zeros at once\n+ *     zeros = min(i, count_trailing_zeros(g))\n+ *     eta, i = eta - zeros, i - zeros\n+ *     g >>= zeros\n+ *     if i == 0:\n+ *         break\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     g += f\n+ *\n+ * Now observe that eta always >= 0 on the last line. If eta is even higher, the loop will not run\n+ * the [eta, f, g = -eta, g, f] statement again until eta goes negative. All the last line does is\n+ * add f to g in order to make its bottom bit zero, which is then shifted out at the beginning of\n+ * the next iteration. Repetitions of this are cancelling out all 1 bits in g by adding f to it\n+ * until we run out of iterations (i reaches 0) or eta goes negative.\n+ *\n+ * Nothing prevents us from instead cancelling out multiple bits of g at once by adding a multiple\n+ * of f to it, as long as it's not more than i (as we'd finish the loop before doing more) and not\n+ * more than eta+1 (as we'd do the [eta, f, g = -eta, g, f] at that point). Here is a way to do\n+ * up to 4 at a time:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * i = N\n+ * while True:\n+ *     ...\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, f\n+ *     # Compute limit on number of bits to cancel\n+ *     limit = min(min(eta + 1, i), 4)\n+ *     # Compute w = -g/f mod 2**limit, using the table value for -1/f mod 2**4. Note that f is\n+ *     # always odd, so its inverse modulo a power of two always exists.\n+ *     w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *     # As w = -g/f mod (2**limit), g+w*f mod 2**limit = 0 mod 2**limit.\n+ *     g += w * f\n+ *     assert g % (2**limit) == 0\n+ *     # The next iteration will now shift out all (limit) botoom zero bits from g.\n+ *\n+ * By using a bigger table more bits can be cancelled at once. The table can also be implemented\n+ * as a formula.\n+ *\n+ * This loop, again extended to also handle u, v, q, and r alongside f and g, placed in\n+ * divsteps_n_matrix, gives a significantly faster version.\n+ *\n+ *\n+ * 6. Putting it all together\n+ * --------------------------\n+ *\n+ * All together we need the following functions:\n+ *\n+ * A way to compute the transition matrix in constant time, using the divsteps_n_matrix function\n+ * from section 2, but with its loop replaced by a variant of the constant-time divstep from\n+ * section 4, extended to handle u, v, q, r:\n+ *\n+ * def divsteps_n_matrix(eta, f, g):\n+ *     \"\"\"Compute eta and transformation matrix after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         c1 = eta >> 63\n+ *         x, y, z = (f ^ c1) - c1, (u ^ c1) - c1, (v ^ c1) - c1\n+ *         c2 = -(g & 1)\n+ *         g, q, r = g + (x & c2), q + (y & c2), r + (z & c2)\n+ *         c = c1 & c2\n+ *         eta = (eta ^ c) - (c + 1)  # inlining the unconditional eta decrement here\n+ *         f, u, v = f + (g & c), u + (q & c), v + (r & c)\n+ *         g, u, v = g >> 1, u << 1, v << 1\n+ *     return eta, (u, v, q, r)\n+ *\n+ * The functions to update f and g, and d and e, from section 2:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     fs, gs = u * f + v * g, q * f + r * g\n+ *     return fs >> N, gs >> N\n+ *\n+ * def div2n(modulus, modulus_inv2n, x):\n+ *     \"\"\"Compute x/2^N mod modulus, given modulus_inv2n = modulus^-1 mod 2^N.\"\"\"\n+ *     m = (modulus_inv2n * x) % (2**N)\n+ *     x -= m * modulus\n+ *     return (x >> N) % modulus\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     ds, es = u * d + v * e, q * d + r * e\n+ *     return div2n(modulus, modulus_inv2n, ds), div2n(modulus, modulus_inv2n, es)\n+ *\n+ * And finally the modinv function too, adapted to use eta instead of delta:\n+ *\n+ * def modinv(modulus, modulus_inv2n, x):\n+ *     \"\"\"Compute the modular inverse of x mod modulus, given modulus^-1 mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, modulus, x, 0, 1\n+ *     while g != 0:\n+ *         eta, t = divsteps_n_matrix(-eta, f % (2**N), g % (2**N))\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, modulus, modulus_inv2n)\n+ *     return d * f\n+ *\n+ * To get a variable time version, replace the divsteps_n_matrix function with one that uses the\n+ * divsteps loop from section 5:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * def divsteps_n_matrix_var(eta, f, g):\n+ *     \"\"\"Compute eta and transformation matrix after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1\n+ *     i = N\n+ *     while True:\n+ *         zeros = min(i, count_trailing_zeros(g))\n+ *         eta, i = eta - zeros, i - zeros\n+ *         g, u, v = g >> zeros, u << zeros, v << zeros\n+ *         if i == 0:\n+ *             break\n+ *         if eta < 0:\n+ *             eta, f, u, v, g, q, r = -eta, g, q, r, -f, -u, -v\n+ *         limit = min(min(eta + 1, i), 4)\n+ *         w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *         g, q, r = g + w * f, q + w * u, r + w * v\n+ *",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 386,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "cea64c0e8e32997037cab393fdfec0246eb07a71",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "missing return statement. ",
      "created_at": "2020-12-11T15:25:37Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r541025928",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541025928"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 681,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541458681",
      "pull_request_review_id": 550666846,
      "id": 541458681,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ1ODY4MQ==",
      "diff_hunk": "@@ -12,33 +12,476 @@\n \n #include \"util.h\"\n \n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * Paper: https://gcd.cr.yp.to/papers.html. The references below are for the Date: 2019.04.13",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 7,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "cea64c0e8e32997037cab393fdfec0246eb07a71",
      "in_reply_to_id": 540993577,
      "user": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The trailing period breaks it in the GitHub GUI, but the link works for me.",
      "created_at": "2020-12-12T00:45:58Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r541458681",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541458681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541829026",
      "pull_request_review_id": 550879398,
      "id": 541829026,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTgyOTAyNg==",
      "diff_hunk": "@@ -12,33 +12,476 @@\n \n #include \"util.h\"\n \n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * Paper: https://gcd.cr.yp.to/papers.html. The references below are for the Date: 2019.04.13\n+ * version of the paper.\n+ *\n+ *\n+ * 1. Computing GCDs using divsteps\n+ * --------------------------------\n+ *\n+ * The general principle is based on repeated application of this function:\n+ *\n+ * def divstep(delta, f, g):\n+ *     \"\"\"Perform one divstep.\"\"\"\n+ *     assert f & 1\n+ *     if delta > 0 and g & 1:\n+ *         return 1 - delta, g, (g - f) // 2\n+ *     elif g & 1:\n+ *         return 1 + delta, f, (g + f) // 2\n+ *     else:\n+ *         return 1 + delta, f, (g    ) // 2\n+ *\n+ * Note that only even numbers are ever divided by 2.\n+ *\n+ * Repeated application, starting with (1, a, b) where a is odd, will eventually reach a state where",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 28,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "cea64c0e8e32997037cab393fdfec0246eb07a71",
      "in_reply_to_id": 540993058,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added something to explain it.",
      "created_at": "2020-12-13T02:54:13Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r541829026",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541829026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541829067",
      "pull_request_review_id": 550879410,
      "id": 541829067,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTgyOTA2Nw==",
      "diff_hunk": "@@ -12,33 +12,476 @@\n \n #include \"util.h\"\n \n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * Paper: https://gcd.cr.yp.to/papers.html. The references below are for the Date: 2019.04.13",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 7,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "cea64c0e8e32997037cab393fdfec0246eb07a71",
      "in_reply_to_id": 540993577,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2020-12-13T02:54:28Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r541829067",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541829067"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541829140",
      "pull_request_review_id": 550879425,
      "id": 541829140,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTgyOTE0MA==",
      "diff_hunk": "@@ -12,33 +12,476 @@\n \n #include \"util.h\"\n \n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * Paper: https://gcd.cr.yp.to/papers.html. The references below are for the Date: 2019.04.13\n+ * version of the paper.\n+ *\n+ *\n+ * 1. Computing GCDs using divsteps\n+ * --------------------------------\n+ *\n+ * The general principle is based on repeated application of this function:\n+ *\n+ * def divstep(delta, f, g):\n+ *     \"\"\"Perform one divstep.\"\"\"\n+ *     assert f & 1\n+ *     if delta > 0 and g & 1:\n+ *         return 1 - delta, g, (g - f) // 2\n+ *     elif g & 1:\n+ *         return 1 + delta, f, (g + f) // 2\n+ *     else:\n+ *         return 1 + delta, f, (g    ) // 2\n+ *\n+ * Note that only even numbers are ever divided by 2.\n+ *\n+ * Repeated application, starting with (1, a, b) where a is odd, will eventually reach a state where\n+ * g=0, and |f| = gcd(a, b). See Theorem 11.2 in the paper for a proof.\n+ *\n+ * def gcd(a, b):\n+ *     \"\"\"Compute the GCD of an odd integer a and another integer b.\"\"\"\n+ *     assert a & 1\n+ *     delta, f, g = 1, a, b\n+ *     while g != 0:\n+ *         delta, f, g = divstep(delta, f, g)\n+ *     return abs(f)\n+ *\n+ *\n+ * 2. From GCDs to modular inverses\n+ * --------------------------------\n+ *\n+ * By tracking how f and g at every stage are written as a linear combination of a and b, similar to\n+ * the https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm, one can compute modular inverses.\n+ * As the modulus is typically an odd number, one can set a=modulus and b=x, to satisfy the\n+ * requirement that a is odd.\n+ *\n+ * Here specifically we keep track of d = f/x (mod modulus) and e = g/x (mod modulus). As f and g\n+ * are initialized to modulus and x respectively, d and e just start off being 0 and 1.\n+ *\n+ * def div2(modulus, x):\n+ *     \"\"\"Divide x by 2 mod odd modulus.\"\"\"\n+ *     assert modulus & 1\n+ *     if x & 1:\n+ *         x += modulus\n+ *     return x // 2\n+ *\n+ * def modinv(modulus, x):\n+ *     \"\"\"Compute the modular inverse of x mod modulus (assuming x is coprime with it).\"\"\"\n+ *     assert modulus & 1\n+ *     delta, f, g, d, e = 1, modulus, x, 0, 1\n+ *     while g != 0:\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(modulus, e - d)\n+ *         elif g & 1:\n+ *             delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(modulus, e + d)\n+ *         else:\n+ *             delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(modulus, e    )\n+ *         assert f % modulus == (d * x) % modulus\n+ *         assert g % modulus == (e * x) % modulus\n+ *     assert f == 1 or f == -1\n+ *     # As f = d*x (mod modulus), d/f = x^-1 (mod modulus). As |f|=1, d/f = d*f.\n+ *     return d * f",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 73,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "cea64c0e8e32997037cab393fdfec0246eb07a71",
      "in_reply_to_id": 541006144,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed, added '% modulus' in a few places.",
      "created_at": "2020-12-13T02:54:43Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r541829140",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541829140"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541829146",
      "pull_request_review_id": 550879428,
      "id": 541829146,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTgyOTE0Ng==",
      "diff_hunk": "@@ -12,33 +12,476 @@\n \n #include \"util.h\"\n \n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * Paper: https://gcd.cr.yp.to/papers.html. The references below are for the Date: 2019.04.13\n+ * version of the paper.\n+ *\n+ *\n+ * 1. Computing GCDs using divsteps\n+ * --------------------------------\n+ *\n+ * The general principle is based on repeated application of this function:\n+ *\n+ * def divstep(delta, f, g):\n+ *     \"\"\"Perform one divstep.\"\"\"\n+ *     assert f & 1\n+ *     if delta > 0 and g & 1:\n+ *         return 1 - delta, g, (g - f) // 2\n+ *     elif g & 1:\n+ *         return 1 + delta, f, (g + f) // 2\n+ *     else:\n+ *         return 1 + delta, f, (g    ) // 2\n+ *\n+ * Note that only even numbers are ever divided by 2.\n+ *\n+ * Repeated application, starting with (1, a, b) where a is odd, will eventually reach a state where\n+ * g=0, and |f| = gcd(a, b). See Theorem 11.2 in the paper for a proof.\n+ *\n+ * def gcd(a, b):\n+ *     \"\"\"Compute the GCD of an odd integer a and another integer b.\"\"\"\n+ *     assert a & 1\n+ *     delta, f, g = 1, a, b\n+ *     while g != 0:\n+ *         delta, f, g = divstep(delta, f, g)\n+ *     return abs(f)\n+ *\n+ *\n+ * 2. From GCDs to modular inverses\n+ * --------------------------------\n+ *\n+ * By tracking how f and g at every stage are written as a linear combination of a and b, similar to\n+ * the https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm, one can compute modular inverses.\n+ * As the modulus is typically an odd number, one can set a=modulus and b=x, to satisfy the\n+ * requirement that a is odd.\n+ *\n+ * Here specifically we keep track of d = f/x (mod modulus) and e = g/x (mod modulus). As f and g\n+ * are initialized to modulus and x respectively, d and e just start off being 0 and 1.\n+ *\n+ * def div2(modulus, x):\n+ *     \"\"\"Divide x by 2 mod odd modulus.\"\"\"\n+ *     assert modulus & 1\n+ *     if x & 1:\n+ *         x += modulus\n+ *     return x // 2\n+ *\n+ * def modinv(modulus, x):\n+ *     \"\"\"Compute the modular inverse of x mod modulus (assuming x is coprime with it).\"\"\"\n+ *     assert modulus & 1\n+ *     delta, f, g, d, e = 1, modulus, x, 0, 1\n+ *     while g != 0:\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(modulus, e - d)\n+ *         elif g & 1:\n+ *             delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(modulus, e + d)\n+ *         else:\n+ *             delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(modulus, e    )\n+ *         assert f % modulus == (d * x) % modulus\n+ *         assert g % modulus == (e * x) % modulus\n+ *     assert f == 1 or f == -1\n+ *     # As f = d*x (mod modulus), d/f = x^-1 (mod modulus). As |f|=1, d/f = d*f.\n+ *     return d * f\n+ *\n+ * Note that the inverse only exists if GCD(modulus,x)=1. This is always the case if 0 < x < modulus\n+ * and modulus is prime.\n+ *\n+ *\n+ * 3. Batching multiple divsteps\n+ * -----------------------------\n+ *\n+ * Every divstep can be seen as multiplying a transformation matrix t with [f, g], and the same\n+ * matrix with [d, e] (mod the modulus); see paragraph 8.1 in the paper:\n+ *\n+ *   [ out_f ] = (1/2 * [ u,  v ]) * [ in_f ]\n+ *   [ out_g ]   (      [ q,  r ])   [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2 * [ u,  v ]) * [ in_d ]  (mod modulus)\n+ *   [ out_e ]   (      [ q,  r ])   [ in_e ]\n+ *\n+ * where (u, v, q, r) is (0, 2, -1, 1), (2, 0, 1, 1), or (2, 0, 0, 1), depending on which branch is\n+ * taken.\n+ *\n+ * This can be generalized. Performing multiple divsteps corresponds with a multiplication with the\n+ * product of all the individual divsteps' transformation matrices. The coefficients of this combined\n+ * matrix for N steps are all multiples of 2^-N (see theorem 9.2 in the paper), and can be computed\n+ * (multiplied by 2^N) by generalizing the divstep operations to keep track of matrix coefficients:\n+ *\n+ * def divsteps_n_matrix(delta, f, g):\n+ *     \"\"\"Compute delta and transformation matrix after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+ *         elif g & 1:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+ *         else:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+ *     return delta, (u, v, q, r)\n+ *\n+ * It so happens that this function doesn't actually need the full f and g numbers; it only needs\n+ * their bottom N bits. Furthermore all intermediate results and outputs fit in (N+1)-bit numbers\n+ * (unsigned for f and g; signed for u, v, q, and r). This means that an implementation using\n+ * 64-bit integers could set N=62 and compute the full transition matrix for 62 steps at once\n+ * without any big integer arithmetic at all. This is the reason why this algorithm is efficient: it\n+ * only needs to update the actual f, g, d, and e numbers once every N steps. We need:\n+ *\n+ *   [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+ *   [ out_g ]   (        [ q,  r ])   [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod modulus)\n+ *   [ out_e ]   (        [ q,  r ])   [ in_e ]\n+ *\n+ * For f and g that's easy:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     fs, gs = u * f + v * g, q * f + r * g\n+ *     # (t / 2^N) should cleanly apply to [f, g] (because divsteps only divide even numbers by 2),\n+ *     # so the result of t * [f, g] should have N zero bottom bits.\n+ *     assert fs % (2**N) == 0\n+ *     assert gs % (2**N) == 0\n+ *     return fs >> N, gs >> N\n+ *\n+ * To do the same for d and e, we need an equivalent of the div2 function for division by 2^N mod\n+ * modulus. This is easy if we have precomputed modulus^-1 mod 2^N:\n+ *\n+ * def div2n(modulus, modulus_inv2n, x):\n+ *     \"\"\"Compute x/2^N mod modulus, given modulus_inv2n = modulus^-1 mod 2^N.\"\"\"\n+ *     assert (modulus * modulus_inv2n) % (2**N) == 1\n+ *     # Find a factor m such that m*modulus has the same bottom N bits as x. We want:\n+ *     #     (m * modulus) mod 2^N = x mod 2^N\n+ *     # <=> m mod 2^N = (x / modulus) mod 2^N\n+ *     # <=> m mod 2^N = (x * modulus_inv2n) mod 2^N\n+ *     m = (modulus_inv2n * x) % (2**N)\n+ *     # Subtract that multiple from x, cancelling its bottom N bits.\n+ *     x -= m * modulus\n+ *     # Now a clean division by 2^N is possible.\n+ *     assert x % (2**N) == 0\n+ *     return (x >> N) % modulus\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     ds, es = u * d + v * e, q * d + r * e\n+ *     return div2n(modulus, modulus_inv2n, ds), div2n(modulus, modulus_inv2n, es)\n+ *\n+ * With all of those, we can write a version of modinv that performs N divsteps at once:\n+ *\n+ * def modinv(modulus, modulus_inv2n, x):\n+ *     \"\"\"Compute the modular inverse of x mod modulus, given modulus^-1 mod 2^N.\"\"\"\n+ *     assert modulus & 1\n+ *     delta, f, g, d, e = 1, modulus, x, 0, 1\n+ *     while g != 0:\n+ *         # Compute the delta and transformation matrix t for the next N divsteps (this only needs\n+ *         # (N+1)-bit signed integer arithmetic).\n+ *         delta, t = divsteps_n_matrix(delta, f % (2**N), g % (2**N))\n+ *         # Apply the t transformation to [f, g]:\n+ *         f, g = update_fg(f, g, t)\n+ *         # Apply the t transformation to [d, e]:\n+ *         d, e = update_de(d, e, t, modulus, modulus_inv2n)\n+ *         assert f % modulus == (d * x) % modulus\n+ *         assert g % modulus == (e * x) % modulus\n+ *     assert f == 1 or f == -1\n+ *     # As f = d*x (mod modulus), d/f = x^-1 (mod modulus). As |f|=1, d/f = d*f.\n+ *     return d * f\n+ *\n+ * This means that in practice we'll always perform a multiple of N divsteps. This is not a problem\n+ * because once g=0, further divsteps do not affect f, g, d, or e anymore (only delta keeps\n+ * increasing). For variable time code such excess iterations will be mostly optimized away later.\n+ *\n+ *\n+ * 4. Constant-time operation\n+ * --------------------------\n+ *\n+ * The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+ * depends on the input data so far?\n+ *\n+ * - The number of iterations of the while g != 0 loop in modinv.\n+ * - The branches inside divsteps_n_matrix.\n+ *\n+ * To make the while loop in modinv constant time it can be replaced with a constant number of\n+ * iterations. The paper proves (Theorem 11.2) that 741 divsteps are sufficient for any 256-bit\n+ * inputs, and https://github.com/sipa/safegcd-bounds shows that the slightly better bound 724 is\n+ * sufficient even. Given that every loop iteration performs N divsteps, the loop needs to run\n+ * ceil(724/N) times.\n+ *\n+ * Dealing with the branches in divsteps_n_matrix requires replacing them with constant-time\n+ * bitwise operations (and hoping the C compiler isn't smart enough to turn them back into\n+ * branches; see valgrind_ctime_test.c for automated tests that this isn't the case). To do so,\n+ * observe that a divstep can be written instead as:\n+ *\n+ * def divstep(delta, f, g):\n+ *     if g & 1:\n+ *         g += -f if delta > 0 else f    # set g to (input) g-f or g+f\n+ *         if delta > 0:\n+ *             delta = -delta\n+ *             f += g                     # set f to (input) g (g is f-g here)\n+ *     delta += 1\n+ *     g >>= 1\n+ *     return delta, f, g\n+ *\n+ * To convert this into bitwise operations, we rely on this trick to implement conditional negation:\n+ * [-v = ~v + 1] is true for every v, so since [~v = v xor -1] we get [-v = (v xor -1) + 1]. Thus,\n+ * [(v xor mask) - mask] is v if mask=0 and -v if mask=-1. With that we just need a way to quickly\n+ * compute this mask from delta and g's parity. It turns out this is slightly easier if instead of\n+ * delta we track the equivalent eta = -delta. In that case a mask for eta < 0 (= delta > 0) is just\n+ * (eta >> 63) for int64_t. With that, we can write a constant-time divstep as:\n+ *\n+ * def divstep(eta, f, g):\n+ *     # Compute a mask c1 for eta < 0, and compute the conditional negation x of f:\n+ *     c1 = eta >> 63\n+ *     x = (f ^ c1) - c1\n+ *     # Compute a mask c2 for odd g, and conditionally add x to g:\n+ *     c2 = -(g & 1)\n+ *     g += x & c2\n+ *     # Compute a mask c for (eta < 0) and odd (input) g, and use it to conditionally negate eta,\n+ *     # and add g to f:\n+ *     c = c1 & c2\n+ *     eta = (eta ^ c) - c\n+ *     f += g & c\n+ *     # Unconditional operations:\n+ *     eta -= 1\n+ *     g >>= 1\n+ *     return eta, f, g\n+ *\n+ * By replacing the loop in divsteps_n_matrix with a variant of the divstep code above (extended to\n+ * also apply all f operations to u, v and all g operations to q, r), a constant-time version of\n+ * divsteps_n_matrix is obtained.\n+ *\n+ *\n+ * 5. Variable-time optimizations\n+ * ------------------------------\n+ *\n+ * If we don't want constant time code, the changes from the previous sections are unnecessary, and\n+ * we may instead see if it's possible to go in the other direction - making things (on average)\n+ * faster by introducing more variable-time steps.\n+ *\n+ * Here we start with yet another way of writing the (loop of) divstep operations, based on\n+ * paragraph 8.2 from the paper:\n+ *\n+ * for _ in range(N):\n+ *     if g & 1 and eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     if g & 1:\n+ *         g += f\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Observe that as long as g is even, all the loop does is shift it down and decrease eta. If we can\n+ * count the bottom 0 bits in g efficiently (as can be done on most platforms), we can do multiple\n+ * iterations at once:\n+ *\n+ * i = N\n+ * while True:\n+ *     # Get rid of all bottom zeros at once\n+ *     zeros = min(i, count_trailing_zeros(g))\n+ *     eta, i = eta - zeros, i - zeros\n+ *     g >>= zeros\n+ *     if i == 0:\n+ *         break\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     g += f\n+ *\n+ * Now observe that eta always >= 0 on the last line. If eta is even higher, the loop will not run\n+ * the [eta, f, g = -eta, g, f] statement again until eta goes negative. All the last line does is\n+ * add f to g in order to make its bottom bit zero, which is then shifted out at the beginning of\n+ * the next iteration. Repetitions of this are cancelling out all 1 bits in g by adding f to it\n+ * until we run out of iterations (i reaches 0) or eta goes negative.\n+ *\n+ * Nothing prevents us from instead cancelling out multiple bits of g at once by adding a multiple\n+ * of f to it, as long as it's not more than i (as we'd finish the loop before doing more) and not\n+ * more than eta+1 (as we'd do the [eta, f, g = -eta, g, f] at that point). Here is a way to do\n+ * up to 4 at a time:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * i = N\n+ * while True:\n+ *     ...\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, f\n+ *     # Compute limit on number of bits to cancel\n+ *     limit = min(min(eta + 1, i), 4)\n+ *     # Compute w = -g/f mod 2**limit, using the table value for -1/f mod 2**4. Note that f is\n+ *     # always odd, so its inverse modulo a power of two always exists.\n+ *     w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *     # As w = -g/f mod (2**limit), g+w*f mod 2**limit = 0 mod 2**limit.\n+ *     g += w * f\n+ *     assert g % (2**limit) == 0\n+ *     # The next iteration will now shift out all (limit) botoom zero bits from g.\n+ *\n+ * By using a bigger table more bits can be cancelled at once. The table can also be implemented\n+ * as a formula.\n+ *\n+ * This loop, again extended to also handle u, v, q, and r alongside f and g, placed in\n+ * divsteps_n_matrix, gives a significantly faster version.\n+ *\n+ *\n+ * 6. Putting it all together\n+ * --------------------------\n+ *\n+ * All together we need the following functions:\n+ *\n+ * A way to compute the transition matrix in constant time, using the divsteps_n_matrix function\n+ * from section 2, but with its loop replaced by a variant of the constant-time divstep from\n+ * section 4, extended to handle u, v, q, r:\n+ *\n+ * def divsteps_n_matrix(eta, f, g):\n+ *     \"\"\"Compute eta and transformation matrix after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         c1 = eta >> 63\n+ *         x, y, z = (f ^ c1) - c1, (u ^ c1) - c1, (v ^ c1) - c1\n+ *         c2 = -(g & 1)\n+ *         g, q, r = g + (x & c2), q + (y & c2), r + (z & c2)\n+ *         c = c1 & c2\n+ *         eta = (eta ^ c) - (c + 1)  # inlining the unconditional eta decrement here\n+ *         f, u, v = f + (g & c), u + (q & c), v + (r & c)\n+ *         g, u, v = g >> 1, u << 1, v << 1\n+ *     return eta, (u, v, q, r)\n+ *\n+ * The functions to update f and g, and d and e, from section 2:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     fs, gs = u * f + v * g, q * f + r * g\n+ *     return fs >> N, gs >> N\n+ *\n+ * def div2n(modulus, modulus_inv2n, x):\n+ *     \"\"\"Compute x/2^N mod modulus, given modulus_inv2n = modulus^-1 mod 2^N.\"\"\"\n+ *     m = (modulus_inv2n * x) % (2**N)\n+ *     x -= m * modulus\n+ *     return (x >> N) % modulus\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     ds, es = u * d + v * e, q * d + r * e\n+ *     return div2n(modulus, modulus_inv2n, ds), div2n(modulus, modulus_inv2n, es)\n+ *\n+ * And finally the modinv function too, adapted to use eta instead of delta:\n+ *\n+ * def modinv(modulus, modulus_inv2n, x):\n+ *     \"\"\"Compute the modular inverse of x mod modulus, given modulus^-1 mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, modulus, x, 0, 1\n+ *     while g != 0:\n+ *         eta, t = divsteps_n_matrix(-eta, f % (2**N), g % (2**N))\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, modulus, modulus_inv2n)\n+ *     return d * f\n+ *\n+ * To get a variable time version, replace the divsteps_n_matrix function with one that uses the\n+ * divsteps loop from section 5:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * def divsteps_n_matrix_var(eta, f, g):\n+ *     \"\"\"Compute eta and transformation matrix after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1\n+ *     i = N\n+ *     while True:\n+ *         zeros = min(i, count_trailing_zeros(g))\n+ *         eta, i = eta - zeros, i - zeros\n+ *         g, u, v = g >> zeros, u << zeros, v << zeros\n+ *         if i == 0:\n+ *             break\n+ *         if eta < 0:\n+ *             eta, f, u, v, g, q, r = -eta, g, q, r, -f, -u, -v\n+ *         limit = min(min(eta + 1, i), 4)\n+ *         w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *         g, q, r = g + w * f, q + w * u, r + w * v\n+ *",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 386,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "cea64c0e8e32997037cab393fdfec0246eb07a71",
      "in_reply_to_id": 541025928,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2020-12-13T02:54:50Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r541829146",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/541829146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 681,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/542326614",
      "pull_request_review_id": 551297274,
      "id": 542326614,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMyNjYxNA==",
      "diff_hunk": "@@ -200,17 +200,128 @@\n  * This means that in practice we'll always perform a multiple of N divsteps. This is not a problem\n  * because once g=0, further divsteps do not affect f, g, d, or e anymore (only delta keeps\n  * increasing). For variable time code such excess iterations will be mostly optimized away in\n- * section 5.\n+ * section 6.\n  *\n  *\n- * 4. Constant-time operation\n+ * 4. Avoiding modulus operations\n+ * ------------------------------\n+ *\n+ * So far, there are two places where we compute a remainder of big numbers modulo the modulus,\n+ * always on d and e: at the end of div2n in every update_de, and at the very end of modinv after\n+ * potentially negating d due to the sign of f. These are relatively expensive operations when done\n+ * generically.\n+ *\n+ * To deal with the modulus in div2n, we simply stop requiring d and e to be in range [0,modulus)\n+ * all the time. Let's start by inlining div2n into update_de, and dropping the modulus operation at\n+ * the end:\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     md = -((modulus_inv2n * (cd % (2**N))) % (2**N))\n+ *     me = -((modulus_inv2n * (ce % (2**N))) % (2**N))\n+ *     cd += md * modulus\n+ *     ce += me * modulus\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * Let's look at bounds on the ranges of these numbers. It can be shown that |u|+|v| and |q|+|r|\n+ * never exceed 2^N, because a divstep's output f and g cannot exceed the input f and g in absolute\n+ * value (see paragraph 8.3 in the paper). Assume that the input d and e are known to be in range\n+ * (l*modulus,h*modulus) for some numbers l<0 and h>0. The bounds for |u|+|v| and |q|+|r| then imply\n+ * that cd and ce (before cancelling out their bottom bits) are in range\n+ * (-s*2^N*modulus,s*2^N*modulus), where s=max(|l|,|h|). After subtracting up to 2^N-1 times the\n+ * modulus to cancel out bits, and dividing by 2^N at the end, we conclude that d and e have an\n+ * output range slightly smaller than (-(s+1)*modulus,s*modulus).\n+ *\n+ * This means that every consecutive update_de increases the potential range of d and e. This can\n+ * easily be counteracted by incrementing d and e by modulus whenever they're negative:\n+ *\n+ *     ...\n+ *     if d < 0:\n+ *         d += modulus\n+ *     if e < 0:\n+ *         e += modulus\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Redoing the earlier bounds analysis for this code we get the same except now s=max(|l+1|,|h|),\n+ * which means that l=-2 and h=1 results in s=1, resulting in outputs with the same bounds as the\n+ * inputs.\n+ *\n+ * Note that increasing d by modulus is equal to incrementing cd by u*modulus and ce by q*modulus.\n+ * The same is true for e and increments of v*modulus and r*modulus. So we could instead write:\n+ *\n+ *     ...\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     if d < 0:\n+ *         cd, ce = cd + u*modulus, ce + q*modulus\n+ *     if e < 0:\n+ *         cd, ce = cd + v*modulus, ce + r*modulus\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Now notice that we have two steps of corrections to cd and ce that add multiples of modulus.\n+ * The second one depends on the first one, but they can still be efficiently combined by only\n+ * computing the bottom bits of cd and ce at first, and using that to compute the final md, me\n+ * values:\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     md, me = 0, 0\n+ *     if d < 0:\n+ *         md, me = md + u, me + q\n+ *     if e < 0:\n+ *         md, me = md + q, me + r",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 82,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "96cb1cba4e119a2a99f72a5fcdb6e9725ba81216",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this should be `md + v` instead of `md + q`.",
      "created_at": "2020-12-14T11:52:51Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r542326614",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/542326614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/542352472",
      "pull_request_review_id": 551327322,
      "id": 542352472,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjQ3Mg==",
      "diff_hunk": "@@ -200,17 +200,128 @@\n  * This means that in practice we'll always perform a multiple of N divsteps. This is not a problem\n  * because once g=0, further divsteps do not affect f, g, d, or e anymore (only delta keeps\n  * increasing). For variable time code such excess iterations will be mostly optimized away in\n- * section 5.\n+ * section 6.\n  *\n  *\n- * 4. Constant-time operation\n+ * 4. Avoiding modulus operations\n+ * ------------------------------\n+ *\n+ * So far, there are two places where we compute a remainder of big numbers modulo the modulus,\n+ * always on d and e: at the end of div2n in every update_de, and at the very end of modinv after\n+ * potentially negating d due to the sign of f. These are relatively expensive operations when done\n+ * generically.\n+ *\n+ * To deal with the modulus in div2n, we simply stop requiring d and e to be in range [0,modulus)\n+ * all the time. Let's start by inlining div2n into update_de, and dropping the modulus operation at\n+ * the end:\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     md = -((modulus_inv2n * (cd % (2**N))) % (2**N))\n+ *     me = -((modulus_inv2n * (ce % (2**N))) % (2**N))\n+ *     cd += md * modulus\n+ *     ce += me * modulus\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * Let's look at bounds on the ranges of these numbers. It can be shown that |u|+|v| and |q|+|r|\n+ * never exceed 2^N, because a divstep's output f and g cannot exceed the input f and g in absolute\n+ * value (see paragraph 8.3 in the paper). Assume that the input d and e are known to be in range\n+ * (l*modulus,h*modulus) for some numbers l<0 and h>0. The bounds for |u|+|v| and |q|+|r| then imply\n+ * that cd and ce (before cancelling out their bottom bits) are in range\n+ * (-s*2^N*modulus,s*2^N*modulus), where s=max(|l|,|h|). After subtracting up to 2^N-1 times the\n+ * modulus to cancel out bits, and dividing by 2^N at the end, we conclude that d and e have an\n+ * output range slightly smaller than (-(s+1)*modulus,s*modulus).\n+ *\n+ * This means that every consecutive update_de increases the potential range of d and e. This can\n+ * easily be counteracted by incrementing d and e by modulus whenever they're negative:\n+ *\n+ *     ...\n+ *     if d < 0:\n+ *         d += modulus\n+ *     if e < 0:\n+ *         e += modulus\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Redoing the earlier bounds analysis for this code we get the same except now s=max(|l+1|,|h|),\n+ * which means that l=-2 and h=1 results in s=1, resulting in outputs with the same bounds as the\n+ * inputs.\n+ *\n+ * Note that increasing d by modulus is equal to incrementing cd by u*modulus and ce by q*modulus.\n+ * The same is true for e and increments of v*modulus and r*modulus. So we could instead write:\n+ *\n+ *     ...\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     if d < 0:\n+ *         cd, ce = cd + u*modulus, ce + q*modulus\n+ *     if e < 0:\n+ *         cd, ce = cd + v*modulus, ce + r*modulus\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Now notice that we have two steps of corrections to cd and ce that add multiples of modulus.\n+ * The second one depends on the first one, but they can still be efficiently combined by only\n+ * computing the bottom bits of cd and ce at first, and using that to compute the final md, me\n+ * values:\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     md, me = 0, 0\n+ *     if d < 0:\n+ *         md, me = md + u, me + q\n+ *     if e < 0:\n+ *         md, me = md + q, me + r\n+ *     # Compute bottom N bits of cd and ce.\n+ *     cd, ce = (u * d + v * e + md * modulus) % 2**N, (q * d + r * e + me*modulus) % 2**N\n+ *     # Correct md and me such that the bottom bits of cd and ce would be cancelled out.\n+ *     md -= ((modulus_inv2n * (cd % (2**N))) % (2**N))\n+ *     me -= ((modulus_inv2n * (ce % (2**N))) % (2**N))",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 87,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "96cb1cba4e119a2a99f72a5fcdb6e9725ba81216",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "minor nit: unnecessary % operation by 2**N as it was done in the previous step. ",
      "created_at": "2020-12-14T12:40:23Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r542352472",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/542352472"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/544004080",
      "pull_request_review_id": 553379904,
      "id": 544004080,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwNDA4MA==",
      "diff_hunk": "@@ -200,17 +200,128 @@\n  * This means that in practice we'll always perform a multiple of N divsteps. This is not a problem\n  * because once g=0, further divsteps do not affect f, g, d, or e anymore (only delta keeps\n  * increasing). For variable time code such excess iterations will be mostly optimized away in\n- * section 5.\n+ * section 6.\n  *\n  *\n- * 4. Constant-time operation\n+ * 4. Avoiding modulus operations\n+ * ------------------------------\n+ *\n+ * So far, there are two places where we compute a remainder of big numbers modulo the modulus,\n+ * always on d and e: at the end of div2n in every update_de, and at the very end of modinv after\n+ * potentially negating d due to the sign of f. These are relatively expensive operations when done\n+ * generically.\n+ *\n+ * To deal with the modulus in div2n, we simply stop requiring d and e to be in range [0,modulus)\n+ * all the time. Let's start by inlining div2n into update_de, and dropping the modulus operation at\n+ * the end:\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     md = -((modulus_inv2n * (cd % (2**N))) % (2**N))\n+ *     me = -((modulus_inv2n * (ce % (2**N))) % (2**N))\n+ *     cd += md * modulus\n+ *     ce += me * modulus\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * Let's look at bounds on the ranges of these numbers. It can be shown that |u|+|v| and |q|+|r|\n+ * never exceed 2^N, because a divstep's output f and g cannot exceed the input f and g in absolute\n+ * value (see paragraph 8.3 in the paper). Assume that the input d and e are known to be in range\n+ * (l*modulus,h*modulus) for some numbers l<0 and h>0. The bounds for |u|+|v| and |q|+|r| then imply\n+ * that cd and ce (before cancelling out their bottom bits) are in range\n+ * (-s*2^N*modulus,s*2^N*modulus), where s=max(|l|,|h|). After subtracting up to 2^N-1 times the\n+ * modulus to cancel out bits, and dividing by 2^N at the end, we conclude that d and e have an\n+ * output range slightly smaller than (-(s+1)*modulus,s*modulus).\n+ *\n+ * This means that every consecutive update_de increases the potential range of d and e. This can\n+ * easily be counteracted by incrementing d and e by modulus whenever they're negative:\n+ *\n+ *     ...\n+ *     if d < 0:\n+ *         d += modulus\n+ *     if e < 0:\n+ *         e += modulus\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Redoing the earlier bounds analysis for this code we get the same except now s=max(|l+1|,|h|),\n+ * which means that l=-2 and h=1 results in s=1, resulting in outputs with the same bounds as the\n+ * inputs.\n+ *\n+ * Note that increasing d by modulus is equal to incrementing cd by u*modulus and ce by q*modulus.\n+ * The same is true for e and increments of v*modulus and r*modulus. So we could instead write:\n+ *\n+ *     ...\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     if d < 0:\n+ *         cd, ce = cd + u*modulus, ce + q*modulus\n+ *     if e < 0:\n+ *         cd, ce = cd + v*modulus, ce + r*modulus\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Now notice that we have two steps of corrections to cd and ce that add multiples of modulus.\n+ * The second one depends on the first one, but they can still be efficiently combined by only\n+ * computing the bottom bits of cd and ce at first, and using that to compute the final md, me\n+ * values:\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     md, me = 0, 0\n+ *     if d < 0:\n+ *         md, me = md + u, me + q\n+ *     if e < 0:\n+ *         md, me = md + q, me + r\n+ *     # Compute bottom N bits of cd and ce.\n+ *     cd, ce = (u * d + v * e + md * modulus) % 2**N, (q * d + r * e + me*modulus) % 2**N\n+ *     # Correct md and me such that the bottom bits of cd and ce would be cancelled out.\n+ *     md -= ((modulus_inv2n * (cd % (2**N))) % (2**N))\n+ *     me -= ((modulus_inv2n * (ce % (2**N))) % (2**N))",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 87,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "96cb1cba4e119a2a99f72a5fcdb6e9725ba81216",
      "in_reply_to_id": 542352472,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2020-12-16T06:04:27Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r544004080",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/544004080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/544007191",
      "pull_request_review_id": 553381330,
      "id": 544007191,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwNzE5MQ==",
      "diff_hunk": "@@ -200,17 +200,128 @@\n  * This means that in practice we'll always perform a multiple of N divsteps. This is not a problem\n  * because once g=0, further divsteps do not affect f, g, d, or e anymore (only delta keeps\n  * increasing). For variable time code such excess iterations will be mostly optimized away in\n- * section 5.\n+ * section 6.\n  *\n  *\n- * 4. Constant-time operation\n+ * 4. Avoiding modulus operations\n+ * ------------------------------\n+ *\n+ * So far, there are two places where we compute a remainder of big numbers modulo the modulus,\n+ * always on d and e: at the end of div2n in every update_de, and at the very end of modinv after\n+ * potentially negating d due to the sign of f. These are relatively expensive operations when done\n+ * generically.\n+ *\n+ * To deal with the modulus in div2n, we simply stop requiring d and e to be in range [0,modulus)\n+ * all the time. Let's start by inlining div2n into update_de, and dropping the modulus operation at\n+ * the end:\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     md = -((modulus_inv2n * (cd % (2**N))) % (2**N))\n+ *     me = -((modulus_inv2n * (ce % (2**N))) % (2**N))\n+ *     cd += md * modulus\n+ *     ce += me * modulus\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * Let's look at bounds on the ranges of these numbers. It can be shown that |u|+|v| and |q|+|r|\n+ * never exceed 2^N, because a divstep's output f and g cannot exceed the input f and g in absolute\n+ * value (see paragraph 8.3 in the paper). Assume that the input d and e are known to be in range\n+ * (l*modulus,h*modulus) for some numbers l<0 and h>0. The bounds for |u|+|v| and |q|+|r| then imply\n+ * that cd and ce (before cancelling out their bottom bits) are in range\n+ * (-s*2^N*modulus,s*2^N*modulus), where s=max(|l|,|h|). After subtracting up to 2^N-1 times the\n+ * modulus to cancel out bits, and dividing by 2^N at the end, we conclude that d and e have an\n+ * output range slightly smaller than (-(s+1)*modulus,s*modulus).\n+ *\n+ * This means that every consecutive update_de increases the potential range of d and e. This can\n+ * easily be counteracted by incrementing d and e by modulus whenever they're negative:\n+ *\n+ *     ...\n+ *     if d < 0:\n+ *         d += modulus\n+ *     if e < 0:\n+ *         e += modulus\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Redoing the earlier bounds analysis for this code we get the same except now s=max(|l+1|,|h|),\n+ * which means that l=-2 and h=1 results in s=1, resulting in outputs with the same bounds as the\n+ * inputs.\n+ *\n+ * Note that increasing d by modulus is equal to incrementing cd by u*modulus and ce by q*modulus.\n+ * The same is true for e and increments of v*modulus and r*modulus. So we could instead write:\n+ *\n+ *     ...\n+ *     cd, ce = u * d + v * e, q * d + r * e\n+ *     if d < 0:\n+ *         cd, ce = cd + u*modulus, ce + q*modulus\n+ *     if e < 0:\n+ *         cd, ce = cd + v*modulus, ce + r*modulus\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Now notice that we have two steps of corrections to cd and ce that add multiples of modulus.\n+ * The second one depends on the first one, but they can still be efficiently combined by only\n+ * computing the bottom bits of cd and ce at first, and using that to compute the final md, me\n+ * values:\n+ *\n+ * def update_de(d, e, t, modulus, modulus_inv2n):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo modulus.\"\"\"\n+ *     u, v, q, r = t\n+ *     md, me = 0, 0\n+ *     if d < 0:\n+ *         md, me = md + u, me + q\n+ *     if e < 0:\n+ *         md, me = md + q, me + r",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 82,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "96cb1cba4e119a2a99f72a5fcdb6e9725ba81216",
      "in_reply_to_id": 542326614,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nice catch, fixed.",
      "created_at": "2020-12-16T06:08:32Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r544007191",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/544007191"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/548177611",
      "pull_request_review_id": 558196996,
      "id": 548177611,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE3NzYxMQ==",
      "diff_hunk": "@@ -252,4 +252,45 @@ SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n SECP256K1_GNUC_EXT typedef __int128 int128_t;\n #endif\n \n+#ifndef __has_builtin\n+#define __has_builtin(x) 0\n+#endif\n+\n+static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\n+#if (__has_builtin(__builtin_ctz) || SECP256K1_GNUC_PREREQ(3,4))\n+    if (((unsigned)UINT32_MAX) == UINT32_MAX) {",
      "path": "src/util.h",
      "position": 38,
      "original_position": 10,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "4ad49c8aab9afba2a6f3aba3f311fd6c27642bb5",
      "in_reply_to_id": 503787800,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2020-12-23T19:45:10Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r548177611",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/548177611"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 313,
      "original_line": 313,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/549203982",
      "pull_request_review_id": 558985722,
      "id": 549203982,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTIwMzk4Mg==",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman, Pieter Wuille                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * See https://gcd.cr.yp.to/papers.html#safegcd for the paper. The references below are for the Date:\n+ * 2019.04.13 version.\n+ *\n+ * Below is an explanation of the implementation, building up the algorithm in Python3 step by step.\n+ *\n+ *\n+ * 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+ * -------------------------------------------------------------\n+ *\n+ * The algorithm from the paper, at a very high level, is this:\n+ *\n+ * def gcd(f, g):\n+ *     \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+ *     assert f & 1  # require f to be odd\n+ *     delta = 1     # additional state variable\n+ *     while g != 0:\n+ *         assert f & 1  # f will be odd in every iteration\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g = 1 - delta, g, (g - f) // 2\n+ *         elif g & 1:\n+ *             delta, f, g = 1 + delta, f, (g + f) // 2\n+ *         else:\n+ *             delta, f, g = 1 + delta, f, (g    ) // 2\n+ *     return abs(f)\n+ *\n+ * It computes the greatest common divisor of an odd integer f and any integer g. Its inner loop\n+ * keeps rewriting the variables f and g alongside a state variable delta that starts at 1, until\n+ * g=0 is reached. At that point, |f| gives the GCD. Each of the transitions in the loop is called a\n+ * \"division step\" (referred to as divstep in what follows).\n+ *\n+ * For example, gcd(21, 14) would be computed as:\n+ * - Start with delta=1 f=21 g=14\n+ * - Take the third branch: delta=2 f=21 g=7\n+ * - Take the first branch: delta=-1 f=7 g=-7\n+ * - Take the second branch: delta=0 f=7 g=0\n+ * - The answer |f| = 7.\n+ *\n+ * Why it works:\n+ * - Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+ *   - (a) If g is odd, replace (f,g) with (g,g-f) or (f,g+f), resulting in an even g.\n+ *   - (b) Replace (f,g) with (f,g//2) (where g is guaranteed to be even).\n+ * - Neither of those two operations change the GCD:\n+ *   - For (a), assume gcd(f,g)=c, then it must be the case that f=a*c and g=b*c for some integers a\n+ *     and b. As (g,g-f)=(b*c,(b-a)*c) and (f,f+g)=(a*c,(a+b)*c), the result clearly still has\n+ *     common factor c. Reasoning in the other direction shows that no common factor can be added by\n+ *     doing so either.\n+ *   - For (b), we know that f is odd, so gcd(f,g) clearly has no common factor 2, and we can remove\n+ *     it from g.\n+ * - The algorithm will eventually converge to g=0. This is proven in the paper (see theorem G.3).\n+ * - It follows that eventually we find a final value f' for which gcd(f,g) = gcd(f',0). As the\n+ *   gcd of f' and 0 is |f'| by definition, that is our answer.\n+ *\n+ * Compared to more traditional GCD algorithms, this one has the property of only ever looking at\n+ * the low-order bits of the variables to decide the next steps, and being easy to make\n+ * constant-time (in more low-level languages than Python). The delta parameter is necessary to\n+ * guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+ * at high order bits.\n+ *\n+ * Properties that will become important later:\n+ * - Performing more divsteps than needed is not a problem, as f does not change anymore after g=0.\n+ * - Only even numbers are divided by 2. This means that when reasoning about it algebraically we\n+ *   do not need to worry about rounding.\n+ * - At every point during the algorithm's execution the next N steps only depend on the bottom N\n+ *   bits of f and g, and on delta.\n+ *\n+ *\n+ * 2. From GCDs to modular inverses\n+ * --------------------------------\n+ *\n+ * We want an algorithm to compute the inverse a of x modulo M, i.e. the number a such that a*x=1\n+ * mod M. This inverse only exists if the GCD of x and M is 1, but that is always the case if M is\n+ * prime and 0 < x < M. In what follows, assume that the modular inverse exists. To find that\n+ * inverse, it turns out this can be computed as a side effect of computing the GCD by keeping track\n+ * of how the internal variables can be written as linear combinations of the inputs at every step.\n+ * Since the GCD is 1, such an algorithm will compute numbers a and b such that a*x + b*M = 1.\n+ * Taking that expression mod M gives a*x mod M = 1, and we see that a is the modular inverse of x\n+ * mod M.\n+ *\n+ * A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+ * algorithm shown above, if the modulus M is odd. To do so, compute gcd(f=M,g=x), while keeping\n+ * track of extra variables d and e, for which at every step d = f/x (mod M) and e = g/x (mod M).\n+ * f/x here means the number which multiplied with x gives f mod M. As f and g are initialized to M\n+ * and x respectively, d and e just start off being 0 (M/x mod M = 0/x mod M = 0) and 1 (x/x mod M\n+ * = 1).\n+ *\n+ * def div2(M, x):\n+ *     \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+ *     assert M & 1\n+ *     if x & 1: # If x is odd, make it even by adding M.\n+ *         x += M\n+ *     # x must be even now, so a clean division by 2 is possible.\n+ *     return x // 2\n+ *\n+ * def modinv(M, x):\n+ *     \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+ *     assert M & 1\n+ *     delta, f, g, d, e = 1, M, x, 0, 1\n+ *     while g != 0:\n+ *         # Note that while division by two for f and g is only ever done on even inputs, this is\n+ *         # not true for d and e, so we need the div2 helper function.\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+ *         elif g & 1:\n+ *             delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+ *         else:\n+ *             delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+ *         # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+ *         assert f % M == (d * x) % M\n+ *         assert g % M == (e * x) % M\n+ *     assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+ *     # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+ *     return (d * f) % M\n+ *\n+ * Also note that this approach to track d and e throughout the computation to determine the inverse\n+ * is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+ * entire computation is determined (see section 3 below) and the inverse is computed from that.\n+ * The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+ * be faster (after the optimizations explained below) for the size of numbers we care about.\n+ *\n+ *\n+ * 3. Batching multiple divsteps\n+ * -----------------------------\n+ *\n+ * Every divstep can be expressed as a matrix multiplication, applying a transition matrix (1/2*t)\n+ * to both vectors [f, g] and [d, e] (see paragraph 8.1 in the paper):\n+ *\n+ *   t = [ u,  v ]\n+ *       [ q,  r ]\n+ *\n+ *   [ out_f ] = (1/2 * t) * [ in_f ]\n+ *   [ out_g ] =             [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+ *   [ out_e ]               [ in_e ]\n+ *\n+ * where (u, v, q, r) is (0, 2, -1, 1), (2, 0, 1, 1), or (2, 0, 0, 1), depending on which branch is\n+ * taken. As above, the resulting f and g are always integers.\n+ *\n+ * Performing multiple divsteps corresponds to a multiplication with the product of all the\n+ * individual divsteps' transition matrices. As each transition matrix consists of integers\n+ * divided by 2, the product of these matrices will consist of integers divided by 2^N (see also\n+ * theorem 9.2 in the paper). These divisions are expensive when updating d and e, so we delay\n+ * them: we compute the integer coefficients of the combined transition matrix scaled by 2^N, and\n+ * do one division by 2^N as a final step:\n+ *\n+ * def divsteps_n_matrix(delta, f, g):\n+ *     \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+ *         elif g & 1:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+ *         else:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+ *     return delta, (u, v, q, r)\n+ *\n+ * As the branches in the divsteps are completely determined by the bottom N bits of f and g, this\n+ * function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+ * intermediate results and outputs fit in (N+1)-bit numbers (unsigned for f and g; signed for u, v,\n+ * q, and r) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+ * integers could set N=62 and compute the full transition matrix for 62 steps at once without any\n+ * big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+ * to update the full-size f, g, d, and e numbers once every N steps.\n+ *\n+ * We still need functions to compute:\n+ *\n+ *   [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+ *   [ out_g ]   (        [ q,  r ])   [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+ *   [ out_e ]   (        [ q,  r ])   [ in_e ]\n+ *\n+ * For f and g that's easy:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     cf, cg = u*f + v*g, q*f + r*g\n+ *     # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+ *     # bottom bits.\n+ *     assert cf % 2**N == 0\n+ *     assert cg % 2**N == 0\n+ *     return cf >> N, cg >> N\n+ *\n+ * To do the same for d and e, we need an equivalent of the div2 function for division by 2^N mod M.\n+ * This is easy if we have precomputed M^-1 mod 2^N (which always exists for odd M):\n+ *\n+ * def div2n(M, Mi, x):\n+ *     \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+ *     assert (M * Mi) % 2**N == 1\n+ *     # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+ *     #     (m * M) mod 2^N = x mod 2^N\n+ *     # <=> m mod 2^N = (x / M) mod 2^N\n+ *     # <=> m mod 2^N = (x * Mi) mod 2^N\n+ *     m = (Mi * x) % 2**N\n+ *     # Subtract that multiple from x, cancelling its bottom N bits.\n+ *     x -= m * M\n+ *     # Now a clean division by 2^N is possible.\n+ *     assert x % 2**N == 0\n+ *     return (x >> N) % M\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+ *\n+ * With all of those, we can write a version of modinv that performs N divsteps at once:\n+ *\n+ * def modinv(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     assert M & 1\n+ *     delta, f, g, d, e = 1, M, x, 0, 1\n+ *     while g != 0:\n+ *         # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+ *         # (N+1)-bit signed integer arithmetic).\n+ *         delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+ *         # Apply the transition matrix t to [f, g]:\n+ *         f, g = update_fg(f, g, t)\n+ *         # Apply the transition matrix t to [d, e]:\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return (d * f) % M\n+ *\n+ * This means that in practice we'll always perform a multiple of N divsteps. This is not a problem\n+ * because once g=0, further divsteps do not affect f, g, d, or e anymore (only delta keeps\n+ * increasing). For variable time code such excess iterations will be mostly optimized away in\n+ * section 6.\n+ *\n+ *\n+ * 4. Avoiding modulus operations\n+ * ------------------------------\n+ *\n+ * So far, there are two places where we compute a remainder of big numbers modulo M: at the end of\n+ * div2n in every update_de, and at the very end of modinv after potentially negating d due to the\n+ * sign of f. These are relatively expensive operations when done generically.\n+ *\n+ * To deal with the modulus operation in div2n, we simply stop requiring d and e to be in range\n+ * [0,M) all the time. Let's start by inlining div2n into update_de, and dropping the modulus\n+ * operation at the end:\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     md = -((Mi * cd) % 2**N)\n+ *     me = -((Mi * ce) % 2**N)\n+ *     cd += md * M\n+ *     ce += me * M\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * Let's look at bounds on the ranges of these numbers. It can be shown that |u|+|v| and |q|+|r|\n+ * never exceed 2^N (see paragraph 8.3 in the paper), and thus a multiplication with t will have\n+ * outputs whose absolute values are at most 2^N times the maximum absolute input value. In case the\n+ * inputs d and e are in (-M,M), which is certainly true for the initial values d=0 and e=1 assuming\n+ * M > 1, the multiplication results in numbers in range (-2^N*M,2^N*M). Subtracting up to 2^N-1\n+ * times M to cancel out N bits brings that up to slightly less than (-2^(N+1)*M,2^N*M), and\n+ * dividing by 2^N at the end takes it to (-2*M,M). Another application of update_de would take that\n+ * to (-3*M,2*M), and so forth. This progressive expansion of the variables' ranges can be\n+ * counteracted by incrementing d and e by M whenever they're negative:\n+ *\n+ *     ...\n+ *     if d < 0:\n+ *         d += M\n+ *     if e < 0:\n+ *         e += M\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * With inputs in (-2*M,M), they will first be shifted into range (-M,M), which means that the\n+ * output will again be in (-2*M,M), and this remains the case regardless of how many update_de\n+ * invocations there are. *\n+ *\n+ * Now note that increasing d by M is equal to incrementing cd by u*M and ce by q*M. Similarly,\n+ * increasing e by M is equal to incrementing cd by v*M and ce by r*M. So we could instead write:\n+ *\n+ *     ...\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     if d < 0:\n+ *         cd, ce = cd + u*M, ce + q*M\n+ *     if e < 0:\n+ *         cd, ce = cd + v*M, ce + r*M\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Now note that we have two steps of corrections to cd and ce that add multiples of M: this\n+ * increment, and the decrement that cancels out bottom bits. The second one depends on the first\n+ * one, but they can still be efficiently combined by only computing the bottom bits of cd and ce\n+ * at first, and using that to compute the final md, me values:\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     md, me = 0, 0\n+ *     # Compute what multiples of M to add to cd and ce.\n+ *     if d < 0:\n+ *         md, me = md + u, me + q\n+ *     if e < 0:\n+ *         md, me = md + v, me + r\n+ *     # Compute bottom N bits of t*[d,e] + M*[md,me].\n+ *     cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N\n+ *     # Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.\n+ *     md -= (Mi * cd) % 2**N\n+ *     me -= (Mi * ce) % 2**N\n+ *     # Do the full computation.\n+ *     cd, ce = u*d + v*e + md*M, q*d + r*e + me*M\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * One last optimization: we can avoid the md*M and me*M multiplications in the bottom bits of cd\n+ * and ce by moving them to the md and me correction:\n+ *\n+ *     ...\n+ *     # Compute bottom N bits of t*[d,e].\n+ *     cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+ *     # Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.\n+ *     # Note that this is not the same as {md = (Mi * cd) % 2**N} etc. That would also result in N\n+ *     # zero bottom bits, but isn't guaranteed to be a reduction of [0,2^N) compared to the\n+ *     # previous md and me values, and thus would violate our bounds analysis.\n+ *     md -= (Mi*cd + md) % 2**N\n+ *     me -= (Mi*ce + me) % 2**N\n+ *     ...\n+ *\n+ * The resulting function takes as input d and e in range (-2*M,M) and outputs values in the same\n+ * range. That also means that the d value at the end of modinv will be in that range, while we want\n+ * a result in [0,M). To do that, we need a normalization function. It's easy to integrate the\n+ * conditional negation of d (based on the sign of f) into it as well:\n+ *\n+ * def normalize(sign, v, M):\n+ *     \"\"\"Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).\"\"\"\n+ *     assert sign == 1 or sign == -1\n+ *     # v in (-2*M,M)\n+ *     if v < 0:\n+ *         v += M\n+ *     # v in (-M,M)\n+ *     if sign == -1:\n+ *         v = -v\n+ *     # v in (-M,M)\n+ *     if v < 0:\n+ *         v += M\n+ *     # v in [0,M)\n+ *     return v\n+ *\n+ * And calling it in modinv is simply:\n+ *\n+ *    ...\n+ *    return normalize(f, d, M)\n+ *\n+ *\n+ * 5. Constant-time operation\n+ * --------------------------\n+ *\n+ * The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+ * depends on the input data so far?\n+ *\n+ * - The number of iterations of the while g != 0 loop in modinv.\n+ * - The branches inside divsteps_n_matrix.\n+ * - The sign checks in update_de\n+ * - The sign checks in normalize\n+ *\n+ * To make the while loop in modinv constant time it can be replaced with a constant number of\n+ * iterations. The paper proves (Theorem 11.2) that 741 divsteps are sufficient for any 256-bit\n+ * inputs, and https://github.com/sipa/safegcd-bounds shows that the slightly better bound 724 is\n+ * sufficient even. Given that every loop iteration performs N divsteps, it will run a total of\n+ * ceil(724/N) times.\n+ *\n+ * Dealing with the branches in divsteps_n_matrix requires replacing them with constant-time\n+ * bitwise operations (and hoping the C compiler isn't smart enough to turn them back into\n+ * branches; see valgrind_ctime_test.c for automated tests that this isn't the case). To do so,\n+ * observe that a divstep can be written instead as:\n+ *\n+ *     if g & 1:\n+ *         g += -f if delta > 0 else f    # set g to (input) g-f or g+f\n+ *         if delta > 0:\n+ *             delta = -delta\n+ *             f += g                     # set f to (input) g (note that g was set to g-f before)\n+ *     delta += 1\n+ *     g >>= 1\n+ *\n+ * To convert this into bitwise operations, we rely on this trick to implement conditional negation:\n+ * For every v, -v == ~v + 1, so since bitflipping is equal to xoring with -1, we get\n+ * -v == (v xor -1) + 1. Thus, ((v xor mask) - mask) is {v if mask=0; -v if mask=-1}. With that we\n+ * just need a way to quickly compute this mask from delta and g's parity. It turns out this is\n+ * slightly easier if instead of delta we track the equivalent eta = -delta. In that case a mask for\n+ * eta < 0 (= delta > 0) is just (eta >> 63) for int64_t. With that, we can write a constant-time\n+ * divstep as:\n+ *\n+ *     # Compute a mask c1 for eta < 0, and compute the conditional negation x of f:\n+ *     c1 = eta >> 63\n+ *     x = (f ^ c1) - c1\n+ *     # Compute a mask c2 for odd g, and conditionally add x to g:\n+ *     c2 = -(g & 1)\n+ *     g += x & c2\n+ *     # Compute a mask c for (eta < 0) and odd (input) g, and use it to conditionally negate eta,\n+ *     # and add g to f:\n+ *     c = c1 & c2\n+ *     eta = (eta ^ c) - c\n+ *     f += g & c\n+ *     # Unconditional operations:\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Note that the semantics of Python ints conveniently matches C here (assuming two's complement\n+ * behavior for signed integers; see assumptions.h), for the purpose of these techniques: right\n+ * shifting always rounds down, so (eta >> 63) is -1 if eta is negative; and bitwise operations with\n+ * -1 treat the number as equivalent to infinitely many 1 bits).\n+ *\n+ * By replacing the loop in divsteps_n_matrix with a variant of the divstep code above (extended to\n+ * also apply all f operations to u, v and all g operations to q, r), a constant-time version of\n+ * divsteps_n_matrix is obtained.\n+ *\n+ * These bit fiddling tricks can also be used to make the conditional negations and additions in\n+ * update_de and normalize constant-time.\n+ *\n+ *\n+ * 6. Variable-time optimizations\n+ * ------------------------------\n+ *\n+ * If we don't want constant time code, the changes from the previous sections are unnecessary, and\n+ * we may instead see if it's possible to go in the other direction - making things faster by\n+ * introducing more variable-time steps.\n+ *\n+ * Here we start with yet another way of writing the (loop of) divstep operations, based on\n+ * paragraph 8.2 from the paper:\n+ *\n+ * for _ in range(N):\n+ *     if g & 1 and eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     if g & 1:\n+ *         g += f\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Observe that as long as g is even, all the loop does is shift it down and decrease eta. If we can\n+ * count the bottom 0 bits in g efficiently (as can be done on most platforms), we can do multiple\n+ * iterations at once:\n+ *\n+ * i = N # divsteps left to do\n+ * while True:\n+ *     # Get rid of all bottom zeros at once\n+ *     zeros = min(i, count_trailing_zeros(g))\n+ *     eta, i = eta - zeros, i - zeros\n+ *     g >>= zeros\n+ *     if i == 0:\n+ *         break\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     g += f\n+ *\n+ * Now observe that eta always >= 0 on the last line. If eta is even higher, the loop will not run\n+ * the {eta, f, g = -eta, g, f} statement again until eta goes negative. All the last line does is\n+ * g += f with various shifted version of g, in order in order to make g's bottom bit zero, until we\n+ * run out of iterations (i reaches 0) or eta goes negative.\n+ *\n+ * Nothing prevents us from instead cancelling out multiple bits of g at once by adding a multiple\n+ * of f to it, as long as it's not more than i steps (as we'd finish the loop before doing more) or\n+ * more than eta+1 steps (as we'd run {eta, f, g = -eta, g, f} at that point). Here is a way to do\n+ * up to 4 at a time:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * i = N\n+ * while True:\n+ *     ...\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, f\n+ *     # Compute limit on number of bits to cancel\n+ *     limit = min(min(eta + 1, i), 4)\n+ *     # Compute w = -g/f mod 2**limit, using the table value for -1/f mod 2**4. Note that f is\n+ *     # always odd, so its inverse modulo a power of two always exists.\n+ *     w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *     # As w = -g/f mod (2**limit), g+w*f mod 2**limit = 0 mod 2**limit.\n+ *     g += w * f\n+ *     assert g % (2**limit) == 0\n+ *     # The next iteration will now shift out all (limit) bottom zero bits from g.\n+ *\n+ * By using a bigger table more bits can be cancelled at once. The table can also be implemented\n+ * as a formula:\n+ *  - Instead of a 3-bit table:\n+ *    * (-f) or (f ^ 6)\n+ *  - Instead of a 4-bit table:\n+ *    * (1 - f * (f + 1))\n+ *    * (-(f + (((f + 1) & 4) << 1)))\n+ *  - For larger tables the following technique can be used: if w=-f^-1 mod 2^i, then w*(w*f+2) is\n+ *    -f^-1 mod 2^(2*i). This allows extending the previous formulas (or tables). In particular we\n+ *    have this 6-bit function (based on the 3-bit function above):\n+ *    * (f * (f * f - 2))\n+ *\n+ * This loop, again extended to also handle u, v, q, and r alongside f and g, placed in\n+ * divsteps_n_matrix, gives a significantly faster, but non-constant time version. It is usable when\n+ * not operating on secret data.\n+ *\n+ * 7. Final Python version\n+ * -----------------------\n+ *\n+ * All together we need the following functions:\n+ *\n+ * - A way to compute the transition matrix in constant time, using the divsteps_n_matrix function\n+ *   from section 2, but with its loop replaced by a variant of the constant-time divstep from\n+ *   section 5, extended to handle u, v, q, r:\n+ *\n+ * def divsteps_n_matrix(eta, f, g):\n+ *     \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         c1 = eta >> 63\n+ *         # Compute x, y, z as conditionally-negated versions of f, u, v.\n+ *         x, y, z = (f ^ c1) - c1, (u ^ c1) - c1, (v ^ c1) - c1\n+ *         c2 = -(g & 1)\n+ *         # Conditionally add x, y, z to g, q, r.\n+ *         g, q, r = g + (x & c2), q + (y & c2), r + (z & c2)\n+ *         c1 &= c2                     # reusing c1 here for further conditionals\n+ *         eta = (eta ^ c1) - (c1 + 1)  # inlining the unconditional eta decrement here\n+ *         # Conditionally add g, q, r to f, u, v.\n+ *         f, u, v = f + (g & c1), u + (q & c1), v + (r & c1)\n+ *         # When shifting g down, don't shift q, r, as we construct a transition matrix multiplied\n+ *         # by 2^N. Instead, shift f's coefficients u and v up.\n+ *         g, u, v = g >> 1, u << 1, v << 1\n+ *     return eta, (u, v, q, r)\n+ *\n+ * - The functions to update f and g, and d and e, from section 2 and section 4, with the constant-time\n+ *   changes to update_de from section 5:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     cf, cg = u*f + v*g, q*f + r*g\n+ *     return cf >> N, cg >> N\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     d_sign, e_sign = d >> 257, e >> 257\n+ *     md, me = (u & d_sign) + (v & e_sign), (q & d_sign) + (r & e_sign)\n+ *     cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+ *     md -= (Mi*cd + md) % 2**N\n+ *     me -= (Mi*ce + me) % 2**N\n+ *     cd, ce = u*d + v*e + Mi*md, q*d + r*e + Mi*me\n+ *     return cd >> N, ce >> N\n+ *\n+ * - The normalize function from section 4, made constant time as well:\n+ *\n+ * def normalize(sign, v, M):\n+ *     \"\"\"Compute sign*v mod M, where v in (-2*M,M); output in [0,M).\"\"\"\n+ *     v_sign = v >> 257\n+ *     # Conditionally add M to v.\n+ *     v += M & v_sign\n+ *     c = (sign - 1) >> 1\n+ *     # Conditionally negate v.\n+ *     v = (v ^ c) - c\n+ *     v_sign = v >> 257\n+ *     # Conditionally add M to v again.\n+ *     v += M & v_sign\n+ *     return v\n+ *\n+ * - And finally the modinv function too, adapted to use eta instead of delta, and using the fixed\n+ *   iteration count from section 5:\n+ *\n+ * def modinv(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, M, x, 0, 1\n+ *     for _ in range((724 + N - 1) // N):\n+ *         eta, t = divsteps_n_matrix(-eta, f % 2**N, g % 2**N)\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return normalize(f, d, M)\n+ *\n+ * - To get a variable time version, replace the divsteps_n_matrix function with one that uses the\n+ *   divsteps loop from section 5, and a modinv version that calls it without the fixed iteration\n+ *   count:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * def divsteps_n_matrix_var(eta, f, g):\n+ *     \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1\n+ *     i = N\n+ *     while True:\n+ *         zeros = min(i, count_trailing_zeros(g))\n+ *         eta, i = eta - zeros, i - zeros\n+ *         g, u, v = g >> zeros, u << zeros, v << zeros\n+ *         if i == 0:\n+ *             break\n+ *         if eta < 0:\n+ *             eta, f, u, v, g, q, r = -eta, g, q, r, -f, -u, -v\n+ *         limit = min(min(eta + 1, i), 4)\n+ *         w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *         g, q, r = g + w*f, q + w*u, r + w*v\n+ *     return eta, (u, v, q, r)\n+ *\n+ * def modinv_var(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi = 1/M mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, M, x, 0, 1\n+ *     while g != 0:\n+ *         eta, t = divsteps_n_matrix_var(eta, f % 2**N, g % 2**N)\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return normalize(f, d, Mi)\n+ *\n+ *\n+ * 8. C implementation\n+ * -------------------\n+ *\n+ * What follows is a C implementation of effectively the Python code from section 7, with N=62, and\n+ * the following changes:\n+ *\n+ * - Representing large integers using 5 62-bit singed limbs that callers need to convert their\n+ *   value from/to. Using 62-bit limbs means shifts by 62 bits are very efficient, and the extra\n+ *   space allows faster operations by delaying carries/borrows in some cases.\n+ *\n+ * - Several modulo operations in the Python code are modulo a power of two. These can be replaced\n+ *   with a bitwise AND with ((1 << bits) - 1).\n+ *\n+ * - Similarly, if an entire expression involving multiplications and additions is computed modulo\n+ *   a power of two, that means only the bottom bits of the inputs and intermediary results is\n+ *   needed.\n+ */\n+\n+#ifdef VERIFY\n+/* Helper function to compute the absolute value of an int64_t.\n+ * (we don't use abs/labs/llabs as it depends on the int sizes). */\n+static int64_t secp256k1_modinv64_abs(int64_t v) {\n+    VERIFY_CHECK(v > INT64_MIN);\n+    if (v < 0) return -v;\n+    return v;\n+}\n+\n+static const secp256k1_modinv64_signed62 SECP256K1_SIGNED62_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^62). */\n+static void secp256k1_modinv64_mul_62(secp256k1_modinv64_signed62 *r, const secp256k1_modinv64_signed62 *a, int alen, int64_t factor) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int128_t c = 0;\n+    int i;\n+    for (i = 0; i < 4; ++i) {\n+        if (i < alen) {\n+            c += (factor == 1) ? (int128_t)a->v[i] : (int128_t)a->v[i] * factor;\n+        }\n+        r->v[i] = (int64_t)c & M62; c >>= 62;\n+    }\n+    if (4 < alen) {\n+        c += (factor == 1) ? (int128_t)a->v[4] : (int128_t)a->v[4] * factor;\n+    }\n+    VERIFY_CHECK(c == (int64_t)c);\n+    r->v[4] = (int64_t)c;\n+}\n+\n+/* Compare af with b*bf. */\n+static int secp256k1_modinv64_mul_cmp_62(const secp256k1_modinv64_signed62 *a, int alen, const secp256k1_modinv64_signed62 *b, int64_t factor) {\n+    int i;\n+    secp256k1_modinv64_signed62 am, bm;\n+    secp256k1_modinv64_mul_62(&am, a, alen, 1);\n+    secp256k1_modinv64_mul_62(&bm, b, 5, factor);\n+    for (i = 4; i >= 0; --i) {\n+        if (i != 4) {\n+            VERIFY_CHECK(am.v[i] >> 62 == 0);\n+            VERIFY_CHECK(bm.v[i] >> 62 == 0);\n+        }\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }\n+    return 0;\n+}\n+#endif\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^62,2^62). */\n+    int i;\n+    for (i = 0; i < 5; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M62);\n+        VERIFY_CHECK(r->v[i] <= M62);\n+    }\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, -2) > 0); /* r > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < P */\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled\n+             * out (as we'd be done before that point), and no more than eta+1 can be done as its\n+             * will flip again once that happens. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            /* m is a mask for the bottom min(limit, 6) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 63U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)\n+             * bits. */\n+            w = (f * g * (f * f - 2)) & m;",
      "path": "src/modinv64_impl.h",
      "position": 262,
      "original_position": 859,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "1e30f79c3807a9c63c6c6f6ae07e7c9445b0f37c",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It may be worth noting that these multiplications should only need a 32x32->32 multiply instruction (or 8x8->8 even!), though I haven't checked whether compilers see that.",
      "created_at": "2020-12-28T03:40:17Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r549203982",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/549203982"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 262,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/549233570",
      "pull_request_review_id": 559014662,
      "id": 549233570,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTIzMzU3MA==",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman, Pieter Wuille                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * See https://gcd.cr.yp.to/papers.html#safegcd for the paper. The references below are for the Date:\n+ * 2019.04.13 version.\n+ *\n+ * Below is an explanation of the implementation, building up the algorithm in Python3 step by step.\n+ *\n+ *\n+ * 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+ * -------------------------------------------------------------\n+ *\n+ * The algorithm from the paper, at a very high level, is this:\n+ *\n+ * def gcd(f, g):\n+ *     \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+ *     assert f & 1  # require f to be odd\n+ *     delta = 1     # additional state variable\n+ *     while g != 0:\n+ *         assert f & 1  # f will be odd in every iteration\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g = 1 - delta, g, (g - f) // 2\n+ *         elif g & 1:\n+ *             delta, f, g = 1 + delta, f, (g + f) // 2\n+ *         else:\n+ *             delta, f, g = 1 + delta, f, (g    ) // 2\n+ *     return abs(f)\n+ *\n+ * It computes the greatest common divisor of an odd integer f and any integer g. Its inner loop\n+ * keeps rewriting the variables f and g alongside a state variable delta that starts at 1, until\n+ * g=0 is reached. At that point, |f| gives the GCD. Each of the transitions in the loop is called a\n+ * \"division step\" (referred to as divstep in what follows).\n+ *\n+ * For example, gcd(21, 14) would be computed as:\n+ * - Start with delta=1 f=21 g=14\n+ * - Take the third branch: delta=2 f=21 g=7\n+ * - Take the first branch: delta=-1 f=7 g=-7\n+ * - Take the second branch: delta=0 f=7 g=0\n+ * - The answer |f| = 7.\n+ *\n+ * Why it works:\n+ * - Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+ *   - (a) If g is odd, replace (f,g) with (g,g-f) or (f,g+f), resulting in an even g.\n+ *   - (b) Replace (f,g) with (f,g//2) (where g is guaranteed to be even).\n+ * - Neither of those two operations change the GCD:\n+ *   - For (a), assume gcd(f,g)=c, then it must be the case that f=a*c and g=b*c for some integers a\n+ *     and b. As (g,g-f)=(b*c,(b-a)*c) and (f,f+g)=(a*c,(a+b)*c), the result clearly still has\n+ *     common factor c. Reasoning in the other direction shows that no common factor can be added by\n+ *     doing so either.\n+ *   - For (b), we know that f is odd, so gcd(f,g) clearly has no common factor 2, and we can remove\n+ *     it from g.\n+ * - The algorithm will eventually converge to g=0. This is proven in the paper (see theorem G.3).\n+ * - It follows that eventually we find a final value f' for which gcd(f,g) = gcd(f',0). As the\n+ *   gcd of f' and 0 is |f'| by definition, that is our answer.\n+ *\n+ * Compared to more traditional GCD algorithms, this one has the property of only ever looking at\n+ * the low-order bits of the variables to decide the next steps, and being easy to make\n+ * constant-time (in more low-level languages than Python). The delta parameter is necessary to\n+ * guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+ * at high order bits.\n+ *\n+ * Properties that will become important later:\n+ * - Performing more divsteps than needed is not a problem, as f does not change anymore after g=0.\n+ * - Only even numbers are divided by 2. This means that when reasoning about it algebraically we\n+ *   do not need to worry about rounding.\n+ * - At every point during the algorithm's execution the next N steps only depend on the bottom N\n+ *   bits of f and g, and on delta.\n+ *\n+ *\n+ * 2. From GCDs to modular inverses\n+ * --------------------------------\n+ *\n+ * We want an algorithm to compute the inverse a of x modulo M, i.e. the number a such that a*x=1\n+ * mod M. This inverse only exists if the GCD of x and M is 1, but that is always the case if M is\n+ * prime and 0 < x < M. In what follows, assume that the modular inverse exists. To find that\n+ * inverse, it turns out this can be computed as a side effect of computing the GCD by keeping track\n+ * of how the internal variables can be written as linear combinations of the inputs at every step.\n+ * Since the GCD is 1, such an algorithm will compute numbers a and b such that a*x + b*M = 1.\n+ * Taking that expression mod M gives a*x mod M = 1, and we see that a is the modular inverse of x\n+ * mod M.\n+ *\n+ * A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+ * algorithm shown above, if the modulus M is odd. To do so, compute gcd(f=M,g=x), while keeping\n+ * track of extra variables d and e, for which at every step d = f/x (mod M) and e = g/x (mod M).\n+ * f/x here means the number which multiplied with x gives f mod M. As f and g are initialized to M\n+ * and x respectively, d and e just start off being 0 (M/x mod M = 0/x mod M = 0) and 1 (x/x mod M\n+ * = 1).\n+ *\n+ * def div2(M, x):\n+ *     \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+ *     assert M & 1\n+ *     if x & 1: # If x is odd, make it even by adding M.\n+ *         x += M\n+ *     # x must be even now, so a clean division by 2 is possible.\n+ *     return x // 2\n+ *\n+ * def modinv(M, x):\n+ *     \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+ *     assert M & 1\n+ *     delta, f, g, d, e = 1, M, x, 0, 1\n+ *     while g != 0:\n+ *         # Note that while division by two for f and g is only ever done on even inputs, this is\n+ *         # not true for d and e, so we need the div2 helper function.\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+ *         elif g & 1:\n+ *             delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+ *         else:\n+ *             delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+ *         # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+ *         assert f % M == (d * x) % M\n+ *         assert g % M == (e * x) % M\n+ *     assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+ *     # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+ *     return (d * f) % M\n+ *\n+ * Also note that this approach to track d and e throughout the computation to determine the inverse\n+ * is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+ * entire computation is determined (see section 3 below) and the inverse is computed from that.\n+ * The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+ * be faster (after the optimizations explained below) for the size of numbers we care about.\n+ *\n+ *\n+ * 3. Batching multiple divsteps\n+ * -----------------------------\n+ *\n+ * Every divstep can be expressed as a matrix multiplication, applying a transition matrix (1/2*t)\n+ * to both vectors [f, g] and [d, e] (see paragraph 8.1 in the paper):\n+ *\n+ *   t = [ u,  v ]\n+ *       [ q,  r ]\n+ *\n+ *   [ out_f ] = (1/2 * t) * [ in_f ]\n+ *   [ out_g ] =             [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+ *   [ out_e ]               [ in_e ]\n+ *\n+ * where (u, v, q, r) is (0, 2, -1, 1), (2, 0, 1, 1), or (2, 0, 0, 1), depending on which branch is\n+ * taken. As above, the resulting f and g are always integers.\n+ *\n+ * Performing multiple divsteps corresponds to a multiplication with the product of all the\n+ * individual divsteps' transition matrices. As each transition matrix consists of integers\n+ * divided by 2, the product of these matrices will consist of integers divided by 2^N (see also\n+ * theorem 9.2 in the paper). These divisions are expensive when updating d and e, so we delay\n+ * them: we compute the integer coefficients of the combined transition matrix scaled by 2^N, and\n+ * do one division by 2^N as a final step:\n+ *\n+ * def divsteps_n_matrix(delta, f, g):\n+ *     \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+ *         elif g & 1:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+ *         else:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+ *     return delta, (u, v, q, r)\n+ *\n+ * As the branches in the divsteps are completely determined by the bottom N bits of f and g, this\n+ * function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+ * intermediate results and outputs fit in (N+1)-bit numbers (unsigned for f and g; signed for u, v,\n+ * q, and r) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+ * integers could set N=62 and compute the full transition matrix for 62 steps at once without any\n+ * big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+ * to update the full-size f, g, d, and e numbers once every N steps.\n+ *\n+ * We still need functions to compute:\n+ *\n+ *   [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+ *   [ out_g ]   (        [ q,  r ])   [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+ *   [ out_e ]   (        [ q,  r ])   [ in_e ]\n+ *\n+ * For f and g that's easy:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     cf, cg = u*f + v*g, q*f + r*g\n+ *     # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+ *     # bottom bits.\n+ *     assert cf % 2**N == 0\n+ *     assert cg % 2**N == 0\n+ *     return cf >> N, cg >> N\n+ *\n+ * To do the same for d and e, we need an equivalent of the div2 function for division by 2^N mod M.\n+ * This is easy if we have precomputed M^-1 mod 2^N (which always exists for odd M):\n+ *\n+ * def div2n(M, Mi, x):\n+ *     \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+ *     assert (M * Mi) % 2**N == 1\n+ *     # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+ *     #     (m * M) mod 2^N = x mod 2^N\n+ *     # <=> m mod 2^N = (x / M) mod 2^N\n+ *     # <=> m mod 2^N = (x * Mi) mod 2^N\n+ *     m = (Mi * x) % 2**N\n+ *     # Subtract that multiple from x, cancelling its bottom N bits.\n+ *     x -= m * M\n+ *     # Now a clean division by 2^N is possible.\n+ *     assert x % 2**N == 0\n+ *     return (x >> N) % M\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+ *\n+ * With all of those, we can write a version of modinv that performs N divsteps at once:\n+ *\n+ * def modinv(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     assert M & 1\n+ *     delta, f, g, d, e = 1, M, x, 0, 1\n+ *     while g != 0:\n+ *         # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+ *         # (N+1)-bit signed integer arithmetic).\n+ *         delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+ *         # Apply the transition matrix t to [f, g]:\n+ *         f, g = update_fg(f, g, t)\n+ *         # Apply the transition matrix t to [d, e]:\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return (d * f) % M\n+ *\n+ * This means that in practice we'll always perform a multiple of N divsteps. This is not a problem\n+ * because once g=0, further divsteps do not affect f, g, d, or e anymore (only delta keeps\n+ * increasing). For variable time code such excess iterations will be mostly optimized away in\n+ * section 6.\n+ *\n+ *\n+ * 4. Avoiding modulus operations\n+ * ------------------------------\n+ *\n+ * So far, there are two places where we compute a remainder of big numbers modulo M: at the end of\n+ * div2n in every update_de, and at the very end of modinv after potentially negating d due to the\n+ * sign of f. These are relatively expensive operations when done generically.\n+ *\n+ * To deal with the modulus operation in div2n, we simply stop requiring d and e to be in range\n+ * [0,M) all the time. Let's start by inlining div2n into update_de, and dropping the modulus\n+ * operation at the end:\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     md = -((Mi * cd) % 2**N)\n+ *     me = -((Mi * ce) % 2**N)\n+ *     cd += md * M\n+ *     ce += me * M\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * Let's look at bounds on the ranges of these numbers. It can be shown that |u|+|v| and |q|+|r|\n+ * never exceed 2^N (see paragraph 8.3 in the paper), and thus a multiplication with t will have\n+ * outputs whose absolute values are at most 2^N times the maximum absolute input value. In case the\n+ * inputs d and e are in (-M,M), which is certainly true for the initial values d=0 and e=1 assuming\n+ * M > 1, the multiplication results in numbers in range (-2^N*M,2^N*M). Subtracting up to 2^N-1\n+ * times M to cancel out N bits brings that up to slightly less than (-2^(N+1)*M,2^N*M), and\n+ * dividing by 2^N at the end takes it to (-2*M,M). Another application of update_de would take that\n+ * to (-3*M,2*M), and so forth. This progressive expansion of the variables' ranges can be\n+ * counteracted by incrementing d and e by M whenever they're negative:\n+ *\n+ *     ...\n+ *     if d < 0:\n+ *         d += M\n+ *     if e < 0:\n+ *         e += M\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * With inputs in (-2*M,M), they will first be shifted into range (-M,M), which means that the\n+ * output will again be in (-2*M,M), and this remains the case regardless of how many update_de\n+ * invocations there are. *\n+ *\n+ * Now note that increasing d by M is equal to incrementing cd by u*M and ce by q*M. Similarly,\n+ * increasing e by M is equal to incrementing cd by v*M and ce by r*M. So we could instead write:\n+ *\n+ *     ...\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     if d < 0:\n+ *         cd, ce = cd + u*M, ce + q*M\n+ *     if e < 0:\n+ *         cd, ce = cd + v*M, ce + r*M\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Now note that we have two steps of corrections to cd and ce that add multiples of M: this\n+ * increment, and the decrement that cancels out bottom bits. The second one depends on the first\n+ * one, but they can still be efficiently combined by only computing the bottom bits of cd and ce\n+ * at first, and using that to compute the final md, me values:\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     md, me = 0, 0\n+ *     # Compute what multiples of M to add to cd and ce.\n+ *     if d < 0:\n+ *         md, me = md + u, me + q\n+ *     if e < 0:\n+ *         md, me = md + v, me + r\n+ *     # Compute bottom N bits of t*[d,e] + M*[md,me].\n+ *     cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N\n+ *     # Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.\n+ *     md -= (Mi * cd) % 2**N\n+ *     me -= (Mi * ce) % 2**N\n+ *     # Do the full computation.\n+ *     cd, ce = u*d + v*e + md*M, q*d + r*e + me*M\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * One last optimization: we can avoid the md*M and me*M multiplications in the bottom bits of cd\n+ * and ce by moving them to the md and me correction:\n+ *\n+ *     ...\n+ *     # Compute bottom N bits of t*[d,e].\n+ *     cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+ *     # Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.\n+ *     # Note that this is not the same as {md = (Mi * cd) % 2**N} etc. That would also result in N\n+ *     # zero bottom bits, but isn't guaranteed to be a reduction of [0,2^N) compared to the\n+ *     # previous md and me values, and thus would violate our bounds analysis.\n+ *     md -= (Mi*cd + md) % 2**N\n+ *     me -= (Mi*ce + me) % 2**N\n+ *     ...\n+ *\n+ * The resulting function takes as input d and e in range (-2*M,M) and outputs values in the same\n+ * range. That also means that the d value at the end of modinv will be in that range, while we want\n+ * a result in [0,M). To do that, we need a normalization function. It's easy to integrate the\n+ * conditional negation of d (based on the sign of f) into it as well:\n+ *\n+ * def normalize(sign, v, M):\n+ *     \"\"\"Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).\"\"\"\n+ *     assert sign == 1 or sign == -1\n+ *     # v in (-2*M,M)\n+ *     if v < 0:\n+ *         v += M\n+ *     # v in (-M,M)\n+ *     if sign == -1:\n+ *         v = -v\n+ *     # v in (-M,M)\n+ *     if v < 0:\n+ *         v += M\n+ *     # v in [0,M)\n+ *     return v\n+ *\n+ * And calling it in modinv is simply:\n+ *\n+ *    ...\n+ *    return normalize(f, d, M)\n+ *\n+ *\n+ * 5. Constant-time operation\n+ * --------------------------\n+ *\n+ * The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+ * depends on the input data so far?\n+ *\n+ * - The number of iterations of the while g != 0 loop in modinv.\n+ * - The branches inside divsteps_n_matrix.\n+ * - The sign checks in update_de\n+ * - The sign checks in normalize\n+ *\n+ * To make the while loop in modinv constant time it can be replaced with a constant number of\n+ * iterations. The paper proves (Theorem 11.2) that 741 divsteps are sufficient for any 256-bit\n+ * inputs, and https://github.com/sipa/safegcd-bounds shows that the slightly better bound 724 is\n+ * sufficient even. Given that every loop iteration performs N divsteps, it will run a total of\n+ * ceil(724/N) times.\n+ *\n+ * Dealing with the branches in divsteps_n_matrix requires replacing them with constant-time\n+ * bitwise operations (and hoping the C compiler isn't smart enough to turn them back into\n+ * branches; see valgrind_ctime_test.c for automated tests that this isn't the case). To do so,\n+ * observe that a divstep can be written instead as:\n+ *\n+ *     if g & 1:\n+ *         g += -f if delta > 0 else f    # set g to (input) g-f or g+f\n+ *         if delta > 0:\n+ *             delta = -delta\n+ *             f += g                     # set f to (input) g (note that g was set to g-f before)\n+ *     delta += 1\n+ *     g >>= 1\n+ *\n+ * To convert this into bitwise operations, we rely on this trick to implement conditional negation:\n+ * For every v, -v == ~v + 1, so since bitflipping is equal to xoring with -1, we get\n+ * -v == (v xor -1) + 1. Thus, ((v xor mask) - mask) is {v if mask=0; -v if mask=-1}. With that we\n+ * just need a way to quickly compute this mask from delta and g's parity. It turns out this is\n+ * slightly easier if instead of delta we track the equivalent eta = -delta. In that case a mask for\n+ * eta < 0 (= delta > 0) is just (eta >> 63) for int64_t. With that, we can write a constant-time\n+ * divstep as:\n+ *\n+ *     # Compute a mask c1 for eta < 0, and compute the conditional negation x of f:\n+ *     c1 = eta >> 63\n+ *     x = (f ^ c1) - c1\n+ *     # Compute a mask c2 for odd g, and conditionally add x to g:\n+ *     c2 = -(g & 1)\n+ *     g += x & c2\n+ *     # Compute a mask c for (eta < 0) and odd (input) g, and use it to conditionally negate eta,\n+ *     # and add g to f:\n+ *     c = c1 & c2\n+ *     eta = (eta ^ c) - c\n+ *     f += g & c\n+ *     # Unconditional operations:\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Note that the semantics of Python ints conveniently matches C here (assuming two's complement\n+ * behavior for signed integers; see assumptions.h), for the purpose of these techniques: right\n+ * shifting always rounds down, so (eta >> 63) is -1 if eta is negative; and bitwise operations with\n+ * -1 treat the number as equivalent to infinitely many 1 bits).\n+ *\n+ * By replacing the loop in divsteps_n_matrix with a variant of the divstep code above (extended to\n+ * also apply all f operations to u, v and all g operations to q, r), a constant-time version of\n+ * divsteps_n_matrix is obtained.\n+ *\n+ * These bit fiddling tricks can also be used to make the conditional negations and additions in\n+ * update_de and normalize constant-time.\n+ *\n+ *\n+ * 6. Variable-time optimizations\n+ * ------------------------------\n+ *\n+ * If we don't want constant time code, the changes from the previous sections are unnecessary, and\n+ * we may instead see if it's possible to go in the other direction - making things faster by\n+ * introducing more variable-time steps.\n+ *\n+ * Here we start with yet another way of writing the (loop of) divstep operations, based on\n+ * paragraph 8.2 from the paper:\n+ *\n+ * for _ in range(N):\n+ *     if g & 1 and eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     if g & 1:\n+ *         g += f\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Observe that as long as g is even, all the loop does is shift it down and decrease eta. If we can\n+ * count the bottom 0 bits in g efficiently (as can be done on most platforms), we can do multiple\n+ * iterations at once:\n+ *\n+ * i = N # divsteps left to do\n+ * while True:\n+ *     # Get rid of all bottom zeros at once\n+ *     zeros = min(i, count_trailing_zeros(g))\n+ *     eta, i = eta - zeros, i - zeros\n+ *     g >>= zeros\n+ *     if i == 0:\n+ *         break\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     g += f\n+ *\n+ * Now observe that eta always >= 0 on the last line. If eta is even higher, the loop will not run\n+ * the {eta, f, g = -eta, g, f} statement again until eta goes negative. All the last line does is\n+ * g += f with various shifted version of g, in order in order to make g's bottom bit zero, until we\n+ * run out of iterations (i reaches 0) or eta goes negative.\n+ *\n+ * Nothing prevents us from instead cancelling out multiple bits of g at once by adding a multiple\n+ * of f to it, as long as it's not more than i steps (as we'd finish the loop before doing more) or\n+ * more than eta+1 steps (as we'd run {eta, f, g = -eta, g, f} at that point). Here is a way to do\n+ * up to 4 at a time:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * i = N\n+ * while True:\n+ *     ...\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, f\n+ *     # Compute limit on number of bits to cancel\n+ *     limit = min(min(eta + 1, i), 4)\n+ *     # Compute w = -g/f mod 2**limit, using the table value for -1/f mod 2**4. Note that f is\n+ *     # always odd, so its inverse modulo a power of two always exists.\n+ *     w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *     # As w = -g/f mod (2**limit), g+w*f mod 2**limit = 0 mod 2**limit.\n+ *     g += w * f\n+ *     assert g % (2**limit) == 0\n+ *     # The next iteration will now shift out all (limit) bottom zero bits from g.\n+ *\n+ * By using a bigger table more bits can be cancelled at once. The table can also be implemented\n+ * as a formula:\n+ *  - Instead of a 3-bit table:\n+ *    * (-f) or (f ^ 6)\n+ *  - Instead of a 4-bit table:\n+ *    * (1 - f * (f + 1))\n+ *    * (-(f + (((f + 1) & 4) << 1)))\n+ *  - For larger tables the following technique can be used: if w=-f^-1 mod 2^i, then w*(w*f+2) is\n+ *    -f^-1 mod 2^(2*i). This allows extending the previous formulas (or tables). In particular we\n+ *    have this 6-bit function (based on the 3-bit function above):\n+ *    * (f * (f * f - 2))\n+ *\n+ * This loop, again extended to also handle u, v, q, and r alongside f and g, placed in\n+ * divsteps_n_matrix, gives a significantly faster, but non-constant time version. It is usable when\n+ * not operating on secret data.\n+ *\n+ * 7. Final Python version\n+ * -----------------------\n+ *\n+ * All together we need the following functions:\n+ *\n+ * - A way to compute the transition matrix in constant time, using the divsteps_n_matrix function\n+ *   from section 2, but with its loop replaced by a variant of the constant-time divstep from\n+ *   section 5, extended to handle u, v, q, r:\n+ *\n+ * def divsteps_n_matrix(eta, f, g):\n+ *     \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         c1 = eta >> 63\n+ *         # Compute x, y, z as conditionally-negated versions of f, u, v.\n+ *         x, y, z = (f ^ c1) - c1, (u ^ c1) - c1, (v ^ c1) - c1\n+ *         c2 = -(g & 1)\n+ *         # Conditionally add x, y, z to g, q, r.\n+ *         g, q, r = g + (x & c2), q + (y & c2), r + (z & c2)\n+ *         c1 &= c2                     # reusing c1 here for further conditionals\n+ *         eta = (eta ^ c1) - (c1 + 1)  # inlining the unconditional eta decrement here\n+ *         # Conditionally add g, q, r to f, u, v.\n+ *         f, u, v = f + (g & c1), u + (q & c1), v + (r & c1)\n+ *         # When shifting g down, don't shift q, r, as we construct a transition matrix multiplied\n+ *         # by 2^N. Instead, shift f's coefficients u and v up.\n+ *         g, u, v = g >> 1, u << 1, v << 1\n+ *     return eta, (u, v, q, r)\n+ *\n+ * - The functions to update f and g, and d and e, from section 2 and section 4, with the constant-time\n+ *   changes to update_de from section 5:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     cf, cg = u*f + v*g, q*f + r*g\n+ *     return cf >> N, cg >> N\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     d_sign, e_sign = d >> 257, e >> 257\n+ *     md, me = (u & d_sign) + (v & e_sign), (q & d_sign) + (r & e_sign)\n+ *     cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+ *     md -= (Mi*cd + md) % 2**N\n+ *     me -= (Mi*ce + me) % 2**N\n+ *     cd, ce = u*d + v*e + Mi*md, q*d + r*e + Mi*me\n+ *     return cd >> N, ce >> N\n+ *\n+ * - The normalize function from section 4, made constant time as well:\n+ *\n+ * def normalize(sign, v, M):\n+ *     \"\"\"Compute sign*v mod M, where v in (-2*M,M); output in [0,M).\"\"\"\n+ *     v_sign = v >> 257\n+ *     # Conditionally add M to v.\n+ *     v += M & v_sign\n+ *     c = (sign - 1) >> 1\n+ *     # Conditionally negate v.\n+ *     v = (v ^ c) - c\n+ *     v_sign = v >> 257\n+ *     # Conditionally add M to v again.\n+ *     v += M & v_sign\n+ *     return v\n+ *\n+ * - And finally the modinv function too, adapted to use eta instead of delta, and using the fixed\n+ *   iteration count from section 5:\n+ *\n+ * def modinv(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, M, x, 0, 1\n+ *     for _ in range((724 + N - 1) // N):\n+ *         eta, t = divsteps_n_matrix(-eta, f % 2**N, g % 2**N)\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return normalize(f, d, M)\n+ *\n+ * - To get a variable time version, replace the divsteps_n_matrix function with one that uses the\n+ *   divsteps loop from section 5, and a modinv version that calls it without the fixed iteration\n+ *   count:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * def divsteps_n_matrix_var(eta, f, g):\n+ *     \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1\n+ *     i = N\n+ *     while True:\n+ *         zeros = min(i, count_trailing_zeros(g))\n+ *         eta, i = eta - zeros, i - zeros\n+ *         g, u, v = g >> zeros, u << zeros, v << zeros\n+ *         if i == 0:\n+ *             break\n+ *         if eta < 0:\n+ *             eta, f, u, v, g, q, r = -eta, g, q, r, -f, -u, -v\n+ *         limit = min(min(eta + 1, i), 4)\n+ *         w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *         g, q, r = g + w*f, q + w*u, r + w*v\n+ *     return eta, (u, v, q, r)\n+ *\n+ * def modinv_var(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi = 1/M mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, M, x, 0, 1\n+ *     while g != 0:\n+ *         eta, t = divsteps_n_matrix_var(eta, f % 2**N, g % 2**N)\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return normalize(f, d, Mi)\n+ *\n+ *\n+ * 8. C implementation\n+ * -------------------\n+ *\n+ * What follows is a C implementation of effectively the Python code from section 7, with N=62, and\n+ * the following changes:\n+ *\n+ * - Representing large integers using 5 62-bit singed limbs that callers need to convert their\n+ *   value from/to. Using 62-bit limbs means shifts by 62 bits are very efficient, and the extra\n+ *   space allows faster operations by delaying carries/borrows in some cases.\n+ *\n+ * - Several modulo operations in the Python code are modulo a power of two. These can be replaced\n+ *   with a bitwise AND with ((1 << bits) - 1).\n+ *\n+ * - Similarly, if an entire expression involving multiplications and additions is computed modulo\n+ *   a power of two, that means only the bottom bits of the inputs and intermediary results is\n+ *   needed.\n+ */\n+\n+#ifdef VERIFY\n+/* Helper function to compute the absolute value of an int64_t.\n+ * (we don't use abs/labs/llabs as it depends on the int sizes). */\n+static int64_t secp256k1_modinv64_abs(int64_t v) {\n+    VERIFY_CHECK(v > INT64_MIN);\n+    if (v < 0) return -v;\n+    return v;\n+}\n+\n+static const secp256k1_modinv64_signed62 SECP256K1_SIGNED62_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^62). */\n+static void secp256k1_modinv64_mul_62(secp256k1_modinv64_signed62 *r, const secp256k1_modinv64_signed62 *a, int alen, int64_t factor) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int128_t c = 0;\n+    int i;\n+    for (i = 0; i < 4; ++i) {\n+        if (i < alen) {\n+            c += (factor == 1) ? (int128_t)a->v[i] : (int128_t)a->v[i] * factor;\n+        }\n+        r->v[i] = (int64_t)c & M62; c >>= 62;\n+    }\n+    if (4 < alen) {\n+        c += (factor == 1) ? (int128_t)a->v[4] : (int128_t)a->v[4] * factor;\n+    }\n+    VERIFY_CHECK(c == (int64_t)c);\n+    r->v[4] = (int64_t)c;\n+}\n+\n+/* Compare af with b*bf. */\n+static int secp256k1_modinv64_mul_cmp_62(const secp256k1_modinv64_signed62 *a, int alen, const secp256k1_modinv64_signed62 *b, int64_t factor) {\n+    int i;\n+    secp256k1_modinv64_signed62 am, bm;\n+    secp256k1_modinv64_mul_62(&am, a, alen, 1);\n+    secp256k1_modinv64_mul_62(&bm, b, 5, factor);\n+    for (i = 4; i >= 0; --i) {\n+        if (i != 4) {\n+            VERIFY_CHECK(am.v[i] >> 62 == 0);\n+            VERIFY_CHECK(bm.v[i] >> 62 == 0);\n+        }\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }\n+    return 0;\n+}\n+#endif\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^62,2^62). */\n+    int i;\n+    for (i = 0; i < 5; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M62);\n+        VERIFY_CHECK(r->v[i] <= M62);\n+    }\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, -2) > 0); /* r > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < P */\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled\n+             * out (as we'd be done before that point), and no more than eta+1 can be done as its\n+             * will flip again once that happens. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            /* m is a mask for the bottom min(limit, 6) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 63U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)\n+             * bits. */\n+            w = (f * g * (f * f - 2)) & m;",
      "path": "src/modinv64_impl.h",
      "position": 262,
      "original_position": 859,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "1e30f79c3807a9c63c6c6f6ae07e7c9445b0f37c",
      "in_reply_to_id": 549203982,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Looking at compiler output in GCC 10.2.0 -O2 x86_64, casting the multiplication result to uint8_t shuffles a few instructions around, but the net effect is replacing a 64x64->64 multiplication with a 32x32->32 multiplication. Presumably that's faster. I haven't benchmarked.",
      "created_at": "2020-12-28T06:43:47Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r549233570",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/549233570"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 262,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/549471488",
      "pull_request_review_id": 559285684,
      "id": 549471488,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ3MTQ4OA==",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman, Pieter Wuille                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * See https://gcd.cr.yp.to/papers.html#safegcd for the paper. The references below are for the Date:\n+ * 2019.04.13 version.\n+ *\n+ * Below is an explanation of the implementation, building up the algorithm in Python3 step by step.\n+ *\n+ *\n+ * 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+ * -------------------------------------------------------------\n+ *\n+ * The algorithm from the paper, at a very high level, is this:\n+ *\n+ * def gcd(f, g):\n+ *     \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+ *     assert f & 1  # require f to be odd\n+ *     delta = 1     # additional state variable\n+ *     while g != 0:\n+ *         assert f & 1  # f will be odd in every iteration\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g = 1 - delta, g, (g - f) // 2\n+ *         elif g & 1:\n+ *             delta, f, g = 1 + delta, f, (g + f) // 2\n+ *         else:\n+ *             delta, f, g = 1 + delta, f, (g    ) // 2\n+ *     return abs(f)\n+ *\n+ * It computes the greatest common divisor of an odd integer f and any integer g. Its inner loop\n+ * keeps rewriting the variables f and g alongside a state variable delta that starts at 1, until\n+ * g=0 is reached. At that point, |f| gives the GCD. Each of the transitions in the loop is called a\n+ * \"division step\" (referred to as divstep in what follows).\n+ *\n+ * For example, gcd(21, 14) would be computed as:\n+ * - Start with delta=1 f=21 g=14\n+ * - Take the third branch: delta=2 f=21 g=7\n+ * - Take the first branch: delta=-1 f=7 g=-7\n+ * - Take the second branch: delta=0 f=7 g=0\n+ * - The answer |f| = 7.\n+ *\n+ * Why it works:\n+ * - Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+ *   - (a) If g is odd, replace (f,g) with (g,g-f) or (f,g+f), resulting in an even g.\n+ *   - (b) Replace (f,g) with (f,g//2) (where g is guaranteed to be even).\n+ * - Neither of those two operations change the GCD:\n+ *   - For (a), assume gcd(f,g)=c, then it must be the case that f=a*c and g=b*c for some integers a\n+ *     and b. As (g,g-f)=(b*c,(b-a)*c) and (f,f+g)=(a*c,(a+b)*c), the result clearly still has\n+ *     common factor c. Reasoning in the other direction shows that no common factor can be added by\n+ *     doing so either.\n+ *   - For (b), we know that f is odd, so gcd(f,g) clearly has no common factor 2, and we can remove\n+ *     it from g.\n+ * - The algorithm will eventually converge to g=0. This is proven in the paper (see theorem G.3).\n+ * - It follows that eventually we find a final value f' for which gcd(f,g) = gcd(f',0). As the\n+ *   gcd of f' and 0 is |f'| by definition, that is our answer.\n+ *\n+ * Compared to more traditional GCD algorithms, this one has the property of only ever looking at\n+ * the low-order bits of the variables to decide the next steps, and being easy to make\n+ * constant-time (in more low-level languages than Python). The delta parameter is necessary to\n+ * guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+ * at high order bits.\n+ *\n+ * Properties that will become important later:\n+ * - Performing more divsteps than needed is not a problem, as f does not change anymore after g=0.\n+ * - Only even numbers are divided by 2. This means that when reasoning about it algebraically we\n+ *   do not need to worry about rounding.\n+ * - At every point during the algorithm's execution the next N steps only depend on the bottom N\n+ *   bits of f and g, and on delta.\n+ *\n+ *\n+ * 2. From GCDs to modular inverses\n+ * --------------------------------\n+ *\n+ * We want an algorithm to compute the inverse a of x modulo M, i.e. the number a such that a*x=1\n+ * mod M. This inverse only exists if the GCD of x and M is 1, but that is always the case if M is\n+ * prime and 0 < x < M. In what follows, assume that the modular inverse exists. To find that\n+ * inverse, it turns out this can be computed as a side effect of computing the GCD by keeping track\n+ * of how the internal variables can be written as linear combinations of the inputs at every step.\n+ * Since the GCD is 1, such an algorithm will compute numbers a and b such that a*x + b*M = 1.\n+ * Taking that expression mod M gives a*x mod M = 1, and we see that a is the modular inverse of x\n+ * mod M.\n+ *\n+ * A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+ * algorithm shown above, if the modulus M is odd. To do so, compute gcd(f=M,g=x), while keeping\n+ * track of extra variables d and e, for which at every step d = f/x (mod M) and e = g/x (mod M).\n+ * f/x here means the number which multiplied with x gives f mod M. As f and g are initialized to M\n+ * and x respectively, d and e just start off being 0 (M/x mod M = 0/x mod M = 0) and 1 (x/x mod M\n+ * = 1).\n+ *\n+ * def div2(M, x):\n+ *     \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+ *     assert M & 1\n+ *     if x & 1: # If x is odd, make it even by adding M.\n+ *         x += M\n+ *     # x must be even now, so a clean division by 2 is possible.\n+ *     return x // 2\n+ *\n+ * def modinv(M, x):\n+ *     \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+ *     assert M & 1\n+ *     delta, f, g, d, e = 1, M, x, 0, 1\n+ *     while g != 0:\n+ *         # Note that while division by two for f and g is only ever done on even inputs, this is\n+ *         # not true for d and e, so we need the div2 helper function.\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+ *         elif g & 1:\n+ *             delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+ *         else:\n+ *             delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+ *         # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+ *         assert f % M == (d * x) % M\n+ *         assert g % M == (e * x) % M\n+ *     assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+ *     # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+ *     return (d * f) % M\n+ *\n+ * Also note that this approach to track d and e throughout the computation to determine the inverse\n+ * is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+ * entire computation is determined (see section 3 below) and the inverse is computed from that.\n+ * The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+ * be faster (after the optimizations explained below) for the size of numbers we care about.\n+ *\n+ *\n+ * 3. Batching multiple divsteps\n+ * -----------------------------\n+ *\n+ * Every divstep can be expressed as a matrix multiplication, applying a transition matrix (1/2*t)\n+ * to both vectors [f, g] and [d, e] (see paragraph 8.1 in the paper):\n+ *\n+ *   t = [ u,  v ]\n+ *       [ q,  r ]\n+ *\n+ *   [ out_f ] = (1/2 * t) * [ in_f ]\n+ *   [ out_g ] =             [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+ *   [ out_e ]               [ in_e ]\n+ *\n+ * where (u, v, q, r) is (0, 2, -1, 1), (2, 0, 1, 1), or (2, 0, 0, 1), depending on which branch is\n+ * taken. As above, the resulting f and g are always integers.\n+ *\n+ * Performing multiple divsteps corresponds to a multiplication with the product of all the\n+ * individual divsteps' transition matrices. As each transition matrix consists of integers\n+ * divided by 2, the product of these matrices will consist of integers divided by 2^N (see also\n+ * theorem 9.2 in the paper). These divisions are expensive when updating d and e, so we delay\n+ * them: we compute the integer coefficients of the combined transition matrix scaled by 2^N, and\n+ * do one division by 2^N as a final step:\n+ *\n+ * def divsteps_n_matrix(delta, f, g):\n+ *     \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+ *         elif g & 1:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+ *         else:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+ *     return delta, (u, v, q, r)\n+ *\n+ * As the branches in the divsteps are completely determined by the bottom N bits of f and g, this\n+ * function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+ * intermediate results and outputs fit in (N+1)-bit numbers (unsigned for f and g; signed for u, v,\n+ * q, and r) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+ * integers could set N=62 and compute the full transition matrix for 62 steps at once without any\n+ * big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+ * to update the full-size f, g, d, and e numbers once every N steps.\n+ *\n+ * We still need functions to compute:\n+ *\n+ *   [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+ *   [ out_g ]   (        [ q,  r ])   [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+ *   [ out_e ]   (        [ q,  r ])   [ in_e ]\n+ *\n+ * For f and g that's easy:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     cf, cg = u*f + v*g, q*f + r*g\n+ *     # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+ *     # bottom bits.\n+ *     assert cf % 2**N == 0\n+ *     assert cg % 2**N == 0\n+ *     return cf >> N, cg >> N\n+ *\n+ * To do the same for d and e, we need an equivalent of the div2 function for division by 2^N mod M.\n+ * This is easy if we have precomputed M^-1 mod 2^N (which always exists for odd M):\n+ *\n+ * def div2n(M, Mi, x):\n+ *     \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+ *     assert (M * Mi) % 2**N == 1\n+ *     # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+ *     #     (m * M) mod 2^N = x mod 2^N\n+ *     # <=> m mod 2^N = (x / M) mod 2^N\n+ *     # <=> m mod 2^N = (x * Mi) mod 2^N\n+ *     m = (Mi * x) % 2**N\n+ *     # Subtract that multiple from x, cancelling its bottom N bits.\n+ *     x -= m * M\n+ *     # Now a clean division by 2^N is possible.\n+ *     assert x % 2**N == 0\n+ *     return (x >> N) % M\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+ *\n+ * With all of those, we can write a version of modinv that performs N divsteps at once:\n+ *\n+ * def modinv(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     assert M & 1\n+ *     delta, f, g, d, e = 1, M, x, 0, 1\n+ *     while g != 0:\n+ *         # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+ *         # (N+1)-bit signed integer arithmetic).\n+ *         delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+ *         # Apply the transition matrix t to [f, g]:\n+ *         f, g = update_fg(f, g, t)\n+ *         # Apply the transition matrix t to [d, e]:\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return (d * f) % M\n+ *\n+ * This means that in practice we'll always perform a multiple of N divsteps. This is not a problem\n+ * because once g=0, further divsteps do not affect f, g, d, or e anymore (only delta keeps\n+ * increasing). For variable time code such excess iterations will be mostly optimized away in\n+ * section 6.\n+ *\n+ *\n+ * 4. Avoiding modulus operations\n+ * ------------------------------\n+ *\n+ * So far, there are two places where we compute a remainder of big numbers modulo M: at the end of\n+ * div2n in every update_de, and at the very end of modinv after potentially negating d due to the\n+ * sign of f. These are relatively expensive operations when done generically.\n+ *\n+ * To deal with the modulus operation in div2n, we simply stop requiring d and e to be in range\n+ * [0,M) all the time. Let's start by inlining div2n into update_de, and dropping the modulus\n+ * operation at the end:\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     md = -((Mi * cd) % 2**N)\n+ *     me = -((Mi * ce) % 2**N)\n+ *     cd += md * M\n+ *     ce += me * M\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * Let's look at bounds on the ranges of these numbers. It can be shown that |u|+|v| and |q|+|r|\n+ * never exceed 2^N (see paragraph 8.3 in the paper), and thus a multiplication with t will have\n+ * outputs whose absolute values are at most 2^N times the maximum absolute input value. In case the\n+ * inputs d and e are in (-M,M), which is certainly true for the initial values d=0 and e=1 assuming\n+ * M > 1, the multiplication results in numbers in range (-2^N*M,2^N*M). Subtracting up to 2^N-1\n+ * times M to cancel out N bits brings that up to slightly less than (-2^(N+1)*M,2^N*M), and\n+ * dividing by 2^N at the end takes it to (-2*M,M). Another application of update_de would take that\n+ * to (-3*M,2*M), and so forth. This progressive expansion of the variables' ranges can be\n+ * counteracted by incrementing d and e by M whenever they're negative:\n+ *\n+ *     ...\n+ *     if d < 0:\n+ *         d += M\n+ *     if e < 0:\n+ *         e += M\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * With inputs in (-2*M,M), they will first be shifted into range (-M,M), which means that the\n+ * output will again be in (-2*M,M), and this remains the case regardless of how many update_de\n+ * invocations there are. *\n+ *\n+ * Now note that increasing d by M is equal to incrementing cd by u*M and ce by q*M. Similarly,\n+ * increasing e by M is equal to incrementing cd by v*M and ce by r*M. So we could instead write:\n+ *\n+ *     ...\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     if d < 0:\n+ *         cd, ce = cd + u*M, ce + q*M\n+ *     if e < 0:\n+ *         cd, ce = cd + v*M, ce + r*M\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Now note that we have two steps of corrections to cd and ce that add multiples of M: this\n+ * increment, and the decrement that cancels out bottom bits. The second one depends on the first\n+ * one, but they can still be efficiently combined by only computing the bottom bits of cd and ce\n+ * at first, and using that to compute the final md, me values:\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     md, me = 0, 0\n+ *     # Compute what multiples of M to add to cd and ce.\n+ *     if d < 0:\n+ *         md, me = md + u, me + q\n+ *     if e < 0:\n+ *         md, me = md + v, me + r\n+ *     # Compute bottom N bits of t*[d,e] + M*[md,me].\n+ *     cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N\n+ *     # Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.\n+ *     md -= (Mi * cd) % 2**N\n+ *     me -= (Mi * ce) % 2**N\n+ *     # Do the full computation.\n+ *     cd, ce = u*d + v*e + md*M, q*d + r*e + me*M\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * One last optimization: we can avoid the md*M and me*M multiplications in the bottom bits of cd\n+ * and ce by moving them to the md and me correction:\n+ *\n+ *     ...\n+ *     # Compute bottom N bits of t*[d,e].\n+ *     cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+ *     # Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.\n+ *     # Note that this is not the same as {md = (Mi * cd) % 2**N} etc. That would also result in N\n+ *     # zero bottom bits, but isn't guaranteed to be a reduction of [0,2^N) compared to the\n+ *     # previous md and me values, and thus would violate our bounds analysis.\n+ *     md -= (Mi*cd + md) % 2**N\n+ *     me -= (Mi*ce + me) % 2**N\n+ *     ...\n+ *\n+ * The resulting function takes as input d and e in range (-2*M,M) and outputs values in the same\n+ * range. That also means that the d value at the end of modinv will be in that range, while we want\n+ * a result in [0,M). To do that, we need a normalization function. It's easy to integrate the\n+ * conditional negation of d (based on the sign of f) into it as well:\n+ *\n+ * def normalize(sign, v, M):\n+ *     \"\"\"Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).\"\"\"\n+ *     assert sign == 1 or sign == -1\n+ *     # v in (-2*M,M)\n+ *     if v < 0:\n+ *         v += M\n+ *     # v in (-M,M)\n+ *     if sign == -1:\n+ *         v = -v\n+ *     # v in (-M,M)\n+ *     if v < 0:\n+ *         v += M\n+ *     # v in [0,M)\n+ *     return v\n+ *\n+ * And calling it in modinv is simply:\n+ *\n+ *    ...\n+ *    return normalize(f, d, M)\n+ *\n+ *\n+ * 5. Constant-time operation\n+ * --------------------------\n+ *\n+ * The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+ * depends on the input data so far?\n+ *\n+ * - The number of iterations of the while g != 0 loop in modinv.\n+ * - The branches inside divsteps_n_matrix.\n+ * - The sign checks in update_de\n+ * - The sign checks in normalize\n+ *\n+ * To make the while loop in modinv constant time it can be replaced with a constant number of\n+ * iterations. The paper proves (Theorem 11.2) that 741 divsteps are sufficient for any 256-bit\n+ * inputs, and https://github.com/sipa/safegcd-bounds shows that the slightly better bound 724 is\n+ * sufficient even. Given that every loop iteration performs N divsteps, it will run a total of\n+ * ceil(724/N) times.\n+ *\n+ * Dealing with the branches in divsteps_n_matrix requires replacing them with constant-time\n+ * bitwise operations (and hoping the C compiler isn't smart enough to turn them back into\n+ * branches; see valgrind_ctime_test.c for automated tests that this isn't the case). To do so,\n+ * observe that a divstep can be written instead as:\n+ *\n+ *     if g & 1:\n+ *         g += -f if delta > 0 else f    # set g to (input) g-f or g+f\n+ *         if delta > 0:\n+ *             delta = -delta\n+ *             f += g                     # set f to (input) g (note that g was set to g-f before)\n+ *     delta += 1\n+ *     g >>= 1\n+ *\n+ * To convert this into bitwise operations, we rely on this trick to implement conditional negation:\n+ * For every v, -v == ~v + 1, so since bitflipping is equal to xoring with -1, we get\n+ * -v == (v xor -1) + 1. Thus, ((v xor mask) - mask) is {v if mask=0; -v if mask=-1}. With that we\n+ * just need a way to quickly compute this mask from delta and g's parity. It turns out this is\n+ * slightly easier if instead of delta we track the equivalent eta = -delta. In that case a mask for\n+ * eta < 0 (= delta > 0) is just (eta >> 63) for int64_t. With that, we can write a constant-time\n+ * divstep as:\n+ *\n+ *     # Compute a mask c1 for eta < 0, and compute the conditional negation x of f:\n+ *     c1 = eta >> 63\n+ *     x = (f ^ c1) - c1\n+ *     # Compute a mask c2 for odd g, and conditionally add x to g:\n+ *     c2 = -(g & 1)\n+ *     g += x & c2\n+ *     # Compute a mask c for (eta < 0) and odd (input) g, and use it to conditionally negate eta,\n+ *     # and add g to f:\n+ *     c = c1 & c2\n+ *     eta = (eta ^ c) - c\n+ *     f += g & c\n+ *     # Unconditional operations:\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Note that the semantics of Python ints conveniently matches C here (assuming two's complement\n+ * behavior for signed integers; see assumptions.h), for the purpose of these techniques: right\n+ * shifting always rounds down, so (eta >> 63) is -1 if eta is negative; and bitwise operations with\n+ * -1 treat the number as equivalent to infinitely many 1 bits).\n+ *\n+ * By replacing the loop in divsteps_n_matrix with a variant of the divstep code above (extended to\n+ * also apply all f operations to u, v and all g operations to q, r), a constant-time version of\n+ * divsteps_n_matrix is obtained.\n+ *\n+ * These bit fiddling tricks can also be used to make the conditional negations and additions in\n+ * update_de and normalize constant-time.\n+ *\n+ *\n+ * 6. Variable-time optimizations\n+ * ------------------------------\n+ *\n+ * If we don't want constant time code, the changes from the previous sections are unnecessary, and\n+ * we may instead see if it's possible to go in the other direction - making things faster by\n+ * introducing more variable-time steps.\n+ *\n+ * Here we start with yet another way of writing the (loop of) divstep operations, based on\n+ * paragraph 8.2 from the paper:\n+ *\n+ * for _ in range(N):\n+ *     if g & 1 and eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     if g & 1:\n+ *         g += f\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Observe that as long as g is even, all the loop does is shift it down and decrease eta. If we can\n+ * count the bottom 0 bits in g efficiently (as can be done on most platforms), we can do multiple\n+ * iterations at once:\n+ *\n+ * i = N # divsteps left to do\n+ * while True:\n+ *     # Get rid of all bottom zeros at once\n+ *     zeros = min(i, count_trailing_zeros(g))\n+ *     eta, i = eta - zeros, i - zeros\n+ *     g >>= zeros\n+ *     if i == 0:\n+ *         break\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     g += f\n+ *\n+ * Now observe that eta always >= 0 on the last line. If eta is even higher, the loop will not run\n+ * the {eta, f, g = -eta, g, f} statement again until eta goes negative. All the last line does is\n+ * g += f with various shifted version of g, in order in order to make g's bottom bit zero, until we\n+ * run out of iterations (i reaches 0) or eta goes negative.\n+ *\n+ * Nothing prevents us from instead cancelling out multiple bits of g at once by adding a multiple\n+ * of f to it, as long as it's not more than i steps (as we'd finish the loop before doing more) or\n+ * more than eta+1 steps (as we'd run {eta, f, g = -eta, g, f} at that point). Here is a way to do\n+ * up to 4 at a time:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * i = N\n+ * while True:\n+ *     ...\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, f\n+ *     # Compute limit on number of bits to cancel\n+ *     limit = min(min(eta + 1, i), 4)\n+ *     # Compute w = -g/f mod 2**limit, using the table value for -1/f mod 2**4. Note that f is\n+ *     # always odd, so its inverse modulo a power of two always exists.\n+ *     w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *     # As w = -g/f mod (2**limit), g+w*f mod 2**limit = 0 mod 2**limit.\n+ *     g += w * f\n+ *     assert g % (2**limit) == 0\n+ *     # The next iteration will now shift out all (limit) bottom zero bits from g.\n+ *\n+ * By using a bigger table more bits can be cancelled at once. The table can also be implemented\n+ * as a formula:\n+ *  - Instead of a 3-bit table:\n+ *    * (-f) or (f ^ 6)\n+ *  - Instead of a 4-bit table:\n+ *    * (1 - f * (f + 1))\n+ *    * (-(f + (((f + 1) & 4) << 1)))\n+ *  - For larger tables the following technique can be used: if w=-f^-1 mod 2^i, then w*(w*f+2) is\n+ *    -f^-1 mod 2^(2*i). This allows extending the previous formulas (or tables). In particular we\n+ *    have this 6-bit function (based on the 3-bit function above):\n+ *    * (f * (f * f - 2))\n+ *\n+ * This loop, again extended to also handle u, v, q, and r alongside f and g, placed in\n+ * divsteps_n_matrix, gives a significantly faster, but non-constant time version. It is usable when\n+ * not operating on secret data.\n+ *\n+ * 7. Final Python version\n+ * -----------------------\n+ *\n+ * All together we need the following functions:\n+ *\n+ * - A way to compute the transition matrix in constant time, using the divsteps_n_matrix function\n+ *   from section 2, but with its loop replaced by a variant of the constant-time divstep from\n+ *   section 5, extended to handle u, v, q, r:\n+ *\n+ * def divsteps_n_matrix(eta, f, g):\n+ *     \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         c1 = eta >> 63\n+ *         # Compute x, y, z as conditionally-negated versions of f, u, v.\n+ *         x, y, z = (f ^ c1) - c1, (u ^ c1) - c1, (v ^ c1) - c1\n+ *         c2 = -(g & 1)\n+ *         # Conditionally add x, y, z to g, q, r.\n+ *         g, q, r = g + (x & c2), q + (y & c2), r + (z & c2)\n+ *         c1 &= c2                     # reusing c1 here for further conditionals\n+ *         eta = (eta ^ c1) - (c1 + 1)  # inlining the unconditional eta decrement here\n+ *         # Conditionally add g, q, r to f, u, v.\n+ *         f, u, v = f + (g & c1), u + (q & c1), v + (r & c1)\n+ *         # When shifting g down, don't shift q, r, as we construct a transition matrix multiplied\n+ *         # by 2^N. Instead, shift f's coefficients u and v up.\n+ *         g, u, v = g >> 1, u << 1, v << 1\n+ *     return eta, (u, v, q, r)\n+ *\n+ * - The functions to update f and g, and d and e, from section 2 and section 4, with the constant-time\n+ *   changes to update_de from section 5:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     cf, cg = u*f + v*g, q*f + r*g\n+ *     return cf >> N, cg >> N\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     d_sign, e_sign = d >> 257, e >> 257\n+ *     md, me = (u & d_sign) + (v & e_sign), (q & d_sign) + (r & e_sign)\n+ *     cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+ *     md -= (Mi*cd + md) % 2**N\n+ *     me -= (Mi*ce + me) % 2**N\n+ *     cd, ce = u*d + v*e + Mi*md, q*d + r*e + Mi*me\n+ *     return cd >> N, ce >> N\n+ *\n+ * - The normalize function from section 4, made constant time as well:\n+ *\n+ * def normalize(sign, v, M):\n+ *     \"\"\"Compute sign*v mod M, where v in (-2*M,M); output in [0,M).\"\"\"\n+ *     v_sign = v >> 257\n+ *     # Conditionally add M to v.\n+ *     v += M & v_sign\n+ *     c = (sign - 1) >> 1\n+ *     # Conditionally negate v.\n+ *     v = (v ^ c) - c\n+ *     v_sign = v >> 257\n+ *     # Conditionally add M to v again.\n+ *     v += M & v_sign\n+ *     return v\n+ *\n+ * - And finally the modinv function too, adapted to use eta instead of delta, and using the fixed\n+ *   iteration count from section 5:\n+ *\n+ * def modinv(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, M, x, 0, 1\n+ *     for _ in range((724 + N - 1) // N):\n+ *         eta, t = divsteps_n_matrix(-eta, f % 2**N, g % 2**N)\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return normalize(f, d, M)\n+ *\n+ * - To get a variable time version, replace the divsteps_n_matrix function with one that uses the\n+ *   divsteps loop from section 5, and a modinv version that calls it without the fixed iteration\n+ *   count:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * def divsteps_n_matrix_var(eta, f, g):\n+ *     \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1\n+ *     i = N\n+ *     while True:\n+ *         zeros = min(i, count_trailing_zeros(g))\n+ *         eta, i = eta - zeros, i - zeros\n+ *         g, u, v = g >> zeros, u << zeros, v << zeros\n+ *         if i == 0:\n+ *             break\n+ *         if eta < 0:\n+ *             eta, f, u, v, g, q, r = -eta, g, q, r, -f, -u, -v\n+ *         limit = min(min(eta + 1, i), 4)\n+ *         w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *         g, q, r = g + w*f, q + w*u, r + w*v\n+ *     return eta, (u, v, q, r)\n+ *\n+ * def modinv_var(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi = 1/M mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, M, x, 0, 1\n+ *     while g != 0:\n+ *         eta, t = divsteps_n_matrix_var(eta, f % 2**N, g % 2**N)\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return normalize(f, d, Mi)\n+ *\n+ *\n+ * 8. C implementation\n+ * -------------------\n+ *\n+ * What follows is a C implementation of effectively the Python code from section 7, with N=62, and\n+ * the following changes:\n+ *\n+ * - Representing large integers using 5 62-bit singed limbs that callers need to convert their\n+ *   value from/to. Using 62-bit limbs means shifts by 62 bits are very efficient, and the extra\n+ *   space allows faster operations by delaying carries/borrows in some cases.\n+ *\n+ * - Several modulo operations in the Python code are modulo a power of two. These can be replaced\n+ *   with a bitwise AND with ((1 << bits) - 1).\n+ *\n+ * - Similarly, if an entire expression involving multiplications and additions is computed modulo\n+ *   a power of two, that means only the bottom bits of the inputs and intermediary results is\n+ *   needed.\n+ */\n+\n+#ifdef VERIFY\n+/* Helper function to compute the absolute value of an int64_t.\n+ * (we don't use abs/labs/llabs as it depends on the int sizes). */\n+static int64_t secp256k1_modinv64_abs(int64_t v) {\n+    VERIFY_CHECK(v > INT64_MIN);\n+    if (v < 0) return -v;\n+    return v;\n+}\n+\n+static const secp256k1_modinv64_signed62 SECP256K1_SIGNED62_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^62). */\n+static void secp256k1_modinv64_mul_62(secp256k1_modinv64_signed62 *r, const secp256k1_modinv64_signed62 *a, int alen, int64_t factor) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int128_t c = 0;\n+    int i;\n+    for (i = 0; i < 4; ++i) {\n+        if (i < alen) {\n+            c += (factor == 1) ? (int128_t)a->v[i] : (int128_t)a->v[i] * factor;\n+        }\n+        r->v[i] = (int64_t)c & M62; c >>= 62;\n+    }\n+    if (4 < alen) {\n+        c += (factor == 1) ? (int128_t)a->v[4] : (int128_t)a->v[4] * factor;\n+    }\n+    VERIFY_CHECK(c == (int64_t)c);\n+    r->v[4] = (int64_t)c;\n+}\n+\n+/* Compare af with b*bf. */\n+static int secp256k1_modinv64_mul_cmp_62(const secp256k1_modinv64_signed62 *a, int alen, const secp256k1_modinv64_signed62 *b, int64_t factor) {\n+    int i;\n+    secp256k1_modinv64_signed62 am, bm;\n+    secp256k1_modinv64_mul_62(&am, a, alen, 1);\n+    secp256k1_modinv64_mul_62(&bm, b, 5, factor);\n+    for (i = 4; i >= 0; --i) {\n+        if (i != 4) {\n+            VERIFY_CHECK(am.v[i] >> 62 == 0);\n+            VERIFY_CHECK(bm.v[i] >> 62 == 0);\n+        }\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }\n+    return 0;\n+}\n+#endif\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^62,2^62). */\n+    int i;\n+    for (i = 0; i < 5; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M62);\n+        VERIFY_CHECK(r->v[i] <= M62);\n+    }\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, -2) > 0); /* r > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < P */\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled\n+             * out (as we'd be done before that point), and no more than eta+1 can be done as its\n+             * will flip again once that happens. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            /* m is a mask for the bottom min(limit, 6) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 63U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)\n+             * bits. */\n+            w = (f * g * (f * f - 2)) & m;",
      "path": "src/modinv64_impl.h",
      "position": 262,
      "original_position": 859,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "1e30f79c3807a9c63c6c6f6ae07e7c9445b0f37c",
      "in_reply_to_id": 549203982,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Looking at https://www.agner.org/optimize/instruction_tables.ods, on most modern x86_64 systems the size of the multiplicands in a 2-operand IMUL instruction (the one that's affected here) doesn't depend on their size. On some early x86_64 ones 64-bit multiplies were slower than other sizes.",
      "created_at": "2020-12-28T20:04:39Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r549471488",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/549471488"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 262,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/556919949",
      "pull_request_review_id": 567716280,
      "id": 556919949,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkxOTk0OQ==",
      "diff_hunk": "@@ -276,4 +276,51 @@ SECP256K1_GNUC_EXT typedef __int128 int128_t;\n # endif\n #endif\n \n+#ifndef __has_builtin\n+#define __has_builtin(x) 0\n+#endif\n+\n+static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\n+#if (__has_builtin(__builtin_ctz) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* If the unsigned type is sufficient to represent the largest uint32_t, consider __builtin_ctz. */\n+    if (((unsigned)UINT32_MAX) == UINT32_MAX) {\n+        return __builtin_ctz(x);\n+    }\n+#endif\n+#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* Otherwise consider __builtin_ctzl (the unsigned long type is always at least 32 bits). */\n+    return __builtin_ctzl(x);\n+#else\n+    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\n+    static const uint8_t debruijn[32] = {\n+        0x00, 0x01, 0x02, 0x18, 0x03, 0x13, 0x06, 0x19, 0x16, 0x04, 0x14, 0x0A,\n+        0x10, 0x07, 0x0C, 0x1A, 0x1F, 0x17, 0x12, 0x05, 0x15, 0x09, 0x0F, 0x0B,\n+        0x1E, 0x11, 0x08, 0x0E, 0x1D, 0x0D, 0x1C, 0x1B\n+    };\n+    return debruijn[((x & -x) * 0x04D7651F) >> 27];",
      "path": "src/util.h",
      "position": null,
      "original_position": 25,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "b4e12d2679ed63c5e02b56a791e6f849a7c90f6a",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Note that this De Bruijn and the corresponding 64-bit one does give secp256k1_ctzxx_var(0) = 0 whereas the built-in on my system gives 32, 64 respectively. \r\n\r\nI don't know what is the expected behavior when x = 0, but the commit message says \"If x is 0, ctz(x) is at least as large as the number of bits in its type\" which is incorrect. ",
      "created_at": "2021-01-13T22:37:53Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r556919949",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/556919949"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/556931653",
      "pull_request_review_id": 567725047,
      "id": 556931653,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMTY1Mw==",
      "diff_hunk": "@@ -276,4 +276,51 @@ SECP256K1_GNUC_EXT typedef __int128 int128_t;\n # endif\n #endif\n \n+#ifndef __has_builtin\n+#define __has_builtin(x) 0\n+#endif\n+\n+static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\n+#if (__has_builtin(__builtin_ctz) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* If the unsigned type is sufficient to represent the largest uint32_t, consider __builtin_ctz. */\n+    if (((unsigned)UINT32_MAX) == UINT32_MAX) {\n+        return __builtin_ctz(x);\n+    }\n+#endif\n+#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* Otherwise consider __builtin_ctzl (the unsigned long type is always at least 32 bits). */\n+    return __builtin_ctzl(x);\n+#else\n+    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\n+    static const uint8_t debruijn[32] = {\n+        0x00, 0x01, 0x02, 0x18, 0x03, 0x13, 0x06, 0x19, 0x16, 0x04, 0x14, 0x0A,\n+        0x10, 0x07, 0x0C, 0x1A, 0x1F, 0x17, 0x12, 0x05, 0x15, 0x09, 0x0F, 0x0B,\n+        0x1E, 0x11, 0x08, 0x0E, 0x1D, 0x0D, 0x1C, 0x1B\n+    };\n+    return debruijn[((x & -x) * 0x04D7651F) >> 27];",
      "path": "src/util.h",
      "position": null,
      "original_position": 25,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "b4e12d2679ed63c5e02b56a791e6f849a7c90f6a",
      "in_reply_to_id": 556919949,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nice catch, will fix. The safegcd code never invokes it with x=0.",
      "created_at": "2021-01-13T22:54:29Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r556931653",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/556931653"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/556937052",
      "pull_request_review_id": 567731878,
      "id": 556937052,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzNzA1Mg==",
      "diff_hunk": "@@ -276,4 +276,51 @@ SECP256K1_GNUC_EXT typedef __int128 int128_t;\n # endif\n #endif\n \n+#ifndef __has_builtin\n+#define __has_builtin(x) 0\n+#endif\n+\n+static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\n+#if (__has_builtin(__builtin_ctz) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* If the unsigned type is sufficient to represent the largest uint32_t, consider __builtin_ctz. */\n+    if (((unsigned)UINT32_MAX) == UINT32_MAX) {\n+        return __builtin_ctz(x);\n+    }\n+#endif\n+#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* Otherwise consider __builtin_ctzl (the unsigned long type is always at least 32 bits). */\n+    return __builtin_ctzl(x);\n+#else\n+    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\n+    static const uint8_t debruijn[32] = {\n+        0x00, 0x01, 0x02, 0x18, 0x03, 0x13, 0x06, 0x19, 0x16, 0x04, 0x14, 0x0A,\n+        0x10, 0x07, 0x0C, 0x1A, 0x1F, 0x17, 0x12, 0x05, 0x15, 0x09, 0x0F, 0x0B,\n+        0x1E, 0x11, 0x08, 0x0E, 0x1D, 0x0D, 0x1C, 0x1B\n+    };\n+    return debruijn[((x & -x) * 0x04D7651F) >> 27];",
      "path": "src/util.h",
      "position": null,
      "original_position": 25,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "b4e12d2679ed63c5e02b56a791e6f849a7c90f6a",
      "in_reply_to_id": 556919949,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2021-01-13T23:07:35Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r556937052",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/556937052"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 302,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/557328028",
      "pull_request_review_id": 568146729,
      "id": 557328028,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMyODAyOA==",
      "diff_hunk": "@@ -416,6 +416,20 @@ void run_scratch_tests(void) {\n     secp256k1_context_destroy(none);\n }\n \n+void run_ctz_tests(void) {\n+    static const uint32_t b32[5] = {1, 0xffffffff, 0x5e56968f, 0xe0d63129};\n+    static const uint64_t b64[5] = {1, 0xffffffffffffffff, 0xbcd02462139b3fc3, 0x98b5f80c769693ef};",
      "path": "src/tests.c",
      "position": null,
      "original_position": 6,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "504a007709d09b5231f1a4c94b0dea36f856f4dd",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Why 5? Maybe `b32[4]` or `b32[]`, same for b64 ",
      "created_at": "2021-01-14T11:28:59Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r557328028",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/557328028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 420,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 421,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/557619797",
      "pull_request_review_id": 568530322,
      "id": 557619797,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzYxOTc5Nw==",
      "diff_hunk": "@@ -416,6 +416,20 @@ void run_scratch_tests(void) {\n     secp256k1_context_destroy(none);\n }\n \n+void run_ctz_tests(void) {\n+    static const uint32_t b32[5] = {1, 0xffffffff, 0x5e56968f, 0xe0d63129};\n+    static const uint64_t b64[5] = {1, 0xffffffffffffffff, 0xbcd02462139b3fc3, 0x98b5f80c769693ef};",
      "path": "src/tests.c",
      "position": null,
      "original_position": 6,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "504a007709d09b5231f1a4c94b0dea36f856f4dd",
      "in_reply_to_id": 557328028,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2021-01-14T18:57:49Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r557619797",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/557619797"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 420,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 421,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558154372",
      "pull_request_review_id": 569111269,
      "id": 558154372,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE1NDM3Mg==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.\n+  - For (b), we know that *f* is odd, so *gcd(f,g)* clearly has no factor *2*, and we can remove\n+    it from *g*.\n+- The algorithm will eventually converge to *g=0*. This is proven in the paper (see theorem G.3).\n+- It follows that eventually we find a final value *f'* for which *gcd(f,g) = gcd(f',0)*. As the\n+  gcd of *f'* and *0* is *|f'|* by definition, that is our answer.\n+\n+Compared to more [traditional GCD algorithms](https://en.wikipedia.org/wiki/Euclidean_algorithm), this one has the property of only ever looking at\n+the low-order bits of the variables to decide the next steps, and being easy to make\n+constant-time (in more low-level languages than Python). The *&delta;* parameter is necessary to\n+guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+at high order bits.\n+\n+Properties that will become important later:\n+- Performing more divsteps than needed is not a problem, as *f* does not change anymore after *g=0*.\n+- Only even numbers are divided by *2*. This means that when reasoning about it algebraically we\n+  do not need to worry about rounding.\n+- At every point during the algorithm's execution the next *N* steps only depend on the bottom *N*\n+  bits of *f* and *g*, and on *&delta;*.\n+\n+\n+## 2. From GCDs to modular inverses\n+\n+We want an algorithm to compute the inverse *a* of *x* modulo *M*, i.e. the number a such that *a&thinsp;x=1\n+mod M*. This inverse only exists if the GCD of *x* and *M* is *1*, but that is always the case if *M* is\n+prime and *0 < x < M*. In what follows, assume that the modular inverse exists.\n+It turns out this inverse can be computed as a side effect of computing the GCD by keeping track\n+of how the internal variables can be written as linear combinations of the inputs at every step\n+(see the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)).\n+Since the GCD is *1*, such an algorithm will compute numbers *a* and *b* such that a&thinsp;x + b&thinsp;M = 1*.\n+Taking that expression *mod M* gives *a&thinsp;x mod M = 1*, and we see that *a* is the modular inverse of *x\n+mod M*.\n+\n+A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+algorithm shown above, if the modulus *M* is odd. To do so, compute *gcd(f=M,g=x)*, while keeping\n+track of extra variables *d* and *e*, for which at every step *d = f/x (mod M)* and *e = g/x (mod M)*.\n+*f/x* here means the number which multiplied with *x* gives *f mod M*. As *f* and *g* are initialized to *M*\n+and *x* respectively, *d* and *e* just start off being *0* (*M/x mod M = 0/x mod M = 0*) and *1* (*x/x mod M\n+= 1*).\n+\n+```python\n+def div2(M, x):\n+    \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+    assert M & 1\n+    if x & 1: # If x is odd, make it even by adding M.\n+        x += M\n+    # x must be even now, so a clean division by 2 is possible.\n+    return x // 2\n+\n+def modinv(M, x):\n+    \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Note that while division by two for f and g is only ever done on even inputs, this is\n+        # not true for d and e, so we need the div2 helper function.\n+        if delta > 0 and g & 1:\n+            delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+        elif g & 1:\n+            delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+        else:\n+            delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+        # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+        assert f % M == (d * x) % M\n+        assert g % M == (e * x) % M\n+    assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+    # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+    return (d * f) % M\n+```\n+\n+Also note that this approach to track *d* and *e* throughout the computation to determine the inverse\n+is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+entire computation is determined (see section 3 below) and the inverse is computed from that.\n+The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+be faster at the level of optimization we're able to do in C.\n+\n+\n+## 3. Batching multiple divsteps\n+\n+Every divstep can be expressed as a matrix multiplication, applying a transition matrix *(1/2 t)*\n+to both vectors *[f, g]* and *[d, e]* (see paragraph 8.1 in the paper):\n+\n+```\n+  t = [ u,  v ]\n+      [ q,  r ]\n+\n+  [ out_f ] = (1/2 * t) * [ in_f ]\n+  [ out_g ] =             [ in_g ]\n+\n+  [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+  [ out_e ]               [ in_e ]\n+```\n+\n+where *(u, v, q, r)* is *(0, 2, -1, 1)*, *(2, 0, 1, 1)*, or *(2, 0, 0, 1)*, depending on which branch is\n+taken. As above, the resulting *f* and *g* are always integers.\n+\n+Performing multiple divsteps corresponds to a multiplication with the product of all the\n+individual divsteps' transition matrices. As each transition matrix consists of integers\n+divided by *2*, the product of these matrices will consist of integers divided by *2<sup>N</sup>* (see also\n+theorem 9.2 in the paper). These divisions are expensive when updating *d* and *e*, so we delay\n+them: we compute the integer coefficients of the combined transition matrix scaled by *2<sup>N</sup>*, and\n+do one division by *2<sup>N</sup>* as a final step:\n+\n+```python\n+def divsteps_n_matrix(delta, f, g):\n+    \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+    for _ in range(N):\n+        if delta > 0 and g & 1:\n+            delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+        elif g & 1:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+        else:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+    return delta, (u, v, q, r)\n+```\n+\n+As the branches in the divsteps are completely determined by the bottom *N* bits of *f* and *g*, this\n+function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+intermediate results and outputs fit in *(N+1)*-bit numbers (unsigned for *f* and *g*; signed for *u*, *v*,\n+*q*, and *r*) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+integers could set *N=62* and compute the full transition matrix for 62 steps at once without any\n+big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+to update the full-size *f*, *g*, *d*, and *e* numbers once every *N* steps.\n+\n+We still need functions to compute:\n+\n+```\n+  [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+  [ out_g ]   (        [ q,  r ])   [ in_g ]\n+\n+  [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+  [ out_e ]   (        [ q,  r ])   [ in_e ]\n+```\n+\n+Because the divsteps transformation only ever divides even numbers by two, the result of *t&thinsp;[f,g]* is always even. When *t* is a composition of *N* divsteps, it follows that the resulting *f*\n+and *g* will be multiple of *2<sup>N</sup>*, and division by *2<sup>N</sup>* is simply shifting them down:\n+\n+```python\n+def update_fg(f, g, t):\n+    \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+    u, v, q, r = t\n+    cf, cg = u*f + v*g, q*f + r*g\n+    # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+    # bottom bits.\n+    assert cf % 2**N == 0\n+    assert cg % 2**N == 0\n+    return cf >> N, cg >> N\n+```\n+\n+The same is not true for *d* and *e*, and we need an equivalent of the `div2` function for division by *2<sup>N</sup> mod M*.\n+This is easy if we have precomputed *1/M mod 2<sup>N</sup>* (which always exists for odd *M*):\n+\n+```python\n+def div2n(M, Mi, x):\n+    \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+    assert (M * Mi) % 2**N == 1\n+    # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+    #     (m * M) mod 2^N = x mod 2^N\n+    # <=> m mod 2^N = (x / M) mod 2^N\n+    # <=> m mod 2^N = (x * Mi) mod 2^N\n+    m = (Mi * x) % 2**N\n+    # Subtract that multiple from x, cancelling its bottom N bits.\n+    x -= m * M\n+    # Now a clean division by 2^N is possible.\n+    assert x % 2**N == 0\n+    return (x >> N) % M\n+\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+```\n+\n+With all of those, we can write a version of `modinv` that performs *N* divsteps at once:\n+\n+```python3\n+def modinv(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+        # (N+1)-bit signed integer arithmetic).\n+        delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+        # Apply the transition matrix t to [f, g]:\n+        f, g = update_fg(f, g, t)\n+        # Apply the transition matrix t to [d, e]:\n+        d, e = update_de(d, e, t, M, Mi)\n+    return (d * f) % M\n+```\n+\n+This means that in practice we'll always perform a multiple of *N* divsteps. This is not a problem\n+because once *g=0*, further divsteps do not affect *f*, *g*, *d*, or *e* anymore (only *&delta;* keeps\n+increasing). For variable time code such excess iterations will be mostly optimized away in\n+section 6.\n+\n+\n+## 4. Avoiding modulus operations\n+\n+So far, there are two places where we compute a remainder of big numbers modulo *M*: at the end of\n+`div2n` in every `update_de`, and at the very end of `modinv` after potentially negating *d* due to the\n+sign of *f*. These are relatively expensive operations when done generically.\n+\n+To deal with the modulus operation in `div2n`, we simply stop requiring *d* and *e* to be in range\n+*[0,M)* all the time. Let's start by inlining `div2n` into `update_de`, and dropping the modulus\n+operation at the end:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+Let's look at bounds on the ranges of these numbers. It can be shown that *|u|+|v|* and *|q|+|r|*\n+never exceed *2<sup>N</sup>* (see paragraph 8.3 in the paper), and thus a multiplication with *t* will have\n+outputs whose absolute values are at most *2<sup>N</sup>* times the maximum absolute input value. In case the\n+inputs *d* and *e* are in *(-M,M)*, which is certainly true for the initial values *d=0* and *e=1* assuming\n+*M > 1*, the multiplication results in numbers in range *(-2<sup>N</sup>M,2<sup>N</sup>M)*. Subtracting up to *2<sup>N</sup>-1*\n+times *M* to cancel out *N* bits brings that up to slightly less than *(-2<sup>N+1</sup>M,2<sup>N</sup>M)*, and",
      "path": "doc/safegcd_implementation.md",
      "position": null,
      "original_position": 280,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: \"less than\" was somewhat unclear to me.",
      "created_at": "2021-01-15T09:50:24Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558154372",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558154372"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558161444",
      "pull_request_review_id": 569111269,
      "id": 558161444,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE2MTQ0NA==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.",
      "path": "doc/safegcd_implementation.md",
      "position": 52,
      "original_position": 52,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Am I right that this is like in the substraction-based variant of the euclidean algorithm? Might help the intuition of the reader.",
      "created_at": "2021-01-15T09:55:05Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558161444",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558161444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 52,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558212388",
      "pull_request_review_id": 569111269,
      "id": 558212388,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIxMjM4OA==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.\n+  - For (b), we know that *f* is odd, so *gcd(f,g)* clearly has no factor *2*, and we can remove\n+    it from *g*.\n+- The algorithm will eventually converge to *g=0*. This is proven in the paper (see theorem G.3).\n+- It follows that eventually we find a final value *f'* for which *gcd(f,g) = gcd(f',0)*. As the\n+  gcd of *f'* and *0* is *|f'|* by definition, that is our answer.\n+\n+Compared to more [traditional GCD algorithms](https://en.wikipedia.org/wiki/Euclidean_algorithm), this one has the property of only ever looking at\n+the low-order bits of the variables to decide the next steps, and being easy to make\n+constant-time (in more low-level languages than Python). The *&delta;* parameter is necessary to\n+guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+at high order bits.\n+\n+Properties that will become important later:\n+- Performing more divsteps than needed is not a problem, as *f* does not change anymore after *g=0*.\n+- Only even numbers are divided by *2*. This means that when reasoning about it algebraically we\n+  do not need to worry about rounding.\n+- At every point during the algorithm's execution the next *N* steps only depend on the bottom *N*\n+  bits of *f* and *g*, and on *&delta;*.\n+\n+\n+## 2. From GCDs to modular inverses\n+\n+We want an algorithm to compute the inverse *a* of *x* modulo *M*, i.e. the number a such that *a&thinsp;x=1\n+mod M*. This inverse only exists if the GCD of *x* and *M* is *1*, but that is always the case if *M* is\n+prime and *0 < x < M*. In what follows, assume that the modular inverse exists.\n+It turns out this inverse can be computed as a side effect of computing the GCD by keeping track\n+of how the internal variables can be written as linear combinations of the inputs at every step\n+(see the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)).\n+Since the GCD is *1*, such an algorithm will compute numbers *a* and *b* such that a&thinsp;x + b&thinsp;M = 1*.\n+Taking that expression *mod M* gives *a&thinsp;x mod M = 1*, and we see that *a* is the modular inverse of *x\n+mod M*.\n+\n+A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+algorithm shown above, if the modulus *M* is odd. To do so, compute *gcd(f=M,g=x)*, while keeping\n+track of extra variables *d* and *e*, for which at every step *d = f/x (mod M)* and *e = g/x (mod M)*.\n+*f/x* here means the number which multiplied with *x* gives *f mod M*. As *f* and *g* are initialized to *M*\n+and *x* respectively, *d* and *e* just start off being *0* (*M/x mod M = 0/x mod M = 0*) and *1* (*x/x mod M\n+= 1*).\n+\n+```python\n+def div2(M, x):\n+    \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+    assert M & 1\n+    if x & 1: # If x is odd, make it even by adding M.\n+        x += M\n+    # x must be even now, so a clean division by 2 is possible.\n+    return x // 2\n+\n+def modinv(M, x):\n+    \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Note that while division by two for f and g is only ever done on even inputs, this is\n+        # not true for d and e, so we need the div2 helper function.\n+        if delta > 0 and g & 1:\n+            delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+        elif g & 1:\n+            delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+        else:\n+            delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+        # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+        assert f % M == (d * x) % M\n+        assert g % M == (e * x) % M\n+    assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+    # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+    return (d * f) % M\n+```\n+\n+Also note that this approach to track *d* and *e* throughout the computation to determine the inverse\n+is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+entire computation is determined (see section 3 below) and the inverse is computed from that.\n+The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+be faster at the level of optimization we're able to do in C.\n+\n+\n+## 3. Batching multiple divsteps\n+\n+Every divstep can be expressed as a matrix multiplication, applying a transition matrix *(1/2 t)*\n+to both vectors *[f, g]* and *[d, e]* (see paragraph 8.1 in the paper):\n+\n+```\n+  t = [ u,  v ]\n+      [ q,  r ]\n+\n+  [ out_f ] = (1/2 * t) * [ in_f ]\n+  [ out_g ] =             [ in_g ]\n+\n+  [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+  [ out_e ]               [ in_e ]\n+```\n+\n+where *(u, v, q, r)* is *(0, 2, -1, 1)*, *(2, 0, 1, 1)*, or *(2, 0, 0, 1)*, depending on which branch is\n+taken. As above, the resulting *f* and *g* are always integers.\n+\n+Performing multiple divsteps corresponds to a multiplication with the product of all the\n+individual divsteps' transition matrices. As each transition matrix consists of integers\n+divided by *2*, the product of these matrices will consist of integers divided by *2<sup>N</sup>* (see also\n+theorem 9.2 in the paper). These divisions are expensive when updating *d* and *e*, so we delay\n+them: we compute the integer coefficients of the combined transition matrix scaled by *2<sup>N</sup>*, and\n+do one division by *2<sup>N</sup>* as a final step:\n+\n+```python\n+def divsteps_n_matrix(delta, f, g):\n+    \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+    for _ in range(N):\n+        if delta > 0 and g & 1:\n+            delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+        elif g & 1:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+        else:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+    return delta, (u, v, q, r)\n+```\n+\n+As the branches in the divsteps are completely determined by the bottom *N* bits of *f* and *g*, this\n+function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+intermediate results and outputs fit in *(N+1)*-bit numbers (unsigned for *f* and *g*; signed for *u*, *v*,\n+*q*, and *r*) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+integers could set *N=62* and compute the full transition matrix for 62 steps at once without any\n+big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+to update the full-size *f*, *g*, *d*, and *e* numbers once every *N* steps.\n+\n+We still need functions to compute:\n+\n+```\n+  [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+  [ out_g ]   (        [ q,  r ])   [ in_g ]\n+\n+  [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+  [ out_e ]   (        [ q,  r ])   [ in_e ]\n+```\n+\n+Because the divsteps transformation only ever divides even numbers by two, the result of *t&thinsp;[f,g]* is always even. When *t* is a composition of *N* divsteps, it follows that the resulting *f*\n+and *g* will be multiple of *2<sup>N</sup>*, and division by *2<sup>N</sup>* is simply shifting them down:\n+\n+```python\n+def update_fg(f, g, t):\n+    \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+    u, v, q, r = t\n+    cf, cg = u*f + v*g, q*f + r*g\n+    # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+    # bottom bits.\n+    assert cf % 2**N == 0\n+    assert cg % 2**N == 0\n+    return cf >> N, cg >> N\n+```\n+\n+The same is not true for *d* and *e*, and we need an equivalent of the `div2` function for division by *2<sup>N</sup> mod M*.\n+This is easy if we have precomputed *1/M mod 2<sup>N</sup>* (which always exists for odd *M*):\n+\n+```python\n+def div2n(M, Mi, x):\n+    \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+    assert (M * Mi) % 2**N == 1\n+    # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+    #     (m * M) mod 2^N = x mod 2^N\n+    # <=> m mod 2^N = (x / M) mod 2^N\n+    # <=> m mod 2^N = (x * Mi) mod 2^N\n+    m = (Mi * x) % 2**N\n+    # Subtract that multiple from x, cancelling its bottom N bits.\n+    x -= m * M\n+    # Now a clean division by 2^N is possible.\n+    assert x % 2**N == 0\n+    return (x >> N) % M\n+\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+```\n+\n+With all of those, we can write a version of `modinv` that performs *N* divsteps at once:\n+\n+```python3\n+def modinv(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+        # (N+1)-bit signed integer arithmetic).\n+        delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+        # Apply the transition matrix t to [f, g]:\n+        f, g = update_fg(f, g, t)\n+        # Apply the transition matrix t to [d, e]:\n+        d, e = update_de(d, e, t, M, Mi)\n+    return (d * f) % M\n+```\n+\n+This means that in practice we'll always perform a multiple of *N* divsteps. This is not a problem\n+because once *g=0*, further divsteps do not affect *f*, *g*, *d*, or *e* anymore (only *&delta;* keeps\n+increasing). For variable time code such excess iterations will be mostly optimized away in\n+section 6.\n+\n+\n+## 4. Avoiding modulus operations\n+\n+So far, there are two places where we compute a remainder of big numbers modulo *M*: at the end of\n+`div2n` in every `update_de`, and at the very end of `modinv` after potentially negating *d* due to the\n+sign of *f*. These are relatively expensive operations when done generically.\n+\n+To deal with the modulus operation in `div2n`, we simply stop requiring *d* and *e* to be in range\n+*[0,M)* all the time. Let's start by inlining `div2n` into `update_de`, and dropping the modulus\n+operation at the end:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+Let's look at bounds on the ranges of these numbers. It can be shown that *|u|+|v|* and *|q|+|r|*\n+never exceed *2<sup>N</sup>* (see paragraph 8.3 in the paper), and thus a multiplication with *t* will have\n+outputs whose absolute values are at most *2<sup>N</sup>* times the maximum absolute input value. In case the\n+inputs *d* and *e* are in *(-M,M)*, which is certainly true for the initial values *d=0* and *e=1* assuming\n+*M > 1*, the multiplication results in numbers in range *(-2<sup>N</sup>M,2<sup>N</sup>M)*. Subtracting up to *2<sup>N</sup>-1*\n+times *M* to cancel out *N* bits brings that up to slightly less than *(-2<sup>N+1</sup>M,2<sup>N</sup>M)*, and\n+dividing by *2<sup>N</sup>* at the end takes it to *(-2M,M)*. Another application of `update_de` would take that\n+to *(-3M,2M)*, and so forth. This progressive expansion of the variables' ranges can be\n+counteracted by incrementing *d* and *e* by *M* whenever they're negative:\n+\n+```python\n+    ...\n+    if d < 0:\n+        d += M\n+    if e < 0:\n+        e += M\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    ...\n+```\n+\n+With inputs in *(-2M,M)*, they will first be shifted into range *(-M,M)*, which means that the\n+output will again be in *(-2M,M)*, and this remains the case regardless of how many `update_de`\n+invocations there are. In what follows, we will try to make this more efficient.\n+\n+Note that increasing *d* by *M* is equal to incrementing *cd* by *u&thinsp;M* and *ce* by *q&thinsp;M*. Similarly,\n+increasing *e* by *M* is equal to incrementing *cd* by *v&thinsp;M* and *ce* by *r&thinsp;M*. So we could instead write:\n+\n+```python\n+    ...\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Perform the equivalent of incrementing d, e by M when they're negative.\n+    if d < 0:\n+        cd += u*M\n+        ce += q*M\n+    if e < 0:\n+        cd += v*M\n+        ce += r*M\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    ...\n+```\n+\n+Now note that we have two steps of corrections to *cd* and *ce* that add multiples of *M*: this\n+increment, and the decrement that cancels out bottom bits. The second one depends on the first\n+one, but they can still be efficiently combined by only computing the bottom bits of *cd* and *ce*\n+at first, and using that to compute the final *md*, *me* values:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    md, me = 0, 0\n+    # Compute what multiples of M to add to cd and ce.\n+    if d < 0:\n+        md += u\n+        me += q\n+    if e < 0:\n+        md += v\n+        me += r\n+    # Compute bottom N bits of t*[d,e] + M*[md,me].\n+    cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.\n+    md -= (Mi * cd) % 2**N\n+    me -= (Mi * ce) % 2**N\n+    # Do the full computation.\n+    cd, ce = u*d + v*e + md*M, q*d + r*e + me*M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+One last optimization: we can avoid the *md&thinsp;M* and *me&thinsp;M* multiplications in the bottom bits of *cd*\n+and *ce* by moving them to the *md* and *me* correction:\n+\n+```python\n+    ...\n+    # Compute bottom N bits of t*[d,e].\n+    cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.\n+    # Note that this is not the same as {md = (Mi * cd) % 2**N} etc. That would also result in N\n+    # zero bottom bits, but isn't guaranteed to be a reduction of [0,2^N) compared to the\n+    # previous md and me values, and thus would violate our bounds analysis.\n+    md -= (Mi*cd + md) % 2**N\n+    me -= (Mi*ce + me) % 2**N\n+    ...\n+```\n+\n+The resulting function takes *d* and *e* in range *(-2M,M)* as inputs, and outputs values in the same\n+range. That also means that the *d* value at the end of `modinv` will be in that range, while we want\n+a result in *[0,M)*. To do that, we need a normalization function. It's easy to integrate the\n+conditional negation of *d* (based on the sign of *f*) into it as well:\n+\n+```python\n+def normalize(sign, v, M):\n+    \"\"\"Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).\"\"\"\n+    assert sign == 1 or sign == -1\n+    # v in (-2*M,M)\n+    if v < 0:\n+        v += M\n+    # v in (-M,M). Now multiply v with sign (which can only be 1 or -1).\n+    if sign == -1:\n+        v = -v\n+    # v in (-M,M)\n+    if v < 0:\n+        v += M\n+    # v in [0,M)\n+    return v\n+```\n+\n+And calling it in `modinv` is simply:\n+\n+```python\n+   ...\n+   return normalize(f, d, M)\n+```\n+\n+\n+## 5. Constant-time operation\n+\n+The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+depends on the input data so far?\n+\n+- the number of iterations of the while *g &ne; 0* loop in `modinv`\n+- the branches inside `divsteps_n_matrix`\n+- the sign checks in `update_de`\n+- the sign checks in `normalize`\n+\n+To make the while loop in `modinv` constant time it can be replaced with a constant number of\n+iterations. The paper proves (Theorem 11.2) that *741* divsteps are sufficient for any *256*-bit\n+inputs, and [safegcd-bounds](https://github.com/sipa/safegcd-bounds) shows that the slightly better bound *724* is\n+sufficient even. Given that every loop iteration performs *N* divsteps, it will run a total of\n+*&lceil;724/N&rceil;* times.\n+\n+To deal with the branches in `divsteps_n_matrix` we will replace them with constant-time bitwise\n+operations (and hope the C compiler isn't smart enough to turn them back into branches; see\n+`valgrind_ctime_test.c` for automated tests that this isn't the case). To do so, observe that a\n+divstep can be written instead as (compare to the inner loop of `gcd` in section 1).\n+\n+```python\n+    x = -f if delta > 0 else f         # set x equal to (input) -f or f\n+    if g & 1:\n+        g += x                         # set g to (input) g-f or g+f\n+        if delta > 0:\n+            delta = -delta\n+            f += g                     # set f to (input) g (note that g was set to g-f before)\n+    delta += 1\n+    g >>= 1\n+```\n+\n+To convert the above to bitwise operations, we rely on a trick to negate conditionally: per the\n+definition of negative numbers in two's complement, (*-v == ~v + 1*) holds for every number *v*. As\n+*-1* in two's complement is all *1* bits, bitflipping can be expressed as xor with *-1*. It follows\n+that *-v == (v ^ -1) - (-1)*. Thus, if we have a variable *c* that takes on values *0* or *-1*, then\n+*(v ^ c) - c* is *v* if *c=0* and *-v* if *c=-1*.\n+\n+Using this we can write:\n+\n+```python\n+    x = -f if delta > 0 else f\n+```\n+\n+in constant-time form as:\n+\n+```python\n+    c1 = (-delta) >> 63\n+    # Conditionally negate f based on c1:\n+    x = (f ^ c1) - c1\n+```\n+\n+To use that trick, we need a helper mask variable *c1* that resolves the condition *&delta;>0* to *-1*\n+(if true) or *0* (if false). We compute *c1* using right shifting, which always rounds down (in\n+Python, and also in C under the assumption of a typical two's complement system; see\n+`assumptions.h` for tests that this is the case).",
      "path": "doc/safegcd_implementation.md",
      "position": null,
      "original_position": 450,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "TIL that `-17 >> 1000 == -1` in python. That's really neat, I never thought about the semantics of right shifting arbitrary-precision integers.\r\n\r\n I got confused by just saying \"rounds down\".  It might be clearer to say that right shifting by 63 bits is equivalent to dividing by 2^63 and taking floors. ",
      "created_at": "2021-01-15T10:29:47Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558212388",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558212388"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558220985",
      "pull_request_review_id": 569111269,
      "id": 558220985,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyMDk4NQ==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:",
      "path": "doc/safegcd_implementation.md",
      "position": null,
      "original_position": 14,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Since the paper offers a lot of algorithms,, it may be good to point the reader to Appendix E",
      "created_at": "2021-01-15T10:38:44Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558220985",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558220985"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558225651",
      "pull_request_review_id": 569111269,
      "id": 558225651,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNTY1MQ==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.\n+  - For (b), we know that *f* is odd, so *gcd(f,g)* clearly has no factor *2*, and we can remove\n+    it from *g*.\n+- The algorithm will eventually converge to *g=0*. This is proven in the paper (see theorem G.3).\n+- It follows that eventually we find a final value *f'* for which *gcd(f,g) = gcd(f',0)*. As the\n+  gcd of *f'* and *0* is *|f'|* by definition, that is our answer.\n+\n+Compared to more [traditional GCD algorithms](https://en.wikipedia.org/wiki/Euclidean_algorithm), this one has the property of only ever looking at\n+the low-order bits of the variables to decide the next steps, and being easy to make\n+constant-time (in more low-level languages than Python). The *&delta;* parameter is necessary to\n+guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+at high order bits.\n+\n+Properties that will become important later:\n+- Performing more divsteps than needed is not a problem, as *f* does not change anymore after *g=0*.\n+- Only even numbers are divided by *2*. This means that when reasoning about it algebraically we\n+  do not need to worry about rounding.\n+- At every point during the algorithm's execution the next *N* steps only depend on the bottom *N*\n+  bits of *f* and *g*, and on *&delta;*.\n+\n+\n+## 2. From GCDs to modular inverses\n+\n+We want an algorithm to compute the inverse *a* of *x* modulo *M*, i.e. the number a such that *a&thinsp;x=1\n+mod M*. This inverse only exists if the GCD of *x* and *M* is *1*, but that is always the case if *M* is\n+prime and *0 < x < M*. In what follows, assume that the modular inverse exists.\n+It turns out this inverse can be computed as a side effect of computing the GCD by keeping track\n+of how the internal variables can be written as linear combinations of the inputs at every step\n+(see the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)).\n+Since the GCD is *1*, such an algorithm will compute numbers *a* and *b* such that a&thinsp;x + b&thinsp;M = 1*.\n+Taking that expression *mod M* gives *a&thinsp;x mod M = 1*, and we see that *a* is the modular inverse of *x\n+mod M*.\n+\n+A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+algorithm shown above, if the modulus *M* is odd. To do so, compute *gcd(f=M,g=x)*, while keeping\n+track of extra variables *d* and *e*, for which at every step *d = f/x (mod M)* and *e = g/x (mod M)*.\n+*f/x* here means the number which multiplied with *x* gives *f mod M*. As *f* and *g* are initialized to *M*\n+and *x* respectively, *d* and *e* just start off being *0* (*M/x mod M = 0/x mod M = 0*) and *1* (*x/x mod M\n+= 1*).\n+\n+```python\n+def div2(M, x):\n+    \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+    assert M & 1\n+    if x & 1: # If x is odd, make it even by adding M.\n+        x += M\n+    # x must be even now, so a clean division by 2 is possible.\n+    return x // 2\n+\n+def modinv(M, x):\n+    \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Note that while division by two for f and g is only ever done on even inputs, this is\n+        # not true for d and e, so we need the div2 helper function.\n+        if delta > 0 and g & 1:\n+            delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+        elif g & 1:\n+            delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+        else:\n+            delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+        # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+        assert f % M == (d * x) % M\n+        assert g % M == (e * x) % M\n+    assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+    # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+    return (d * f) % M\n+```\n+\n+Also note that this approach to track *d* and *e* throughout the computation to determine the inverse\n+is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+entire computation is determined (see section 3 below) and the inverse is computed from that.\n+The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+be faster at the level of optimization we're able to do in C.\n+\n+\n+## 3. Batching multiple divsteps\n+\n+Every divstep can be expressed as a matrix multiplication, applying a transition matrix *(1/2 t)*\n+to both vectors *[f, g]* and *[d, e]* (see paragraph 8.1 in the paper):\n+\n+```\n+  t = [ u,  v ]\n+      [ q,  r ]\n+\n+  [ out_f ] = (1/2 * t) * [ in_f ]\n+  [ out_g ] =             [ in_g ]\n+\n+  [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+  [ out_e ]               [ in_e ]\n+```\n+\n+where *(u, v, q, r)* is *(0, 2, -1, 1)*, *(2, 0, 1, 1)*, or *(2, 0, 0, 1)*, depending on which branch is\n+taken. As above, the resulting *f* and *g* are always integers.\n+\n+Performing multiple divsteps corresponds to a multiplication with the product of all the\n+individual divsteps' transition matrices. As each transition matrix consists of integers\n+divided by *2*, the product of these matrices will consist of integers divided by *2<sup>N</sup>* (see also\n+theorem 9.2 in the paper). These divisions are expensive when updating *d* and *e*, so we delay\n+them: we compute the integer coefficients of the combined transition matrix scaled by *2<sup>N</sup>*, and\n+do one division by *2<sup>N</sup>* as a final step:\n+\n+```python\n+def divsteps_n_matrix(delta, f, g):\n+    \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+    for _ in range(N):\n+        if delta > 0 and g & 1:\n+            delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+        elif g & 1:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+        else:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+    return delta, (u, v, q, r)\n+```\n+\n+As the branches in the divsteps are completely determined by the bottom *N* bits of *f* and *g*, this\n+function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+intermediate results and outputs fit in *(N+1)*-bit numbers (unsigned for *f* and *g*; signed for *u*, *v*,\n+*q*, and *r*) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+integers could set *N=62* and compute the full transition matrix for 62 steps at once without any\n+big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+to update the full-size *f*, *g*, *d*, and *e* numbers once every *N* steps.\n+\n+We still need functions to compute:\n+\n+```\n+  [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+  [ out_g ]   (        [ q,  r ])   [ in_g ]\n+\n+  [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+  [ out_e ]   (        [ q,  r ])   [ in_e ]\n+```\n+\n+Because the divsteps transformation only ever divides even numbers by two, the result of *t&thinsp;[f,g]* is always even. When *t* is a composition of *N* divsteps, it follows that the resulting *f*\n+and *g* will be multiple of *2<sup>N</sup>*, and division by *2<sup>N</sup>* is simply shifting them down:\n+\n+```python\n+def update_fg(f, g, t):\n+    \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+    u, v, q, r = t\n+    cf, cg = u*f + v*g, q*f + r*g\n+    # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+    # bottom bits.\n+    assert cf % 2**N == 0\n+    assert cg % 2**N == 0\n+    return cf >> N, cg >> N\n+```\n+\n+The same is not true for *d* and *e*, and we need an equivalent of the `div2` function for division by *2<sup>N</sup> mod M*.\n+This is easy if we have precomputed *1/M mod 2<sup>N</sup>* (which always exists for odd *M*):\n+\n+```python\n+def div2n(M, Mi, x):\n+    \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+    assert (M * Mi) % 2**N == 1\n+    # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+    #     (m * M) mod 2^N = x mod 2^N\n+    # <=> m mod 2^N = (x / M) mod 2^N\n+    # <=> m mod 2^N = (x * Mi) mod 2^N\n+    m = (Mi * x) % 2**N\n+    # Subtract that multiple from x, cancelling its bottom N bits.\n+    x -= m * M\n+    # Now a clean division by 2^N is possible.\n+    assert x % 2**N == 0\n+    return (x >> N) % M\n+\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+```\n+\n+With all of those, we can write a version of `modinv` that performs *N* divsteps at once:\n+\n+```python3\n+def modinv(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+        # (N+1)-bit signed integer arithmetic).\n+        delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+        # Apply the transition matrix t to [f, g]:\n+        f, g = update_fg(f, g, t)\n+        # Apply the transition matrix t to [d, e]:\n+        d, e = update_de(d, e, t, M, Mi)\n+    return (d * f) % M\n+```\n+\n+This means that in practice we'll always perform a multiple of *N* divsteps. This is not a problem\n+because once *g=0*, further divsteps do not affect *f*, *g*, *d*, or *e* anymore (only *&delta;* keeps\n+increasing). For variable time code such excess iterations will be mostly optimized away in\n+section 6.\n+\n+\n+## 4. Avoiding modulus operations\n+\n+So far, there are two places where we compute a remainder of big numbers modulo *M*: at the end of\n+`div2n` in every `update_de`, and at the very end of `modinv` after potentially negating *d* due to the\n+sign of *f*. These are relatively expensive operations when done generically.\n+\n+To deal with the modulus operation in `div2n`, we simply stop requiring *d* and *e* to be in range\n+*[0,M)* all the time. Let's start by inlining `div2n` into `update_de`, and dropping the modulus\n+operation at the end:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+Let's look at bounds on the ranges of these numbers. It can be shown that *|u|+|v|* and *|q|+|r|*\n+never exceed *2<sup>N</sup>* (see paragraph 8.3 in the paper), and thus a multiplication with *t* will have\n+outputs whose absolute values are at most *2<sup>N</sup>* times the maximum absolute input value. In case the\n+inputs *d* and *e* are in *(-M,M)*, which is certainly true for the initial values *d=0* and *e=1* assuming\n+*M > 1*, the multiplication results in numbers in range *(-2<sup>N</sup>M,2<sup>N</sup>M)*. Subtracting up to *2<sup>N</sup>-1*\n+times *M* to cancel out *N* bits brings that up to slightly less than *(-2<sup>N+1</sup>M,2<sup>N</sup>M)*, and\n+dividing by *2<sup>N</sup>* at the end takes it to *(-2M,M)*. Another application of `update_de` would take that\n+to *(-3M,2M)*, and so forth. This progressive expansion of the variables' ranges can be\n+counteracted by incrementing *d* and *e* by *M* whenever they're negative:\n+\n+```python\n+    ...\n+    if d < 0:\n+        d += M\n+    if e < 0:\n+        e += M\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    ...\n+```\n+\n+With inputs in *(-2M,M)*, they will first be shifted into range *(-M,M)*, which means that the\n+output will again be in *(-2M,M)*, and this remains the case regardless of how many `update_de`\n+invocations there are. In what follows, we will try to make this more efficient.\n+\n+Note that increasing *d* by *M* is equal to incrementing *cd* by *u&thinsp;M* and *ce* by *q&thinsp;M*. Similarly,\n+increasing *e* by *M* is equal to incrementing *cd* by *v&thinsp;M* and *ce* by *r&thinsp;M*. So we could instead write:\n+\n+```python\n+    ...\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Perform the equivalent of incrementing d, e by M when they're negative.\n+    if d < 0:\n+        cd += u*M\n+        ce += q*M\n+    if e < 0:\n+        cd += v*M\n+        ce += r*M\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    ...\n+```\n+\n+Now note that we have two steps of corrections to *cd* and *ce* that add multiples of *M*: this\n+increment, and the decrement that cancels out bottom bits. The second one depends on the first\n+one, but they can still be efficiently combined by only computing the bottom bits of *cd* and *ce*\n+at first, and using that to compute the final *md*, *me* values:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    md, me = 0, 0\n+    # Compute what multiples of M to add to cd and ce.\n+    if d < 0:\n+        md += u\n+        me += q\n+    if e < 0:\n+        md += v\n+        me += r\n+    # Compute bottom N bits of t*[d,e] + M*[md,me].\n+    cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.\n+    md -= (Mi * cd) % 2**N\n+    me -= (Mi * ce) % 2**N\n+    # Do the full computation.\n+    cd, ce = u*d + v*e + md*M, q*d + r*e + me*M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+One last optimization: we can avoid the *md&thinsp;M* and *me&thinsp;M* multiplications in the bottom bits of *cd*\n+and *ce* by moving them to the *md* and *me* correction:\n+\n+```python\n+    ...\n+    # Compute bottom N bits of t*[d,e].\n+    cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.\n+    # Note that this is not the same as {md = (Mi * cd) % 2**N} etc. That would also result in N\n+    # zero bottom bits, but isn't guaranteed to be a reduction of [0,2^N) compared to the\n+    # previous md and me values, and thus would violate our bounds analysis.\n+    md -= (Mi*cd + md) % 2**N\n+    me -= (Mi*ce + me) % 2**N\n+    ...\n+```\n+\n+The resulting function takes *d* and *e* in range *(-2M,M)* as inputs, and outputs values in the same\n+range. That also means that the *d* value at the end of `modinv` will be in that range, while we want\n+a result in *[0,M)*. To do that, we need a normalization function. It's easy to integrate the\n+conditional negation of *d* (based on the sign of *f*) into it as well:\n+\n+```python\n+def normalize(sign, v, M):\n+    \"\"\"Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).\"\"\"\n+    assert sign == 1 or sign == -1\n+    # v in (-2*M,M)\n+    if v < 0:\n+        v += M\n+    # v in (-M,M). Now multiply v with sign (which can only be 1 or -1).\n+    if sign == -1:\n+        v = -v\n+    # v in (-M,M)\n+    if v < 0:\n+        v += M\n+    # v in [0,M)\n+    return v\n+```\n+\n+And calling it in `modinv` is simply:\n+\n+```python\n+   ...\n+   return normalize(f, d, M)\n+```\n+\n+\n+## 5. Constant-time operation\n+\n+The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+depends on the input data so far?\n+\n+- the number of iterations of the while *g &ne; 0* loop in `modinv`\n+- the branches inside `divsteps_n_matrix`\n+- the sign checks in `update_de`\n+- the sign checks in `normalize`\n+\n+To make the while loop in `modinv` constant time it can be replaced with a constant number of\n+iterations. The paper proves (Theorem 11.2) that *741* divsteps are sufficient for any *256*-bit\n+inputs, and [safegcd-bounds](https://github.com/sipa/safegcd-bounds) shows that the slightly better bound *724* is\n+sufficient even. Given that every loop iteration performs *N* divsteps, it will run a total of\n+*&lceil;724/N&rceil;* times.\n+\n+To deal with the branches in `divsteps_n_matrix` we will replace them with constant-time bitwise\n+operations (and hope the C compiler isn't smart enough to turn them back into branches; see\n+`valgrind_ctime_test.c` for automated tests that this isn't the case). To do so, observe that a\n+divstep can be written instead as (compare to the inner loop of `gcd` in section 1).\n+\n+```python\n+    x = -f if delta > 0 else f         # set x equal to (input) -f or f\n+    if g & 1:\n+        g += x                         # set g to (input) g-f or g+f\n+        if delta > 0:\n+            delta = -delta\n+            f += g                     # set f to (input) g (note that g was set to g-f before)\n+    delta += 1\n+    g >>= 1\n+```\n+\n+To convert the above to bitwise operations, we rely on a trick to negate conditionally: per the\n+definition of negative numbers in two's complement, (*-v == ~v + 1*) holds for every number *v*. As\n+*-1* in two's complement is all *1* bits, bitflipping can be expressed as xor with *-1*. It follows\n+that *-v == (v ^ -1) - (-1)*. Thus, if we have a variable *c* that takes on values *0* or *-1*, then\n+*(v ^ c) - c* is *v* if *c=0* and *-v* if *c=-1*.\n+\n+Using this we can write:\n+\n+```python\n+    x = -f if delta > 0 else f\n+```\n+\n+in constant-time form as:\n+\n+```python\n+    c1 = (-delta) >> 63\n+    # Conditionally negate f based on c1:\n+    x = (f ^ c1) - c1\n+```\n+\n+To use that trick, we need a helper mask variable *c1* that resolves the condition *&delta;>0* to *-1*\n+(if true) or *0* (if false). We compute *c1* using right shifting, which always rounds down (in\n+Python, and also in C under the assumption of a typical two's complement system; see\n+`assumptions.h` for tests that this is the case).\n+\n+Using the facts that *x&0=0* and *x&(-1)=x* (on two's complement systems again), we can write:\n+\n+```python\n+    if g & 1:\n+        g += x\n+```\n+\n+as:\n+\n+```python\n+    # Compute c2=0 if g is even and c2=-1 if g is odd.\n+    c2 = -(g & 1)\n+    # This masks out x if g is even, and leaves x be if g is odd.\n+    g += x & c2\n+```\n+\n+Using the conditional negation trick again we can write:\n+\n+```python\n+    if g & 1:\n+        if delta > 0:\n+            delta = -delta\n+```\n+\n+as:\n+\n+```python\n+    # Compute c3=-1 if g is odd and delta>0, and 0 otherwise.\n+    c3 = c1 & c2\n+    # Conditionally negate delta based on c3:\n+    delta = (delta ^ c3) - c3\n+```\n+\n+Finally:\n+\n+```python\n+    if g & 1:\n+        if delta > 0:\n+            f += g\n+```\n+\n+becomes:\n+\n+```python\n+    f += g & c3\n+```\n+\n+It turns out that this can be implemented more efficiently by applying the substitution\n+*&eta;=-&delta;*. In this representation, negating *&delta;* corresponds to negating *&eta;*, and incrementing\n+*&delta;* corresponds to decrementing *&eta;*. This allows us to remove the negation in the *c1*\n+computation:\n+\n+```python\n+    # Compute a mask c1 for eta < 0, and compute the conditional negation x of f:\n+    c1 = eta >> 63\n+    x = (f ^ c1) - c1\n+    # Compute a mask c2 for odd g, and conditionally add x to g:\n+    c2 = -(g & 1)\n+    g += x & c2\n+    # Compute a mask c for (eta < 0) and odd (input) g, and use it to conditionally negate eta,\n+    # and add g to f:\n+    c3 = c1 & c2\n+    eta = (eta ^ c3) - c3\n+    f += g & c3\n+    # Incrementing delta corresponds to decrementing eta.\n+    eta -= 1\n+    g >>= 1\n+```\n+\n+By replacing the loop in `divsteps_n_matrix` with a variant of the divstep code above (extended to\n+also apply all *f* operations to *u*, *v* and all *g* operations to *q*, *r*), a constant-time version of\n+`divsteps_n_matrix` is obtained. The full code will be in section 7.\n+\n+These bit fiddling tricks can also be used to make the conditional negations and additions in\n+`update_de` and `normalize` constant-time.\n+\n+\n+## 6. Variable-time optimizations\n+\n+In section 5, we modified the `divsteps_n_matrix` function (and a few others) to be constant time.\n+Constant time operations are only necessary when computing modular inverses of secret data. In\n+other cases, it slows down calculations unnecessarily. In this section, we will construct a\n+faster non-constant time `divsteps_n_matrix` function.\n+\n+To do so, first consider yet another way of writing the inner loop of divstep operations in\n+`gcd` from section 1. This decomposition is also explained in the paper in section 8.2.\n+\n+```python\n+for _ in range(N):\n+    if g & 1 and eta < 0:\n+        eta, f, g = -eta, g, -f\n+    if g & 1:\n+        g += f\n+    eta -= 1\n+    g >>= 1\n+```\n+\n+Whenever *g* is even, the loop only shifts *g* down and decreases *&eta;*. When *g* ends in multiple zero\n+bits, these iterations can be consolidated into one step. This requires counting the bottom zero\n+bits efficiently, which is possible on most platforms; it is abstracted here as the function\n+`count_trailing_zeros`.",
      "path": "doc/safegcd_implementation.md",
      "position": 553,
      "original_position": 552,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Please add a possible definition of `count_trailing_zeros`. Then the reader can easier play around with it.  This one seems nice to me: https://stackoverflow.com/a/63552117",
      "created_at": "2021-01-15T10:47:20Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558225651",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558225651"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 553,
      "original_line": 553,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558567812",
      "pull_request_review_id": 569585980,
      "id": 558567812,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU2NzgxMg==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.\n+  - For (b), we know that *f* is odd, so *gcd(f,g)* clearly has no factor *2*, and we can remove\n+    it from *g*.\n+- The algorithm will eventually converge to *g=0*. This is proven in the paper (see theorem G.3).\n+- It follows that eventually we find a final value *f'* for which *gcd(f,g) = gcd(f',0)*. As the\n+  gcd of *f'* and *0* is *|f'|* by definition, that is our answer.\n+\n+Compared to more [traditional GCD algorithms](https://en.wikipedia.org/wiki/Euclidean_algorithm), this one has the property of only ever looking at\n+the low-order bits of the variables to decide the next steps, and being easy to make\n+constant-time (in more low-level languages than Python). The *&delta;* parameter is necessary to\n+guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+at high order bits.\n+\n+Properties that will become important later:\n+- Performing more divsteps than needed is not a problem, as *f* does not change anymore after *g=0*.\n+- Only even numbers are divided by *2*. This means that when reasoning about it algebraically we\n+  do not need to worry about rounding.\n+- At every point during the algorithm's execution the next *N* steps only depend on the bottom *N*\n+  bits of *f* and *g*, and on *&delta;*.\n+\n+\n+## 2. From GCDs to modular inverses\n+\n+We want an algorithm to compute the inverse *a* of *x* modulo *M*, i.e. the number a such that *a&thinsp;x=1\n+mod M*. This inverse only exists if the GCD of *x* and *M* is *1*, but that is always the case if *M* is\n+prime and *0 < x < M*. In what follows, assume that the modular inverse exists.\n+It turns out this inverse can be computed as a side effect of computing the GCD by keeping track\n+of how the internal variables can be written as linear combinations of the inputs at every step\n+(see the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)).\n+Since the GCD is *1*, such an algorithm will compute numbers *a* and *b* such that a&thinsp;x + b&thinsp;M = 1*.\n+Taking that expression *mod M* gives *a&thinsp;x mod M = 1*, and we see that *a* is the modular inverse of *x\n+mod M*.\n+\n+A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+algorithm shown above, if the modulus *M* is odd. To do so, compute *gcd(f=M,g=x)*, while keeping\n+track of extra variables *d* and *e*, for which at every step *d = f/x (mod M)* and *e = g/x (mod M)*.\n+*f/x* here means the number which multiplied with *x* gives *f mod M*. As *f* and *g* are initialized to *M*\n+and *x* respectively, *d* and *e* just start off being *0* (*M/x mod M = 0/x mod M = 0*) and *1* (*x/x mod M\n+= 1*).\n+\n+```python\n+def div2(M, x):\n+    \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+    assert M & 1\n+    if x & 1: # If x is odd, make it even by adding M.\n+        x += M\n+    # x must be even now, so a clean division by 2 is possible.\n+    return x // 2\n+\n+def modinv(M, x):\n+    \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Note that while division by two for f and g is only ever done on even inputs, this is\n+        # not true for d and e, so we need the div2 helper function.\n+        if delta > 0 and g & 1:\n+            delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+        elif g & 1:\n+            delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+        else:\n+            delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+        # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+        assert f % M == (d * x) % M\n+        assert g % M == (e * x) % M\n+    assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+    # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+    return (d * f) % M\n+```\n+\n+Also note that this approach to track *d* and *e* throughout the computation to determine the inverse\n+is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+entire computation is determined (see section 3 below) and the inverse is computed from that.\n+The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+be faster at the level of optimization we're able to do in C.\n+\n+\n+## 3. Batching multiple divsteps\n+\n+Every divstep can be expressed as a matrix multiplication, applying a transition matrix *(1/2 t)*\n+to both vectors *[f, g]* and *[d, e]* (see paragraph 8.1 in the paper):\n+\n+```\n+  t = [ u,  v ]\n+      [ q,  r ]\n+\n+  [ out_f ] = (1/2 * t) * [ in_f ]\n+  [ out_g ] =             [ in_g ]\n+\n+  [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+  [ out_e ]               [ in_e ]\n+```\n+\n+where *(u, v, q, r)* is *(0, 2, -1, 1)*, *(2, 0, 1, 1)*, or *(2, 0, 0, 1)*, depending on which branch is\n+taken. As above, the resulting *f* and *g* are always integers.\n+\n+Performing multiple divsteps corresponds to a multiplication with the product of all the\n+individual divsteps' transition matrices. As each transition matrix consists of integers\n+divided by *2*, the product of these matrices will consist of integers divided by *2<sup>N</sup>* (see also\n+theorem 9.2 in the paper). These divisions are expensive when updating *d* and *e*, so we delay\n+them: we compute the integer coefficients of the combined transition matrix scaled by *2<sup>N</sup>*, and\n+do one division by *2<sup>N</sup>* as a final step:\n+\n+```python\n+def divsteps_n_matrix(delta, f, g):\n+    \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+    for _ in range(N):\n+        if delta > 0 and g & 1:\n+            delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+        elif g & 1:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+        else:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+    return delta, (u, v, q, r)\n+```\n+\n+As the branches in the divsteps are completely determined by the bottom *N* bits of *f* and *g*, this\n+function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+intermediate results and outputs fit in *(N+1)*-bit numbers (unsigned for *f* and *g*; signed for *u*, *v*,\n+*q*, and *r*) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+integers could set *N=62* and compute the full transition matrix for 62 steps at once without any\n+big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+to update the full-size *f*, *g*, *d*, and *e* numbers once every *N* steps.\n+\n+We still need functions to compute:\n+\n+```\n+  [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+  [ out_g ]   (        [ q,  r ])   [ in_g ]\n+\n+  [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+  [ out_e ]   (        [ q,  r ])   [ in_e ]\n+```\n+\n+Because the divsteps transformation only ever divides even numbers by two, the result of *t&thinsp;[f,g]* is always even. When *t* is a composition of *N* divsteps, it follows that the resulting *f*\n+and *g* will be multiple of *2<sup>N</sup>*, and division by *2<sup>N</sup>* is simply shifting them down:\n+\n+```python\n+def update_fg(f, g, t):\n+    \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+    u, v, q, r = t\n+    cf, cg = u*f + v*g, q*f + r*g\n+    # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+    # bottom bits.\n+    assert cf % 2**N == 0\n+    assert cg % 2**N == 0\n+    return cf >> N, cg >> N\n+```\n+\n+The same is not true for *d* and *e*, and we need an equivalent of the `div2` function for division by *2<sup>N</sup> mod M*.\n+This is easy if we have precomputed *1/M mod 2<sup>N</sup>* (which always exists for odd *M*):\n+\n+```python\n+def div2n(M, Mi, x):\n+    \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+    assert (M * Mi) % 2**N == 1\n+    # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+    #     (m * M) mod 2^N = x mod 2^N\n+    # <=> m mod 2^N = (x / M) mod 2^N\n+    # <=> m mod 2^N = (x * Mi) mod 2^N\n+    m = (Mi * x) % 2**N\n+    # Subtract that multiple from x, cancelling its bottom N bits.\n+    x -= m * M\n+    # Now a clean division by 2^N is possible.\n+    assert x % 2**N == 0\n+    return (x >> N) % M\n+\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+```\n+\n+With all of those, we can write a version of `modinv` that performs *N* divsteps at once:\n+\n+```python3\n+def modinv(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+        # (N+1)-bit signed integer arithmetic).\n+        delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+        # Apply the transition matrix t to [f, g]:\n+        f, g = update_fg(f, g, t)\n+        # Apply the transition matrix t to [d, e]:\n+        d, e = update_de(d, e, t, M, Mi)\n+    return (d * f) % M\n+```\n+\n+This means that in practice we'll always perform a multiple of *N* divsteps. This is not a problem\n+because once *g=0*, further divsteps do not affect *f*, *g*, *d*, or *e* anymore (only *&delta;* keeps\n+increasing). For variable time code such excess iterations will be mostly optimized away in\n+section 6.\n+\n+\n+## 4. Avoiding modulus operations\n+\n+So far, there are two places where we compute a remainder of big numbers modulo *M*: at the end of\n+`div2n` in every `update_de`, and at the very end of `modinv` after potentially negating *d* due to the\n+sign of *f*. These are relatively expensive operations when done generically.\n+\n+To deal with the modulus operation in `div2n`, we simply stop requiring *d* and *e* to be in range\n+*[0,M)* all the time. Let's start by inlining `div2n` into `update_de`, and dropping the modulus\n+operation at the end:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+Let's look at bounds on the ranges of these numbers. It can be shown that *|u|+|v|* and *|q|+|r|*\n+never exceed *2<sup>N</sup>* (see paragraph 8.3 in the paper), and thus a multiplication with *t* will have\n+outputs whose absolute values are at most *2<sup>N</sup>* times the maximum absolute input value. In case the\n+inputs *d* and *e* are in *(-M,M)*, which is certainly true for the initial values *d=0* and *e=1* assuming\n+*M > 1*, the multiplication results in numbers in range *(-2<sup>N</sup>M,2<sup>N</sup>M)*. Subtracting up to *2<sup>N</sup>-1*\n+times *M* to cancel out *N* bits brings that up to slightly less than *(-2<sup>N+1</sup>M,2<sup>N</sup>M)*, and",
      "path": "doc/safegcd_implementation.md",
      "position": null,
      "original_position": 280,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": 558154372,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've changed it to the rounding up front. Is it clearer now?",
      "created_at": "2021-01-15T20:10:21Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558567812",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558567812"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558569726",
      "pull_request_review_id": 569588531,
      "id": 558569726,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU2OTcyNg==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.",
      "path": "doc/safegcd_implementation.md",
      "position": 52,
      "original_position": 52,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": 558161444,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe it is the case that any linear transformation `f' = u*f + v*g; g' = q*f + r*g;`, which is (a) reversible and (b) has gcd(u,v)=1 gcd(q,r)=1 so it doesn't introduce new factors has this property of not affecting the overall gcd. Do you think there is another way of formulating this which is easier?",
      "created_at": "2021-01-15T20:14:38Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558569726",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558569726"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 52,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558569861",
      "pull_request_review_id": 569588746,
      "id": 558569861,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU2OTg2MQ==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.\n+  - For (b), we know that *f* is odd, so *gcd(f,g)* clearly has no factor *2*, and we can remove\n+    it from *g*.\n+- The algorithm will eventually converge to *g=0*. This is proven in the paper (see theorem G.3).\n+- It follows that eventually we find a final value *f'* for which *gcd(f,g) = gcd(f',0)*. As the\n+  gcd of *f'* and *0* is *|f'|* by definition, that is our answer.\n+\n+Compared to more [traditional GCD algorithms](https://en.wikipedia.org/wiki/Euclidean_algorithm), this one has the property of only ever looking at\n+the low-order bits of the variables to decide the next steps, and being easy to make\n+constant-time (in more low-level languages than Python). The *&delta;* parameter is necessary to\n+guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+at high order bits.\n+\n+Properties that will become important later:\n+- Performing more divsteps than needed is not a problem, as *f* does not change anymore after *g=0*.\n+- Only even numbers are divided by *2*. This means that when reasoning about it algebraically we\n+  do not need to worry about rounding.\n+- At every point during the algorithm's execution the next *N* steps only depend on the bottom *N*\n+  bits of *f* and *g*, and on *&delta;*.\n+\n+\n+## 2. From GCDs to modular inverses\n+\n+We want an algorithm to compute the inverse *a* of *x* modulo *M*, i.e. the number a such that *a&thinsp;x=1\n+mod M*. This inverse only exists if the GCD of *x* and *M* is *1*, but that is always the case if *M* is\n+prime and *0 < x < M*. In what follows, assume that the modular inverse exists.\n+It turns out this inverse can be computed as a side effect of computing the GCD by keeping track\n+of how the internal variables can be written as linear combinations of the inputs at every step\n+(see the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)).\n+Since the GCD is *1*, such an algorithm will compute numbers *a* and *b* such that a&thinsp;x + b&thinsp;M = 1*.\n+Taking that expression *mod M* gives *a&thinsp;x mod M = 1*, and we see that *a* is the modular inverse of *x\n+mod M*.\n+\n+A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+algorithm shown above, if the modulus *M* is odd. To do so, compute *gcd(f=M,g=x)*, while keeping\n+track of extra variables *d* and *e*, for which at every step *d = f/x (mod M)* and *e = g/x (mod M)*.\n+*f/x* here means the number which multiplied with *x* gives *f mod M*. As *f* and *g* are initialized to *M*\n+and *x* respectively, *d* and *e* just start off being *0* (*M/x mod M = 0/x mod M = 0*) and *1* (*x/x mod M\n+= 1*).\n+\n+```python\n+def div2(M, x):\n+    \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+    assert M & 1\n+    if x & 1: # If x is odd, make it even by adding M.\n+        x += M\n+    # x must be even now, so a clean division by 2 is possible.\n+    return x // 2\n+\n+def modinv(M, x):\n+    \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Note that while division by two for f and g is only ever done on even inputs, this is\n+        # not true for d and e, so we need the div2 helper function.\n+        if delta > 0 and g & 1:\n+            delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+        elif g & 1:\n+            delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+        else:\n+            delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+        # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+        assert f % M == (d * x) % M\n+        assert g % M == (e * x) % M\n+    assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+    # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+    return (d * f) % M\n+```\n+\n+Also note that this approach to track *d* and *e* throughout the computation to determine the inverse\n+is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+entire computation is determined (see section 3 below) and the inverse is computed from that.\n+The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+be faster at the level of optimization we're able to do in C.\n+\n+\n+## 3. Batching multiple divsteps\n+\n+Every divstep can be expressed as a matrix multiplication, applying a transition matrix *(1/2 t)*\n+to both vectors *[f, g]* and *[d, e]* (see paragraph 8.1 in the paper):\n+\n+```\n+  t = [ u,  v ]\n+      [ q,  r ]\n+\n+  [ out_f ] = (1/2 * t) * [ in_f ]\n+  [ out_g ] =             [ in_g ]\n+\n+  [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+  [ out_e ]               [ in_e ]\n+```\n+\n+where *(u, v, q, r)* is *(0, 2, -1, 1)*, *(2, 0, 1, 1)*, or *(2, 0, 0, 1)*, depending on which branch is\n+taken. As above, the resulting *f* and *g* are always integers.\n+\n+Performing multiple divsteps corresponds to a multiplication with the product of all the\n+individual divsteps' transition matrices. As each transition matrix consists of integers\n+divided by *2*, the product of these matrices will consist of integers divided by *2<sup>N</sup>* (see also\n+theorem 9.2 in the paper). These divisions are expensive when updating *d* and *e*, so we delay\n+them: we compute the integer coefficients of the combined transition matrix scaled by *2<sup>N</sup>*, and\n+do one division by *2<sup>N</sup>* as a final step:\n+\n+```python\n+def divsteps_n_matrix(delta, f, g):\n+    \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+    for _ in range(N):\n+        if delta > 0 and g & 1:\n+            delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+        elif g & 1:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+        else:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+    return delta, (u, v, q, r)\n+```\n+\n+As the branches in the divsteps are completely determined by the bottom *N* bits of *f* and *g*, this\n+function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+intermediate results and outputs fit in *(N+1)*-bit numbers (unsigned for *f* and *g*; signed for *u*, *v*,\n+*q*, and *r*) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+integers could set *N=62* and compute the full transition matrix for 62 steps at once without any\n+big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+to update the full-size *f*, *g*, *d*, and *e* numbers once every *N* steps.\n+\n+We still need functions to compute:\n+\n+```\n+  [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+  [ out_g ]   (        [ q,  r ])   [ in_g ]\n+\n+  [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+  [ out_e ]   (        [ q,  r ])   [ in_e ]\n+```\n+\n+Because the divsteps transformation only ever divides even numbers by two, the result of *t&thinsp;[f,g]* is always even. When *t* is a composition of *N* divsteps, it follows that the resulting *f*\n+and *g* will be multiple of *2<sup>N</sup>*, and division by *2<sup>N</sup>* is simply shifting them down:\n+\n+```python\n+def update_fg(f, g, t):\n+    \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+    u, v, q, r = t\n+    cf, cg = u*f + v*g, q*f + r*g\n+    # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+    # bottom bits.\n+    assert cf % 2**N == 0\n+    assert cg % 2**N == 0\n+    return cf >> N, cg >> N\n+```\n+\n+The same is not true for *d* and *e*, and we need an equivalent of the `div2` function for division by *2<sup>N</sup> mod M*.\n+This is easy if we have precomputed *1/M mod 2<sup>N</sup>* (which always exists for odd *M*):\n+\n+```python\n+def div2n(M, Mi, x):\n+    \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+    assert (M * Mi) % 2**N == 1\n+    # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+    #     (m * M) mod 2^N = x mod 2^N\n+    # <=> m mod 2^N = (x / M) mod 2^N\n+    # <=> m mod 2^N = (x * Mi) mod 2^N\n+    m = (Mi * x) % 2**N\n+    # Subtract that multiple from x, cancelling its bottom N bits.\n+    x -= m * M\n+    # Now a clean division by 2^N is possible.\n+    assert x % 2**N == 0\n+    return (x >> N) % M\n+\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+```\n+\n+With all of those, we can write a version of `modinv` that performs *N* divsteps at once:\n+\n+```python3\n+def modinv(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+        # (N+1)-bit signed integer arithmetic).\n+        delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+        # Apply the transition matrix t to [f, g]:\n+        f, g = update_fg(f, g, t)\n+        # Apply the transition matrix t to [d, e]:\n+        d, e = update_de(d, e, t, M, Mi)\n+    return (d * f) % M\n+```\n+\n+This means that in practice we'll always perform a multiple of *N* divsteps. This is not a problem\n+because once *g=0*, further divsteps do not affect *f*, *g*, *d*, or *e* anymore (only *&delta;* keeps\n+increasing). For variable time code such excess iterations will be mostly optimized away in\n+section 6.\n+\n+\n+## 4. Avoiding modulus operations\n+\n+So far, there are two places where we compute a remainder of big numbers modulo *M*: at the end of\n+`div2n` in every `update_de`, and at the very end of `modinv` after potentially negating *d* due to the\n+sign of *f*. These are relatively expensive operations when done generically.\n+\n+To deal with the modulus operation in `div2n`, we simply stop requiring *d* and *e* to be in range\n+*[0,M)* all the time. Let's start by inlining `div2n` into `update_de`, and dropping the modulus\n+operation at the end:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+Let's look at bounds on the ranges of these numbers. It can be shown that *|u|+|v|* and *|q|+|r|*\n+never exceed *2<sup>N</sup>* (see paragraph 8.3 in the paper), and thus a multiplication with *t* will have\n+outputs whose absolute values are at most *2<sup>N</sup>* times the maximum absolute input value. In case the\n+inputs *d* and *e* are in *(-M,M)*, which is certainly true for the initial values *d=0* and *e=1* assuming\n+*M > 1*, the multiplication results in numbers in range *(-2<sup>N</sup>M,2<sup>N</sup>M)*. Subtracting up to *2<sup>N</sup>-1*\n+times *M* to cancel out *N* bits brings that up to slightly less than *(-2<sup>N+1</sup>M,2<sup>N</sup>M)*, and\n+dividing by *2<sup>N</sup>* at the end takes it to *(-2M,M)*. Another application of `update_de` would take that\n+to *(-3M,2M)*, and so forth. This progressive expansion of the variables' ranges can be\n+counteracted by incrementing *d* and *e* by *M* whenever they're negative:\n+\n+```python\n+    ...\n+    if d < 0:\n+        d += M\n+    if e < 0:\n+        e += M\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    ...\n+```\n+\n+With inputs in *(-2M,M)*, they will first be shifted into range *(-M,M)*, which means that the\n+output will again be in *(-2M,M)*, and this remains the case regardless of how many `update_de`\n+invocations there are. In what follows, we will try to make this more efficient.\n+\n+Note that increasing *d* by *M* is equal to incrementing *cd* by *u&thinsp;M* and *ce* by *q&thinsp;M*. Similarly,\n+increasing *e* by *M* is equal to incrementing *cd* by *v&thinsp;M* and *ce* by *r&thinsp;M*. So we could instead write:\n+\n+```python\n+    ...\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Perform the equivalent of incrementing d, e by M when they're negative.\n+    if d < 0:\n+        cd += u*M\n+        ce += q*M\n+    if e < 0:\n+        cd += v*M\n+        ce += r*M\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    ...\n+```\n+\n+Now note that we have two steps of corrections to *cd* and *ce* that add multiples of *M*: this\n+increment, and the decrement that cancels out bottom bits. The second one depends on the first\n+one, but they can still be efficiently combined by only computing the bottom bits of *cd* and *ce*\n+at first, and using that to compute the final *md*, *me* values:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    md, me = 0, 0\n+    # Compute what multiples of M to add to cd and ce.\n+    if d < 0:\n+        md += u\n+        me += q\n+    if e < 0:\n+        md += v\n+        me += r\n+    # Compute bottom N bits of t*[d,e] + M*[md,me].\n+    cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.\n+    md -= (Mi * cd) % 2**N\n+    me -= (Mi * ce) % 2**N\n+    # Do the full computation.\n+    cd, ce = u*d + v*e + md*M, q*d + r*e + me*M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+One last optimization: we can avoid the *md&thinsp;M* and *me&thinsp;M* multiplications in the bottom bits of *cd*\n+and *ce* by moving them to the *md* and *me* correction:\n+\n+```python\n+    ...\n+    # Compute bottom N bits of t*[d,e].\n+    cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.\n+    # Note that this is not the same as {md = (Mi * cd) % 2**N} etc. That would also result in N\n+    # zero bottom bits, but isn't guaranteed to be a reduction of [0,2^N) compared to the\n+    # previous md and me values, and thus would violate our bounds analysis.\n+    md -= (Mi*cd + md) % 2**N\n+    me -= (Mi*ce + me) % 2**N\n+    ...\n+```\n+\n+The resulting function takes *d* and *e* in range *(-2M,M)* as inputs, and outputs values in the same\n+range. That also means that the *d* value at the end of `modinv` will be in that range, while we want\n+a result in *[0,M)*. To do that, we need a normalization function. It's easy to integrate the\n+conditional negation of *d* (based on the sign of *f*) into it as well:\n+\n+```python\n+def normalize(sign, v, M):\n+    \"\"\"Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).\"\"\"\n+    assert sign == 1 or sign == -1\n+    # v in (-2*M,M)\n+    if v < 0:\n+        v += M\n+    # v in (-M,M). Now multiply v with sign (which can only be 1 or -1).\n+    if sign == -1:\n+        v = -v\n+    # v in (-M,M)\n+    if v < 0:\n+        v += M\n+    # v in [0,M)\n+    return v\n+```\n+\n+And calling it in `modinv` is simply:\n+\n+```python\n+   ...\n+   return normalize(f, d, M)\n+```\n+\n+\n+## 5. Constant-time operation\n+\n+The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+depends on the input data so far?\n+\n+- the number of iterations of the while *g &ne; 0* loop in `modinv`\n+- the branches inside `divsteps_n_matrix`\n+- the sign checks in `update_de`\n+- the sign checks in `normalize`\n+\n+To make the while loop in `modinv` constant time it can be replaced with a constant number of\n+iterations. The paper proves (Theorem 11.2) that *741* divsteps are sufficient for any *256*-bit\n+inputs, and [safegcd-bounds](https://github.com/sipa/safegcd-bounds) shows that the slightly better bound *724* is\n+sufficient even. Given that every loop iteration performs *N* divsteps, it will run a total of\n+*&lceil;724/N&rceil;* times.\n+\n+To deal with the branches in `divsteps_n_matrix` we will replace them with constant-time bitwise\n+operations (and hope the C compiler isn't smart enough to turn them back into branches; see\n+`valgrind_ctime_test.c` for automated tests that this isn't the case). To do so, observe that a\n+divstep can be written instead as (compare to the inner loop of `gcd` in section 1).\n+\n+```python\n+    x = -f if delta > 0 else f         # set x equal to (input) -f or f\n+    if g & 1:\n+        g += x                         # set g to (input) g-f or g+f\n+        if delta > 0:\n+            delta = -delta\n+            f += g                     # set f to (input) g (note that g was set to g-f before)\n+    delta += 1\n+    g >>= 1\n+```\n+\n+To convert the above to bitwise operations, we rely on a trick to negate conditionally: per the\n+definition of negative numbers in two's complement, (*-v == ~v + 1*) holds for every number *v*. As\n+*-1* in two's complement is all *1* bits, bitflipping can be expressed as xor with *-1*. It follows\n+that *-v == (v ^ -1) - (-1)*. Thus, if we have a variable *c* that takes on values *0* or *-1*, then\n+*(v ^ c) - c* is *v* if *c=0* and *-v* if *c=-1*.\n+\n+Using this we can write:\n+\n+```python\n+    x = -f if delta > 0 else f\n+```\n+\n+in constant-time form as:\n+\n+```python\n+    c1 = (-delta) >> 63\n+    # Conditionally negate f based on c1:\n+    x = (f ^ c1) - c1\n+```\n+\n+To use that trick, we need a helper mask variable *c1* that resolves the condition *&delta;>0* to *-1*\n+(if true) or *0* (if false). We compute *c1* using right shifting, which always rounds down (in\n+Python, and also in C under the assumption of a typical two's complement system; see\n+`assumptions.h` for tests that this is the case).",
      "path": "doc/safegcd_implementation.md",
      "position": null,
      "original_position": 450,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": 558212388,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've reformulated this.",
      "created_at": "2021-01-15T20:14:57Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558569861",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558569861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 450,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558570475",
      "pull_request_review_id": 569589458,
      "id": 558570475,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU3MDQ3NQ==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:",
      "path": "doc/safegcd_implementation.md",
      "position": null,
      "original_position": 14,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": 558220985,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done; the right reference is chapter 11 actually. Appendix E gives a very different algorithm, which is then proven to be equivalent to safegcd.",
      "created_at": "2021-01-15T20:16:05Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558570475",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558570475"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558570518",
      "pull_request_review_id": 569589524,
      "id": 558570518,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU3MDUxOA==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.\n+  - For (b), we know that *f* is odd, so *gcd(f,g)* clearly has no factor *2*, and we can remove\n+    it from *g*.\n+- The algorithm will eventually converge to *g=0*. This is proven in the paper (see theorem G.3).\n+- It follows that eventually we find a final value *f'* for which *gcd(f,g) = gcd(f',0)*. As the\n+  gcd of *f'* and *0* is *|f'|* by definition, that is our answer.\n+\n+Compared to more [traditional GCD algorithms](https://en.wikipedia.org/wiki/Euclidean_algorithm), this one has the property of only ever looking at\n+the low-order bits of the variables to decide the next steps, and being easy to make\n+constant-time (in more low-level languages than Python). The *&delta;* parameter is necessary to\n+guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+at high order bits.\n+\n+Properties that will become important later:\n+- Performing more divsteps than needed is not a problem, as *f* does not change anymore after *g=0*.\n+- Only even numbers are divided by *2*. This means that when reasoning about it algebraically we\n+  do not need to worry about rounding.\n+- At every point during the algorithm's execution the next *N* steps only depend on the bottom *N*\n+  bits of *f* and *g*, and on *&delta;*.\n+\n+\n+## 2. From GCDs to modular inverses\n+\n+We want an algorithm to compute the inverse *a* of *x* modulo *M*, i.e. the number a such that *a&thinsp;x=1\n+mod M*. This inverse only exists if the GCD of *x* and *M* is *1*, but that is always the case if *M* is\n+prime and *0 < x < M*. In what follows, assume that the modular inverse exists.\n+It turns out this inverse can be computed as a side effect of computing the GCD by keeping track\n+of how the internal variables can be written as linear combinations of the inputs at every step\n+(see the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)).\n+Since the GCD is *1*, such an algorithm will compute numbers *a* and *b* such that a&thinsp;x + b&thinsp;M = 1*.\n+Taking that expression *mod M* gives *a&thinsp;x mod M = 1*, and we see that *a* is the modular inverse of *x\n+mod M*.\n+\n+A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+algorithm shown above, if the modulus *M* is odd. To do so, compute *gcd(f=M,g=x)*, while keeping\n+track of extra variables *d* and *e*, for which at every step *d = f/x (mod M)* and *e = g/x (mod M)*.\n+*f/x* here means the number which multiplied with *x* gives *f mod M*. As *f* and *g* are initialized to *M*\n+and *x* respectively, *d* and *e* just start off being *0* (*M/x mod M = 0/x mod M = 0*) and *1* (*x/x mod M\n+= 1*).\n+\n+```python\n+def div2(M, x):\n+    \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+    assert M & 1\n+    if x & 1: # If x is odd, make it even by adding M.\n+        x += M\n+    # x must be even now, so a clean division by 2 is possible.\n+    return x // 2\n+\n+def modinv(M, x):\n+    \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Note that while division by two for f and g is only ever done on even inputs, this is\n+        # not true for d and e, so we need the div2 helper function.\n+        if delta > 0 and g & 1:\n+            delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+        elif g & 1:\n+            delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+        else:\n+            delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+        # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+        assert f % M == (d * x) % M\n+        assert g % M == (e * x) % M\n+    assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+    # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+    return (d * f) % M\n+```\n+\n+Also note that this approach to track *d* and *e* throughout the computation to determine the inverse\n+is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+entire computation is determined (see section 3 below) and the inverse is computed from that.\n+The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+be faster at the level of optimization we're able to do in C.\n+\n+\n+## 3. Batching multiple divsteps\n+\n+Every divstep can be expressed as a matrix multiplication, applying a transition matrix *(1/2 t)*\n+to both vectors *[f, g]* and *[d, e]* (see paragraph 8.1 in the paper):\n+\n+```\n+  t = [ u,  v ]\n+      [ q,  r ]\n+\n+  [ out_f ] = (1/2 * t) * [ in_f ]\n+  [ out_g ] =             [ in_g ]\n+\n+  [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+  [ out_e ]               [ in_e ]\n+```\n+\n+where *(u, v, q, r)* is *(0, 2, -1, 1)*, *(2, 0, 1, 1)*, or *(2, 0, 0, 1)*, depending on which branch is\n+taken. As above, the resulting *f* and *g* are always integers.\n+\n+Performing multiple divsteps corresponds to a multiplication with the product of all the\n+individual divsteps' transition matrices. As each transition matrix consists of integers\n+divided by *2*, the product of these matrices will consist of integers divided by *2<sup>N</sup>* (see also\n+theorem 9.2 in the paper). These divisions are expensive when updating *d* and *e*, so we delay\n+them: we compute the integer coefficients of the combined transition matrix scaled by *2<sup>N</sup>*, and\n+do one division by *2<sup>N</sup>* as a final step:\n+\n+```python\n+def divsteps_n_matrix(delta, f, g):\n+    \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+    u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+    for _ in range(N):\n+        if delta > 0 and g & 1:\n+            delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+        elif g & 1:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+        else:\n+            delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+    return delta, (u, v, q, r)\n+```\n+\n+As the branches in the divsteps are completely determined by the bottom *N* bits of *f* and *g*, this\n+function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+intermediate results and outputs fit in *(N+1)*-bit numbers (unsigned for *f* and *g*; signed for *u*, *v*,\n+*q*, and *r*) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+integers could set *N=62* and compute the full transition matrix for 62 steps at once without any\n+big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+to update the full-size *f*, *g*, *d*, and *e* numbers once every *N* steps.\n+\n+We still need functions to compute:\n+\n+```\n+  [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+  [ out_g ]   (        [ q,  r ])   [ in_g ]\n+\n+  [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+  [ out_e ]   (        [ q,  r ])   [ in_e ]\n+```\n+\n+Because the divsteps transformation only ever divides even numbers by two, the result of *t&thinsp;[f,g]* is always even. When *t* is a composition of *N* divsteps, it follows that the resulting *f*\n+and *g* will be multiple of *2<sup>N</sup>*, and division by *2<sup>N</sup>* is simply shifting them down:\n+\n+```python\n+def update_fg(f, g, t):\n+    \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+    u, v, q, r = t\n+    cf, cg = u*f + v*g, q*f + r*g\n+    # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+    # bottom bits.\n+    assert cf % 2**N == 0\n+    assert cg % 2**N == 0\n+    return cf >> N, cg >> N\n+```\n+\n+The same is not true for *d* and *e*, and we need an equivalent of the `div2` function for division by *2<sup>N</sup> mod M*.\n+This is easy if we have precomputed *1/M mod 2<sup>N</sup>* (which always exists for odd *M*):\n+\n+```python\n+def div2n(M, Mi, x):\n+    \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+    assert (M * Mi) % 2**N == 1\n+    # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+    #     (m * M) mod 2^N = x mod 2^N\n+    # <=> m mod 2^N = (x / M) mod 2^N\n+    # <=> m mod 2^N = (x * Mi) mod 2^N\n+    m = (Mi * x) % 2**N\n+    # Subtract that multiple from x, cancelling its bottom N bits.\n+    x -= m * M\n+    # Now a clean division by 2^N is possible.\n+    assert x % 2**N == 0\n+    return (x >> N) % M\n+\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+```\n+\n+With all of those, we can write a version of `modinv` that performs *N* divsteps at once:\n+\n+```python3\n+def modinv(M, Mi, x):\n+    \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+    assert M & 1\n+    delta, f, g, d, e = 1, M, x, 0, 1\n+    while g != 0:\n+        # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+        # (N+1)-bit signed integer arithmetic).\n+        delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+        # Apply the transition matrix t to [f, g]:\n+        f, g = update_fg(f, g, t)\n+        # Apply the transition matrix t to [d, e]:\n+        d, e = update_de(d, e, t, M, Mi)\n+    return (d * f) % M\n+```\n+\n+This means that in practice we'll always perform a multiple of *N* divsteps. This is not a problem\n+because once *g=0*, further divsteps do not affect *f*, *g*, *d*, or *e* anymore (only *&delta;* keeps\n+increasing). For variable time code such excess iterations will be mostly optimized away in\n+section 6.\n+\n+\n+## 4. Avoiding modulus operations\n+\n+So far, there are two places where we compute a remainder of big numbers modulo *M*: at the end of\n+`div2n` in every `update_de`, and at the very end of `modinv` after potentially negating *d* due to the\n+sign of *f*. These are relatively expensive operations when done generically.\n+\n+To deal with the modulus operation in `div2n`, we simply stop requiring *d* and *e* to be in range\n+*[0,M)* all the time. Let's start by inlining `div2n` into `update_de`, and dropping the modulus\n+operation at the end:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+    u, v, q, r = t\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+Let's look at bounds on the ranges of these numbers. It can be shown that *|u|+|v|* and *|q|+|r|*\n+never exceed *2<sup>N</sup>* (see paragraph 8.3 in the paper), and thus a multiplication with *t* will have\n+outputs whose absolute values are at most *2<sup>N</sup>* times the maximum absolute input value. In case the\n+inputs *d* and *e* are in *(-M,M)*, which is certainly true for the initial values *d=0* and *e=1* assuming\n+*M > 1*, the multiplication results in numbers in range *(-2<sup>N</sup>M,2<sup>N</sup>M)*. Subtracting up to *2<sup>N</sup>-1*\n+times *M* to cancel out *N* bits brings that up to slightly less than *(-2<sup>N+1</sup>M,2<sup>N</sup>M)*, and\n+dividing by *2<sup>N</sup>* at the end takes it to *(-2M,M)*. Another application of `update_de` would take that\n+to *(-3M,2M)*, and so forth. This progressive expansion of the variables' ranges can be\n+counteracted by incrementing *d* and *e* by *M* whenever they're negative:\n+\n+```python\n+    ...\n+    if d < 0:\n+        d += M\n+    if e < 0:\n+        e += M\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Cancel out bottom N bits of cd and ce.\n+    ...\n+```\n+\n+With inputs in *(-2M,M)*, they will first be shifted into range *(-M,M)*, which means that the\n+output will again be in *(-2M,M)*, and this remains the case regardless of how many `update_de`\n+invocations there are. In what follows, we will try to make this more efficient.\n+\n+Note that increasing *d* by *M* is equal to incrementing *cd* by *u&thinsp;M* and *ce* by *q&thinsp;M*. Similarly,\n+increasing *e* by *M* is equal to incrementing *cd* by *v&thinsp;M* and *ce* by *r&thinsp;M*. So we could instead write:\n+\n+```python\n+    ...\n+    cd, ce = u*d + v*e, q*d + r*e\n+    # Perform the equivalent of incrementing d, e by M when they're negative.\n+    if d < 0:\n+        cd += u*M\n+        ce += q*M\n+    if e < 0:\n+        cd += v*M\n+        ce += r*M\n+    # Cancel out bottom N bits of cd and ce.\n+    md = -((Mi * cd) % 2**N)\n+    me = -((Mi * ce) % 2**N)\n+    cd += md * M\n+    ce += me * M\n+    ...\n+```\n+\n+Now note that we have two steps of corrections to *cd* and *ce* that add multiples of *M*: this\n+increment, and the decrement that cancels out bottom bits. The second one depends on the first\n+one, but they can still be efficiently combined by only computing the bottom bits of *cd* and *ce*\n+at first, and using that to compute the final *md*, *me* values:\n+\n+```python\n+def update_de(d, e, t, M, Mi):\n+    \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+    u, v, q, r = t\n+    md, me = 0, 0\n+    # Compute what multiples of M to add to cd and ce.\n+    if d < 0:\n+        md += u\n+        me += q\n+    if e < 0:\n+        md += v\n+        me += r\n+    # Compute bottom N bits of t*[d,e] + M*[md,me].\n+    cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.\n+    md -= (Mi * cd) % 2**N\n+    me -= (Mi * ce) % 2**N\n+    # Do the full computation.\n+    cd, ce = u*d + v*e + md*M, q*d + r*e + me*M\n+    # And cleanly divide by 2**N.\n+    return cd >> N, ce >> N\n+```\n+\n+One last optimization: we can avoid the *md&thinsp;M* and *me&thinsp;M* multiplications in the bottom bits of *cd*\n+and *ce* by moving them to the *md* and *me* correction:\n+\n+```python\n+    ...\n+    # Compute bottom N bits of t*[d,e].\n+    cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+    # Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.\n+    # Note that this is not the same as {md = (Mi * cd) % 2**N} etc. That would also result in N\n+    # zero bottom bits, but isn't guaranteed to be a reduction of [0,2^N) compared to the\n+    # previous md and me values, and thus would violate our bounds analysis.\n+    md -= (Mi*cd + md) % 2**N\n+    me -= (Mi*ce + me) % 2**N\n+    ...\n+```\n+\n+The resulting function takes *d* and *e* in range *(-2M,M)* as inputs, and outputs values in the same\n+range. That also means that the *d* value at the end of `modinv` will be in that range, while we want\n+a result in *[0,M)*. To do that, we need a normalization function. It's easy to integrate the\n+conditional negation of *d* (based on the sign of *f*) into it as well:\n+\n+```python\n+def normalize(sign, v, M):\n+    \"\"\"Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).\"\"\"\n+    assert sign == 1 or sign == -1\n+    # v in (-2*M,M)\n+    if v < 0:\n+        v += M\n+    # v in (-M,M). Now multiply v with sign (which can only be 1 or -1).\n+    if sign == -1:\n+        v = -v\n+    # v in (-M,M)\n+    if v < 0:\n+        v += M\n+    # v in [0,M)\n+    return v\n+```\n+\n+And calling it in `modinv` is simply:\n+\n+```python\n+   ...\n+   return normalize(f, d, M)\n+```\n+\n+\n+## 5. Constant-time operation\n+\n+The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+depends on the input data so far?\n+\n+- the number of iterations of the while *g &ne; 0* loop in `modinv`\n+- the branches inside `divsteps_n_matrix`\n+- the sign checks in `update_de`\n+- the sign checks in `normalize`\n+\n+To make the while loop in `modinv` constant time it can be replaced with a constant number of\n+iterations. The paper proves (Theorem 11.2) that *741* divsteps are sufficient for any *256*-bit\n+inputs, and [safegcd-bounds](https://github.com/sipa/safegcd-bounds) shows that the slightly better bound *724* is\n+sufficient even. Given that every loop iteration performs *N* divsteps, it will run a total of\n+*&lceil;724/N&rceil;* times.\n+\n+To deal with the branches in `divsteps_n_matrix` we will replace them with constant-time bitwise\n+operations (and hope the C compiler isn't smart enough to turn them back into branches; see\n+`valgrind_ctime_test.c` for automated tests that this isn't the case). To do so, observe that a\n+divstep can be written instead as (compare to the inner loop of `gcd` in section 1).\n+\n+```python\n+    x = -f if delta > 0 else f         # set x equal to (input) -f or f\n+    if g & 1:\n+        g += x                         # set g to (input) g-f or g+f\n+        if delta > 0:\n+            delta = -delta\n+            f += g                     # set f to (input) g (note that g was set to g-f before)\n+    delta += 1\n+    g >>= 1\n+```\n+\n+To convert the above to bitwise operations, we rely on a trick to negate conditionally: per the\n+definition of negative numbers in two's complement, (*-v == ~v + 1*) holds for every number *v*. As\n+*-1* in two's complement is all *1* bits, bitflipping can be expressed as xor with *-1*. It follows\n+that *-v == (v ^ -1) - (-1)*. Thus, if we have a variable *c* that takes on values *0* or *-1*, then\n+*(v ^ c) - c* is *v* if *c=0* and *-v* if *c=-1*.\n+\n+Using this we can write:\n+\n+```python\n+    x = -f if delta > 0 else f\n+```\n+\n+in constant-time form as:\n+\n+```python\n+    c1 = (-delta) >> 63\n+    # Conditionally negate f based on c1:\n+    x = (f ^ c1) - c1\n+```\n+\n+To use that trick, we need a helper mask variable *c1* that resolves the condition *&delta;>0* to *-1*\n+(if true) or *0* (if false). We compute *c1* using right shifting, which always rounds down (in\n+Python, and also in C under the assumption of a typical two's complement system; see\n+`assumptions.h` for tests that this is the case).\n+\n+Using the facts that *x&0=0* and *x&(-1)=x* (on two's complement systems again), we can write:\n+\n+```python\n+    if g & 1:\n+        g += x\n+```\n+\n+as:\n+\n+```python\n+    # Compute c2=0 if g is even and c2=-1 if g is odd.\n+    c2 = -(g & 1)\n+    # This masks out x if g is even, and leaves x be if g is odd.\n+    g += x & c2\n+```\n+\n+Using the conditional negation trick again we can write:\n+\n+```python\n+    if g & 1:\n+        if delta > 0:\n+            delta = -delta\n+```\n+\n+as:\n+\n+```python\n+    # Compute c3=-1 if g is odd and delta>0, and 0 otherwise.\n+    c3 = c1 & c2\n+    # Conditionally negate delta based on c3:\n+    delta = (delta ^ c3) - c3\n+```\n+\n+Finally:\n+\n+```python\n+    if g & 1:\n+        if delta > 0:\n+            f += g\n+```\n+\n+becomes:\n+\n+```python\n+    f += g & c3\n+```\n+\n+It turns out that this can be implemented more efficiently by applying the substitution\n+*&eta;=-&delta;*. In this representation, negating *&delta;* corresponds to negating *&eta;*, and incrementing\n+*&delta;* corresponds to decrementing *&eta;*. This allows us to remove the negation in the *c1*\n+computation:\n+\n+```python\n+    # Compute a mask c1 for eta < 0, and compute the conditional negation x of f:\n+    c1 = eta >> 63\n+    x = (f ^ c1) - c1\n+    # Compute a mask c2 for odd g, and conditionally add x to g:\n+    c2 = -(g & 1)\n+    g += x & c2\n+    # Compute a mask c for (eta < 0) and odd (input) g, and use it to conditionally negate eta,\n+    # and add g to f:\n+    c3 = c1 & c2\n+    eta = (eta ^ c3) - c3\n+    f += g & c3\n+    # Incrementing delta corresponds to decrementing eta.\n+    eta -= 1\n+    g >>= 1\n+```\n+\n+By replacing the loop in `divsteps_n_matrix` with a variant of the divstep code above (extended to\n+also apply all *f* operations to *u*, *v* and all *g* operations to *q*, *r*), a constant-time version of\n+`divsteps_n_matrix` is obtained. The full code will be in section 7.\n+\n+These bit fiddling tricks can also be used to make the conditional negations and additions in\n+`update_de` and `normalize` constant-time.\n+\n+\n+## 6. Variable-time optimizations\n+\n+In section 5, we modified the `divsteps_n_matrix` function (and a few others) to be constant time.\n+Constant time operations are only necessary when computing modular inverses of secret data. In\n+other cases, it slows down calculations unnecessarily. In this section, we will construct a\n+faster non-constant time `divsteps_n_matrix` function.\n+\n+To do so, first consider yet another way of writing the inner loop of divstep operations in\n+`gcd` from section 1. This decomposition is also explained in the paper in section 8.2.\n+\n+```python\n+for _ in range(N):\n+    if g & 1 and eta < 0:\n+        eta, f, g = -eta, g, -f\n+    if g & 1:\n+        g += f\n+    eta -= 1\n+    g >>= 1\n+```\n+\n+Whenever *g* is even, the loop only shifts *g* down and decreases *&eta;*. When *g* ends in multiple zero\n+bits, these iterations can be consolidated into one step. This requires counting the bottom zero\n+bits efficiently, which is possible on most platforms; it is abstracted here as the function\n+`count_trailing_zeros`.",
      "path": "doc/safegcd_implementation.md",
      "position": 553,
      "original_position": 552,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": 558225651,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, nice.",
      "created_at": "2021-01-15T20:16:13Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558570518",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558570518"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 553,
      "original_line": 553,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558603270",
      "pull_request_review_id": 569632843,
      "id": 558603270,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYwMzI3MA==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.",
      "path": "doc/safegcd_implementation.md",
      "position": 52,
      "original_position": 52,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": 558161444,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Another formulation: if M is a square matrix with integer coefficients and its inverse exists and also has integer coefficients, then applying the matrix M to a vector of integers does not change the gcd of its elements. This is true because in both directions the multiplication at least preserves any common factor the input had.\r\n\r\nThis holds for [[0,1],[-1,1]] (g,g-f) and for [[0,1],[1,1]] (f,g+f).",
      "created_at": "2021-01-15T21:31:37Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558603270",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558603270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 52,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558619883",
      "pull_request_review_id": 569663049,
      "id": 558619883,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYxOTg4Mw==",
      "diff_hunk": "@@ -0,0 +1,743 @@\n+# The safegcd implementation in libsecp256k1 explained\n+\n+This document explains the modular inverse implementation in the `src/modinv*.h` files. It is based\n+on the paper\n+[\"Fast constant-time gcd computation and modular inversion\"](https://gcd.cr.yp.to/papers.html#safegcd)\n+by Daniel J. Bernstein and Bo-Yin Yang. The references below are for the Date: 2019.04.13 version.\n+\n+The actual implementation is in C of course, but for demonstration purposes Python3 is used here.\n+Most implementation aspects and optimizations are explained, except those that depend on the specific\n+number representation used in the C code.\n+\n+## 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+\n+The algorithm from the paper, at a very high level, is this:\n+\n+```python\n+def gcd(f, g):\n+    \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+    assert f & 1  # require f to be odd\n+    delta = 1     # additional state variable\n+    while g != 0:\n+        assert f & 1  # f will be odd in every iteration\n+        if delta > 0 and g & 1:\n+            delta, f, g = 1 - delta, g, (g - f) // 2\n+        elif g & 1:\n+            delta, f, g = 1 + delta, f, (g + f) // 2\n+        else:\n+            delta, f, g = 1 + delta, f, (g    ) // 2\n+    return abs(f)\n+```\n+\n+It computes the greatest common divisor of an odd integer *f* and any integer *g*. Its inner loop\n+keeps rewriting the variables *f* and *g* alongside a state variable *&delta;* that starts at *1*, until\n+*g=0* is reached. At that point, *|f|* gives the GCD. Each of the transitions in the loop is called a\n+\"division step\" (referred to as divstep in what follows).\n+\n+For example, *gcd(21, 14)* would be computed as:\n+- Start with *&delta;=1 f=21 g=14*\n+- Take the third branch: *&delta;=2 f=21 g=7*\n+- Take the first branch: *&delta;=-1 f=7 g=-7*\n+- Take the second branch: *&delta;=0 f=7 g=0*\n+- The answer *|f| = 7*.\n+\n+Why it works:\n+- Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+  - (a) If *g* is odd, replace *(f,g)* with *(g,g-f)* or (f,g+f), resulting in an even *g*.\n+  - (b) Replace *(f,g)* with *(f,g/2)* (where *g* is guaranteed to be even).\n+- Neither of those two operations change the GCD:\n+  - For (a), assume *gcd(f,g)=c*, then it must be the case that *f=a&thinsp;c* and *g=b&thinsp;c* for some integers *a*\n+    and *b*. As *(g,g-f)=(b&thinsp;c,(b-a)c)* and *(f,f+g)=(a&thinsp;c,(a+b)c)*, the result clearly still has\n+    common factor *c*. Reasoning in the other direction shows that no common factor can be added by\n+    doing so either.",
      "path": "doc/safegcd_implementation.md",
      "position": 52,
      "original_position": 52,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "06a1fd1fd219841d218e94308b0982a5ad006f35",
      "in_reply_to_id": 558161444,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yet another: any square matrix M with integer coefficients and determinant 1 or -1 does not change gcds. This is easy to show in this direction, but I believe it also holds in the other direction (every matrix that doesn't change gcds has integer coefficients and det 1 or -1).",
      "created_at": "2021-01-15T22:12:18Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r558619883",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/558619883"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 52,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/559942183",
      "pull_request_review_id": 570939553,
      "id": 559942183,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk0MjE4Mw==",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+#ifdef VERIFY\n+/* Helper function to compute the absolute value of an int64_t.\n+ * (we don't use abs/labs/llabs as it depends on the int sizes). */\n+static int64_t secp256k1_modinv64_abs(int64_t v) {\n+    VERIFY_CHECK(v > INT64_MIN);\n+    if (v < 0) return -v;\n+    return v;\n+}\n+\n+static const secp256k1_modinv64_signed62 SECP256K1_SIGNED62_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^62). */\n+static void secp256k1_modinv64_mul_62(secp256k1_modinv64_signed62 *r, const secp256k1_modinv64_signed62 *a, int alen, int64_t factor) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int128_t c = 0;\n+    int i;\n+    for (i = 0; i < 4; ++i) {\n+        if (i < alen) {\n+            c += (factor == 1) ? (int128_t)a->v[i] : (int128_t)a->v[i] * factor;\n+        }\n+        r->v[i] = (int64_t)c & M62; c >>= 62;\n+    }\n+    if (4 < alen) {\n+        c += (factor == 1) ? (int128_t)a->v[4] : (int128_t)a->v[4] * factor;\n+    }\n+    VERIFY_CHECK(c == (int64_t)c);\n+    r->v[4] = (int64_t)c;\n+}\n+\n+/* Compare af with b*bf. */\n+static int secp256k1_modinv64_mul_cmp_62(const secp256k1_modinv64_signed62 *a, int alen, const secp256k1_modinv64_signed62 *b, int64_t factor) {\n+    int i;\n+    secp256k1_modinv64_signed62 am, bm;\n+    secp256k1_modinv64_mul_62(&am, a, alen, 1);\n+    secp256k1_modinv64_mul_62(&bm, b, 5, factor);\n+    for (i = 4; i >= 0; --i) {\n+        if (i != 4) {\n+            VERIFY_CHECK(am.v[i] >> 62 == 0);\n+            VERIFY_CHECK(bm.v[i] >> 62 == 0);\n+        }\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }\n+    return 0;\n+}\n+#endif\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^62,2^62). */\n+    int i;\n+    for (i = 0; i < 5; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M62);\n+        VERIFY_CHECK(r->v[i] <= M62);\n+    }\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, -2) > 0); /* r > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < P */\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2, the\n+     * aggregate of 62 of them will have determinant 2^62. */\n+    VERIFY_CHECK((int128_t)t->u * t->r - (int128_t)t->v * t->q == ((int128_t)1) << 62);\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, x, y, z;\n+    uint32_t m, w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled\n+             * out (as we'd be done before that point), and no more than eta+1 can be done as its\n+             * will flip again once that happens. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            /* m is a mask for the bottom min(limit, 6) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 63U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)\n+             * bits. */\n+            w = (f * g * (f * f - 2)) & m;\n+        } else {\n+            /* In this branch, use a simpler formula that only lets us cancel up to 4 bits of g, as\n+             * eta tends to be smaller here. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            /* m is a mask for the bottom min(limit, 4) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 15U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 255,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "dd9b3812740bc59e8bd06d8cc9588edc850c6748",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Typo: 6 -> 4.",
      "created_at": "2021-01-19T06:34:46Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r559942183",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/559942183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 255,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/559956626",
      "pull_request_review_id": 570957257,
      "id": 559956626,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk1NjYyNg==",
      "diff_hunk": "@@ -0,0 +1,570 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+#ifdef VERIFY\n+/* Helper function to compute the absolute value of an int64_t.\n+ * (we don't use abs/labs/llabs as it depends on the int sizes). */\n+static int64_t secp256k1_modinv64_abs(int64_t v) {\n+    VERIFY_CHECK(v > INT64_MIN);\n+    if (v < 0) return -v;\n+    return v;\n+}\n+\n+static const secp256k1_modinv64_signed62 SECP256K1_SIGNED62_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^62). */\n+static void secp256k1_modinv64_mul_62(secp256k1_modinv64_signed62 *r, const secp256k1_modinv64_signed62 *a, int alen, int64_t factor) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int128_t c = 0;\n+    int i;\n+    for (i = 0; i < 4; ++i) {\n+        if (i < alen) {\n+            c += (factor == 1) ? (int128_t)a->v[i] : (int128_t)a->v[i] * factor;\n+        }\n+        r->v[i] = (int64_t)c & M62; c >>= 62;\n+    }\n+    if (4 < alen) {\n+        c += (factor == 1) ? (int128_t)a->v[4] : (int128_t)a->v[4] * factor;\n+    }\n+    VERIFY_CHECK(c == (int64_t)c);\n+    r->v[4] = (int64_t)c;\n+}\n+\n+/* Compare af with b*bf. */\n+static int secp256k1_modinv64_mul_cmp_62(const secp256k1_modinv64_signed62 *a, int alen, const secp256k1_modinv64_signed62 *b, int64_t factor) {\n+    int i;\n+    secp256k1_modinv64_signed62 am, bm;\n+    secp256k1_modinv64_mul_62(&am, a, alen, 1);\n+    secp256k1_modinv64_mul_62(&bm, b, 5, factor);\n+    for (i = 4; i >= 0; --i) {\n+        if (i != 4) {\n+            VERIFY_CHECK(am.v[i] >> 62 == 0);\n+            VERIFY_CHECK(bm.v[i] >> 62 == 0);\n+        }\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }\n+    return 0;\n+}\n+#endif\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^62,2^62). */\n+    int i;\n+    for (i = 0; i < 5; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M62);\n+        VERIFY_CHECK(r->v[i] <= M62);\n+    }\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, -2) > 0); /* r > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < P */\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    /* The determinant of t must be a power of two. This guarantees that multiplication with t\n+     * does not change the gcd of f and g, apart from adding a power-of-2 factor to it (which\n+     * will be divided out again). As each divstep's individual matrix has determinant 2, the\n+     * aggregate of 62 of them will have determinant 2^62. */\n+    VERIFY_CHECK((int128_t)t->u * t->r - (int128_t)t->v * t->q == ((int128_t)1) << 62);\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, x, y, z;\n+    uint32_t m, w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled\n+             * out (as we'd be done before that point), and no more than eta+1 can be done as its\n+             * will flip again once that happens. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            /* m is a mask for the bottom min(limit, 6) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 63U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)\n+             * bits. */\n+            w = (f * g * (f * f - 2)) & m;\n+        } else {\n+            /* In this branch, use a simpler formula that only lets us cancel up to 4 bits of g, as\n+             * eta tends to be smaller here. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            /* m is a mask for the bottom min(limit, 4) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 15U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 255,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "dd9b3812740bc59e8bd06d8cc9588edc850c6748",
      "in_reply_to_id": 559942183,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2021-01-19T07:15:23Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r559956626",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/559956626"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 255,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561083762",
      "pull_request_review_id": 572381384,
      "id": 561083762,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA4Mzc2Mg==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;",
      "path": "src/modinv64_impl.h",
      "position": 90,
      "original_position": 32,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Maybe refer to assumptions.h here again for the semantics of the right shift. ",
      "created_at": "2021-01-20T16:05:49Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561083762",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561083762"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561085514",
      "pull_request_review_id": 572381384,
      "id": 561085514,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTA4NTUxNA==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;",
      "path": "src/modinv64_impl.h",
      "position": 101,
      "original_position": 42,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: the function is not self-contained because it's not clear what `cond_negate` should be. Perhaps make that a normal boolean (int) and compute the mask here for clarity.\r\n\r\nOn a second thought, this may be marginally slower. If that's the case, maybe just explain and VERIFY_CHECK the allowed values of `cond_negate`. ",
      "created_at": "2021-01-20T16:08:03Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561085514",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561085514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561102919",
      "pull_request_review_id": 572381384,
      "id": 561102919,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTEwMjkxOQ==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 74,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this is because the modulus is at most 256 bits? Or should this be anyway true because `secp256k1_modinv64_signed62` is supposed to hold only 256 bit integers? Maybe add comment to say where this comes from.",
      "created_at": "2021-01-20T16:26:36Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561102919",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561102919"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561112422",
      "pull_request_review_id": 572381384,
      "id": 561112422,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTExMjQyMg==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, x, y, z;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 189,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Maybe rename and unify `x`,`y`,`z` in a single `tmp` or `swap`.  \r\n\r\nI'd be curious if the compiler really finds code that is faster than our branchless version. ",
      "created_at": "2021-01-20T16:39:54Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561112422",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561112422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 187,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561124656",
      "pull_request_review_id": 572381384,
      "id": 561124656,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTEyNDY1Ng==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, x, y, z;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 194,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you say something in general on the range of `eta`?  `eta` should simply be bounded by the number of divsteps, so the casts and the +1 here are far from being problematic. Still, it may be more natural/easier to review to upcast `i` instead of downcasting `eta` in the comparisons. (Or simply make `eta` signed as you suggested, then upcasting `i` is done implicitly by the integer conversions and you don't need an explicit cast to suppress warnings.)",
      "created_at": "2021-01-20T16:57:45Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561124656",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561124656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561131410",
      "pull_request_review_id": 572381384,
      "id": 561131410,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTEzMTQxMA==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, x, y, z;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 196,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "n.b. `limit > 0` so `64 - limit < 64`.",
      "created_at": "2021-01-20T17:07:32Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561131410",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561131410"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561134006",
      "pull_request_review_id": 572446778,
      "id": 561134006,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTEzNDAwNg==",
      "diff_hunk": "@@ -34,11 +34,11 @@ Implementation details\n   * Optimized implementation of arithmetic modulo the curve's field size (2^256 - 0x1000003D1).\n     * Using 5 52-bit limbs (including hand-optimized assembly for x86_64, by Diederik Huys).\n     * Using 10 26-bit limbs (including hand-optimized assembly for 32-bit ARM, by Wladimir J. van der Laan).\n-  * Field inverses and square roots using a sliding window over blocks of 1s (by Peter Dettman).\n * Scalar operations\n   * Optimized implementation without data-dependent branches of arithmetic modulo the curve's order.\n     * Using 4 64-bit limbs (relying on __int128 support in the compiler).\n     * Using 8 32-bit limbs.\n+* Modular inverses (both field elements and scalars) based on [safegcd](https://gcd.cr.yp.to/index.html) with some modifications, and a variable-time variant.",
      "path": "README.md",
      "position": null,
      "original_position": 9,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "876b5d06ea65cb32038306db745244eefde08e22",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should still mention Peter. :)",
      "created_at": "2021-01-20T17:11:28Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561134006",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561134006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561138078",
      "pull_request_review_id": 572452352,
      "id": 561138078,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTEzODA3OA==",
      "diff_hunk": "@@ -320,22 +320,28 @@ static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp\n     /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n     cd += (int128_t)u * d1 + (int128_t)v * e1;\n     ce += (int128_t)q * d1 + (int128_t)r * e1;\n-    cd += (int128_t)modinfo->modulus.v[1] * md;\n-    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    if (modinfo->modulus.v[1]) { /* Optimize for the case where limb of modulus is zero. */",
      "path": "src/modinv64_impl.h",
      "position": 337,
      "original_position": 6,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "62a4c359990ff60aec0d2c2d2da7fb233fc982fe",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we know if this is evaluated at compile-time? Maybe that's the reason why this is only sometimes faster.  ",
      "created_at": "2021-01-20T17:17:45Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561138078",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561138078"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 337,
      "original_line": 337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561161777",
      "pull_request_review_id": 572483712,
      "id": 561161777,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE2MTc3Nw==",
      "diff_hunk": "@@ -320,22 +320,28 @@ static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp\n     /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n     cd += (int128_t)u * d1 + (int128_t)v * e1;\n     ce += (int128_t)q * d1 + (int128_t)r * e1;\n-    cd += (int128_t)modinfo->modulus.v[1] * md;\n-    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    if (modinfo->modulus.v[1]) { /* Optimize for the case where limb of modulus is zero. */",
      "path": "src/modinv64_impl.h",
      "position": 337,
      "original_position": 6,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "62a4c359990ff60aec0d2c2d2da7fb233fc982fe",
      "in_reply_to_id": 561138078,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's not in general (it is when modinv* is only invoked once in a binary, in which case it's inlined in its entirety).\r\n\r\nI believe that the cost of the conditional jump here outweighs the cost of 2 wide multiplications.\r\n\r\nIt is hard to be actually sure here though, as our benchmarks may be priming the branch predictor in a way that isn't representative of what happens in a real world load.",
      "created_at": "2021-01-20T17:55:01Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561161777",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561161777"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 337,
      "original_line": 337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561434642",
      "pull_request_review_id": 572809722,
      "id": 561434642,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQzNDY0Mg==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, x, y, z;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 194,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": 561124656,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah eta can go in theory up to +-(1+steps), though finding cases for which it exceeds 256 is very hard (because the first 256 bits you can directly reason about based on the input, but all further steps operate on g bits that are a complex function of the effect of the previous steps).",
      "created_at": "2021-01-21T00:37:36Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561434642",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561434642"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561434839",
      "pull_request_review_id": 572809900,
      "id": 561434839,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQzNDgzOQ==",
      "diff_hunk": "@@ -34,11 +34,11 @@ Implementation details\n   * Optimized implementation of arithmetic modulo the curve's field size (2^256 - 0x1000003D1).\n     * Using 5 52-bit limbs (including hand-optimized assembly for x86_64, by Diederik Huys).\n     * Using 10 26-bit limbs (including hand-optimized assembly for 32-bit ARM, by Wladimir J. van der Laan).\n-  * Field inverses and square roots using a sliding window over blocks of 1s (by Peter Dettman).\n * Scalar operations\n   * Optimized implementation without data-dependent branches of arithmetic modulo the curve's order.\n     * Using 4 64-bit limbs (relying on __int128 support in the compiler).\n     * Using 8 32-bit limbs.\n+* Modular inverses (both field elements and scalars) based on [safegcd](https://gcd.cr.yp.to/index.html) with some modifications, and a variable-time variant.",
      "path": "README.md",
      "position": null,
      "original_position": 9,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "876b5d06ea65cb32038306db745244eefde08e22",
      "in_reply_to_id": 561134006,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-01-21T00:38:02Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561434839",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561434839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561435159",
      "pull_request_review_id": 572810259,
      "id": 561435159,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQzNTE1OQ==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 74,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": 561102919,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've moved this set of assertions from modinv to the caller's (the from_signed{30,62} functions in field/scalar), because that's where it matters (the conversion relies on the numbers being in range and normalized). Added some extra comments as well there.",
      "created_at": "2021-01-21T00:38:59Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561435159",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561435159"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561435327",
      "pull_request_review_id": 572810447,
      "id": 561435327,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQzNTMyNw==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;",
      "path": "src/modinv64_impl.h",
      "position": 101,
      "original_position": 42,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": 561085514,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. I've changed the _normalize function to take in a \"sign\" variable instead, and make it do the mask computation internally.",
      "created_at": "2021-01-21T00:39:30Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561435327",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561435327"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561435376",
      "pull_request_review_id": 572810495,
      "id": 561435376,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQzNTM3Ng==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;",
      "path": "src/modinv64_impl.h",
      "position": 90,
      "original_position": 32,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": 561083762,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-01-21T00:39:37Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r561435376",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/561435376"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/562974325",
      "pull_request_review_id": 574697369,
      "id": 562974325,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk3NDMyNQ==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, x, y, z;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 189,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": 561112422,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. Changed for a local `tmp` variable.",
      "created_at": "2021-01-22T23:44:32Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r562974325",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/562974325"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 187,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/562975374",
      "pull_request_review_id": 574698485,
      "id": 562975374,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk3NTM3NA==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, x, y, z;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 194,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": 561124656,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added VERIFY_CHECK statements to check the range of eta.",
      "created_at": "2021-01-22T23:48:22Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r562975374",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/562975374"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/562975422",
      "pull_request_review_id": 574698569,
      "id": 562975422,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk3NTQyMg==",
      "diff_hunk": "@@ -0,0 +1,389 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, x, y, z;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 196,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a16192bdd0405a68a62270b94125ae32ad8a4872",
      "in_reply_to_id": 561131410,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a VERIFY_CHECK for the range of limit.",
      "created_at": "2021-01-22T23:48:39Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r562975422",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/562975422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/580325581",
      "pull_request_review_id": 595448725,
      "id": 580325581,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDMyNTU4MQ==",
      "diff_hunk": "@@ -20,6 +20,41 @@\n  * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n  */\n \n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        c += (factor == 1) ? (int64_t)a->v[i] : (int64_t)a->v[i] * factor;\n+        r->v[i] = (int32_t)c & M30; c >>= 30;\n+    }\n+    c += (factor == 1) ? (int64_t)a->v[8] : (int64_t)a->v[8] * factor;\n+    VERIFY_CHECK(c == (int32_t)c);\n+    r->v[8] = (int32_t)c;\n+}\n+\n+/* Compare af with b*factor. */\n+static int secp256k1_modinv32_mul_cmp_30(const secp256k1_modinv32_signed30 *a, const secp256k1_modinv32_signed30 *b, int32_t factor) {\n+    int i;\n+    secp256k1_modinv32_signed30 am, bm;\n+    secp256k1_modinv32_mul_30(&am, a, 1);",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 25,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In bf8c6e7f2f309f34e53f10718ee55cda1b5db130 \r\nWhy do we have this function call for multiplying by 1? It seems that function is cloning `a` into `am` when `factor = 1`. Unless we are unsure that a may have limbs exceeding 2^30.",
      "created_at": "2021-02-22T15:09:46Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r580325581",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/580325581"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/580327943",
      "pull_request_review_id": 595448725,
      "id": 580327943,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDMyNzk0Mw==",
      "diff_hunk": "@@ -20,6 +20,41 @@\n  * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n  */\n \n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        c += (factor == 1) ? (int64_t)a->v[i] : (int64_t)a->v[i] * factor;",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 13,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In bf8c6e7f2f309f34e53f10718ee55cda1b5db130 \r\nIf the following comment about factor = 1 is correct, we can remove all checks for factor ==1 ",
      "created_at": "2021-02-22T15:12:41Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r580327943",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/580327943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/584560340",
      "pull_request_review_id": 595448725,
      "id": 584560340,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDU2MDM0MA==",
      "diff_hunk": "@@ -20,6 +20,41 @@\n  * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n  */\n \n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        c += (factor == 1) ? (int64_t)a->v[i] : (int64_t)a->v[i] * factor;\n+        r->v[i] = (int32_t)c & M30; c >>= 30;\n+    }\n+    c += (factor == 1) ? (int64_t)a->v[8] : (int64_t)a->v[8] * factor;\n+    VERIFY_CHECK(c == (int32_t)c);\n+    r->v[8] = (int32_t)c;\n+}\n+\n+/* Compare af with b*factor. */",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 21,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In bf8c6e7f2f309f34e53f10718ee55cda1b5db130 \r\ntypo: a with b*factor\r\n",
      "created_at": "2021-03-01T09:30:00Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r584560340",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/584560340"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/584564693",
      "pull_request_review_id": 595448725,
      "id": 584564693,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDU2NDY5Mw==",
      "diff_hunk": "@@ -149,12 +209,19 @@ static int32_t secp256k1_modinv32_divsteps_30(int32_t eta, uint32_t f0, uint32_t\n         g >>= 1;\n         u <<= 1;\n         v <<= 1;\n+        /* Bounds on eta that follow from the bounds on iteration count (max 25*30 divsteps). */\n+        VERIFY_CHECK(eta >= -751 && eta <= 751);",
      "path": "src/modinv32_impl.h",
      "position": 220,
      "original_position": 86,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in bf8c6e7f2f309f34e53f10718ee55cda1b5db130\r\nThis seems too loose. Can we say `(eta >= -725 && eta <= 724)` ?. If the point of this is just a sanity check and facilitate review maybe it's not worth thinking about the exact numbers here",
      "created_at": "2021-03-01T09:36:37Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r584564693",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/584564693"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 220,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/584565585",
      "pull_request_review_id": 595448725,
      "id": 584565585,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDU2NTU4NQ==",
      "diff_hunk": "@@ -204,6 +271,8 @@ static int32_t secp256k1_modinv32_divsteps_30_var(int32_t eta, uint32_t f0, uint\n         VERIFY_CHECK((g & 1) == 1);\n         VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n         VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+        /* Bounds on eta that follow from the bounds on iteration count (max 12*62 divsteps). */\n+        VERIFY_CHECK(eta >= -751 && eta <= 751);",
      "path": "src/modinv32_impl.h",
      "position": 283,
      "original_position": 106,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in bf8c6e7f2f309f34e53f10718ee55cda1b5db130, \r\nShould be 25\\*30 instead of 12\\*62",
      "created_at": "2021-03-01T09:37:55Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r584565585",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/584565585"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 283,
      "original_line": 283,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585021159",
      "pull_request_review_id": 601129110,
      "id": 585021159,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTAyMTE1OQ==",
      "diff_hunk": "@@ -20,6 +20,41 @@\n  * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n  */\n \n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        c += (factor == 1) ? (int64_t)a->v[i] : (int64_t)a->v[i] * factor;\n+        r->v[i] = (int32_t)c & M30; c >>= 30;\n+    }\n+    c += (factor == 1) ? (int64_t)a->v[8] : (int64_t)a->v[8] * factor;\n+    VERIFY_CHECK(c == (int32_t)c);\n+    r->v[8] = (int32_t)c;\n+}\n+\n+/* Compare af with b*factor. */\n+static int secp256k1_modinv32_mul_cmp_30(const secp256k1_modinv32_signed30 *a, const secp256k1_modinv32_signed30 *b, int32_t factor) {\n+    int i;\n+    secp256k1_modinv32_signed30 am, bm;\n+    secp256k1_modinv32_mul_30(&am, a, 1);",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 25,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "in_reply_to_id": 580325581,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, `a` is not necessarily normalized. I'll add a comment.",
      "created_at": "2021-03-01T20:18:36Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r585021159",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585021159"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585021428",
      "pull_request_review_id": 601129475,
      "id": 585021428,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTAyMTQyOA==",
      "diff_hunk": "@@ -20,6 +20,41 @@\n  * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n  */\n \n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        c += (factor == 1) ? (int64_t)a->v[i] : (int64_t)a->v[i] * factor;",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 13,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "in_reply_to_id": 580327943,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'll just drop this, it's an optimization for test-only code.",
      "created_at": "2021-03-01T20:19:06Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r585021428",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585021428"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585031902",
      "pull_request_review_id": 601143131,
      "id": 585031902,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTAzMTkwMg==",
      "diff_hunk": "@@ -204,6 +271,8 @@ static int32_t secp256k1_modinv32_divsteps_30_var(int32_t eta, uint32_t f0, uint\n         VERIFY_CHECK((g & 1) == 1);\n         VERIFY_CHECK((u * f0 + v * g0) == f << (30 - i));\n         VERIFY_CHECK((q * f0 + r * g0) == g << (30 - i));\n+        /* Bounds on eta that follow from the bounds on iteration count (max 12*62 divsteps). */\n+        VERIFY_CHECK(eta >= -751 && eta <= 751);",
      "path": "src/modinv32_impl.h",
      "position": 283,
      "original_position": 106,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "in_reply_to_id": 584565585,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2021-03-01T20:36:39Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r585031902",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585031902"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 283,
      "original_line": 283,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585033227",
      "pull_request_review_id": 601144804,
      "id": 585033227,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTAzMzIyNw==",
      "diff_hunk": "@@ -20,6 +20,41 @@\n  * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n  */\n \n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        c += (factor == 1) ? (int64_t)a->v[i] : (int64_t)a->v[i] * factor;\n+        r->v[i] = (int32_t)c & M30; c >>= 30;\n+    }\n+    c += (factor == 1) ? (int64_t)a->v[8] : (int64_t)a->v[8] * factor;\n+    VERIFY_CHECK(c == (int32_t)c);\n+    r->v[8] = (int32_t)c;\n+}\n+\n+/* Compare af with b*factor. */",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 21,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "in_reply_to_id": 584560340,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2021-03-01T20:38:52Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r585033227",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585033227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585037285",
      "pull_request_review_id": 601150196,
      "id": 585037285,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTAzNzI4NQ==",
      "diff_hunk": "@@ -149,12 +209,19 @@ static int32_t secp256k1_modinv32_divsteps_30(int32_t eta, uint32_t f0, uint32_t\n         g >>= 1;\n         u <<= 1;\n         v <<= 1;\n+        /* Bounds on eta that follow from the bounds on iteration count (max 25*30 divsteps). */\n+        VERIFY_CHECK(eta >= -751 && eta <= 751);",
      "path": "src/modinv32_impl.h",
      "position": 220,
      "original_position": 86,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "in_reply_to_id": 584564693,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Don't forget that we perform divsteps in batches of 62/30, so you can't assume we stop immediately when g=0 is reached. The ongoing batch will still be completed, and during that, eta and u/v/q/r will still change.",
      "created_at": "2021-03-01T20:45:54Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r585037285",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585037285"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 220,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585076909",
      "pull_request_review_id": 601201223,
      "id": 585076909,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTA3NjkwOQ==",
      "diff_hunk": "@@ -149,12 +209,19 @@ static int32_t secp256k1_modinv32_divsteps_30(int32_t eta, uint32_t f0, uint32_t\n         g >>= 1;\n         u <<= 1;\n         v <<= 1;\n+        /* Bounds on eta that follow from the bounds on iteration count (max 25*30 divsteps). */\n+        VERIFY_CHECK(eta >= -751 && eta <= 751);",
      "path": "src/modinv32_impl.h",
      "position": 220,
      "original_position": 86,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "bf8c6e7f2f309f34e53f10718ee55cda1b5db130",
      "in_reply_to_id": 584564693,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, you are right. It is apparent in the case where we set g = 0 directly. ",
      "created_at": "2021-03-01T21:53:50Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r585076909",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/585076909"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 220,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586786108",
      "pull_request_review_id": 603358235,
      "id": 586786108,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Njc4NjEwOA==",
      "diff_hunk": "@@ -276,4 +276,55 @@ SECP256K1_GNUC_EXT typedef __int128 int128_t;\n # endif\n #endif\n \n+#ifndef __has_builtin\n+#define __has_builtin(x) 0\n+#endif\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 32-bit x. */\n+static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\n+    VERIFY_CHECK(x != 0);\n+#if (__has_builtin(__builtin_ctz) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* If the unsigned type is sufficient to represent the largest uint32_t, consider __builtin_ctz. */\n+    if (((unsigned)UINT32_MAX) == UINT32_MAX) {\n+        return __builtin_ctz(x);\n+    }\n+#endif\n+#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* Otherwise consider __builtin_ctzl (the unsigned long type is always at least 32 bits). */\n+    return __builtin_ctzl(x);\n+#else\n+    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\n+    static const uint8_t debruijn[32] = {\n+        0x00, 0x01, 0x02, 0x18, 0x03, 0x13, 0x06, 0x19, 0x16, 0x04, 0x14, 0x0A,\n+        0x10, 0x07, 0x0C, 0x1A, 0x1F, 0x17, 0x12, 0x05, 0x15, 0x09, 0x0F, 0x0B,\n+        0x1E, 0x11, 0x08, 0x0E, 0x1D, 0x0D, 0x1C, 0x1B\n+    };\n+    return debruijn[((x & -x) * 0x04D7651F) >> 27];\n+#endif\n+}\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 64-bit x. */\n+static SECP256K1_INLINE int secp256k1_ctz64_var(uint64_t x) {\n+    VERIFY_CHECK(x != 0);\n+#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* If the unsigned long type is sufficient to represent the largest uint64_t, consider __builtin_ctzl. */\n+    if (((unsigned long)UINT64_MAX) == UINT64_MAX) {\n+        return __builtin_ctzl(x);\n+    }\n+#endif\n+#if (__has_builtin(__builtin_ctzll) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* Otherwise consider __builtin_ctzll (the unsigned long long type is always at least 64 bits). */\n+    return __builtin_ctzll(x);\n+#else\n+    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\n+    static const uint8_t debruijn[64] = {\n+        0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,\n+        62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,\n+        63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,\n+        51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12\n+    };\n+    return debruijn[((x & -x) * 0x022FDD63CC95386D) >> 58];",
      "path": "src/util.h",
      "position": null,
      "original_position": 51,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a772bfba5380e96036650fb52005a8b9f58aefe3",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "a772bfba5380e96036650fb52005a8b9f58aefe3\r\n\r\nI'm concerned about the ability to test these fallback implementations, because all tests we typically run locally and in CI won't even use these. Could you move these implementations into separate functions such that we can always test them independently?",
      "created_at": "2021-03-03T21:15:55Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r586786108",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586786108"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 326,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586790134",
      "pull_request_review_id": 603358235,
      "id": 586790134,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Njc5MDEzNA==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 95,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/831/commits/c6de80260d758c2deed2b6a2b74665a050643fb4\r\n\r\nIs there a reason why these are still unsigned?",
      "created_at": "2021-03-03T21:19:10Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r586790134",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586790134"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 94,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586832794",
      "pull_request_review_id": 603358235,
      "id": 586832794,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NjgzMjc5NA==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix for 62 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    cd += (int128_t)modinfo->modulus.v[1] * md;\n+    ce += (int128_t)modinfo->modulus.v[1] * me;",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 245,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/831/commits/c6de80260d758c2deed2b6a2b74665a050643fb4\r\n\r\nMaybe this helps others. I think `cd` and `ce` don't overflow in the last line here because\r\n - after 239: `cd` is at most 128 - 62 bits = 66 bits\r\n - after 242: `u * d1` is at most 63 + 62 = 125 bits, same for the other summand, so `cd` will end up being at most 125 + 1 + 1 = 127 bits [1]\r\n - after 245: `v[1] * m` is at most 62 + 64 = 126 bits, so the sum `cd` is at most 128 bits   \r\n\r\n[1] not sure if `u` is in fact even 62 bits instead of 63?\r\n",
      "created_at": "2021-03-03T22:14:33Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r586832794",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586832794"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 238,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586844591",
      "pull_request_review_id": 603358235,
      "id": 586844591,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Njg0NDU5MQ==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix for 62 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    cd += (int128_t)modinfo->modulus.v[1] * md;\n+    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    d->v[0] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[0] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */\n+    cd += (int128_t)u * d2 + (int128_t)v * e2;\n+    ce += (int128_t)q * d2 + (int128_t)r * e2;\n+    cd += (int128_t)modinfo->modulus.v[2] * md;\n+    ce += (int128_t)modinfo->modulus.v[2] * me;\n+    d->v[1] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[1] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */\n+    cd += (int128_t)u * d3 + (int128_t)v * e3;\n+    ce += (int128_t)q * d3 + (int128_t)r * e3;\n+    cd += (int128_t)modinfo->modulus.v[3] * md;\n+    ce += (int128_t)modinfo->modulus.v[3] * me;\n+    d->v[2] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[2] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */\n+    cd += (int128_t)u * d4 + (int128_t)v * e4;\n+    ce += (int128_t)q * d4 + (int128_t)r * e4;\n+    cd += (int128_t)modinfo->modulus.v[4] * md;\n+    ce += (int128_t)modinfo->modulus.v[4] * me;\n+    d->v[3] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[3] = (int64_t)ce & M62; ce >>= 62;\n+    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */\n+    d->v[4] = (int64_t)cd;\n+    e->v[4] = (int64_t)ce;\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix for 62 divsteps.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];\n+    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int128_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    cf = (int128_t)u * f0 + (int128_t)v * g0;\n+    cg = (int128_t)q * f0 + (int128_t)r * g0;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */\n+    cf += (int128_t)u * f1 + (int128_t)v * g1;\n+    cg += (int128_t)q * f1 + (int128_t)r * g1;\n+    f->v[0] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[0] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */\n+    cf += (int128_t)u * f2 + (int128_t)v * g2;\n+    cg += (int128_t)q * f2 + (int128_t)r * g2;\n+    f->v[1] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[1] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */\n+    cf += (int128_t)u * f3 + (int128_t)v * g3;\n+    cg += (int128_t)q * f3 + (int128_t)r * g3;\n+    f->v[2] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[2] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */\n+    cf += (int128_t)u * f4 + (int128_t)v * g4;\n+    cg += (int128_t)q * f4 + (int128_t)r * g4;\n+    f->v[3] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[3] = (int64_t)cg & M62; cg >>= 62;\n+    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */\n+    f->v[4] = (int64_t)cf;\n+    g->v[4] = (int64_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i;\n+    int64_t eta = -1;\n+\n+    /* Do 12 iterations of 62 divsteps each = 744 divsteps. 724 suffices for 256-bit inputs. */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+    VERIFY_CHECK((g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4]) == 0);\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i, j;\n+    int64_t eta = -1;\n+    int64_t cond;\n+\n+    /* Do up to 12 iterations of 62 divsteps each = 744 divsteps, or until g=0 (whichever comes first). */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62_var(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+        /* If the bottom limb of g is zero, there is a chance that g=0. */\n+        if (g.v[0] == 0) {",
      "path": "src/modinv64_impl.h",
      "position": 539,
      "original_position": 367,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/831/commits/c6de80260d758c2deed2b6a2b74665a050643fb4\r\n\r\nThis is correct but I'm curious if you have benchmarked whether it's worth to have this branch or if this is just an educated guess. We may also want to add an EXPECT here.\r\n\r\nand nit: You could declare `cond` here.",
      "created_at": "2021-03-03T22:36:47Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r586844591",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586844591"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": 538,
      "original_start_line": 366,
      "start_side": "RIGHT",
      "line": 539,
      "original_line": 539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586849411",
      "pull_request_review_id": 603358235,
      "id": 586849411,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Njg0OTQxMQ==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix for 62 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    cd += (int128_t)modinfo->modulus.v[1] * md;\n+    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    d->v[0] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[0] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */\n+    cd += (int128_t)u * d2 + (int128_t)v * e2;\n+    ce += (int128_t)q * d2 + (int128_t)r * e2;\n+    cd += (int128_t)modinfo->modulus.v[2] * md;\n+    ce += (int128_t)modinfo->modulus.v[2] * me;\n+    d->v[1] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[1] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */\n+    cd += (int128_t)u * d3 + (int128_t)v * e3;\n+    ce += (int128_t)q * d3 + (int128_t)r * e3;\n+    cd += (int128_t)modinfo->modulus.v[3] * md;\n+    ce += (int128_t)modinfo->modulus.v[3] * me;\n+    d->v[2] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[2] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */\n+    cd += (int128_t)u * d4 + (int128_t)v * e4;\n+    ce += (int128_t)q * d4 + (int128_t)r * e4;\n+    cd += (int128_t)modinfo->modulus.v[4] * md;\n+    ce += (int128_t)modinfo->modulus.v[4] * me;\n+    d->v[3] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[3] = (int64_t)ce & M62; ce >>= 62;\n+    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */\n+    d->v[4] = (int64_t)cd;\n+    e->v[4] = (int64_t)ce;\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix for 62 divsteps.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];\n+    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int128_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    cf = (int128_t)u * f0 + (int128_t)v * g0;\n+    cg = (int128_t)q * f0 + (int128_t)r * g0;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */\n+    cf += (int128_t)u * f1 + (int128_t)v * g1;\n+    cg += (int128_t)q * f1 + (int128_t)r * g1;\n+    f->v[0] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[0] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */\n+    cf += (int128_t)u * f2 + (int128_t)v * g2;\n+    cg += (int128_t)q * f2 + (int128_t)r * g2;\n+    f->v[1] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[1] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */\n+    cf += (int128_t)u * f3 + (int128_t)v * g3;\n+    cg += (int128_t)q * f3 + (int128_t)r * g3;\n+    f->v[2] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[2] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */\n+    cf += (int128_t)u * f4 + (int128_t)v * g4;\n+    cg += (int128_t)q * f4 + (int128_t)r * g4;\n+    f->v[3] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[3] = (int64_t)cg & M62; cg >>= 62;\n+    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */\n+    f->v[4] = (int64_t)cf;\n+    g->v[4] = (int64_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i;\n+    int64_t eta = -1;\n+\n+    /* Do 12 iterations of 62 divsteps each = 744 divsteps. 724 suffices for 256-bit inputs. */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+    VERIFY_CHECK((g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4]) == 0);\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i, j;\n+    int64_t eta = -1;\n+    int64_t cond;\n+\n+    /* Do up to 12 iterations of 62 divsteps each = 744 divsteps, or until g=0 (whichever comes first). */\n+    for (i = 0; i < 12; ++i) {",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 358,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/831/commits/c6de80260d758c2deed2b6a2b74665a050643fb4\r\n\r\nIs there a reason to keep the iteration bound? I see that it may help the compiler prove termination, whatever this is good for.",
      "created_at": "2021-03-03T22:46:21Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r586849411",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586849411"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 357,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 521,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586859340",
      "pull_request_review_id": 603358235,
      "id": 586859340,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Njg1OTM0MA==",
      "diff_hunk": "@@ -320,22 +320,28 @@ static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp\n     /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n     cd += (int128_t)u * d1 + (int128_t)v * e1;\n     ce += (int128_t)q * d1 + (int128_t)r * e1;\n-    cd += (int128_t)modinfo->modulus.v[1] * md;\n-    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    if (modinfo->modulus.v[1]) { /* Optimize for the case where limb of modulus is zero. */",
      "path": "src/modinv64_impl.h",
      "position": 337,
      "original_position": 6,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "62a4c359990ff60aec0d2c2d2da7fb233fc982fe",
      "in_reply_to_id": 561138078,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A while ago I was reading up on defenses against Spectre, and since it is based on branch mispredictions, one of the simplest defenses is of course to avoid branches in context where we process secret data, even if the branch is on public data. [1]  I think we have a few \"interesting\" branches in our code base, where I could see how we compute on secret data if the wrong branch is predicted. This branch is not obviously of that kind but I may be a good rule of thumb to avoid branches when in doubt.\r\n\r\nThis is more of a note, I'm not saying that this branch must be removed. I should provide more evidence, and it's on my list to open an issue about this and point to more interesting cases in our code. \r\n\r\n[1] See also https://fc21.ifca.ai/papers/18.pdf but this is different because they do automatic rewriting.",
      "created_at": "2021-03-03T23:07:36Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r586859340",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586859340"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 337,
      "original_line": 337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586861089",
      "pull_request_review_id": 603358235,
      "id": 586861089,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Njg2MTA4OQ==",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman, Pieter Wuille                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * See https://gcd.cr.yp.to/papers.html#safegcd for the paper. The references below are for the Date:\n+ * 2019.04.13 version.\n+ *\n+ * Below is an explanation of the implementation, building up the algorithm in Python3 step by step.\n+ *\n+ *\n+ * 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+ * -------------------------------------------------------------\n+ *\n+ * The algorithm from the paper, at a very high level, is this:\n+ *\n+ * def gcd(f, g):\n+ *     \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+ *     assert f & 1  # require f to be odd\n+ *     delta = 1     # additional state variable\n+ *     while g != 0:\n+ *         assert f & 1  # f will be odd in every iteration\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g = 1 - delta, g, (g - f) // 2\n+ *         elif g & 1:\n+ *             delta, f, g = 1 + delta, f, (g + f) // 2\n+ *         else:\n+ *             delta, f, g = 1 + delta, f, (g    ) // 2\n+ *     return abs(f)\n+ *\n+ * It computes the greatest common divisor of an odd integer f and any integer g. Its inner loop\n+ * keeps rewriting the variables f and g alongside a state variable delta that starts at 1, until\n+ * g=0 is reached. At that point, |f| gives the GCD. Each of the transitions in the loop is called a\n+ * \"division step\" (referred to as divstep in what follows).\n+ *\n+ * For example, gcd(21, 14) would be computed as:\n+ * - Start with delta=1 f=21 g=14\n+ * - Take the third branch: delta=2 f=21 g=7\n+ * - Take the first branch: delta=-1 f=7 g=-7\n+ * - Take the second branch: delta=0 f=7 g=0\n+ * - The answer |f| = 7.\n+ *\n+ * Why it works:\n+ * - Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+ *   - (a) If g is odd, replace (f,g) with (g,g-f) or (f,g+f), resulting in an even g.\n+ *   - (b) Replace (f,g) with (f,g//2) (where g is guaranteed to be even).\n+ * - Neither of those two operations change the GCD:\n+ *   - For (a), assume gcd(f,g)=c, then it must be the case that f=a*c and g=b*c for some integers a\n+ *     and b. As (g,g-f)=(b*c,(b-a)*c) and (f,f+g)=(a*c,(a+b)*c), the result clearly still has\n+ *     common factor c. Reasoning in the other direction shows that no common factor can be added by\n+ *     doing so either.\n+ *   - For (b), we know that f is odd, so gcd(f,g) clearly has no common factor 2, and we can remove\n+ *     it from g.\n+ * - The algorithm will eventually converge to g=0. This is proven in the paper (see theorem G.3).\n+ * - It follows that eventually we find a final value f' for which gcd(f,g) = gcd(f',0). As the\n+ *   gcd of f' and 0 is |f'| by definition, that is our answer.\n+ *\n+ * Compared to more traditional GCD algorithms, this one has the property of only ever looking at\n+ * the low-order bits of the variables to decide the next steps, and being easy to make\n+ * constant-time (in more low-level languages than Python). The delta parameter is necessary to\n+ * guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+ * at high order bits.\n+ *\n+ * Properties that will become important later:\n+ * - Performing more divsteps than needed is not a problem, as f does not change anymore after g=0.\n+ * - Only even numbers are divided by 2. This means that when reasoning about it algebraically we\n+ *   do not need to worry about rounding.\n+ * - At every point during the algorithm's execution the next N steps only depend on the bottom N\n+ *   bits of f and g, and on delta.\n+ *\n+ *\n+ * 2. From GCDs to modular inverses\n+ * --------------------------------\n+ *\n+ * We want an algorithm to compute the inverse a of x modulo M, i.e. the number a such that a*x=1\n+ * mod M. This inverse only exists if the GCD of x and M is 1, but that is always the case if M is\n+ * prime and 0 < x < M. In what follows, assume that the modular inverse exists. To find that\n+ * inverse, it turns out this can be computed as a side effect of computing the GCD by keeping track\n+ * of how the internal variables can be written as linear combinations of the inputs at every step.\n+ * Since the GCD is 1, such an algorithm will compute numbers a and b such that a*x + b*M = 1.\n+ * Taking that expression mod M gives a*x mod M = 1, and we see that a is the modular inverse of x\n+ * mod M.\n+ *\n+ * A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+ * algorithm shown above, if the modulus M is odd. To do so, compute gcd(f=M,g=x), while keeping\n+ * track of extra variables d and e, for which at every step d = f/x (mod M) and e = g/x (mod M).\n+ * f/x here means the number which multiplied with x gives f mod M. As f and g are initialized to M\n+ * and x respectively, d and e just start off being 0 (M/x mod M = 0/x mod M = 0) and 1 (x/x mod M\n+ * = 1).\n+ *\n+ * def div2(M, x):\n+ *     \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+ *     assert M & 1\n+ *     if x & 1: # If x is odd, make it even by adding M.\n+ *         x += M\n+ *     # x must be even now, so a clean division by 2 is possible.\n+ *     return x // 2\n+ *\n+ * def modinv(M, x):\n+ *     \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+ *     assert M & 1\n+ *     delta, f, g, d, e = 1, M, x, 0, 1\n+ *     while g != 0:\n+ *         # Note that while division by two for f and g is only ever done on even inputs, this is\n+ *         # not true for d and e, so we need the div2 helper function.\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+ *         elif g & 1:\n+ *             delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+ *         else:\n+ *             delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+ *         # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+ *         assert f % M == (d * x) % M\n+ *         assert g % M == (e * x) % M\n+ *     assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+ *     # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+ *     return (d * f) % M\n+ *\n+ * Also note that this approach to track d and e throughout the computation to determine the inverse\n+ * is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+ * entire computation is determined (see section 3 below) and the inverse is computed from that.\n+ * The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+ * be faster (after the optimizations explained below) for the size of numbers we care about.\n+ *\n+ *\n+ * 3. Batching multiple divsteps\n+ * -----------------------------\n+ *\n+ * Every divstep can be expressed as a matrix multiplication, applying a transition matrix (1/2*t)\n+ * to both vectors [f, g] and [d, e] (see paragraph 8.1 in the paper):\n+ *\n+ *   t = [ u,  v ]\n+ *       [ q,  r ]\n+ *\n+ *   [ out_f ] = (1/2 * t) * [ in_f ]\n+ *   [ out_g ] =             [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+ *   [ out_e ]               [ in_e ]\n+ *\n+ * where (u, v, q, r) is (0, 2, -1, 1), (2, 0, 1, 1), or (2, 0, 0, 1), depending on which branch is\n+ * taken. As above, the resulting f and g are always integers.\n+ *\n+ * Performing multiple divsteps corresponds to a multiplication with the product of all the\n+ * individual divsteps' transition matrices. As each transition matrix consists of integers\n+ * divided by 2, the product of these matrices will consist of integers divided by 2^N (see also\n+ * theorem 9.2 in the paper). These divisions are expensive when updating d and e, so we delay\n+ * them: we compute the integer coefficients of the combined transition matrix scaled by 2^N, and\n+ * do one division by 2^N as a final step:\n+ *\n+ * def divsteps_n_matrix(delta, f, g):\n+ *     \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+ *         elif g & 1:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+ *         else:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+ *     return delta, (u, v, q, r)\n+ *\n+ * As the branches in the divsteps are completely determined by the bottom N bits of f and g, this\n+ * function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+ * intermediate results and outputs fit in (N+1)-bit numbers (unsigned for f and g; signed for u, v,\n+ * q, and r) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+ * integers could set N=62 and compute the full transition matrix for 62 steps at once without any\n+ * big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+ * to update the full-size f, g, d, and e numbers once every N steps.\n+ *\n+ * We still need functions to compute:\n+ *\n+ *   [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+ *   [ out_g ]   (        [ q,  r ])   [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+ *   [ out_e ]   (        [ q,  r ])   [ in_e ]\n+ *\n+ * For f and g that's easy:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     cf, cg = u*f + v*g, q*f + r*g\n+ *     # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+ *     # bottom bits.\n+ *     assert cf % 2**N == 0\n+ *     assert cg % 2**N == 0\n+ *     return cf >> N, cg >> N\n+ *\n+ * To do the same for d and e, we need an equivalent of the div2 function for division by 2^N mod M.\n+ * This is easy if we have precomputed M^-1 mod 2^N (which always exists for odd M):\n+ *\n+ * def div2n(M, Mi, x):\n+ *     \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+ *     assert (M * Mi) % 2**N == 1\n+ *     # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+ *     #     (m * M) mod 2^N = x mod 2^N\n+ *     # <=> m mod 2^N = (x / M) mod 2^N\n+ *     # <=> m mod 2^N = (x * Mi) mod 2^N\n+ *     m = (Mi * x) % 2**N\n+ *     # Subtract that multiple from x, cancelling its bottom N bits.\n+ *     x -= m * M\n+ *     # Now a clean division by 2^N is possible.\n+ *     assert x % 2**N == 0\n+ *     return (x >> N) % M\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+ *\n+ * With all of those, we can write a version of modinv that performs N divsteps at once:\n+ *\n+ * def modinv(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     assert M & 1\n+ *     delta, f, g, d, e = 1, M, x, 0, 1\n+ *     while g != 0:\n+ *         # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+ *         # (N+1)-bit signed integer arithmetic).\n+ *         delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+ *         # Apply the transition matrix t to [f, g]:\n+ *         f, g = update_fg(f, g, t)\n+ *         # Apply the transition matrix t to [d, e]:\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return (d * f) % M\n+ *\n+ * This means that in practice we'll always perform a multiple of N divsteps. This is not a problem\n+ * because once g=0, further divsteps do not affect f, g, d, or e anymore (only delta keeps\n+ * increasing). For variable time code such excess iterations will be mostly optimized away in\n+ * section 6.\n+ *\n+ *\n+ * 4. Avoiding modulus operations\n+ * ------------------------------\n+ *\n+ * So far, there are two places where we compute a remainder of big numbers modulo M: at the end of\n+ * div2n in every update_de, and at the very end of modinv after potentially negating d due to the\n+ * sign of f. These are relatively expensive operations when done generically.\n+ *\n+ * To deal with the modulus operation in div2n, we simply stop requiring d and e to be in range\n+ * [0,M) all the time. Let's start by inlining div2n into update_de, and dropping the modulus\n+ * operation at the end:\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     md = -((Mi * cd) % 2**N)\n+ *     me = -((Mi * ce) % 2**N)\n+ *     cd += md * M\n+ *     ce += me * M\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * Let's look at bounds on the ranges of these numbers. It can be shown that |u|+|v| and |q|+|r|\n+ * never exceed 2^N (see paragraph 8.3 in the paper), and thus a multiplication with t will have\n+ * outputs whose absolute values are at most 2^N times the maximum absolute input value. In case the\n+ * inputs d and e are in (-M,M), which is certainly true for the initial values d=0 and e=1 assuming\n+ * M > 1, the multiplication results in numbers in range (-2^N*M,2^N*M). Subtracting up to 2^N-1\n+ * times M to cancel out N bits brings that up to slightly less than (-2^(N+1)*M,2^N*M), and\n+ * dividing by 2^N at the end takes it to (-2*M,M). Another application of update_de would take that\n+ * to (-3*M,2*M), and so forth. This progressive expansion of the variables' ranges can be\n+ * counteracted by incrementing d and e by M whenever they're negative:\n+ *\n+ *     ...\n+ *     if d < 0:\n+ *         d += M\n+ *     if e < 0:\n+ *         e += M\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * With inputs in (-2*M,M), they will first be shifted into range (-M,M), which means that the\n+ * output will again be in (-2*M,M), and this remains the case regardless of how many update_de\n+ * invocations there are. *\n+ *\n+ * Now note that increasing d by M is equal to incrementing cd by u*M and ce by q*M. Similarly,\n+ * increasing e by M is equal to incrementing cd by v*M and ce by r*M. So we could instead write:\n+ *\n+ *     ...\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     if d < 0:\n+ *         cd, ce = cd + u*M, ce + q*M\n+ *     if e < 0:\n+ *         cd, ce = cd + v*M, ce + r*M\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Now note that we have two steps of corrections to cd and ce that add multiples of M: this\n+ * increment, and the decrement that cancels out bottom bits. The second one depends on the first\n+ * one, but they can still be efficiently combined by only computing the bottom bits of cd and ce\n+ * at first, and using that to compute the final md, me values:\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     md, me = 0, 0\n+ *     # Compute what multiples of M to add to cd and ce.\n+ *     if d < 0:\n+ *         md, me = md + u, me + q\n+ *     if e < 0:\n+ *         md, me = md + v, me + r\n+ *     # Compute bottom N bits of t*[d,e] + M*[md,me].\n+ *     cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N\n+ *     # Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.\n+ *     md -= (Mi * cd) % 2**N\n+ *     me -= (Mi * ce) % 2**N\n+ *     # Do the full computation.\n+ *     cd, ce = u*d + v*e + md*M, q*d + r*e + me*M\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * One last optimization: we can avoid the md*M and me*M multiplications in the bottom bits of cd\n+ * and ce by moving them to the md and me correction:\n+ *\n+ *     ...\n+ *     # Compute bottom N bits of t*[d,e].\n+ *     cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+ *     # Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.\n+ *     # Note that this is not the same as {md = (Mi * cd) % 2**N} etc. That would also result in N\n+ *     # zero bottom bits, but isn't guaranteed to be a reduction of [0,2^N) compared to the\n+ *     # previous md and me values, and thus would violate our bounds analysis.\n+ *     md -= (Mi*cd + md) % 2**N\n+ *     me -= (Mi*ce + me) % 2**N\n+ *     ...\n+ *\n+ * The resulting function takes as input d and e in range (-2*M,M) and outputs values in the same\n+ * range. That also means that the d value at the end of modinv will be in that range, while we want\n+ * a result in [0,M). To do that, we need a normalization function. It's easy to integrate the\n+ * conditional negation of d (based on the sign of f) into it as well:\n+ *\n+ * def normalize(sign, v, M):\n+ *     \"\"\"Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).\"\"\"\n+ *     assert sign == 1 or sign == -1\n+ *     # v in (-2*M,M)\n+ *     if v < 0:\n+ *         v += M\n+ *     # v in (-M,M)\n+ *     if sign == -1:\n+ *         v = -v\n+ *     # v in (-M,M)\n+ *     if v < 0:\n+ *         v += M\n+ *     # v in [0,M)\n+ *     return v\n+ *\n+ * And calling it in modinv is simply:\n+ *\n+ *    ...\n+ *    return normalize(f, d, M)\n+ *\n+ *\n+ * 5. Constant-time operation\n+ * --------------------------\n+ *\n+ * The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+ * depends on the input data so far?\n+ *\n+ * - The number of iterations of the while g != 0 loop in modinv.\n+ * - The branches inside divsteps_n_matrix.\n+ * - The sign checks in update_de\n+ * - The sign checks in normalize\n+ *\n+ * To make the while loop in modinv constant time it can be replaced with a constant number of\n+ * iterations. The paper proves (Theorem 11.2) that 741 divsteps are sufficient for any 256-bit\n+ * inputs, and https://github.com/sipa/safegcd-bounds shows that the slightly better bound 724 is\n+ * sufficient even. Given that every loop iteration performs N divsteps, it will run a total of\n+ * ceil(724/N) times.\n+ *\n+ * Dealing with the branches in divsteps_n_matrix requires replacing them with constant-time\n+ * bitwise operations (and hoping the C compiler isn't smart enough to turn them back into\n+ * branches; see valgrind_ctime_test.c for automated tests that this isn't the case). To do so,\n+ * observe that a divstep can be written instead as:\n+ *\n+ *     if g & 1:\n+ *         g += -f if delta > 0 else f    # set g to (input) g-f or g+f\n+ *         if delta > 0:\n+ *             delta = -delta\n+ *             f += g                     # set f to (input) g (note that g was set to g-f before)\n+ *     delta += 1\n+ *     g >>= 1\n+ *\n+ * To convert this into bitwise operations, we rely on this trick to implement conditional negation:\n+ * For every v, -v == ~v + 1, so since bitflipping is equal to xoring with -1, we get\n+ * -v == (v xor -1) + 1. Thus, ((v xor mask) - mask) is {v if mask=0; -v if mask=-1}. With that we\n+ * just need a way to quickly compute this mask from delta and g's parity. It turns out this is\n+ * slightly easier if instead of delta we track the equivalent eta = -delta. In that case a mask for\n+ * eta < 0 (= delta > 0) is just (eta >> 63) for int64_t. With that, we can write a constant-time\n+ * divstep as:\n+ *\n+ *     # Compute a mask c1 for eta < 0, and compute the conditional negation x of f:\n+ *     c1 = eta >> 63\n+ *     x = (f ^ c1) - c1\n+ *     # Compute a mask c2 for odd g, and conditionally add x to g:\n+ *     c2 = -(g & 1)\n+ *     g += x & c2\n+ *     # Compute a mask c for (eta < 0) and odd (input) g, and use it to conditionally negate eta,\n+ *     # and add g to f:\n+ *     c = c1 & c2\n+ *     eta = (eta ^ c) - c\n+ *     f += g & c\n+ *     # Unconditional operations:\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Note that the semantics of Python ints conveniently matches C here (assuming two's complement\n+ * behavior for signed integers; see assumptions.h), for the purpose of these techniques: right\n+ * shifting always rounds down, so (eta >> 63) is -1 if eta is negative; and bitwise operations with\n+ * -1 treat the number as equivalent to infinitely many 1 bits).\n+ *\n+ * By replacing the loop in divsteps_n_matrix with a variant of the divstep code above (extended to\n+ * also apply all f operations to u, v and all g operations to q, r), a constant-time version of\n+ * divsteps_n_matrix is obtained.\n+ *\n+ * These bit fiddling tricks can also be used to make the conditional negations and additions in\n+ * update_de and normalize constant-time.\n+ *\n+ *\n+ * 6. Variable-time optimizations\n+ * ------------------------------\n+ *\n+ * If we don't want constant time code, the changes from the previous sections are unnecessary, and\n+ * we may instead see if it's possible to go in the other direction - making things faster by\n+ * introducing more variable-time steps.\n+ *\n+ * Here we start with yet another way of writing the (loop of) divstep operations, based on\n+ * paragraph 8.2 from the paper:\n+ *\n+ * for _ in range(N):\n+ *     if g & 1 and eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     if g & 1:\n+ *         g += f\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Observe that as long as g is even, all the loop does is shift it down and decrease eta. If we can\n+ * count the bottom 0 bits in g efficiently (as can be done on most platforms), we can do multiple\n+ * iterations at once:\n+ *\n+ * i = N # divsteps left to do\n+ * while True:\n+ *     # Get rid of all bottom zeros at once\n+ *     zeros = min(i, count_trailing_zeros(g))\n+ *     eta, i = eta - zeros, i - zeros\n+ *     g >>= zeros\n+ *     if i == 0:\n+ *         break\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     g += f\n+ *\n+ * Now observe that eta always >= 0 on the last line. If eta is even higher, the loop will not run\n+ * the {eta, f, g = -eta, g, f} statement again until eta goes negative. All the last line does is\n+ * g += f with various shifted version of g, in order in order to make g's bottom bit zero, until we\n+ * run out of iterations (i reaches 0) or eta goes negative.\n+ *\n+ * Nothing prevents us from instead cancelling out multiple bits of g at once by adding a multiple\n+ * of f to it, as long as it's not more than i steps (as we'd finish the loop before doing more) or\n+ * more than eta+1 steps (as we'd run {eta, f, g = -eta, g, f} at that point). Here is a way to do\n+ * up to 4 at a time:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * i = N\n+ * while True:\n+ *     ...\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, f\n+ *     # Compute limit on number of bits to cancel\n+ *     limit = min(min(eta + 1, i), 4)\n+ *     # Compute w = -g/f mod 2**limit, using the table value for -1/f mod 2**4. Note that f is\n+ *     # always odd, so its inverse modulo a power of two always exists.\n+ *     w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *     # As w = -g/f mod (2**limit), g+w*f mod 2**limit = 0 mod 2**limit.\n+ *     g += w * f\n+ *     assert g % (2**limit) == 0\n+ *     # The next iteration will now shift out all (limit) bottom zero bits from g.\n+ *\n+ * By using a bigger table more bits can be cancelled at once. The table can also be implemented\n+ * as a formula:\n+ *  - Instead of a 3-bit table:\n+ *    * (-f) or (f ^ 6)\n+ *  - Instead of a 4-bit table:\n+ *    * (1 - f * (f + 1))\n+ *    * (-(f + (((f + 1) & 4) << 1)))\n+ *  - For larger tables the following technique can be used: if w=-f^-1 mod 2^i, then w*(w*f+2) is\n+ *    -f^-1 mod 2^(2*i). This allows extending the previous formulas (or tables). In particular we\n+ *    have this 6-bit function (based on the 3-bit function above):\n+ *    * (f * (f * f - 2))\n+ *\n+ * This loop, again extended to also handle u, v, q, and r alongside f and g, placed in\n+ * divsteps_n_matrix, gives a significantly faster, but non-constant time version. It is usable when\n+ * not operating on secret data.\n+ *\n+ * 7. Final Python version\n+ * -----------------------\n+ *\n+ * All together we need the following functions:\n+ *\n+ * - A way to compute the transition matrix in constant time, using the divsteps_n_matrix function\n+ *   from section 2, but with its loop replaced by a variant of the constant-time divstep from\n+ *   section 5, extended to handle u, v, q, r:\n+ *\n+ * def divsteps_n_matrix(eta, f, g):\n+ *     \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         c1 = eta >> 63\n+ *         # Compute x, y, z as conditionally-negated versions of f, u, v.\n+ *         x, y, z = (f ^ c1) - c1, (u ^ c1) - c1, (v ^ c1) - c1\n+ *         c2 = -(g & 1)\n+ *         # Conditionally add x, y, z to g, q, r.\n+ *         g, q, r = g + (x & c2), q + (y & c2), r + (z & c2)\n+ *         c1 &= c2                     # reusing c1 here for further conditionals\n+ *         eta = (eta ^ c1) - (c1 + 1)  # inlining the unconditional eta decrement here\n+ *         # Conditionally add g, q, r to f, u, v.\n+ *         f, u, v = f + (g & c1), u + (q & c1), v + (r & c1)\n+ *         # When shifting g down, don't shift q, r, as we construct a transition matrix multiplied\n+ *         # by 2^N. Instead, shift f's coefficients u and v up.\n+ *         g, u, v = g >> 1, u << 1, v << 1\n+ *     return eta, (u, v, q, r)\n+ *\n+ * - The functions to update f and g, and d and e, from section 2 and section 4, with the constant-time\n+ *   changes to update_de from section 5:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     cf, cg = u*f + v*g, q*f + r*g\n+ *     return cf >> N, cg >> N\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     d_sign, e_sign = d >> 257, e >> 257\n+ *     md, me = (u & d_sign) + (v & e_sign), (q & d_sign) + (r & e_sign)\n+ *     cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+ *     md -= (Mi*cd + md) % 2**N\n+ *     me -= (Mi*ce + me) % 2**N\n+ *     cd, ce = u*d + v*e + Mi*md, q*d + r*e + Mi*me\n+ *     return cd >> N, ce >> N\n+ *\n+ * - The normalize function from section 4, made constant time as well:\n+ *\n+ * def normalize(sign, v, M):\n+ *     \"\"\"Compute sign*v mod M, where v in (-2*M,M); output in [0,M).\"\"\"\n+ *     v_sign = v >> 257\n+ *     # Conditionally add M to v.\n+ *     v += M & v_sign\n+ *     c = (sign - 1) >> 1\n+ *     # Conditionally negate v.\n+ *     v = (v ^ c) - c\n+ *     v_sign = v >> 257\n+ *     # Conditionally add M to v again.\n+ *     v += M & v_sign\n+ *     return v\n+ *\n+ * - And finally the modinv function too, adapted to use eta instead of delta, and using the fixed\n+ *   iteration count from section 5:\n+ *\n+ * def modinv(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, M, x, 0, 1\n+ *     for _ in range((724 + N - 1) // N):\n+ *         eta, t = divsteps_n_matrix(-eta, f % 2**N, g % 2**N)\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return normalize(f, d, M)\n+ *\n+ * - To get a variable time version, replace the divsteps_n_matrix function with one that uses the\n+ *   divsteps loop from section 5, and a modinv version that calls it without the fixed iteration\n+ *   count:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * def divsteps_n_matrix_var(eta, f, g):\n+ *     \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1\n+ *     i = N\n+ *     while True:\n+ *         zeros = min(i, count_trailing_zeros(g))\n+ *         eta, i = eta - zeros, i - zeros\n+ *         g, u, v = g >> zeros, u << zeros, v << zeros\n+ *         if i == 0:\n+ *             break\n+ *         if eta < 0:\n+ *             eta, f, u, v, g, q, r = -eta, g, q, r, -f, -u, -v\n+ *         limit = min(min(eta + 1, i), 4)\n+ *         w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *         g, q, r = g + w*f, q + w*u, r + w*v\n+ *     return eta, (u, v, q, r)\n+ *\n+ * def modinv_var(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi = 1/M mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, M, x, 0, 1\n+ *     while g != 0:\n+ *         eta, t = divsteps_n_matrix_var(eta, f % 2**N, g % 2**N)\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return normalize(f, d, Mi)\n+ *\n+ *\n+ * 8. C implementation\n+ * -------------------\n+ *\n+ * What follows is a C implementation of effectively the Python code from section 7, with N=62, and\n+ * the following changes:\n+ *\n+ * - Representing large integers using 5 62-bit singed limbs that callers need to convert their\n+ *   value from/to. Using 62-bit limbs means shifts by 62 bits are very efficient, and the extra\n+ *   space allows faster operations by delaying carries/borrows in some cases.\n+ *\n+ * - Several modulo operations in the Python code are modulo a power of two. These can be replaced\n+ *   with a bitwise AND with ((1 << bits) - 1).\n+ *\n+ * - Similarly, if an entire expression involving multiplications and additions is computed modulo\n+ *   a power of two, that means only the bottom bits of the inputs and intermediary results is\n+ *   needed.\n+ */\n+\n+#ifdef VERIFY\n+/* Helper function to compute the absolute value of an int64_t.\n+ * (we don't use abs/labs/llabs as it depends on the int sizes). */\n+static int64_t secp256k1_modinv64_abs(int64_t v) {\n+    VERIFY_CHECK(v > INT64_MIN);\n+    if (v < 0) return -v;\n+    return v;\n+}\n+\n+static const secp256k1_modinv64_signed62 SECP256K1_SIGNED62_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^62). */\n+static void secp256k1_modinv64_mul_62(secp256k1_modinv64_signed62 *r, const secp256k1_modinv64_signed62 *a, int alen, int64_t factor) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int128_t c = 0;\n+    int i;\n+    for (i = 0; i < 4; ++i) {\n+        if (i < alen) {\n+            c += (factor == 1) ? (int128_t)a->v[i] : (int128_t)a->v[i] * factor;\n+        }\n+        r->v[i] = (int64_t)c & M62; c >>= 62;\n+    }\n+    if (4 < alen) {\n+        c += (factor == 1) ? (int128_t)a->v[4] : (int128_t)a->v[4] * factor;\n+    }\n+    VERIFY_CHECK(c == (int64_t)c);\n+    r->v[4] = (int64_t)c;\n+}\n+\n+/* Compare af with b*bf. */\n+static int secp256k1_modinv64_mul_cmp_62(const secp256k1_modinv64_signed62 *a, int alen, const secp256k1_modinv64_signed62 *b, int64_t factor) {\n+    int i;\n+    secp256k1_modinv64_signed62 am, bm;\n+    secp256k1_modinv64_mul_62(&am, a, alen, 1);\n+    secp256k1_modinv64_mul_62(&bm, b, 5, factor);\n+    for (i = 4; i >= 0; --i) {\n+        if (i != 4) {\n+            VERIFY_CHECK(am.v[i] >> 62 == 0);\n+            VERIFY_CHECK(bm.v[i] >> 62 == 0);\n+        }\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }\n+    return 0;\n+}\n+#endif\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^62,2^62). */\n+    int i;\n+    for (i = 0; i < 5; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M62);\n+        VERIFY_CHECK(r->v[i] <= M62);\n+    }\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, -2) > 0); /* r > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < P */\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled\n+             * out (as we'd be done before that point), and no more than eta+1 can be done as its\n+             * will flip again once that happens. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            /* m is a mask for the bottom min(limit, 6) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 63U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)\n+             * bits. */\n+            w = (f * g * (f * f - 2)) & m;",
      "path": "src/modinv64_impl.h",
      "position": 262,
      "original_position": 859,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "1e30f79c3807a9c63c6c6f6ae07e7c9445b0f37c",
      "in_reply_to_id": 549203982,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/831/commits/f8df286b7f826fd71e7732d7124d04d5814b44ee\r\nDo you have some reference for that formula? Same below for 4 bits.",
      "created_at": "2021-03-03T23:10:54Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r586861089",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586861089"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 262,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586868295",
      "pull_request_review_id": 603457834,
      "id": 586868295,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Njg2ODI5NQ==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix for 62 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    cd += (int128_t)modinfo->modulus.v[1] * md;\n+    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    d->v[0] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[0] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */\n+    cd += (int128_t)u * d2 + (int128_t)v * e2;\n+    ce += (int128_t)q * d2 + (int128_t)r * e2;\n+    cd += (int128_t)modinfo->modulus.v[2] * md;\n+    ce += (int128_t)modinfo->modulus.v[2] * me;\n+    d->v[1] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[1] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */\n+    cd += (int128_t)u * d3 + (int128_t)v * e3;\n+    ce += (int128_t)q * d3 + (int128_t)r * e3;\n+    cd += (int128_t)modinfo->modulus.v[3] * md;\n+    ce += (int128_t)modinfo->modulus.v[3] * me;\n+    d->v[2] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[2] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */\n+    cd += (int128_t)u * d4 + (int128_t)v * e4;\n+    ce += (int128_t)q * d4 + (int128_t)r * e4;\n+    cd += (int128_t)modinfo->modulus.v[4] * md;\n+    ce += (int128_t)modinfo->modulus.v[4] * me;\n+    d->v[3] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[3] = (int64_t)ce & M62; ce >>= 62;\n+    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */\n+    d->v[4] = (int64_t)cd;\n+    e->v[4] = (int64_t)ce;\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix for 62 divsteps.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];\n+    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int128_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    cf = (int128_t)u * f0 + (int128_t)v * g0;\n+    cg = (int128_t)q * f0 + (int128_t)r * g0;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */\n+    cf += (int128_t)u * f1 + (int128_t)v * g1;\n+    cg += (int128_t)q * f1 + (int128_t)r * g1;\n+    f->v[0] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[0] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */\n+    cf += (int128_t)u * f2 + (int128_t)v * g2;\n+    cg += (int128_t)q * f2 + (int128_t)r * g2;\n+    f->v[1] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[1] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */\n+    cf += (int128_t)u * f3 + (int128_t)v * g3;\n+    cg += (int128_t)q * f3 + (int128_t)r * g3;\n+    f->v[2] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[2] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */\n+    cf += (int128_t)u * f4 + (int128_t)v * g4;\n+    cg += (int128_t)q * f4 + (int128_t)r * g4;\n+    f->v[3] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[3] = (int64_t)cg & M62; cg >>= 62;\n+    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */\n+    f->v[4] = (int64_t)cf;\n+    g->v[4] = (int64_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i;\n+    int64_t eta = -1;\n+\n+    /* Do 12 iterations of 62 divsteps each = 744 divsteps. 724 suffices for 256-bit inputs. */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+    VERIFY_CHECK((g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4]) == 0);\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i, j;\n+    int64_t eta = -1;\n+    int64_t cond;\n+\n+    /* Do up to 12 iterations of 62 divsteps each = 744 divsteps, or until g=0 (whichever comes first). */\n+    for (i = 0; i < 12; ++i) {",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 358,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": 586849411,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah I see this is removed later.",
      "created_at": "2021-03-03T23:18:34Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r586868295",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/586868295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 357,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 521,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587831135",
      "pull_request_review_id": 604567768,
      "id": 587831135,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzgzMTEzNQ==",
      "diff_hunk": "@@ -814,8 +820,437 @@ void run_num_smalltests(void) {\n }\n #endif\n \n+/***** MODINV TESTS *****/\n+\n+/* compute out = (a*b) mod m; if b=NULL, treat b=1. */\n+void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16_t* m) {",
      "path": "src/tests.c",
      "position": 74,
      "original_position": 27,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "24f17be8f301d91ebd84caf7cf611e105a70a0e2",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/831/commits/24f17be8f301d91ebd84caf7cf611e105a70a0e2\r\n\r\nThis was a little bit hard to read at first without specifying the lengths of the argument arrays.\r\n```suggestion\r\nvoid mulmod256(uint16_t[32] out, const uint16_t[16] a, const uint16_t[16] b, const uint16_t[16] m) {\r\n```\r\n\r\nor simply add a comment. (The array notation may not be our style.)",
      "created_at": "2021-03-04T21:16:01Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r587831135",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587831135"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 658,
      "original_line": 658,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587854192",
      "pull_request_review_id": 604567768,
      "id": 587854192,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Nzg1NDE5Mg==",
      "diff_hunk": "@@ -814,8 +820,437 @@ void run_num_smalltests(void) {\n }\n #endif\n \n+/***** MODINV TESTS *****/\n+\n+/* compute out = (a*b) mod m; if b=NULL, treat b=1. */\n+void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16_t* m) {\n+    uint16_t mul[32];\n+    uint64_t c = 0;\n+    int i, j;\n+    int m_bitlen = 0;\n+    int mul_bitlen = 0;\n+\n+    if (b != NULL) {\n+        /* Compute the product of a and b, and put it in mul. */\n+        for (i = 0; i < 32; ++i) {\n+            for (j = i <= 15 ? 0 : i - 15; j <= i && j <= 15; j++) {\n+                c += (uint64_t)a[j] * b[i - j];\n+            }\n+            mul[i] = c & 0xFFFF;\n+            c >>= 16;\n+        }\n+        CHECK(c == 0);\n+\n+        /* compute the highest set bit in mul */\n+        for (i = 511; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    } else {\n+        /* if b==NULL, set mul=a. */\n+        memcpy(mul, a, 32);\n+        memset(mul + 16, 0, 32);\n+        /* compute the highest set bit in mul */\n+        for (i = 255; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Compute the highest set bit in m. */\n+    for (i = 255; i >= 0; --i) {\n+        if ((m[i >> 4] >> (i & 15)) & 1) {\n+            m_bitlen = i;\n+            break;\n+        }\n+    }\n+\n+    /* Try do mul -= m<<i, for i going down to 0, whenever the result is not negative */\n+    for (i = mul_bitlen - m_bitlen; i >= 0; --i) {\n+        uint16_t mul2[32];\n+        int64_t cs;\n+\n+        /* Compute mul2 = mul - m<<i. */\n+        cs = 0;\n+        for (j = (i >> 4); j < 32; ++j) { /* skip limbs before i/16 */\n+            uint16_t sub = 0;\n+            int p;\n+            for (p = 0; p < 16; ++p) {\n+                int bitpos = j * 16 - i + p;\n+                if (bitpos >= 0 && bitpos < 256) {\n+                    sub |= ((m[bitpos >> 4] >> (bitpos & 15)) & 1) << p;\n+                }\n+            }\n+            cs += mul[j];\n+            cs -= sub;\n+            mul2[j] = (cs & 0xFFFF);\n+            cs >>= 16;\n+        }\n+        /* If remainder of subtraction is 0, set mul = mul2. */\n+        if (cs == 0) {\n+            memcpy(mul + (i >> 4), mul2 + (i >> 4), sizeof(mul) - 2 * (i >> 4));\n+        }\n+    }\n+    /* Test that all limbs higher than m's highest are zero */\n+    for (i = (m_bitlen >> 4) + 1; i < 32; ++i) {\n+        CHECK(mul[i] == 0);\n+    }\n+    memcpy(out, mul, 32);\n+}\n+\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed30 notation. */\n+void uint16_to_signed30(secp256k1_modinv32_signed30* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 30] |= (int32_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 30);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed30 notation to a representation as 16 uint16_t's. */\n+void signed30_to_uint16(uint16_t* out, const secp256k1_modinv32_signed30* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 30]) >> (i % 30)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */",
      "path": "src/tests.c",
      "position": null,
      "original_position": 124,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "24f17be8f301d91ebd84caf7cf611e105a70a0e2",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/831/commits/24f17be8f301d91ebd84caf7cf611e105a70a0e2 ... without changing the number",
      "created_at": "2021-03-04T21:55:14Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r587854192",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587854192"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 923,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587858052",
      "pull_request_review_id": 604567768,
      "id": 587858052,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Nzg1ODA1Mg==",
      "diff_hunk": "@@ -814,8 +820,437 @@ void run_num_smalltests(void) {\n }\n #endif\n \n+/***** MODINV TESTS *****/\n+\n+/* compute out = (a*b) mod m; if b=NULL, treat b=1. */\n+void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16_t* m) {\n+    uint16_t mul[32];\n+    uint64_t c = 0;\n+    int i, j;\n+    int m_bitlen = 0;\n+    int mul_bitlen = 0;\n+\n+    if (b != NULL) {\n+        /* Compute the product of a and b, and put it in mul. */\n+        for (i = 0; i < 32; ++i) {\n+            for (j = i <= 15 ? 0 : i - 15; j <= i && j <= 15; j++) {\n+                c += (uint64_t)a[j] * b[i - j];\n+            }\n+            mul[i] = c & 0xFFFF;\n+            c >>= 16;\n+        }\n+        CHECK(c == 0);\n+\n+        /* compute the highest set bit in mul */\n+        for (i = 511; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    } else {\n+        /* if b==NULL, set mul=a. */\n+        memcpy(mul, a, 32);\n+        memset(mul + 16, 0, 32);\n+        /* compute the highest set bit in mul */\n+        for (i = 255; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Compute the highest set bit in m. */\n+    for (i = 255; i >= 0; --i) {\n+        if ((m[i >> 4] >> (i & 15)) & 1) {\n+            m_bitlen = i;\n+            break;\n+        }\n+    }\n+\n+    /* Try do mul -= m<<i, for i going down to 0, whenever the result is not negative */\n+    for (i = mul_bitlen - m_bitlen; i >= 0; --i) {\n+        uint16_t mul2[32];\n+        int64_t cs;\n+\n+        /* Compute mul2 = mul - m<<i. */\n+        cs = 0;\n+        for (j = (i >> 4); j < 32; ++j) { /* skip limbs before i/16 */\n+            uint16_t sub = 0;\n+            int p;\n+            for (p = 0; p < 16; ++p) {\n+                int bitpos = j * 16 - i + p;\n+                if (bitpos >= 0 && bitpos < 256) {\n+                    sub |= ((m[bitpos >> 4] >> (bitpos & 15)) & 1) << p;\n+                }\n+            }\n+            cs += mul[j];\n+            cs -= sub;\n+            mul2[j] = (cs & 0xFFFF);\n+            cs >>= 16;\n+        }\n+        /* If remainder of subtraction is 0, set mul = mul2. */\n+        if (cs == 0) {\n+            memcpy(mul + (i >> 4), mul2 + (i >> 4), sizeof(mul) - 2 * (i >> 4));\n+        }\n+    }\n+    /* Test that all limbs higher than m's highest are zero */\n+    for (i = (m_bitlen >> 4) + 1; i < 32; ++i) {\n+        CHECK(mul[i] == 0);\n+    }\n+    memcpy(out, mul, 32);\n+}\n+\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed30 notation. */\n+void uint16_to_signed30(secp256k1_modinv32_signed30* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 30] |= (int32_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 30);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed30 notation to a representation as 16 uint16_t's. */\n+void signed30_to_uint16(uint16_t* out, const secp256k1_modinv32_signed30* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 30]) >> (i % 30)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */\n+void mutate_sign_signed30(secp256k1_modinv32_signed30* x) {\n+    int i;\n+    for (i = 0; i < 16; ++i) {\n+        int pos = secp256k1_testrand_int(7);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 128,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "24f17be8f301d91ebd84caf7cf611e105a70a0e2",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/831/commits/24f17be8f301d91ebd84caf7cf611e105a70a0e2 \r\n\r\n```suggestion\r\n        int pos = secp256k1_testrand_int(8);\r\n```\r\n\r\n`testrand(n)` returns an integer in [0..n-1]",
      "created_at": "2021-03-04T22:00:29Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r587858052",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587858052"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 927,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587879209",
      "pull_request_review_id": 604567768,
      "id": 587879209,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Nzg3OTIwOQ==",
      "diff_hunk": "@@ -814,8 +820,437 @@ void run_num_smalltests(void) {\n }\n #endif\n \n+/***** MODINV TESTS *****/\n+\n+/* compute out = (a*b) mod m; if b=NULL, treat b=1. */\n+void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16_t* m) {\n+    uint16_t mul[32];\n+    uint64_t c = 0;\n+    int i, j;\n+    int m_bitlen = 0;\n+    int mul_bitlen = 0;\n+\n+    if (b != NULL) {\n+        /* Compute the product of a and b, and put it in mul. */\n+        for (i = 0; i < 32; ++i) {\n+            for (j = i <= 15 ? 0 : i - 15; j <= i && j <= 15; j++) {\n+                c += (uint64_t)a[j] * b[i - j];\n+            }\n+            mul[i] = c & 0xFFFF;\n+            c >>= 16;\n+        }\n+        CHECK(c == 0);\n+\n+        /* compute the highest set bit in mul */\n+        for (i = 511; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    } else {\n+        /* if b==NULL, set mul=a. */\n+        memcpy(mul, a, 32);\n+        memset(mul + 16, 0, 32);\n+        /* compute the highest set bit in mul */\n+        for (i = 255; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Compute the highest set bit in m. */\n+    for (i = 255; i >= 0; --i) {\n+        if ((m[i >> 4] >> (i & 15)) & 1) {\n+            m_bitlen = i;\n+            break;\n+        }\n+    }\n+\n+    /* Try do mul -= m<<i, for i going down to 0, whenever the result is not negative */\n+    for (i = mul_bitlen - m_bitlen; i >= 0; --i) {\n+        uint16_t mul2[32];\n+        int64_t cs;\n+\n+        /* Compute mul2 = mul - m<<i. */\n+        cs = 0;\n+        for (j = (i >> 4); j < 32; ++j) { /* skip limbs before i/16 */\n+            uint16_t sub = 0;\n+            int p;\n+            for (p = 0; p < 16; ++p) {\n+                int bitpos = j * 16 - i + p;\n+                if (bitpos >= 0 && bitpos < 256) {\n+                    sub |= ((m[bitpos >> 4] >> (bitpos & 15)) & 1) << p;\n+                }\n+            }\n+            cs += mul[j];\n+            cs -= sub;\n+            mul2[j] = (cs & 0xFFFF);\n+            cs >>= 16;\n+        }\n+        /* If remainder of subtraction is 0, set mul = mul2. */\n+        if (cs == 0) {\n+            memcpy(mul + (i >> 4), mul2 + (i >> 4), sizeof(mul) - 2 * (i >> 4));\n+        }\n+    }\n+    /* Test that all limbs higher than m's highest are zero */\n+    for (i = (m_bitlen >> 4) + 1; i < 32; ++i) {\n+        CHECK(mul[i] == 0);\n+    }\n+    memcpy(out, mul, 32);\n+}\n+\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed30 notation. */\n+void uint16_to_signed30(secp256k1_modinv32_signed30* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 30] |= (int32_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 30);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed30 notation to a representation as 16 uint16_t's. */\n+void signed30_to_uint16(uint16_t* out, const secp256k1_modinv32_signed30* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 30]) >> (i % 30)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */\n+void mutate_sign_signed30(secp256k1_modinv32_signed30* x) {\n+    int i;\n+    for (i = 0; i < 16; ++i) {\n+        int pos = secp256k1_testrand_int(7);\n+        if (x->v[pos] > 0 && x->v[pos + 1] <= 0x3fffffff) {\n+            x->v[pos] -= 0x40000000;\n+            x->v[pos + 1] += 1;\n+        } else if (x->v[pos] < 0 && x->v[pos + 1] >= 0x3fffffff) {\n+            x->v[pos] += 0x40000000;\n+            x->v[pos + 1] -= 1;\n+        }\n+    }\n+}\n+\n+/* Test secp256k1_modinv32{_var}, using inputs in 16-bit limb format, and returning inverse. */\n+void test_modinv32_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod) {\n+    uint16_t tmp[16];\n+    secp256k1_modinv32_signed30 x;\n+    secp256k1_modinv32_modinfo m;\n+    int i, vartime, nonzero;\n+\n+    uint16_to_signed30(&x, in);\n+    nonzero = (x.v[0] | x.v[1] | x.v[2] | x.v[3] | x.v[4] | x.v[5] | x.v[6] | x.v[7] | x.v[8]) != 0;\n+    uint16_to_signed30(&m.modulus, mod);\n+    mutate_sign_signed30(&m.modulus);\n+\n+    /* compute 1/modulus mod 2^30 */\n+    m.modulus_inv30 = m.modulus.v[0];\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 &= 0x3fffffff;\n+    CHECK(((m.modulus_inv30 * m.modulus.v[0]) & 0x3fffffff) == 1);\n+\n+    for (vartime = 0; vartime < 2; ++vartime) {\n+        /* compute inverse */\n+        (vartime ? secp256k1_modinv32_var : secp256k1_modinv32)(&x, &m);\n+\n+        /* produce output */\n+        signed30_to_uint16(out, &x);\n+\n+        /* check if the inverse times the input is 1 (mod m), unless x is 0. */\n+        mulmod256(tmp, out, in, mod);\n+        CHECK(tmp[0] == nonzero);\n+        for (i = 1; i < 16; ++i) CHECK(tmp[i] == 0);\n+\n+        /* invert again */\n+        (vartime ? secp256k1_modinv32_var : secp256k1_modinv32)(&x, &m);\n+\n+        /* check if the result is equal to the input */\n+        signed30_to_uint16(tmp, &x);\n+        for (i = 0; i < 16; ++i) CHECK(tmp[i] == in[i]);\n+    }\n+}\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed62 notation. */\n+void uint16_to_signed62(secp256k1_modinv64_signed62* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 62] |= (int64_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 62);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed62 notation to a representation as 16 uint16_t's. */\n+void signed62_to_uint16(uint16_t* out, const secp256k1_modinv64_signed62* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 62]) >> (i % 62)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */\n+void mutate_sign_signed62(secp256k1_modinv64_signed62* x) {\n+    static const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        int pos = secp256k1_testrand_int(3);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 205,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "24f17be8f301d91ebd84caf7cf611e105a70a0e2",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/831/commits/24f17be8f301d91ebd84caf7cf611e105a70a0e2 \r\n\r\n```suggestion\r\n        int pos = secp256k1_testrand_int(4);\r\n```",
      "created_at": "2021-03-04T22:39:56Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r587879209",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587879209"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1004,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587904172",
      "pull_request_review_id": 604567768,
      "id": 587904172,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkwNDE3Mg==",
      "diff_hunk": "@@ -814,8 +820,437 @@ void run_num_smalltests(void) {\n }\n #endif\n \n+/***** MODINV TESTS *****/\n+\n+/* compute out = (a*b) mod m; if b=NULL, treat b=1. */\n+void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16_t* m) {\n+    uint16_t mul[32];\n+    uint64_t c = 0;\n+    int i, j;\n+    int m_bitlen = 0;\n+    int mul_bitlen = 0;\n+\n+    if (b != NULL) {\n+        /* Compute the product of a and b, and put it in mul. */\n+        for (i = 0; i < 32; ++i) {\n+            for (j = i <= 15 ? 0 : i - 15; j <= i && j <= 15; j++) {\n+                c += (uint64_t)a[j] * b[i - j];\n+            }\n+            mul[i] = c & 0xFFFF;\n+            c >>= 16;\n+        }\n+        CHECK(c == 0);\n+\n+        /* compute the highest set bit in mul */\n+        for (i = 511; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    } else {\n+        /* if b==NULL, set mul=a. */\n+        memcpy(mul, a, 32);\n+        memset(mul + 16, 0, 32);\n+        /* compute the highest set bit in mul */\n+        for (i = 255; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Compute the highest set bit in m. */\n+    for (i = 255; i >= 0; --i) {\n+        if ((m[i >> 4] >> (i & 15)) & 1) {\n+            m_bitlen = i;\n+            break;\n+        }\n+    }\n+\n+    /* Try do mul -= m<<i, for i going down to 0, whenever the result is not negative */\n+    for (i = mul_bitlen - m_bitlen; i >= 0; --i) {\n+        uint16_t mul2[32];\n+        int64_t cs;\n+\n+        /* Compute mul2 = mul - m<<i. */\n+        cs = 0;\n+        for (j = (i >> 4); j < 32; ++j) { /* skip limbs before i/16 */\n+            uint16_t sub = 0;\n+            int p;\n+            for (p = 0; p < 16; ++p) {\n+                int bitpos = j * 16 - i + p;\n+                if (bitpos >= 0 && bitpos < 256) {\n+                    sub |= ((m[bitpos >> 4] >> (bitpos & 15)) & 1) << p;\n+                }\n+            }\n+            cs += mul[j];\n+            cs -= sub;\n+            mul2[j] = (cs & 0xFFFF);\n+            cs >>= 16;\n+        }\n+        /* If remainder of subtraction is 0, set mul = mul2. */\n+        if (cs == 0) {\n+            memcpy(mul + (i >> 4), mul2 + (i >> 4), sizeof(mul) - 2 * (i >> 4));\n+        }\n+    }\n+    /* Test that all limbs higher than m's highest are zero */\n+    for (i = (m_bitlen >> 4) + 1; i < 32; ++i) {\n+        CHECK(mul[i] == 0);\n+    }\n+    memcpy(out, mul, 32);\n+}\n+\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed30 notation. */\n+void uint16_to_signed30(secp256k1_modinv32_signed30* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 30] |= (int32_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 30);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed30 notation to a representation as 16 uint16_t's. */\n+void signed30_to_uint16(uint16_t* out, const secp256k1_modinv32_signed30* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 30]) >> (i % 30)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */\n+void mutate_sign_signed30(secp256k1_modinv32_signed30* x) {\n+    int i;\n+    for (i = 0; i < 16; ++i) {\n+        int pos = secp256k1_testrand_int(7);\n+        if (x->v[pos] > 0 && x->v[pos + 1] <= 0x3fffffff) {\n+            x->v[pos] -= 0x40000000;\n+            x->v[pos + 1] += 1;\n+        } else if (x->v[pos] < 0 && x->v[pos + 1] >= 0x3fffffff) {\n+            x->v[pos] += 0x40000000;\n+            x->v[pos + 1] -= 1;\n+        }\n+    }\n+}\n+\n+/* Test secp256k1_modinv32{_var}, using inputs in 16-bit limb format, and returning inverse. */\n+void test_modinv32_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod) {\n+    uint16_t tmp[16];\n+    secp256k1_modinv32_signed30 x;\n+    secp256k1_modinv32_modinfo m;\n+    int i, vartime, nonzero;\n+\n+    uint16_to_signed30(&x, in);\n+    nonzero = (x.v[0] | x.v[1] | x.v[2] | x.v[3] | x.v[4] | x.v[5] | x.v[6] | x.v[7] | x.v[8]) != 0;\n+    uint16_to_signed30(&m.modulus, mod);\n+    mutate_sign_signed30(&m.modulus);\n+\n+    /* compute 1/modulus mod 2^30 */\n+    m.modulus_inv30 = m.modulus.v[0];\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 &= 0x3fffffff;\n+    CHECK(((m.modulus_inv30 * m.modulus.v[0]) & 0x3fffffff) == 1);\n+\n+    for (vartime = 0; vartime < 2; ++vartime) {\n+        /* compute inverse */\n+        (vartime ? secp256k1_modinv32_var : secp256k1_modinv32)(&x, &m);\n+\n+        /* produce output */\n+        signed30_to_uint16(out, &x);\n+\n+        /* check if the inverse times the input is 1 (mod m), unless x is 0. */\n+        mulmod256(tmp, out, in, mod);\n+        CHECK(tmp[0] == nonzero);\n+        for (i = 1; i < 16; ++i) CHECK(tmp[i] == 0);\n+\n+        /* invert again */\n+        (vartime ? secp256k1_modinv32_var : secp256k1_modinv32)(&x, &m);\n+\n+        /* check if the result is equal to the input */\n+        signed30_to_uint16(tmp, &x);\n+        for (i = 0; i < 16; ++i) CHECK(tmp[i] == in[i]);\n+    }\n+}\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed62 notation. */\n+void uint16_to_signed62(secp256k1_modinv64_signed62* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 62] |= (int64_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 62);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed62 notation to a representation as 16 uint16_t's. */\n+void signed62_to_uint16(uint16_t* out, const secp256k1_modinv64_signed62* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 62]) >> (i % 62)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */\n+void mutate_sign_signed62(secp256k1_modinv64_signed62* x) {\n+    static const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        int pos = secp256k1_testrand_int(3);\n+        if (x->v[pos] > 0 && x->v[pos + 1] <= M62) {\n+            x->v[pos] -= (M62 + 1);\n+            x->v[pos + 1] += 1;\n+        } else if (x->v[pos] < 0 && x->v[pos + 1] >= -M62) {\n+            x->v[pos] += (M62 + 1);\n+            x->v[pos + 1] -= 1;\n+        }\n+    }\n+}\n+\n+/* Test secp256k1_modinv64{_var}, using inputs in 16-bit limb format, and returning inverse. */\n+void test_modinv64_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod) {\n+    static const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    uint16_t tmp[16];\n+    secp256k1_modinv64_signed62 x;\n+    secp256k1_modinv64_modinfo m;\n+    int i, vartime, nonzero;\n+\n+    uint16_to_signed62(&x, in);\n+    nonzero = (x.v[0] | x.v[1] | x.v[2] | x.v[3] | x.v[4]) != 0;\n+    uint16_to_signed62(&m.modulus, mod);\n+    mutate_sign_signed62(&m.modulus);\n+\n+    /* compute 1/modulus mod 2^62 */\n+    m.modulus_inv62 = m.modulus.v[0];\n+    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\n+    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\n+    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\n+    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\n+    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\n+    m.modulus_inv62 &= M62;\n+    CHECK(((m.modulus_inv62 * m.modulus.v[0]) & M62) == 1);\n+\n+    for (vartime = 0; vartime < 2; ++vartime) {\n+        /* compute inverse */\n+        (vartime ? secp256k1_modinv64_var : secp256k1_modinv64)(&x, &m);\n+\n+        /* produce output */\n+        signed62_to_uint16(out, &x);\n+\n+        /* check if the inverse times the input is 1 (mod m), unless x is 0. */\n+        mulmod256(tmp, out, in, mod);\n+        CHECK(tmp[0] == nonzero);\n+        for (i = 1; i < 16; ++i) CHECK(tmp[i] == 0);\n+\n+        /* invert again */\n+        (vartime ? secp256k1_modinv64_var : secp256k1_modinv64)(&x, &m);\n+\n+        /* check if the result is equal to the input */\n+        signed62_to_uint16(tmp, &x);\n+        for (i = 0; i < 16; ++i) CHECK(tmp[i] == in[i]);\n+    }\n+}\n+#endif\n+\n+/* test if a and b are coprime */\n+int coprime(const uint16_t* a, const uint16_t* b) {\n+    uint16_t x[16], y[16], t[16];\n+    int i;\n+    int iszero;\n+    memcpy(x, a, 32);\n+    memcpy(y, b, 32);\n+\n+    /* simple gcd loop: while x!=0, (x,y)=(y%x,x) */\n+    while (1) {\n+        iszero = 1;\n+        for (i = 0; i < 16; ++i) {\n+            if (x[i] != 0) {\n+                iszero = 0;\n+                break;\n+            }\n+        }\n+        if (iszero) break;\n+        mulmod256(t, y, NULL, x);\n+        memcpy(y, x, 32);\n+        memcpy(x, t, 32);\n+    }\n+\n+    /* return whether y=1 */\n+    if (y[0] != 1) return 0;\n+    for (i = 1; i < 16; ++i) {\n+        if (y[i] != 0) return 0;\n+    }\n+    return 1;\n+}\n+\n+void run_modinv_tests(void) {\n+    /* Fixed test cases. Each tuple is (input, modulus, output), each as 16x16 bits in LE order. */\n+    static const uint16_t CASES[][3][16] = {\n+        /* Test case known to need 713 divsteps */\n+        {{0x1513, 0x5389, 0x54e9, 0x2798, 0x1957, 0x66a0, 0x8057, 0x3477,\n+          0x7784, 0x1052, 0x326a, 0x9331, 0x6506, 0xa95c, 0x91f3, 0xfb5e},\n+         {0x2bdd, 0x8df4, 0xcc61, 0x481f, 0xdae5, 0x5ca7, 0xf43b, 0x7d54,\n+          0x13d6, 0x469b, 0x2294, 0x20f4, 0xb2a4, 0xa2d1, 0x3ff1, 0xfd4b},\n+         {0xffd8, 0xd9a0, 0x456e, 0x81bb, 0xbabd, 0x6cea, 0x6dbd, 0x73ab,\n+          0xbb94, 0x3d3c, 0xdf08, 0x31c4, 0x3e32, 0xc179, 0x2486, 0xb86b}},\n+        /* Test case known to need 589 divsteps, reaching delta=-140 and\n+           delta=141. */\n+        {{0x3fb1, 0x903b, 0x4eb7, 0x4813, 0xd863, 0x26bf, 0xd89f, 0xa8a9,\n+          0x02fe, 0x57c6, 0x554a, 0x4eab, 0x165e, 0x3d61, 0xee1e, 0x456c},\n+         {0x9295, 0x823b, 0x5c1f, 0x5386, 0x48e0, 0x02ff, 0x4c2a, 0xa2da,\n+          0xe58f, 0x967c, 0xc97e, 0x3f5a, 0x69fb, 0x52d9, 0x0a86, 0xb4a3},\n+         {0x3d30, 0xb893, 0xa809, 0xa7a8, 0x26f5, 0x5b42, 0x55be, 0xf4d0,\n+          0x12c2, 0x7e6a, 0xe41a, 0x90c7, 0xebfa, 0xf920, 0x304e, 0x1419}},\n+        /* Test case known to need 650 divsteps, and doing 65 consecutive (f,g/2) steps. */\n+        {{0x8583, 0x5058, 0xbeae, 0xeb69, 0x48bc, 0x52bb, 0x6a9d, 0xcc94,\n+          0x2a21, 0x87d5, 0x5b0d, 0x42f6, 0x5b8a, 0x2214, 0xe9d6, 0xa040},\n+         {0x7531, 0x27cb, 0x7e53, 0xb739, 0x6a5f, 0x83f5, 0xa45c, 0xcb1d,\n+          0x8a87, 0x1c9c, 0x51d7, 0x851c, 0xb9d8, 0x1fbe, 0xc241, 0xd4a3},\n+         {0xcdb4, 0x275c, 0x7d22, 0xa906, 0x0173, 0xc054, 0x7fdf, 0x5005,\n+          0x7fb8, 0x9059, 0xdf51, 0x99df, 0x2654, 0x8f6e, 0x070f, 0xb347}},\n+        /* Test case with the group order as modulus, needing 635 divsteps. */\n+        {{0x95ed, 0x6c01, 0xd113, 0x5ff1, 0xd7d0, 0x29cc, 0x5817, 0x6120,\n+          0xca8e, 0xaad1, 0x25ae, 0x8e84, 0x9af6, 0x30bf, 0xf0ed, 0x1686},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x1631, 0xbf4a, 0x286a, 0x2716, 0x469f, 0x2ac8, 0x1312, 0xe9bc,\n+          0x04f4, 0x304b, 0x9931, 0x113b, 0xd932, 0xc8f4, 0x0d0d, 0x01a1}},\n+        /* Test case with the field size as modulus, needing 637 divsteps. */\n+        {{0x9ec3, 0x1919, 0xca84, 0x7c11, 0xf996, 0x06f3, 0x5408, 0x6688,\n+          0x1320, 0xdb8a, 0x632a, 0x0dcb, 0x8a84, 0x6bee, 0x9c95, 0xe34e},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x18e5, 0x19b6, 0xdf92, 0x1aaa, 0x09fb, 0x8a3f, 0x52b0, 0x8701,\n+          0xac0c, 0x2582, 0xda44, 0x9bcc, 0x6828, 0x1c53, 0xbd8f, 0xbd2c}},\n+        /* Test case with the field size as modulus, needing 935 divsteps with\n+           broken eta handling. */\n+        {{0x1b37, 0xbdc3, 0x8bcd, 0x25e3, 0x1eae, 0x567d, 0x30b6, 0xf0d8,\n+          0x9277, 0x0cf8, 0x9c2e, 0xecd7, 0x631d, 0xe38f, 0xd4f8, 0x5c93},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x1622, 0xe05b, 0xe880, 0x7de9, 0x3e45, 0xb682, 0xee6c, 0x67ed,\n+          0xa179, 0x15db, 0x6b0d, 0xa656, 0x7ccb, 0x8ef7, 0xa2ff, 0xe279}},\n+        /* Test case with the group size as modulus, needing 981 divsteps with\n+           broken eta handling. */\n+        {{0xfeb9, 0xb877, 0xee41, 0x7fa3, 0x87da, 0x94c4, 0x9d04, 0xc5ae,\n+          0x5708, 0x0994, 0xfc79, 0x0916, 0xbf32, 0x3ad8, 0xe11c, 0x5ca2},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x0f12, 0x075e, 0xce1c, 0x6f92, 0xc80f, 0xca92, 0x9a04, 0x6126,\n+          0x4b6c, 0x57d6, 0xca31, 0x97f3, 0x1f99, 0xf4fd, 0xda4d, 0x42ce}},\n+        /* Test case with the field size as modulus, input = 0. */\n+        {{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}},\n+        /* Test case with the field size as modulus, input = 1. */\n+        {{0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}},\n+        /* Test case with the field size as modulus, input = 2. */\n+        {{0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0xfe18, 0x7fff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x7fff}},\n+        /* Test case with the field size as modulus, input = field - 1. */\n+        {{0xfc2e, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0xfc2e, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff}},\n+        /* Test case with the group size as modulus, input = 0. */\n+        {{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}},\n+        /* Test case with the group size as modulus, input = 1. */\n+        {{0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}},\n+        /* Test case with the group size as modulus, input = 2. */\n+        {{0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x20a1, 0x681b, 0x2f46, 0xdfe9, 0x501d, 0x57a4, 0x6e73, 0x5d57,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x7fff}},\n+        /* Test case with the group size as modulus, input = group - 1. */\n+        {{0x4140, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x4140, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff}}\n+    };\n+\n+    int i, j, ok;\n+\n+    /* Test known inputs/outputs */\n+    for (i = 0; (size_t)i < sizeof(CASES) / sizeof(CASES[0]); ++i) {\n+        uint16_t out[16];\n+        test_modinv32_uint16(out, CASES[i][0], CASES[i][1]);\n+        for (j = 0; j < 16; ++j) CHECK(out[j] == CASES[i][2][j]);\n+#ifdef SECP256K1_WIDEMUL_INT128\n+        test_modinv64_uint16(out, CASES[i][0], CASES[i][1]);\n+        for (j = 0; j < 16; ++j) CHECK(out[j] == CASES[i][2][j]);\n+#endif\n+    }\n+\n+    for (i = 0; i < 100 * count; ++i) {\n+        /* 256-bit numbers in 16-uint16_t's notation */\n+        static const uint16_t ZERO[16] = {0};\n+        uint16_t xd[16];  /* the number (in range [0,2^256)) to be inverted */\n+        uint16_t md[16];  /* the modulus (odd, in range [3,2^256)) */\n+        uint16_t id[16];  /* the inverse of xd mod md */\n+\n+        /* generate random xd and md, so that md is odd, md>1, xd<md, and gcd(xd,md)=1 */\n+        do {\n+            /* generate random xd and md (with many subsequent 0s and 1s) */\n+            secp256k1_testrand256_test((unsigned char*)xd);\n+            secp256k1_testrand256_test((unsigned char*)md);\n+            md[0] |= 1; /* modulus must be odd */\n+            /* If modulus is 1, find another one. */\n+            ok = md[0] != 1;\n+            for (j = 1; j < 16; ++j) ok |= md[j] != 0;\n+            mulmod256(xd, xd, NULL, md); /* Make xd = xd mod m32 */",
      "path": "src/tests.c",
      "position": null,
      "original_position": 434,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "24f17be8f301d91ebd84caf7cf611e105a70a0e2",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin-core/secp256k1/pull/831/commits/24f17be8f301d91ebd84caf7cf611e105a70a0e2\r\n\r\n```suggestion\r\n            mulmod256(xd, xd, NULL, md); /* Make xd = xd mod md */\r\n```",
      "created_at": "2021-03-04T23:22:16Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r587904172",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587904172"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1051,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587909698",
      "pull_request_review_id": 604664325,
      "id": 587909698,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NzkwOTY5OA==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 95,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": 586790134,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ah I guess to avoid signed overflow with `<<` ?",
      "created_at": "2021-03-04T23:35:32Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r587909698",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/587909698"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 94,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588001047",
      "pull_request_review_id": 604769020,
      "id": 588001047,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAwMTA0Nw==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix for 62 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    cd += (int128_t)modinfo->modulus.v[1] * md;\n+    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    d->v[0] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[0] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */\n+    cd += (int128_t)u * d2 + (int128_t)v * e2;\n+    ce += (int128_t)q * d2 + (int128_t)r * e2;\n+    cd += (int128_t)modinfo->modulus.v[2] * md;\n+    ce += (int128_t)modinfo->modulus.v[2] * me;\n+    d->v[1] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[1] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */\n+    cd += (int128_t)u * d3 + (int128_t)v * e3;\n+    ce += (int128_t)q * d3 + (int128_t)r * e3;\n+    cd += (int128_t)modinfo->modulus.v[3] * md;\n+    ce += (int128_t)modinfo->modulus.v[3] * me;\n+    d->v[2] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[2] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */\n+    cd += (int128_t)u * d4 + (int128_t)v * e4;\n+    ce += (int128_t)q * d4 + (int128_t)r * e4;\n+    cd += (int128_t)modinfo->modulus.v[4] * md;\n+    ce += (int128_t)modinfo->modulus.v[4] * me;\n+    d->v[3] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[3] = (int64_t)ce & M62; ce >>= 62;\n+    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */\n+    d->v[4] = (int64_t)cd;\n+    e->v[4] = (int64_t)ce;\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix for 62 divsteps.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];\n+    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int128_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    cf = (int128_t)u * f0 + (int128_t)v * g0;\n+    cg = (int128_t)q * f0 + (int128_t)r * g0;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */\n+    cf += (int128_t)u * f1 + (int128_t)v * g1;\n+    cg += (int128_t)q * f1 + (int128_t)r * g1;\n+    f->v[0] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[0] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */\n+    cf += (int128_t)u * f2 + (int128_t)v * g2;\n+    cg += (int128_t)q * f2 + (int128_t)r * g2;\n+    f->v[1] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[1] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */\n+    cf += (int128_t)u * f3 + (int128_t)v * g3;\n+    cg += (int128_t)q * f3 + (int128_t)r * g3;\n+    f->v[2] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[2] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */\n+    cf += (int128_t)u * f4 + (int128_t)v * g4;\n+    cg += (int128_t)q * f4 + (int128_t)r * g4;\n+    f->v[3] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[3] = (int64_t)cg & M62; cg >>= 62;\n+    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */\n+    f->v[4] = (int64_t)cf;\n+    g->v[4] = (int64_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i;\n+    int64_t eta = -1;\n+\n+    /* Do 12 iterations of 62 divsteps each = 744 divsteps. 724 suffices for 256-bit inputs. */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+    VERIFY_CHECK((g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4]) == 0);\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i, j;\n+    int64_t eta = -1;\n+    int64_t cond;\n+\n+    /* Do up to 12 iterations of 62 divsteps each = 744 divsteps, or until g=0 (whichever comes first). */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62_var(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+        /* If the bottom limb of g is zero, there is a chance that g=0. */\n+        if (g.v[0] == 0) {",
      "path": "src/modinv64_impl.h",
      "position": 539,
      "original_position": 367,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": 586844591,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I did benchmark it, and it was a small but statistically significant improvement for me. I'm also perfectly fine with just dropping this commit if it's not considered worth the complexity.",
      "created_at": "2021-03-05T03:11:24Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588001047",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588001047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": 538,
      "original_start_line": 366,
      "start_side": "RIGHT",
      "line": 539,
      "original_line": 539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588001857",
      "pull_request_review_id": 604770037,
      "id": 588001857,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAwMTg1Nw==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix for 62 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    cd += (int128_t)modinfo->modulus.v[1] * md;\n+    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    d->v[0] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[0] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */\n+    cd += (int128_t)u * d2 + (int128_t)v * e2;\n+    ce += (int128_t)q * d2 + (int128_t)r * e2;\n+    cd += (int128_t)modinfo->modulus.v[2] * md;\n+    ce += (int128_t)modinfo->modulus.v[2] * me;\n+    d->v[1] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[1] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */\n+    cd += (int128_t)u * d3 + (int128_t)v * e3;\n+    ce += (int128_t)q * d3 + (int128_t)r * e3;\n+    cd += (int128_t)modinfo->modulus.v[3] * md;\n+    ce += (int128_t)modinfo->modulus.v[3] * me;\n+    d->v[2] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[2] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */\n+    cd += (int128_t)u * d4 + (int128_t)v * e4;\n+    ce += (int128_t)q * d4 + (int128_t)r * e4;\n+    cd += (int128_t)modinfo->modulus.v[4] * md;\n+    ce += (int128_t)modinfo->modulus.v[4] * me;\n+    d->v[3] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[3] = (int64_t)ce & M62; ce >>= 62;\n+    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */\n+    d->v[4] = (int64_t)cd;\n+    e->v[4] = (int64_t)ce;\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix for 62 divsteps.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];\n+    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int128_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    cf = (int128_t)u * f0 + (int128_t)v * g0;\n+    cg = (int128_t)q * f0 + (int128_t)r * g0;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */\n+    cf += (int128_t)u * f1 + (int128_t)v * g1;\n+    cg += (int128_t)q * f1 + (int128_t)r * g1;\n+    f->v[0] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[0] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */\n+    cf += (int128_t)u * f2 + (int128_t)v * g2;\n+    cg += (int128_t)q * f2 + (int128_t)r * g2;\n+    f->v[1] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[1] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */\n+    cf += (int128_t)u * f3 + (int128_t)v * g3;\n+    cg += (int128_t)q * f3 + (int128_t)r * g3;\n+    f->v[2] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[2] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */\n+    cf += (int128_t)u * f4 + (int128_t)v * g4;\n+    cg += (int128_t)q * f4 + (int128_t)r * g4;\n+    f->v[3] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[3] = (int64_t)cg & M62; cg >>= 62;\n+    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */\n+    f->v[4] = (int64_t)cf;\n+    g->v[4] = (int64_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i;\n+    int64_t eta = -1;\n+\n+    /* Do 12 iterations of 62 divsteps each = 744 divsteps. 724 suffices for 256-bit inputs. */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+    VERIFY_CHECK((g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4]) == 0);\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i, j;\n+    int64_t eta = -1;\n+    int64_t cond;\n+\n+    /* Do up to 12 iterations of 62 divsteps each = 744 divsteps, or until g=0 (whichever comes first). */\n+    for (i = 0; i < 12; ++i) {",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 358,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": 586849411,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's not removed?\r\n\r\nI prefer keeping it because it means that at least in tests we'd hit an error in the VERIFY_CHECK that follows rather than going into a possibly infinite loop. I guess an argument could be made about not doing that in non-test builds (it could be a `while (true)` loop that breaks when g=0, with a `VERIFY_CHECK(i++ < 12);` in it for example).",
      "created_at": "2021-03-05T03:14:43Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588001857",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588001857"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 357,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 521,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588011584",
      "pull_request_review_id": 604780609,
      "id": 588011584,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAxMTU4NA==",
      "diff_hunk": "@@ -814,8 +820,437 @@ void run_num_smalltests(void) {\n }\n #endif\n \n+/***** MODINV TESTS *****/\n+\n+/* compute out = (a*b) mod m; if b=NULL, treat b=1. */\n+void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16_t* m) {\n+    uint16_t mul[32];\n+    uint64_t c = 0;\n+    int i, j;\n+    int m_bitlen = 0;\n+    int mul_bitlen = 0;\n+\n+    if (b != NULL) {\n+        /* Compute the product of a and b, and put it in mul. */\n+        for (i = 0; i < 32; ++i) {\n+            for (j = i <= 15 ? 0 : i - 15; j <= i && j <= 15; j++) {\n+                c += (uint64_t)a[j] * b[i - j];\n+            }\n+            mul[i] = c & 0xFFFF;\n+            c >>= 16;\n+        }\n+        CHECK(c == 0);\n+\n+        /* compute the highest set bit in mul */\n+        for (i = 511; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    } else {\n+        /* if b==NULL, set mul=a. */\n+        memcpy(mul, a, 32);\n+        memset(mul + 16, 0, 32);\n+        /* compute the highest set bit in mul */\n+        for (i = 255; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Compute the highest set bit in m. */\n+    for (i = 255; i >= 0; --i) {\n+        if ((m[i >> 4] >> (i & 15)) & 1) {\n+            m_bitlen = i;\n+            break;\n+        }\n+    }\n+\n+    /* Try do mul -= m<<i, for i going down to 0, whenever the result is not negative */\n+    for (i = mul_bitlen - m_bitlen; i >= 0; --i) {\n+        uint16_t mul2[32];\n+        int64_t cs;\n+\n+        /* Compute mul2 = mul - m<<i. */\n+        cs = 0;\n+        for (j = (i >> 4); j < 32; ++j) { /* skip limbs before i/16 */\n+            uint16_t sub = 0;\n+            int p;\n+            for (p = 0; p < 16; ++p) {\n+                int bitpos = j * 16 - i + p;\n+                if (bitpos >= 0 && bitpos < 256) {\n+                    sub |= ((m[bitpos >> 4] >> (bitpos & 15)) & 1) << p;\n+                }\n+            }\n+            cs += mul[j];\n+            cs -= sub;\n+            mul2[j] = (cs & 0xFFFF);\n+            cs >>= 16;\n+        }\n+        /* If remainder of subtraction is 0, set mul = mul2. */\n+        if (cs == 0) {\n+            memcpy(mul + (i >> 4), mul2 + (i >> 4), sizeof(mul) - 2 * (i >> 4));\n+        }\n+    }\n+    /* Test that all limbs higher than m's highest are zero */\n+    for (i = (m_bitlen >> 4) + 1; i < 32; ++i) {\n+        CHECK(mul[i] == 0);\n+    }\n+    memcpy(out, mul, 32);\n+}\n+\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed30 notation. */\n+void uint16_to_signed30(secp256k1_modinv32_signed30* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 30] |= (int32_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 30);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed30 notation to a representation as 16 uint16_t's. */\n+void signed30_to_uint16(uint16_t* out, const secp256k1_modinv32_signed30* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 30]) >> (i % 30)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */\n+void mutate_sign_signed30(secp256k1_modinv32_signed30* x) {\n+    int i;\n+    for (i = 0; i < 16; ++i) {\n+        int pos = secp256k1_testrand_int(7);\n+        if (x->v[pos] > 0 && x->v[pos + 1] <= 0x3fffffff) {\n+            x->v[pos] -= 0x40000000;\n+            x->v[pos + 1] += 1;\n+        } else if (x->v[pos] < 0 && x->v[pos + 1] >= 0x3fffffff) {\n+            x->v[pos] += 0x40000000;\n+            x->v[pos + 1] -= 1;\n+        }\n+    }\n+}\n+\n+/* Test secp256k1_modinv32{_var}, using inputs in 16-bit limb format, and returning inverse. */\n+void test_modinv32_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod) {\n+    uint16_t tmp[16];\n+    secp256k1_modinv32_signed30 x;\n+    secp256k1_modinv32_modinfo m;\n+    int i, vartime, nonzero;\n+\n+    uint16_to_signed30(&x, in);\n+    nonzero = (x.v[0] | x.v[1] | x.v[2] | x.v[3] | x.v[4] | x.v[5] | x.v[6] | x.v[7] | x.v[8]) != 0;\n+    uint16_to_signed30(&m.modulus, mod);\n+    mutate_sign_signed30(&m.modulus);\n+\n+    /* compute 1/modulus mod 2^30 */\n+    m.modulus_inv30 = m.modulus.v[0];\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 &= 0x3fffffff;\n+    CHECK(((m.modulus_inv30 * m.modulus.v[0]) & 0x3fffffff) == 1);\n+\n+    for (vartime = 0; vartime < 2; ++vartime) {\n+        /* compute inverse */\n+        (vartime ? secp256k1_modinv32_var : secp256k1_modinv32)(&x, &m);\n+\n+        /* produce output */\n+        signed30_to_uint16(out, &x);\n+\n+        /* check if the inverse times the input is 1 (mod m), unless x is 0. */\n+        mulmod256(tmp, out, in, mod);\n+        CHECK(tmp[0] == nonzero);\n+        for (i = 1; i < 16; ++i) CHECK(tmp[i] == 0);\n+\n+        /* invert again */\n+        (vartime ? secp256k1_modinv32_var : secp256k1_modinv32)(&x, &m);\n+\n+        /* check if the result is equal to the input */\n+        signed30_to_uint16(tmp, &x);\n+        for (i = 0; i < 16; ++i) CHECK(tmp[i] == in[i]);\n+    }\n+}\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed62 notation. */\n+void uint16_to_signed62(secp256k1_modinv64_signed62* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 62] |= (int64_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 62);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed62 notation to a representation as 16 uint16_t's. */\n+void signed62_to_uint16(uint16_t* out, const secp256k1_modinv64_signed62* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 62]) >> (i % 62)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */\n+void mutate_sign_signed62(secp256k1_modinv64_signed62* x) {\n+    static const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        int pos = secp256k1_testrand_int(3);\n+        if (x->v[pos] > 0 && x->v[pos + 1] <= M62) {\n+            x->v[pos] -= (M62 + 1);\n+            x->v[pos + 1] += 1;\n+        } else if (x->v[pos] < 0 && x->v[pos + 1] >= -M62) {\n+            x->v[pos] += (M62 + 1);\n+            x->v[pos + 1] -= 1;\n+        }\n+    }\n+}\n+\n+/* Test secp256k1_modinv64{_var}, using inputs in 16-bit limb format, and returning inverse. */\n+void test_modinv64_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod) {\n+    static const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    uint16_t tmp[16];\n+    secp256k1_modinv64_signed62 x;\n+    secp256k1_modinv64_modinfo m;\n+    int i, vartime, nonzero;\n+\n+    uint16_to_signed62(&x, in);\n+    nonzero = (x.v[0] | x.v[1] | x.v[2] | x.v[3] | x.v[4]) != 0;\n+    uint16_to_signed62(&m.modulus, mod);\n+    mutate_sign_signed62(&m.modulus);\n+\n+    /* compute 1/modulus mod 2^62 */\n+    m.modulus_inv62 = m.modulus.v[0];\n+    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\n+    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\n+    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\n+    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\n+    m.modulus_inv62 *= (2 - m.modulus_inv62 * m.modulus.v[0]);\n+    m.modulus_inv62 &= M62;\n+    CHECK(((m.modulus_inv62 * m.modulus.v[0]) & M62) == 1);\n+\n+    for (vartime = 0; vartime < 2; ++vartime) {\n+        /* compute inverse */\n+        (vartime ? secp256k1_modinv64_var : secp256k1_modinv64)(&x, &m);\n+\n+        /* produce output */\n+        signed62_to_uint16(out, &x);\n+\n+        /* check if the inverse times the input is 1 (mod m), unless x is 0. */\n+        mulmod256(tmp, out, in, mod);\n+        CHECK(tmp[0] == nonzero);\n+        for (i = 1; i < 16; ++i) CHECK(tmp[i] == 0);\n+\n+        /* invert again */\n+        (vartime ? secp256k1_modinv64_var : secp256k1_modinv64)(&x, &m);\n+\n+        /* check if the result is equal to the input */\n+        signed62_to_uint16(tmp, &x);\n+        for (i = 0; i < 16; ++i) CHECK(tmp[i] == in[i]);\n+    }\n+}\n+#endif\n+\n+/* test if a and b are coprime */\n+int coprime(const uint16_t* a, const uint16_t* b) {\n+    uint16_t x[16], y[16], t[16];\n+    int i;\n+    int iszero;\n+    memcpy(x, a, 32);\n+    memcpy(y, b, 32);\n+\n+    /* simple gcd loop: while x!=0, (x,y)=(y%x,x) */\n+    while (1) {\n+        iszero = 1;\n+        for (i = 0; i < 16; ++i) {\n+            if (x[i] != 0) {\n+                iszero = 0;\n+                break;\n+            }\n+        }\n+        if (iszero) break;\n+        mulmod256(t, y, NULL, x);\n+        memcpy(y, x, 32);\n+        memcpy(x, t, 32);\n+    }\n+\n+    /* return whether y=1 */\n+    if (y[0] != 1) return 0;\n+    for (i = 1; i < 16; ++i) {\n+        if (y[i] != 0) return 0;\n+    }\n+    return 1;\n+}\n+\n+void run_modinv_tests(void) {\n+    /* Fixed test cases. Each tuple is (input, modulus, output), each as 16x16 bits in LE order. */\n+    static const uint16_t CASES[][3][16] = {\n+        /* Test case known to need 713 divsteps */\n+        {{0x1513, 0x5389, 0x54e9, 0x2798, 0x1957, 0x66a0, 0x8057, 0x3477,\n+          0x7784, 0x1052, 0x326a, 0x9331, 0x6506, 0xa95c, 0x91f3, 0xfb5e},\n+         {0x2bdd, 0x8df4, 0xcc61, 0x481f, 0xdae5, 0x5ca7, 0xf43b, 0x7d54,\n+          0x13d6, 0x469b, 0x2294, 0x20f4, 0xb2a4, 0xa2d1, 0x3ff1, 0xfd4b},\n+         {0xffd8, 0xd9a0, 0x456e, 0x81bb, 0xbabd, 0x6cea, 0x6dbd, 0x73ab,\n+          0xbb94, 0x3d3c, 0xdf08, 0x31c4, 0x3e32, 0xc179, 0x2486, 0xb86b}},\n+        /* Test case known to need 589 divsteps, reaching delta=-140 and\n+           delta=141. */\n+        {{0x3fb1, 0x903b, 0x4eb7, 0x4813, 0xd863, 0x26bf, 0xd89f, 0xa8a9,\n+          0x02fe, 0x57c6, 0x554a, 0x4eab, 0x165e, 0x3d61, 0xee1e, 0x456c},\n+         {0x9295, 0x823b, 0x5c1f, 0x5386, 0x48e0, 0x02ff, 0x4c2a, 0xa2da,\n+          0xe58f, 0x967c, 0xc97e, 0x3f5a, 0x69fb, 0x52d9, 0x0a86, 0xb4a3},\n+         {0x3d30, 0xb893, 0xa809, 0xa7a8, 0x26f5, 0x5b42, 0x55be, 0xf4d0,\n+          0x12c2, 0x7e6a, 0xe41a, 0x90c7, 0xebfa, 0xf920, 0x304e, 0x1419}},\n+        /* Test case known to need 650 divsteps, and doing 65 consecutive (f,g/2) steps. */\n+        {{0x8583, 0x5058, 0xbeae, 0xeb69, 0x48bc, 0x52bb, 0x6a9d, 0xcc94,\n+          0x2a21, 0x87d5, 0x5b0d, 0x42f6, 0x5b8a, 0x2214, 0xe9d6, 0xa040},\n+         {0x7531, 0x27cb, 0x7e53, 0xb739, 0x6a5f, 0x83f5, 0xa45c, 0xcb1d,\n+          0x8a87, 0x1c9c, 0x51d7, 0x851c, 0xb9d8, 0x1fbe, 0xc241, 0xd4a3},\n+         {0xcdb4, 0x275c, 0x7d22, 0xa906, 0x0173, 0xc054, 0x7fdf, 0x5005,\n+          0x7fb8, 0x9059, 0xdf51, 0x99df, 0x2654, 0x8f6e, 0x070f, 0xb347}},\n+        /* Test case with the group order as modulus, needing 635 divsteps. */\n+        {{0x95ed, 0x6c01, 0xd113, 0x5ff1, 0xd7d0, 0x29cc, 0x5817, 0x6120,\n+          0xca8e, 0xaad1, 0x25ae, 0x8e84, 0x9af6, 0x30bf, 0xf0ed, 0x1686},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x1631, 0xbf4a, 0x286a, 0x2716, 0x469f, 0x2ac8, 0x1312, 0xe9bc,\n+          0x04f4, 0x304b, 0x9931, 0x113b, 0xd932, 0xc8f4, 0x0d0d, 0x01a1}},\n+        /* Test case with the field size as modulus, needing 637 divsteps. */\n+        {{0x9ec3, 0x1919, 0xca84, 0x7c11, 0xf996, 0x06f3, 0x5408, 0x6688,\n+          0x1320, 0xdb8a, 0x632a, 0x0dcb, 0x8a84, 0x6bee, 0x9c95, 0xe34e},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x18e5, 0x19b6, 0xdf92, 0x1aaa, 0x09fb, 0x8a3f, 0x52b0, 0x8701,\n+          0xac0c, 0x2582, 0xda44, 0x9bcc, 0x6828, 0x1c53, 0xbd8f, 0xbd2c}},\n+        /* Test case with the field size as modulus, needing 935 divsteps with\n+           broken eta handling. */\n+        {{0x1b37, 0xbdc3, 0x8bcd, 0x25e3, 0x1eae, 0x567d, 0x30b6, 0xf0d8,\n+          0x9277, 0x0cf8, 0x9c2e, 0xecd7, 0x631d, 0xe38f, 0xd4f8, 0x5c93},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x1622, 0xe05b, 0xe880, 0x7de9, 0x3e45, 0xb682, 0xee6c, 0x67ed,\n+          0xa179, 0x15db, 0x6b0d, 0xa656, 0x7ccb, 0x8ef7, 0xa2ff, 0xe279}},\n+        /* Test case with the group size as modulus, needing 981 divsteps with\n+           broken eta handling. */\n+        {{0xfeb9, 0xb877, 0xee41, 0x7fa3, 0x87da, 0x94c4, 0x9d04, 0xc5ae,\n+          0x5708, 0x0994, 0xfc79, 0x0916, 0xbf32, 0x3ad8, 0xe11c, 0x5ca2},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x0f12, 0x075e, 0xce1c, 0x6f92, 0xc80f, 0xca92, 0x9a04, 0x6126,\n+          0x4b6c, 0x57d6, 0xca31, 0x97f3, 0x1f99, 0xf4fd, 0xda4d, 0x42ce}},\n+        /* Test case with the field size as modulus, input = 0. */\n+        {{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}},\n+        /* Test case with the field size as modulus, input = 1. */\n+        {{0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}},\n+        /* Test case with the field size as modulus, input = 2. */\n+        {{0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0xfe18, 0x7fff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x7fff}},\n+        /* Test case with the field size as modulus, input = field - 1. */\n+        {{0xfc2e, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0xfc2f, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0xfc2e, 0xffff, 0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff}},\n+        /* Test case with the group size as modulus, input = 0. */\n+        {{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}},\n+        /* Test case with the group size as modulus, input = 1. */\n+        {{0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}},\n+        /* Test case with the group size as modulus, input = 2. */\n+        {{0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n+          0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x20a1, 0x681b, 0x2f46, 0xdfe9, 0x501d, 0x57a4, 0x6e73, 0x5d57,\n+          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x7fff}},\n+        /* Test case with the group size as modulus, input = group - 1. */\n+        {{0x4140, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x4141, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},\n+         {0x4140, 0xd036, 0x5e8c, 0xbfd2, 0xa03b, 0xaf48, 0xdce6, 0xbaae,\n+          0xfffe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff}}\n+    };\n+\n+    int i, j, ok;\n+\n+    /* Test known inputs/outputs */\n+    for (i = 0; (size_t)i < sizeof(CASES) / sizeof(CASES[0]); ++i) {\n+        uint16_t out[16];\n+        test_modinv32_uint16(out, CASES[i][0], CASES[i][1]);\n+        for (j = 0; j < 16; ++j) CHECK(out[j] == CASES[i][2][j]);\n+#ifdef SECP256K1_WIDEMUL_INT128\n+        test_modinv64_uint16(out, CASES[i][0], CASES[i][1]);\n+        for (j = 0; j < 16; ++j) CHECK(out[j] == CASES[i][2][j]);\n+#endif\n+    }\n+\n+    for (i = 0; i < 100 * count; ++i) {\n+        /* 256-bit numbers in 16-uint16_t's notation */\n+        static const uint16_t ZERO[16] = {0};\n+        uint16_t xd[16];  /* the number (in range [0,2^256)) to be inverted */\n+        uint16_t md[16];  /* the modulus (odd, in range [3,2^256)) */\n+        uint16_t id[16];  /* the inverse of xd mod md */\n+\n+        /* generate random xd and md, so that md is odd, md>1, xd<md, and gcd(xd,md)=1 */\n+        do {\n+            /* generate random xd and md (with many subsequent 0s and 1s) */\n+            secp256k1_testrand256_test((unsigned char*)xd);\n+            secp256k1_testrand256_test((unsigned char*)md);\n+            md[0] |= 1; /* modulus must be odd */\n+            /* If modulus is 1, find another one. */\n+            ok = md[0] != 1;\n+            for (j = 1; j < 16; ++j) ok |= md[j] != 0;\n+            mulmod256(xd, xd, NULL, md); /* Make xd = xd mod m32 */",
      "path": "src/tests.c",
      "position": null,
      "original_position": 434,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "24f17be8f301d91ebd84caf7cf611e105a70a0e2",
      "in_reply_to_id": 587904172,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-03-05T03:43:14Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588011584",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588011584"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1051,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588011609",
      "pull_request_review_id": 604780672,
      "id": 588011609,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAxMTYwOQ==",
      "diff_hunk": "@@ -814,8 +820,437 @@ void run_num_smalltests(void) {\n }\n #endif\n \n+/***** MODINV TESTS *****/\n+\n+/* compute out = (a*b) mod m; if b=NULL, treat b=1. */\n+void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16_t* m) {\n+    uint16_t mul[32];\n+    uint64_t c = 0;\n+    int i, j;\n+    int m_bitlen = 0;\n+    int mul_bitlen = 0;\n+\n+    if (b != NULL) {\n+        /* Compute the product of a and b, and put it in mul. */\n+        for (i = 0; i < 32; ++i) {\n+            for (j = i <= 15 ? 0 : i - 15; j <= i && j <= 15; j++) {\n+                c += (uint64_t)a[j] * b[i - j];\n+            }\n+            mul[i] = c & 0xFFFF;\n+            c >>= 16;\n+        }\n+        CHECK(c == 0);\n+\n+        /* compute the highest set bit in mul */\n+        for (i = 511; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    } else {\n+        /* if b==NULL, set mul=a. */\n+        memcpy(mul, a, 32);\n+        memset(mul + 16, 0, 32);\n+        /* compute the highest set bit in mul */\n+        for (i = 255; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Compute the highest set bit in m. */\n+    for (i = 255; i >= 0; --i) {\n+        if ((m[i >> 4] >> (i & 15)) & 1) {\n+            m_bitlen = i;\n+            break;\n+        }\n+    }\n+\n+    /* Try do mul -= m<<i, for i going down to 0, whenever the result is not negative */\n+    for (i = mul_bitlen - m_bitlen; i >= 0; --i) {\n+        uint16_t mul2[32];\n+        int64_t cs;\n+\n+        /* Compute mul2 = mul - m<<i. */\n+        cs = 0;\n+        for (j = (i >> 4); j < 32; ++j) { /* skip limbs before i/16 */\n+            uint16_t sub = 0;\n+            int p;\n+            for (p = 0; p < 16; ++p) {\n+                int bitpos = j * 16 - i + p;\n+                if (bitpos >= 0 && bitpos < 256) {\n+                    sub |= ((m[bitpos >> 4] >> (bitpos & 15)) & 1) << p;\n+                }\n+            }\n+            cs += mul[j];\n+            cs -= sub;\n+            mul2[j] = (cs & 0xFFFF);\n+            cs >>= 16;\n+        }\n+        /* If remainder of subtraction is 0, set mul = mul2. */\n+        if (cs == 0) {\n+            memcpy(mul + (i >> 4), mul2 + (i >> 4), sizeof(mul) - 2 * (i >> 4));\n+        }\n+    }\n+    /* Test that all limbs higher than m's highest are zero */\n+    for (i = (m_bitlen >> 4) + 1; i < 32; ++i) {\n+        CHECK(mul[i] == 0);\n+    }\n+    memcpy(out, mul, 32);\n+}\n+\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed30 notation. */\n+void uint16_to_signed30(secp256k1_modinv32_signed30* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 30] |= (int32_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 30);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed30 notation to a representation as 16 uint16_t's. */\n+void signed30_to_uint16(uint16_t* out, const secp256k1_modinv32_signed30* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 30]) >> (i % 30)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */\n+void mutate_sign_signed30(secp256k1_modinv32_signed30* x) {\n+    int i;\n+    for (i = 0; i < 16; ++i) {\n+        int pos = secp256k1_testrand_int(7);\n+        if (x->v[pos] > 0 && x->v[pos + 1] <= 0x3fffffff) {\n+            x->v[pos] -= 0x40000000;\n+            x->v[pos + 1] += 1;\n+        } else if (x->v[pos] < 0 && x->v[pos + 1] >= 0x3fffffff) {\n+            x->v[pos] += 0x40000000;\n+            x->v[pos + 1] -= 1;\n+        }\n+    }\n+}\n+\n+/* Test secp256k1_modinv32{_var}, using inputs in 16-bit limb format, and returning inverse. */\n+void test_modinv32_uint16(uint16_t* out, const uint16_t* in, const uint16_t* mod) {\n+    uint16_t tmp[16];\n+    secp256k1_modinv32_signed30 x;\n+    secp256k1_modinv32_modinfo m;\n+    int i, vartime, nonzero;\n+\n+    uint16_to_signed30(&x, in);\n+    nonzero = (x.v[0] | x.v[1] | x.v[2] | x.v[3] | x.v[4] | x.v[5] | x.v[6] | x.v[7] | x.v[8]) != 0;\n+    uint16_to_signed30(&m.modulus, mod);\n+    mutate_sign_signed30(&m.modulus);\n+\n+    /* compute 1/modulus mod 2^30 */\n+    m.modulus_inv30 = m.modulus.v[0];\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 *= (2 - m.modulus_inv30 * m.modulus.v[0]);\n+    m.modulus_inv30 &= 0x3fffffff;\n+    CHECK(((m.modulus_inv30 * m.modulus.v[0]) & 0x3fffffff) == 1);\n+\n+    for (vartime = 0; vartime < 2; ++vartime) {\n+        /* compute inverse */\n+        (vartime ? secp256k1_modinv32_var : secp256k1_modinv32)(&x, &m);\n+\n+        /* produce output */\n+        signed30_to_uint16(out, &x);\n+\n+        /* check if the inverse times the input is 1 (mod m), unless x is 0. */\n+        mulmod256(tmp, out, in, mod);\n+        CHECK(tmp[0] == nonzero);\n+        for (i = 1; i < 16; ++i) CHECK(tmp[i] == 0);\n+\n+        /* invert again */\n+        (vartime ? secp256k1_modinv32_var : secp256k1_modinv32)(&x, &m);\n+\n+        /* check if the result is equal to the input */\n+        signed30_to_uint16(tmp, &x);\n+        for (i = 0; i < 16; ++i) CHECK(tmp[i] == in[i]);\n+    }\n+}\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed62 notation. */\n+void uint16_to_signed62(secp256k1_modinv64_signed62* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 62] |= (int64_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 62);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed62 notation to a representation as 16 uint16_t's. */\n+void signed62_to_uint16(uint16_t* out, const secp256k1_modinv64_signed62* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 62]) >> (i % 62)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */\n+void mutate_sign_signed62(secp256k1_modinv64_signed62* x) {\n+    static const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        int pos = secp256k1_testrand_int(3);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 205,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "24f17be8f301d91ebd84caf7cf611e105a70a0e2",
      "in_reply_to_id": 587879209,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-03-05T03:43:20Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588011609",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588011609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1004,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588011669",
      "pull_request_review_id": 604780916,
      "id": 588011669,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAxMTY2OQ==",
      "diff_hunk": "@@ -814,8 +820,437 @@ void run_num_smalltests(void) {\n }\n #endif\n \n+/***** MODINV TESTS *****/\n+\n+/* compute out = (a*b) mod m; if b=NULL, treat b=1. */\n+void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16_t* m) {\n+    uint16_t mul[32];\n+    uint64_t c = 0;\n+    int i, j;\n+    int m_bitlen = 0;\n+    int mul_bitlen = 0;\n+\n+    if (b != NULL) {\n+        /* Compute the product of a and b, and put it in mul. */\n+        for (i = 0; i < 32; ++i) {\n+            for (j = i <= 15 ? 0 : i - 15; j <= i && j <= 15; j++) {\n+                c += (uint64_t)a[j] * b[i - j];\n+            }\n+            mul[i] = c & 0xFFFF;\n+            c >>= 16;\n+        }\n+        CHECK(c == 0);\n+\n+        /* compute the highest set bit in mul */\n+        for (i = 511; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    } else {\n+        /* if b==NULL, set mul=a. */\n+        memcpy(mul, a, 32);\n+        memset(mul + 16, 0, 32);\n+        /* compute the highest set bit in mul */\n+        for (i = 255; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Compute the highest set bit in m. */\n+    for (i = 255; i >= 0; --i) {\n+        if ((m[i >> 4] >> (i & 15)) & 1) {\n+            m_bitlen = i;\n+            break;\n+        }\n+    }\n+\n+    /* Try do mul -= m<<i, for i going down to 0, whenever the result is not negative */\n+    for (i = mul_bitlen - m_bitlen; i >= 0; --i) {\n+        uint16_t mul2[32];\n+        int64_t cs;\n+\n+        /* Compute mul2 = mul - m<<i. */\n+        cs = 0;\n+        for (j = (i >> 4); j < 32; ++j) { /* skip limbs before i/16 */\n+            uint16_t sub = 0;\n+            int p;\n+            for (p = 0; p < 16; ++p) {\n+                int bitpos = j * 16 - i + p;\n+                if (bitpos >= 0 && bitpos < 256) {\n+                    sub |= ((m[bitpos >> 4] >> (bitpos & 15)) & 1) << p;\n+                }\n+            }\n+            cs += mul[j];\n+            cs -= sub;\n+            mul2[j] = (cs & 0xFFFF);\n+            cs >>= 16;\n+        }\n+        /* If remainder of subtraction is 0, set mul = mul2. */\n+        if (cs == 0) {\n+            memcpy(mul + (i >> 4), mul2 + (i >> 4), sizeof(mul) - 2 * (i >> 4));\n+        }\n+    }\n+    /* Test that all limbs higher than m's highest are zero */\n+    for (i = (m_bitlen >> 4) + 1; i < 32; ++i) {\n+        CHECK(mul[i] == 0);\n+    }\n+    memcpy(out, mul, 32);\n+}\n+\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed30 notation. */\n+void uint16_to_signed30(secp256k1_modinv32_signed30* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 30] |= (int32_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 30);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed30 notation to a representation as 16 uint16_t's. */\n+void signed30_to_uint16(uint16_t* out, const secp256k1_modinv32_signed30* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 30]) >> (i % 30)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */\n+void mutate_sign_signed30(secp256k1_modinv32_signed30* x) {\n+    int i;\n+    for (i = 0; i < 16; ++i) {\n+        int pos = secp256k1_testrand_int(7);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 128,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "24f17be8f301d91ebd84caf7cf611e105a70a0e2",
      "in_reply_to_id": 587858052,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-03-05T03:43:28Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588011669",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588011669"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 927,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588011819",
      "pull_request_review_id": 604780955,
      "id": 588011819,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAxMTgxOQ==",
      "diff_hunk": "@@ -814,8 +820,437 @@ void run_num_smalltests(void) {\n }\n #endif\n \n+/***** MODINV TESTS *****/\n+\n+/* compute out = (a*b) mod m; if b=NULL, treat b=1. */\n+void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16_t* m) {\n+    uint16_t mul[32];\n+    uint64_t c = 0;\n+    int i, j;\n+    int m_bitlen = 0;\n+    int mul_bitlen = 0;\n+\n+    if (b != NULL) {\n+        /* Compute the product of a and b, and put it in mul. */\n+        for (i = 0; i < 32; ++i) {\n+            for (j = i <= 15 ? 0 : i - 15; j <= i && j <= 15; j++) {\n+                c += (uint64_t)a[j] * b[i - j];\n+            }\n+            mul[i] = c & 0xFFFF;\n+            c >>= 16;\n+        }\n+        CHECK(c == 0);\n+\n+        /* compute the highest set bit in mul */\n+        for (i = 511; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    } else {\n+        /* if b==NULL, set mul=a. */\n+        memcpy(mul, a, 32);\n+        memset(mul + 16, 0, 32);\n+        /* compute the highest set bit in mul */\n+        for (i = 255; i >= 0; --i) {\n+            if ((mul[i >> 4] >> (i & 15)) & 1) {\n+                mul_bitlen = i;\n+                break;\n+            }\n+        }\n+    }\n+\n+    /* Compute the highest set bit in m. */\n+    for (i = 255; i >= 0; --i) {\n+        if ((m[i >> 4] >> (i & 15)) & 1) {\n+            m_bitlen = i;\n+            break;\n+        }\n+    }\n+\n+    /* Try do mul -= m<<i, for i going down to 0, whenever the result is not negative */\n+    for (i = mul_bitlen - m_bitlen; i >= 0; --i) {\n+        uint16_t mul2[32];\n+        int64_t cs;\n+\n+        /* Compute mul2 = mul - m<<i. */\n+        cs = 0;\n+        for (j = (i >> 4); j < 32; ++j) { /* skip limbs before i/16 */\n+            uint16_t sub = 0;\n+            int p;\n+            for (p = 0; p < 16; ++p) {\n+                int bitpos = j * 16 - i + p;\n+                if (bitpos >= 0 && bitpos < 256) {\n+                    sub |= ((m[bitpos >> 4] >> (bitpos & 15)) & 1) << p;\n+                }\n+            }\n+            cs += mul[j];\n+            cs -= sub;\n+            mul2[j] = (cs & 0xFFFF);\n+            cs >>= 16;\n+        }\n+        /* If remainder of subtraction is 0, set mul = mul2. */\n+        if (cs == 0) {\n+            memcpy(mul + (i >> 4), mul2 + (i >> 4), sizeof(mul) - 2 * (i >> 4));\n+        }\n+    }\n+    /* Test that all limbs higher than m's highest are zero */\n+    for (i = (m_bitlen >> 4) + 1; i < 32; ++i) {\n+        CHECK(mul[i] == 0);\n+    }\n+    memcpy(out, mul, 32);\n+}\n+\n+/* Convert a 256-bit number represented as 16 uint16_t's to signed30 notation. */\n+void uint16_to_signed30(secp256k1_modinv32_signed30* out, const uint16_t* in) {\n+    int i;\n+    memset(out->v, 0, sizeof(out->v));\n+    for (i = 0; i < 256; ++i) {\n+        out->v[i / 30] |= (int32_t)(((in[i >> 4]) >> (i & 15)) & 1) << (i % 30);\n+    }\n+}\n+\n+/* Convert a 256-bit number in signed30 notation to a representation as 16 uint16_t's. */\n+void signed30_to_uint16(uint16_t* out, const secp256k1_modinv32_signed30* in) {\n+    int i;\n+    memset(out, 0, 32);\n+    for (i = 0; i < 256; ++i) {\n+        out[i >> 4] |= (((in->v[i / 30]) >> (i % 30)) & 1) << (i & 15);\n+    }\n+}\n+\n+/* Randomly mutate the sign of limbs in signed62 representation. */",
      "path": "src/tests.c",
      "position": null,
      "original_position": 124,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "24f17be8f301d91ebd84caf7cf611e105a70a0e2",
      "in_reply_to_id": 587854192,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-03-05T03:43:35Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588011819",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588011819"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 923,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588011974",
      "pull_request_review_id": 604781012,
      "id": 588011974,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAxMTk3NA==",
      "diff_hunk": "@@ -814,8 +820,437 @@ void run_num_smalltests(void) {\n }\n #endif\n \n+/***** MODINV TESTS *****/\n+\n+/* compute out = (a*b) mod m; if b=NULL, treat b=1. */\n+void mulmod256(uint16_t* out, const uint16_t* a, const uint16_t* b, const uint16_t* m) {",
      "path": "src/tests.c",
      "position": 74,
      "original_position": 27,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "24f17be8f301d91ebd84caf7cf611e105a70a0e2",
      "in_reply_to_id": 587831135,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a comment.",
      "created_at": "2021-03-05T03:43:44Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588011974",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588011974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 658,
      "original_line": 658,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588012992",
      "pull_request_review_id": 604782032,
      "id": 588012992,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAxMjk5Mg==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 95,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": 586790134,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a comment.",
      "created_at": "2021-03-05T03:46:29Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588012992",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588012992"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 94,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588013021",
      "pull_request_review_id": 604782074,
      "id": 588013021,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAxMzAyMQ==",
      "diff_hunk": "@@ -276,4 +276,55 @@ SECP256K1_GNUC_EXT typedef __int128 int128_t;\n # endif\n #endif\n \n+#ifndef __has_builtin\n+#define __has_builtin(x) 0\n+#endif\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 32-bit x. */\n+static SECP256K1_INLINE int secp256k1_ctz32_var(uint32_t x) {\n+    VERIFY_CHECK(x != 0);\n+#if (__has_builtin(__builtin_ctz) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* If the unsigned type is sufficient to represent the largest uint32_t, consider __builtin_ctz. */\n+    if (((unsigned)UINT32_MAX) == UINT32_MAX) {\n+        return __builtin_ctz(x);\n+    }\n+#endif\n+#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* Otherwise consider __builtin_ctzl (the unsigned long type is always at least 32 bits). */\n+    return __builtin_ctzl(x);\n+#else\n+    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\n+    static const uint8_t debruijn[32] = {\n+        0x00, 0x01, 0x02, 0x18, 0x03, 0x13, 0x06, 0x19, 0x16, 0x04, 0x14, 0x0A,\n+        0x10, 0x07, 0x0C, 0x1A, 0x1F, 0x17, 0x12, 0x05, 0x15, 0x09, 0x0F, 0x0B,\n+        0x1E, 0x11, 0x08, 0x0E, 0x1D, 0x0D, 0x1C, 0x1B\n+    };\n+    return debruijn[((x & -x) * 0x04D7651F) >> 27];\n+#endif\n+}\n+\n+/* Determine the number of trailing zero bits in a (non-zero) 64-bit x. */\n+static SECP256K1_INLINE int secp256k1_ctz64_var(uint64_t x) {\n+    VERIFY_CHECK(x != 0);\n+#if (__has_builtin(__builtin_ctzl) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* If the unsigned long type is sufficient to represent the largest uint64_t, consider __builtin_ctzl. */\n+    if (((unsigned long)UINT64_MAX) == UINT64_MAX) {\n+        return __builtin_ctzl(x);\n+    }\n+#endif\n+#if (__has_builtin(__builtin_ctzll) || SECP256K1_GNUC_PREREQ(3,4))\n+    /* Otherwise consider __builtin_ctzll (the unsigned long long type is always at least 64 bits). */\n+    return __builtin_ctzll(x);\n+#else\n+    /* If no suitable CTZ builtin is available, use a (variable time) software emulation. */\n+    static const uint8_t debruijn[64] = {\n+        0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,\n+        62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,\n+        63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,\n+        51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12\n+    };\n+    return debruijn[((x & -x) * 0x022FDD63CC95386D) >> 58];",
      "path": "src/util.h",
      "position": null,
      "original_position": 51,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a772bfba5380e96036650fb52005a8b9f58aefe3",
      "in_reply_to_id": 586786108,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-03-05T03:46:37Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588013021",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588013021"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 320,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 326,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588024157",
      "pull_request_review_id": 604794943,
      "id": 588024157,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODAyNDE1Nw==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix for 62 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    cd += (int128_t)modinfo->modulus.v[1] * md;\n+    ce += (int128_t)modinfo->modulus.v[1] * me;",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 245,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": 586832794,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If you reason at a slightly higher level, and accept/verify that cd and ce act as accumulators for a big integer computation (values scaled by 1 get added to it, one limb is extracted/shifted, values scaled by 2^62 get added to it, another limb is extracted/shifted, ...) you can look at the sum of all those scaled values - and we know that the value of those is d and e itself, which are in range (-modulus,2*modulus).\r\n\r\nThat's not a guarantee on itself about the intermediary ranges during the computation, but if no overflows happen there, it implies that after the last addition, the cd/ce values are in range `floor(-modulus/2^(3*62))..floor(2*modulus/2^(3*62))`, or just 71 bit (with 256-bit modulus).",
      "created_at": "2021-03-05T04:24:09Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588024157",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588024157"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 238,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588211810",
      "pull_request_review_id": 605029367,
      "id": 588211810,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxMTgxMA==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix for 62 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    cd += (int128_t)modinfo->modulus.v[1] * md;\n+    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    d->v[0] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[0] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */\n+    cd += (int128_t)u * d2 + (int128_t)v * e2;\n+    ce += (int128_t)q * d2 + (int128_t)r * e2;\n+    cd += (int128_t)modinfo->modulus.v[2] * md;\n+    ce += (int128_t)modinfo->modulus.v[2] * me;\n+    d->v[1] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[1] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */\n+    cd += (int128_t)u * d3 + (int128_t)v * e3;\n+    ce += (int128_t)q * d3 + (int128_t)r * e3;\n+    cd += (int128_t)modinfo->modulus.v[3] * md;\n+    ce += (int128_t)modinfo->modulus.v[3] * me;\n+    d->v[2] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[2] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */\n+    cd += (int128_t)u * d4 + (int128_t)v * e4;\n+    ce += (int128_t)q * d4 + (int128_t)r * e4;\n+    cd += (int128_t)modinfo->modulus.v[4] * md;\n+    ce += (int128_t)modinfo->modulus.v[4] * me;\n+    d->v[3] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[3] = (int64_t)ce & M62; ce >>= 62;\n+    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */\n+    d->v[4] = (int64_t)cd;\n+    e->v[4] = (int64_t)ce;\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix for 62 divsteps.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];\n+    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int128_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    cf = (int128_t)u * f0 + (int128_t)v * g0;\n+    cg = (int128_t)q * f0 + (int128_t)r * g0;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */\n+    cf += (int128_t)u * f1 + (int128_t)v * g1;\n+    cg += (int128_t)q * f1 + (int128_t)r * g1;\n+    f->v[0] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[0] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */\n+    cf += (int128_t)u * f2 + (int128_t)v * g2;\n+    cg += (int128_t)q * f2 + (int128_t)r * g2;\n+    f->v[1] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[1] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */\n+    cf += (int128_t)u * f3 + (int128_t)v * g3;\n+    cg += (int128_t)q * f3 + (int128_t)r * g3;\n+    f->v[2] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[2] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */\n+    cf += (int128_t)u * f4 + (int128_t)v * g4;\n+    cg += (int128_t)q * f4 + (int128_t)r * g4;\n+    f->v[3] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[3] = (int64_t)cg & M62; cg >>= 62;\n+    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */\n+    f->v[4] = (int64_t)cf;\n+    g->v[4] = (int64_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i;\n+    int64_t eta = -1;\n+\n+    /* Do 12 iterations of 62 divsteps each = 744 divsteps. 724 suffices for 256-bit inputs. */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+    VERIFY_CHECK((g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4]) == 0);\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i, j;\n+    int64_t eta = -1;\n+    int64_t cond;\n+\n+    /* Do up to 12 iterations of 62 divsteps each = 744 divsteps, or until g=0 (whichever comes first). */\n+    for (i = 0; i < 12; ++i) {",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 358,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": 586849411,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh yes, I was looking at the wrong loop.\r\n\r\n>  I guess an argument could be made about not doing that in non-test builds (it could be a while (true) loop that breaks when g=0, with a VERIFY_CHECK(i++ < 12); in it for example).\r\n\r\nYeah, I think this will be a little bit more conservative and it also expresses the algorithm more in a more natural way.",
      "created_at": "2021-03-05T11:04:24Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588211810",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588211810"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 357,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 521,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588212646",
      "pull_request_review_id": 605030459,
      "id": 588212646,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxMjY0Ng==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix for 62 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    cd += (int128_t)modinfo->modulus.v[1] * md;\n+    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    d->v[0] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[0] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */\n+    cd += (int128_t)u * d2 + (int128_t)v * e2;\n+    ce += (int128_t)q * d2 + (int128_t)r * e2;\n+    cd += (int128_t)modinfo->modulus.v[2] * md;\n+    ce += (int128_t)modinfo->modulus.v[2] * me;\n+    d->v[1] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[1] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */\n+    cd += (int128_t)u * d3 + (int128_t)v * e3;\n+    ce += (int128_t)q * d3 + (int128_t)r * e3;\n+    cd += (int128_t)modinfo->modulus.v[3] * md;\n+    ce += (int128_t)modinfo->modulus.v[3] * me;\n+    d->v[2] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[2] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */\n+    cd += (int128_t)u * d4 + (int128_t)v * e4;\n+    ce += (int128_t)q * d4 + (int128_t)r * e4;\n+    cd += (int128_t)modinfo->modulus.v[4] * md;\n+    ce += (int128_t)modinfo->modulus.v[4] * me;\n+    d->v[3] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[3] = (int64_t)ce & M62; ce >>= 62;\n+    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */\n+    d->v[4] = (int64_t)cd;\n+    e->v[4] = (int64_t)ce;\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix for 62 divsteps.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];\n+    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int128_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    cf = (int128_t)u * f0 + (int128_t)v * g0;\n+    cg = (int128_t)q * f0 + (int128_t)r * g0;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */\n+    cf += (int128_t)u * f1 + (int128_t)v * g1;\n+    cg += (int128_t)q * f1 + (int128_t)r * g1;\n+    f->v[0] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[0] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */\n+    cf += (int128_t)u * f2 + (int128_t)v * g2;\n+    cg += (int128_t)q * f2 + (int128_t)r * g2;\n+    f->v[1] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[1] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */\n+    cf += (int128_t)u * f3 + (int128_t)v * g3;\n+    cg += (int128_t)q * f3 + (int128_t)r * g3;\n+    f->v[2] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[2] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */\n+    cf += (int128_t)u * f4 + (int128_t)v * g4;\n+    cg += (int128_t)q * f4 + (int128_t)r * g4;\n+    f->v[3] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[3] = (int64_t)cg & M62; cg >>= 62;\n+    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */\n+    f->v[4] = (int64_t)cf;\n+    g->v[4] = (int64_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i;\n+    int64_t eta = -1;\n+\n+    /* Do 12 iterations of 62 divsteps each = 744 divsteps. 724 suffices for 256-bit inputs. */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+    VERIFY_CHECK((g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4]) == 0);\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i, j;\n+    int64_t eta = -1;\n+    int64_t cond;\n+\n+    /* Do up to 12 iterations of 62 divsteps each = 744 divsteps, or until g=0 (whichever comes first). */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62_var(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+        /* If the bottom limb of g is zero, there is a chance that g=0. */\n+        if (g.v[0] == 0) {",
      "path": "src/modinv64_impl.h",
      "position": 539,
      "original_position": 367,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": 586844591,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No, I think it's fine, I was really just curious. You may still want to add the EXPECT then.",
      "created_at": "2021-03-05T11:05:54Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588212646",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588212646"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": 538,
      "original_start_line": 366,
      "start_side": "RIGHT",
      "line": 539,
      "original_line": 539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588747002",
      "pull_request_review_id": 605650119,
      "id": 588747002,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODc0NzAwMg==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix for 62 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    cd += (int128_t)modinfo->modulus.v[1] * md;\n+    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    d->v[0] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[0] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */\n+    cd += (int128_t)u * d2 + (int128_t)v * e2;\n+    ce += (int128_t)q * d2 + (int128_t)r * e2;\n+    cd += (int128_t)modinfo->modulus.v[2] * md;\n+    ce += (int128_t)modinfo->modulus.v[2] * me;\n+    d->v[1] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[1] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */\n+    cd += (int128_t)u * d3 + (int128_t)v * e3;\n+    ce += (int128_t)q * d3 + (int128_t)r * e3;\n+    cd += (int128_t)modinfo->modulus.v[3] * md;\n+    ce += (int128_t)modinfo->modulus.v[3] * me;\n+    d->v[2] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[2] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */\n+    cd += (int128_t)u * d4 + (int128_t)v * e4;\n+    ce += (int128_t)q * d4 + (int128_t)r * e4;\n+    cd += (int128_t)modinfo->modulus.v[4] * md;\n+    ce += (int128_t)modinfo->modulus.v[4] * me;\n+    d->v[3] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[3] = (int64_t)ce & M62; ce >>= 62;\n+    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */\n+    d->v[4] = (int64_t)cd;\n+    e->v[4] = (int64_t)ce;\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix for 62 divsteps.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];\n+    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int128_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    cf = (int128_t)u * f0 + (int128_t)v * g0;\n+    cg = (int128_t)q * f0 + (int128_t)r * g0;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */\n+    cf += (int128_t)u * f1 + (int128_t)v * g1;\n+    cg += (int128_t)q * f1 + (int128_t)r * g1;\n+    f->v[0] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[0] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */\n+    cf += (int128_t)u * f2 + (int128_t)v * g2;\n+    cg += (int128_t)q * f2 + (int128_t)r * g2;\n+    f->v[1] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[1] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */\n+    cf += (int128_t)u * f3 + (int128_t)v * g3;\n+    cg += (int128_t)q * f3 + (int128_t)r * g3;\n+    f->v[2] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[2] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */\n+    cf += (int128_t)u * f4 + (int128_t)v * g4;\n+    cg += (int128_t)q * f4 + (int128_t)r * g4;\n+    f->v[3] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[3] = (int64_t)cg & M62; cg >>= 62;\n+    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */\n+    f->v[4] = (int64_t)cf;\n+    g->v[4] = (int64_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i;\n+    int64_t eta = -1;\n+\n+    /* Do 12 iterations of 62 divsteps each = 744 divsteps. 724 suffices for 256-bit inputs. */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+    VERIFY_CHECK((g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4]) == 0);\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i, j;\n+    int64_t eta = -1;\n+    int64_t cond;\n+\n+    /* Do up to 12 iterations of 62 divsteps each = 744 divsteps, or until g=0 (whichever comes first). */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62_var(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+        /* If the bottom limb of g is zero, there is a chance that g=0. */\n+        if (g.v[0] == 0) {",
      "path": "src/modinv64_impl.h",
      "position": 539,
      "original_position": 367,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": 586844591,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I tried a few alternatives (looping and breaking at the first nonzero, looping like the current code but without branch on the 1st limb, same code with EXPECT(...,0), same code with EXPECT(...,1)), but they're all measurably slower (some less than 1%, which may be the result of random binary alignments, but it's still consistently the case).",
      "created_at": "2021-03-05T22:07:24Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588747002",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588747002"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": 538,
      "original_start_line": 366,
      "start_side": "RIGHT",
      "line": 539,
      "original_line": 539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588751304",
      "pull_request_review_id": 605652869,
      "id": 588751304,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODc1MTMwNA==",
      "diff_hunk": "@@ -0,0 +1,386 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman                                    *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * For an explanation of the algorithm, see doc/safegcd_implementation.md. This file contains an\n+ * implementation for N=62, using 62-bit signed limbs represented as int64_t.\n+ */\n+\n+/* Take as input a signed62 number in range (-2*modulus,modulus), and add a multiple of the modulus\n+ * to it to bring it to range [0,modulus). If sign < 0, the input will also be negated in the\n+ * process. The input must have limbs in range (-2^62,2^62). The output will have limbs in range\n+ * [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t sign, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add, cond_negate;\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. Note that the right\n+     * shifts below are signed sign-extending shifts (see assumptions.h for tests that that is\n+     * indeed the behavior of the right shift operator). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    cond_negate = sign >> 63;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static int64_t secp256k1_modinv64_divsteps_62_var(int64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    /* inv256[i] = -(2*i+1)^-1 (mod 256) */\n+    static const uint8_t inv256[128] = {\n+        0xFF, 0x55, 0x33, 0x49, 0xC7, 0x5D, 0x3B, 0x11, 0x0F, 0xE5, 0xC3, 0x59,\n+        0xD7, 0xED, 0xCB, 0x21, 0x1F, 0x75, 0x53, 0x69, 0xE7, 0x7D, 0x5B, 0x31,\n+        0x2F, 0x05, 0xE3, 0x79, 0xF7, 0x0D, 0xEB, 0x41, 0x3F, 0x95, 0x73, 0x89,\n+        0x07, 0x9D, 0x7B, 0x51, 0x4F, 0x25, 0x03, 0x99, 0x17, 0x2D, 0x0B, 0x61,\n+        0x5F, 0xB5, 0x93, 0xA9, 0x27, 0xBD, 0x9B, 0x71, 0x6F, 0x45, 0x23, 0xB9,\n+        0x37, 0x4D, 0x2B, 0x81, 0x7F, 0xD5, 0xB3, 0xC9, 0x47, 0xDD, 0xBB, 0x91,\n+        0x8F, 0x65, 0x43, 0xD9, 0x57, 0x6D, 0x4B, 0xA1, 0x9F, 0xF5, 0xD3, 0xE9,\n+        0x67, 0xFD, 0xDB, 0xB1, 0xAF, 0x85, 0x63, 0xF9, 0x77, 0x8D, 0x6B, 0xC1,\n+        0xBF, 0x15, 0xF3, 0x09, 0x87, 0x1D, 0xFB, 0xD1, 0xCF, 0xA5, 0x83, 0x19,\n+        0x97, 0xAD, 0x8B, 0xE1, 0xDF, 0x35, 0x13, 0x29, 0xA7, 0x3D, 0x1B, 0xF1,\n+        0xEF, 0xC5, 0xA3, 0x39, 0xB7, 0xCD, 0xAB, 0x01\n+    };\n+\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m;\n+    uint32_t w;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if (eta < 0) {\n+            uint64_t tmp;\n+            eta = -eta;\n+            tmp = f; f = g; g = -tmp;\n+            tmp = u; u = q; q = -tmp;\n+            tmp = v; v = r; r = -tmp;\n+        }\n+        /* eta is now >= 0. In what follows we're going to cancel out the bottom bits of g. No more\n+         * than i can be cancelled out (as we'd be done before that point), and no more than eta+1\n+         * can be done as its sign will flip once that happens. */\n+        limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+        /* m is a mask for the bottom min(limit, 8) bits (our table only supports 8 bits). */\n+        m = (UINT64_MAX >> (64 - limit)) & 255U;\n+        /* Find what multiple of f must be added to g to cancel its bottom min(limit, 8) bits. */\n+        w = (g * inv256[(f >> 1) & 127]) & m;\n+        /* Do so. */\n+        g += f * w;\n+        q += u * w;\n+        r += v * w;\n+        VERIFY_CHECK((g & m) == 0);\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute (t/2^62) * [d, e] mod modulus, where t is a transition matrix for 62 divsteps.\n+ *\n+ * On input and output, d and e are in range (-2*modulus,modulus). All output limbs will be in range\n+ * (-2^62,2^62).\n+ *\n+ * This implements the update_de function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_de_62(secp256k1_modinv64_signed62 *d, secp256k1_modinv64_signed62 *e, const secp256k1_modinv64_trans2x2 *t, const secp256k1_modinv64_modinfo* modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t d0 = d->v[0], d1 = d->v[1], d2 = d->v[2], d3 = d->v[3], d4 = d->v[4];\n+    const int64_t e0 = e->v[0], e1 = e->v[1], e2 = e->v[2], e3 = e->v[3], e4 = e->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int64_t md, me, sd, se;\n+    int128_t cd, ce;\n+    /* [md,me] start as zero; plus [u,q] if d is negative; plus [v,r] if e is negative. */\n+    sd = d4 >> 63;\n+    se = e4 >> 63;\n+    md = (u & sd) + (v & se);\n+    me = (q & sd) + (r & se);\n+    /* Begin computing t*[d,e]. */\n+    cd = (int128_t)u * d0 + (int128_t)v * e0;\n+    ce = (int128_t)q * d0 + (int128_t)r * e0;\n+    /* Correct md,me so that t*[d,e]+modulus*[md,me] has 62 zero bottom bits. */\n+    md -= (modinfo->modulus_inv62 * (uint64_t)cd + md) & M62;\n+    me -= (modinfo->modulus_inv62 * (uint64_t)ce + me) & M62;\n+    /* Update the beginning of computation for t*[d,e]+modulus*[md,me] now md,me are known. */\n+    cd += (int128_t)modinfo->modulus.v[0] * md;\n+    ce += (int128_t)modinfo->modulus.v[0] * me;\n+    /* Verify that the low 62 bits of the computation are indeed zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cd & M62) == 0); cd >>= 62;\n+    VERIFY_CHECK(((int64_t)ce & M62) == 0); ce >>= 62;\n+    /* Compute limb 1 of t*[d,e]+modulus*[md,me], and store it as output limb 0 (= down shift). */\n+    cd += (int128_t)u * d1 + (int128_t)v * e1;\n+    ce += (int128_t)q * d1 + (int128_t)r * e1;\n+    cd += (int128_t)modinfo->modulus.v[1] * md;\n+    ce += (int128_t)modinfo->modulus.v[1] * me;\n+    d->v[0] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[0] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 2 of t*[d,e]+modulus*[md,me], and store it as output limb 1. */\n+    cd += (int128_t)u * d2 + (int128_t)v * e2;\n+    ce += (int128_t)q * d2 + (int128_t)r * e2;\n+    cd += (int128_t)modinfo->modulus.v[2] * md;\n+    ce += (int128_t)modinfo->modulus.v[2] * me;\n+    d->v[1] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[1] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 3 of t*[d,e]+modulus*[md,me], and store it as output limb 2. */\n+    cd += (int128_t)u * d3 + (int128_t)v * e3;\n+    ce += (int128_t)q * d3 + (int128_t)r * e3;\n+    cd += (int128_t)modinfo->modulus.v[3] * md;\n+    ce += (int128_t)modinfo->modulus.v[3] * me;\n+    d->v[2] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[2] = (int64_t)ce & M62; ce >>= 62;\n+    /* Compute limb 4 of t*[d,e]+modulus*[md,me], and store it as output limb 3. */\n+    cd += (int128_t)u * d4 + (int128_t)v * e4;\n+    ce += (int128_t)q * d4 + (int128_t)r * e4;\n+    cd += (int128_t)modinfo->modulus.v[4] * md;\n+    ce += (int128_t)modinfo->modulus.v[4] * me;\n+    d->v[3] = (int64_t)cd & M62; cd >>= 62;\n+    e->v[3] = (int64_t)ce & M62; ce >>= 62;\n+    /* What remains is limb 5 of t*[d,e]+modulus*[md,me]; store it as output limb 4. */\n+    d->v[4] = (int64_t)cd;\n+    e->v[4] = (int64_t)ce;\n+}\n+\n+/* Compute (t/2^62) * [f, g], where t is a transition matrix for 62 divsteps.\n+ *\n+ * This implements the update_fg function from the explanation.\n+ */\n+static void secp256k1_modinv64_update_fg_62(secp256k1_modinv64_signed62 *f, secp256k1_modinv64_signed62 *g, const secp256k1_modinv64_trans2x2 *t) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    const int64_t f0 = f->v[0], f1 = f->v[1], f2 = f->v[2], f3 = f->v[3], f4 = f->v[4];\n+    const int64_t g0 = g->v[0], g1 = g->v[1], g2 = g->v[2], g3 = g->v[3], g4 = g->v[4];\n+    const int64_t u = t->u, v = t->v, q = t->q, r = t->r;\n+    int128_t cf, cg;\n+    /* Start computing t*[f,g]. */\n+    cf = (int128_t)u * f0 + (int128_t)v * g0;\n+    cg = (int128_t)q * f0 + (int128_t)r * g0;\n+    /* Verify that the bottom 62 bits of the result are zero, and then throw them away. */\n+    VERIFY_CHECK(((int64_t)cf & M62) == 0); cf >>= 62;\n+    VERIFY_CHECK(((int64_t)cg & M62) == 0); cg >>= 62;\n+    /* Compute limb 1 of t*[f,g], and store it as output limb 0 (= down shift). */\n+    cf += (int128_t)u * f1 + (int128_t)v * g1;\n+    cg += (int128_t)q * f1 + (int128_t)r * g1;\n+    f->v[0] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[0] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 2 of t*[f,g], and store it as output limb 1. */\n+    cf += (int128_t)u * f2 + (int128_t)v * g2;\n+    cg += (int128_t)q * f2 + (int128_t)r * g2;\n+    f->v[1] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[1] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 3 of t*[f,g], and store it as output limb 2. */\n+    cf += (int128_t)u * f3 + (int128_t)v * g3;\n+    cg += (int128_t)q * f3 + (int128_t)r * g3;\n+    f->v[2] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[2] = (int64_t)cg & M62; cg >>= 62;\n+    /* Compute limb 4 of t*[f,g], and store it as output limb 3. */\n+    cf += (int128_t)u * f4 + (int128_t)v * g4;\n+    cg += (int128_t)q * f4 + (int128_t)r * g4;\n+    f->v[3] = (int64_t)cf & M62; cf >>= 62;\n+    g->v[3] = (int64_t)cg & M62; cg >>= 62;\n+    /* What remains is limb 5 of t*[f,g]; store it as output limb 4. */\n+    f->v[4] = (int64_t)cf;\n+    g->v[4] = (int64_t)cg;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (constant time in x). */\n+static void secp256k1_modinv64(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i;\n+    int64_t eta = -1;\n+\n+    /* Do 12 iterations of 62 divsteps each = 744 divsteps. 724 suffices for 256-bit inputs. */\n+    for (i = 0; i < 12; ++i) {\n+        /* Compute transition matrix and new eta after 62 divsteps. */\n+        secp256k1_modinv64_trans2x2 t;\n+        eta = secp256k1_modinv64_divsteps_62(eta, f.v[0], g.v[0], &t);\n+        /* Update d,e using that transition matrix. */\n+        secp256k1_modinv64_update_de_62(&d, &e, &t, modinfo);\n+        /* Update f,g using that transition matrix. */\n+        secp256k1_modinv64_update_fg_62(&f, &g, &t);\n+    }\n+\n+    /* At this point sufficient iterations have been performed that g must have reached 0\n+     * and (if g was not originally 0) f must now equal +/- GCD of the initial f, g\n+     * values i.e. +/- 1, and d now contains +/- the modular inverse. */\n+    VERIFY_CHECK((g.v[0] | g.v[1] | g.v[2] | g.v[3] | g.v[4]) == 0);\n+\n+    /* Optionally negate d, normalize to [0,modulus), and return it. */\n+    secp256k1_modinv64_normalize_62(&d, f.v[4], modinfo);\n+    *x = d;\n+}\n+\n+/* Compute the inverse of x modulo modinfo->modulus, and replace x with it (variable time). */\n+static void secp256k1_modinv64_var(secp256k1_modinv64_signed62 *x, const secp256k1_modinv64_modinfo *modinfo) {\n+    /* Start with d=0, e=1, f=modulus, g=x, eta=-1. */\n+    secp256k1_modinv64_signed62 d = {{0, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 e = {{1, 0, 0, 0, 0}};\n+    secp256k1_modinv64_signed62 f = modinfo->modulus;\n+    secp256k1_modinv64_signed62 g = *x;\n+    int i, j;\n+    int64_t eta = -1;\n+    int64_t cond;\n+\n+    /* Do up to 12 iterations of 62 divsteps each = 744 divsteps, or until g=0 (whichever comes first). */\n+    for (i = 0; i < 12; ++i) {",
      "path": "src/modinv64_impl.h",
      "position": null,
      "original_position": 358,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "faff81b3ae62fb7a99a609ed321e84397f71c6f3",
      "in_reply_to_id": 586849411,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-03-05T22:12:59Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588751304",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588751304"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 357,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 521,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588766553",
      "pull_request_review_id": 605665673,
      "id": 588766553,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODc2NjU1Mw==",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+/***********************************************************************\n+ * Copyright (c) 2020 Peter Dettman, Pieter Wuille                     *\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef SECP256K1_MODINV64_IMPL_H\n+#define SECP256K1_MODINV64_IMPL_H\n+\n+#include \"modinv64.h\"\n+\n+#include \"util.h\"\n+\n+/* This file implements modular inversion based on the paper \"Fast constant-time gcd computation and\n+ * modular inversion\" by Daniel J. Bernstein and Bo-Yin Yang.\n+ *\n+ * See https://gcd.cr.yp.to/papers.html#safegcd for the paper. The references below are for the Date:\n+ * 2019.04.13 version.\n+ *\n+ * Below is an explanation of the implementation, building up the algorithm in Python3 step by step.\n+ *\n+ *\n+ * 1. Computing the Greatest Common Divisor (GCD) using divsteps\n+ * -------------------------------------------------------------\n+ *\n+ * The algorithm from the paper, at a very high level, is this:\n+ *\n+ * def gcd(f, g):\n+ *     \"\"\"Compute the GCD of an odd integer f and another integer g.\"\"\"\n+ *     assert f & 1  # require f to be odd\n+ *     delta = 1     # additional state variable\n+ *     while g != 0:\n+ *         assert f & 1  # f will be odd in every iteration\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g = 1 - delta, g, (g - f) // 2\n+ *         elif g & 1:\n+ *             delta, f, g = 1 + delta, f, (g + f) // 2\n+ *         else:\n+ *             delta, f, g = 1 + delta, f, (g    ) // 2\n+ *     return abs(f)\n+ *\n+ * It computes the greatest common divisor of an odd integer f and any integer g. Its inner loop\n+ * keeps rewriting the variables f and g alongside a state variable delta that starts at 1, until\n+ * g=0 is reached. At that point, |f| gives the GCD. Each of the transitions in the loop is called a\n+ * \"division step\" (referred to as divstep in what follows).\n+ *\n+ * For example, gcd(21, 14) would be computed as:\n+ * - Start with delta=1 f=21 g=14\n+ * - Take the third branch: delta=2 f=21 g=7\n+ * - Take the first branch: delta=-1 f=7 g=-7\n+ * - Take the second branch: delta=0 f=7 g=0\n+ * - The answer |f| = 7.\n+ *\n+ * Why it works:\n+ * - Divsteps can be decomposed into two steps (see paragraph 8.2 in the paper):\n+ *   - (a) If g is odd, replace (f,g) with (g,g-f) or (f,g+f), resulting in an even g.\n+ *   - (b) Replace (f,g) with (f,g//2) (where g is guaranteed to be even).\n+ * - Neither of those two operations change the GCD:\n+ *   - For (a), assume gcd(f,g)=c, then it must be the case that f=a*c and g=b*c for some integers a\n+ *     and b. As (g,g-f)=(b*c,(b-a)*c) and (f,f+g)=(a*c,(a+b)*c), the result clearly still has\n+ *     common factor c. Reasoning in the other direction shows that no common factor can be added by\n+ *     doing so either.\n+ *   - For (b), we know that f is odd, so gcd(f,g) clearly has no common factor 2, and we can remove\n+ *     it from g.\n+ * - The algorithm will eventually converge to g=0. This is proven in the paper (see theorem G.3).\n+ * - It follows that eventually we find a final value f' for which gcd(f,g) = gcd(f',0). As the\n+ *   gcd of f' and 0 is |f'| by definition, that is our answer.\n+ *\n+ * Compared to more traditional GCD algorithms, this one has the property of only ever looking at\n+ * the low-order bits of the variables to decide the next steps, and being easy to make\n+ * constant-time (in more low-level languages than Python). The delta parameter is necessary to\n+ * guide the algorithm towards shrinking the numbers' magnitudes without explicitly needing to look\n+ * at high order bits.\n+ *\n+ * Properties that will become important later:\n+ * - Performing more divsteps than needed is not a problem, as f does not change anymore after g=0.\n+ * - Only even numbers are divided by 2. This means that when reasoning about it algebraically we\n+ *   do not need to worry about rounding.\n+ * - At every point during the algorithm's execution the next N steps only depend on the bottom N\n+ *   bits of f and g, and on delta.\n+ *\n+ *\n+ * 2. From GCDs to modular inverses\n+ * --------------------------------\n+ *\n+ * We want an algorithm to compute the inverse a of x modulo M, i.e. the number a such that a*x=1\n+ * mod M. This inverse only exists if the GCD of x and M is 1, but that is always the case if M is\n+ * prime and 0 < x < M. In what follows, assume that the modular inverse exists. To find that\n+ * inverse, it turns out this can be computed as a side effect of computing the GCD by keeping track\n+ * of how the internal variables can be written as linear combinations of the inputs at every step.\n+ * Since the GCD is 1, such an algorithm will compute numbers a and b such that a*x + b*M = 1.\n+ * Taking that expression mod M gives a*x mod M = 1, and we see that a is the modular inverse of x\n+ * mod M.\n+ *\n+ * A similar approach can be used to calculate modular inverses using the divsteps-based GCD\n+ * algorithm shown above, if the modulus M is odd. To do so, compute gcd(f=M,g=x), while keeping\n+ * track of extra variables d and e, for which at every step d = f/x (mod M) and e = g/x (mod M).\n+ * f/x here means the number which multiplied with x gives f mod M. As f and g are initialized to M\n+ * and x respectively, d and e just start off being 0 (M/x mod M = 0/x mod M = 0) and 1 (x/x mod M\n+ * = 1).\n+ *\n+ * def div2(M, x):\n+ *     \"\"\"Helper routine to compute x/2 mod M (where M is odd).\"\"\"\n+ *     assert M & 1\n+ *     if x & 1: # If x is odd, make it even by adding M.\n+ *         x += M\n+ *     # x must be even now, so a clean division by 2 is possible.\n+ *     return x // 2\n+ *\n+ * def modinv(M, x):\n+ *     \"\"\"Compute the inverse of x mod M (given that it exists, and M is odd).\"\"\"\n+ *     assert M & 1\n+ *     delta, f, g, d, e = 1, M, x, 0, 1\n+ *     while g != 0:\n+ *         # Note that while division by two for f and g is only ever done on even inputs, this is\n+ *         # not true for d and e, so we need the div2 helper function.\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, d, e = 1 - delta, g, (g - f) // 2, e, div2(M, e - d)\n+ *         elif g & 1:\n+ *             delta, f, g, d, e = 1 + delta, f, (g + f) // 2, d, div2(M, e + d)\n+ *         else:\n+ *             delta, f, g, d, e = 1 + delta, f, (g    ) // 2, d, div2(M, e    )\n+ *         # Verify that the invariants d=f/x mod M, e=g/x mod M are maintained.\n+ *         assert f % M == (d * x) % M\n+ *         assert g % M == (e * x) % M\n+ *     assert f == 1 or f == -1  # |f| is the GCD, it must be 1\n+ *     # Because of invariant d = f/x (mod M), 1/x = d/f (mod M). As |f|=1, d/f = d*f.\n+ *     return (d * f) % M\n+ *\n+ * Also note that this approach to track d and e throughout the computation to determine the inverse\n+ * is different from the paper. There (see paragraph 12.1 in the paper) a transition matrix for the\n+ * entire computation is determined (see section 3 below) and the inverse is computed from that.\n+ * The approach here avoids the need for 2x2 matrix multiplications of various sizes, and appears to\n+ * be faster (after the optimizations explained below) for the size of numbers we care about.\n+ *\n+ *\n+ * 3. Batching multiple divsteps\n+ * -----------------------------\n+ *\n+ * Every divstep can be expressed as a matrix multiplication, applying a transition matrix (1/2*t)\n+ * to both vectors [f, g] and [d, e] (see paragraph 8.1 in the paper):\n+ *\n+ *   t = [ u,  v ]\n+ *       [ q,  r ]\n+ *\n+ *   [ out_f ] = (1/2 * t) * [ in_f ]\n+ *   [ out_g ] =             [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2 * t) * [ in_d ]  (mod M)\n+ *   [ out_e ]               [ in_e ]\n+ *\n+ * where (u, v, q, r) is (0, 2, -1, 1), (2, 0, 1, 1), or (2, 0, 0, 1), depending on which branch is\n+ * taken. As above, the resulting f and g are always integers.\n+ *\n+ * Performing multiple divsteps corresponds to a multiplication with the product of all the\n+ * individual divsteps' transition matrices. As each transition matrix consists of integers\n+ * divided by 2, the product of these matrices will consist of integers divided by 2^N (see also\n+ * theorem 9.2 in the paper). These divisions are expensive when updating d and e, so we delay\n+ * them: we compute the integer coefficients of the combined transition matrix scaled by 2^N, and\n+ * do one division by 2^N as a final step:\n+ *\n+ * def divsteps_n_matrix(delta, f, g):\n+ *     \"\"\"Compute delta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         if delta > 0 and g & 1:\n+ *             delta, f, g, u, v, q, r = 1 - delta, g, (g - f) // 2, 2*q, 2*r, q-u, r-v\n+ *         elif g & 1:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g + f) // 2, 2*u, 2*v, q+u, r+v\n+ *         else:\n+ *             delta, f, g, u, v, q, r = 1 + delta, f, (g    ) // 2, 2*u, 2*v, q  , r\n+ *     return delta, (u, v, q, r)\n+ *\n+ * As the branches in the divsteps are completely determined by the bottom N bits of f and g, this\n+ * function to compute the transition matrix only needs to see those bottom bits. Furthermore all\n+ * intermediate results and outputs fit in (N+1)-bit numbers (unsigned for f and g; signed for u, v,\n+ * q, and r) (see also paragraph 8.3 in the paper). This means that an implementation using 64-bit\n+ * integers could set N=62 and compute the full transition matrix for 62 steps at once without any\n+ * big integer arithmetic at all. This is the reason why this algorithm is efficient: it only needs\n+ * to update the full-size f, g, d, and e numbers once every N steps.\n+ *\n+ * We still need functions to compute:\n+ *\n+ *   [ out_f ] = (1/2^N * [ u,  v ]) * [ in_f ]\n+ *   [ out_g ]   (        [ q,  r ])   [ in_g ]\n+ *\n+ *   [ out_d ] = (1/2^N * [ u,  v ]) * [ in_d ]  (mod M)\n+ *   [ out_e ]   (        [ q,  r ])   [ in_e ]\n+ *\n+ * For f and g that's easy:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     cf, cg = u*f + v*g, q*f + r*g\n+ *     # (t / 2^N) should cleanly apply to [f,g] so the result of t*[f,g] should have N zero\n+ *     # bottom bits.\n+ *     assert cf % 2**N == 0\n+ *     assert cg % 2**N == 0\n+ *     return cf >> N, cg >> N\n+ *\n+ * To do the same for d and e, we need an equivalent of the div2 function for division by 2^N mod M.\n+ * This is easy if we have precomputed M^-1 mod 2^N (which always exists for odd M):\n+ *\n+ * def div2n(M, Mi, x):\n+ *     \"\"\"Compute x/2^N mod M, given Mi = 1/M mod 2^N.\"\"\"\n+ *     assert (M * Mi) % 2**N == 1\n+ *     # Find a factor m such that m*M has the same bottom N bits as x. We want:\n+ *     #     (m * M) mod 2^N = x mod 2^N\n+ *     # <=> m mod 2^N = (x / M) mod 2^N\n+ *     # <=> m mod 2^N = (x * Mi) mod 2^N\n+ *     m = (Mi * x) % 2**N\n+ *     # Subtract that multiple from x, cancelling its bottom N bits.\n+ *     x -= m * M\n+ *     # Now a clean division by 2^N is possible.\n+ *     assert x % 2**N == 0\n+ *     return (x >> N) % M\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     return div2n(M, Mi, cd), div2n(M, Mi, ce)\n+ *\n+ * With all of those, we can write a version of modinv that performs N divsteps at once:\n+ *\n+ * def modinv(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     assert M & 1\n+ *     delta, f, g, d, e = 1, M, x, 0, 1\n+ *     while g != 0:\n+ *         # Compute the delta and transition matrix t for the next N divsteps (this only needs\n+ *         # (N+1)-bit signed integer arithmetic).\n+ *         delta, t = divsteps_n_matrix(delta, f % 2**N, g % 2**N)\n+ *         # Apply the transition matrix t to [f, g]:\n+ *         f, g = update_fg(f, g, t)\n+ *         # Apply the transition matrix t to [d, e]:\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return (d * f) % M\n+ *\n+ * This means that in practice we'll always perform a multiple of N divsteps. This is not a problem\n+ * because once g=0, further divsteps do not affect f, g, d, or e anymore (only delta keeps\n+ * increasing). For variable time code such excess iterations will be mostly optimized away in\n+ * section 6.\n+ *\n+ *\n+ * 4. Avoiding modulus operations\n+ * ------------------------------\n+ *\n+ * So far, there are two places where we compute a remainder of big numbers modulo M: at the end of\n+ * div2n in every update_de, and at the very end of modinv after potentially negating d due to the\n+ * sign of f. These are relatively expensive operations when done generically.\n+ *\n+ * To deal with the modulus operation in div2n, we simply stop requiring d and e to be in range\n+ * [0,M) all the time. Let's start by inlining div2n into update_de, and dropping the modulus\n+ * operation at the end:\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e] mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     u, v, q, r = t\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     md = -((Mi * cd) % 2**N)\n+ *     me = -((Mi * ce) % 2**N)\n+ *     cd += md * M\n+ *     ce += me * M\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * Let's look at bounds on the ranges of these numbers. It can be shown that |u|+|v| and |q|+|r|\n+ * never exceed 2^N (see paragraph 8.3 in the paper), and thus a multiplication with t will have\n+ * outputs whose absolute values are at most 2^N times the maximum absolute input value. In case the\n+ * inputs d and e are in (-M,M), which is certainly true for the initial values d=0 and e=1 assuming\n+ * M > 1, the multiplication results in numbers in range (-2^N*M,2^N*M). Subtracting up to 2^N-1\n+ * times M to cancel out N bits brings that up to slightly less than (-2^(N+1)*M,2^N*M), and\n+ * dividing by 2^N at the end takes it to (-2*M,M). Another application of update_de would take that\n+ * to (-3*M,2*M), and so forth. This progressive expansion of the variables' ranges can be\n+ * counteracted by incrementing d and e by M whenever they're negative:\n+ *\n+ *     ...\n+ *     if d < 0:\n+ *         d += M\n+ *     if e < 0:\n+ *         e += M\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * With inputs in (-2*M,M), they will first be shifted into range (-M,M), which means that the\n+ * output will again be in (-2*M,M), and this remains the case regardless of how many update_de\n+ * invocations there are. *\n+ *\n+ * Now note that increasing d by M is equal to incrementing cd by u*M and ce by q*M. Similarly,\n+ * increasing e by M is equal to incrementing cd by v*M and ce by r*M. So we could instead write:\n+ *\n+ *     ...\n+ *     cd, ce = u*d + v*e, q*d + r*e\n+ *     if d < 0:\n+ *         cd, ce = cd + u*M, ce + q*M\n+ *     if e < 0:\n+ *         cd, ce = cd + v*M, ce + r*M\n+ *     # Cancel out bottom N bits of cd and ce.\n+ *     ...\n+ *\n+ * Now note that we have two steps of corrections to cd and ce that add multiples of M: this\n+ * increment, and the decrement that cancels out bottom bits. The second one depends on the first\n+ * one, but they can still be efficiently combined by only computing the bottom bits of cd and ce\n+ * at first, and using that to compute the final md, me values:\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     md, me = 0, 0\n+ *     # Compute what multiples of M to add to cd and ce.\n+ *     if d < 0:\n+ *         md, me = md + u, me + q\n+ *     if e < 0:\n+ *         md, me = md + v, me + r\n+ *     # Compute bottom N bits of t*[d,e] + M*[md,me].\n+ *     cd, ce = (u*d + v*e + md*M) % 2**N, (q*d + r*e + me*M) % 2**N\n+ *     # Correct md and me such that the bottom N bits of t*[d,e] + M*[md,me] are zero.\n+ *     md -= (Mi * cd) % 2**N\n+ *     me -= (Mi * ce) % 2**N\n+ *     # Do the full computation.\n+ *     cd, ce = u*d + v*e + md*M, q*d + r*e + me*M\n+ *     # And cleanly divide by 2**N.\n+ *     return cd >> N, ce >> N\n+ *\n+ * One last optimization: we can avoid the md*M and me*M multiplications in the bottom bits of cd\n+ * and ce by moving them to the md and me correction:\n+ *\n+ *     ...\n+ *     # Compute bottom N bits of t*[d,e].\n+ *     cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+ *     # Correct md and me such that the bottom N bits of t*[d,e]+M*[md,me] are zero.\n+ *     # Note that this is not the same as {md = (Mi * cd) % 2**N} etc. That would also result in N\n+ *     # zero bottom bits, but isn't guaranteed to be a reduction of [0,2^N) compared to the\n+ *     # previous md and me values, and thus would violate our bounds analysis.\n+ *     md -= (Mi*cd + md) % 2**N\n+ *     me -= (Mi*ce + me) % 2**N\n+ *     ...\n+ *\n+ * The resulting function takes as input d and e in range (-2*M,M) and outputs values in the same\n+ * range. That also means that the d value at the end of modinv will be in that range, while we want\n+ * a result in [0,M). To do that, we need a normalization function. It's easy to integrate the\n+ * conditional negation of d (based on the sign of f) into it as well:\n+ *\n+ * def normalize(sign, v, M):\n+ *     \"\"\"Compute sign*v mod M, where v is in range (-2*M,M); output in [0,M).\"\"\"\n+ *     assert sign == 1 or sign == -1\n+ *     # v in (-2*M,M)\n+ *     if v < 0:\n+ *         v += M\n+ *     # v in (-M,M)\n+ *     if sign == -1:\n+ *         v = -v\n+ *     # v in (-M,M)\n+ *     if v < 0:\n+ *         v += M\n+ *     # v in [0,M)\n+ *     return v\n+ *\n+ * And calling it in modinv is simply:\n+ *\n+ *    ...\n+ *    return normalize(f, d, M)\n+ *\n+ *\n+ * 5. Constant-time operation\n+ * --------------------------\n+ *\n+ * The primary selling point of the algorithm is fast constant-time operation. What code flow still\n+ * depends on the input data so far?\n+ *\n+ * - The number of iterations of the while g != 0 loop in modinv.\n+ * - The branches inside divsteps_n_matrix.\n+ * - The sign checks in update_de\n+ * - The sign checks in normalize\n+ *\n+ * To make the while loop in modinv constant time it can be replaced with a constant number of\n+ * iterations. The paper proves (Theorem 11.2) that 741 divsteps are sufficient for any 256-bit\n+ * inputs, and https://github.com/sipa/safegcd-bounds shows that the slightly better bound 724 is\n+ * sufficient even. Given that every loop iteration performs N divsteps, it will run a total of\n+ * ceil(724/N) times.\n+ *\n+ * Dealing with the branches in divsteps_n_matrix requires replacing them with constant-time\n+ * bitwise operations (and hoping the C compiler isn't smart enough to turn them back into\n+ * branches; see valgrind_ctime_test.c for automated tests that this isn't the case). To do so,\n+ * observe that a divstep can be written instead as:\n+ *\n+ *     if g & 1:\n+ *         g += -f if delta > 0 else f    # set g to (input) g-f or g+f\n+ *         if delta > 0:\n+ *             delta = -delta\n+ *             f += g                     # set f to (input) g (note that g was set to g-f before)\n+ *     delta += 1\n+ *     g >>= 1\n+ *\n+ * To convert this into bitwise operations, we rely on this trick to implement conditional negation:\n+ * For every v, -v == ~v + 1, so since bitflipping is equal to xoring with -1, we get\n+ * -v == (v xor -1) + 1. Thus, ((v xor mask) - mask) is {v if mask=0; -v if mask=-1}. With that we\n+ * just need a way to quickly compute this mask from delta and g's parity. It turns out this is\n+ * slightly easier if instead of delta we track the equivalent eta = -delta. In that case a mask for\n+ * eta < 0 (= delta > 0) is just (eta >> 63) for int64_t. With that, we can write a constant-time\n+ * divstep as:\n+ *\n+ *     # Compute a mask c1 for eta < 0, and compute the conditional negation x of f:\n+ *     c1 = eta >> 63\n+ *     x = (f ^ c1) - c1\n+ *     # Compute a mask c2 for odd g, and conditionally add x to g:\n+ *     c2 = -(g & 1)\n+ *     g += x & c2\n+ *     # Compute a mask c for (eta < 0) and odd (input) g, and use it to conditionally negate eta,\n+ *     # and add g to f:\n+ *     c = c1 & c2\n+ *     eta = (eta ^ c) - c\n+ *     f += g & c\n+ *     # Unconditional operations:\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Note that the semantics of Python ints conveniently matches C here (assuming two's complement\n+ * behavior for signed integers; see assumptions.h), for the purpose of these techniques: right\n+ * shifting always rounds down, so (eta >> 63) is -1 if eta is negative; and bitwise operations with\n+ * -1 treat the number as equivalent to infinitely many 1 bits).\n+ *\n+ * By replacing the loop in divsteps_n_matrix with a variant of the divstep code above (extended to\n+ * also apply all f operations to u, v and all g operations to q, r), a constant-time version of\n+ * divsteps_n_matrix is obtained.\n+ *\n+ * These bit fiddling tricks can also be used to make the conditional negations and additions in\n+ * update_de and normalize constant-time.\n+ *\n+ *\n+ * 6. Variable-time optimizations\n+ * ------------------------------\n+ *\n+ * If we don't want constant time code, the changes from the previous sections are unnecessary, and\n+ * we may instead see if it's possible to go in the other direction - making things faster by\n+ * introducing more variable-time steps.\n+ *\n+ * Here we start with yet another way of writing the (loop of) divstep operations, based on\n+ * paragraph 8.2 from the paper:\n+ *\n+ * for _ in range(N):\n+ *     if g & 1 and eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     if g & 1:\n+ *         g += f\n+ *     eta -= 1\n+ *     g >>= 1\n+ *\n+ * Observe that as long as g is even, all the loop does is shift it down and decrease eta. If we can\n+ * count the bottom 0 bits in g efficiently (as can be done on most platforms), we can do multiple\n+ * iterations at once:\n+ *\n+ * i = N # divsteps left to do\n+ * while True:\n+ *     # Get rid of all bottom zeros at once\n+ *     zeros = min(i, count_trailing_zeros(g))\n+ *     eta, i = eta - zeros, i - zeros\n+ *     g >>= zeros\n+ *     if i == 0:\n+ *         break\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, -f\n+ *     g += f\n+ *\n+ * Now observe that eta always >= 0 on the last line. If eta is even higher, the loop will not run\n+ * the {eta, f, g = -eta, g, f} statement again until eta goes negative. All the last line does is\n+ * g += f with various shifted version of g, in order in order to make g's bottom bit zero, until we\n+ * run out of iterations (i reaches 0) or eta goes negative.\n+ *\n+ * Nothing prevents us from instead cancelling out multiple bits of g at once by adding a multiple\n+ * of f to it, as long as it's not more than i steps (as we'd finish the loop before doing more) or\n+ * more than eta+1 steps (as we'd run {eta, f, g = -eta, g, f} at that point). Here is a way to do\n+ * up to 4 at a time:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * i = N\n+ * while True:\n+ *     ...\n+ *     # We know g is odd now\n+ *     if eta < 0:\n+ *         eta, f, g = -eta, g, f\n+ *     # Compute limit on number of bits to cancel\n+ *     limit = min(min(eta + 1, i), 4)\n+ *     # Compute w = -g/f mod 2**limit, using the table value for -1/f mod 2**4. Note that f is\n+ *     # always odd, so its inverse modulo a power of two always exists.\n+ *     w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *     # As w = -g/f mod (2**limit), g+w*f mod 2**limit = 0 mod 2**limit.\n+ *     g += w * f\n+ *     assert g % (2**limit) == 0\n+ *     # The next iteration will now shift out all (limit) bottom zero bits from g.\n+ *\n+ * By using a bigger table more bits can be cancelled at once. The table can also be implemented\n+ * as a formula:\n+ *  - Instead of a 3-bit table:\n+ *    * (-f) or (f ^ 6)\n+ *  - Instead of a 4-bit table:\n+ *    * (1 - f * (f + 1))\n+ *    * (-(f + (((f + 1) & 4) << 1)))\n+ *  - For larger tables the following technique can be used: if w=-f^-1 mod 2^i, then w*(w*f+2) is\n+ *    -f^-1 mod 2^(2*i). This allows extending the previous formulas (or tables). In particular we\n+ *    have this 6-bit function (based on the 3-bit function above):\n+ *    * (f * (f * f - 2))\n+ *\n+ * This loop, again extended to also handle u, v, q, and r alongside f and g, placed in\n+ * divsteps_n_matrix, gives a significantly faster, but non-constant time version. It is usable when\n+ * not operating on secret data.\n+ *\n+ * 7. Final Python version\n+ * -----------------------\n+ *\n+ * All together we need the following functions:\n+ *\n+ * - A way to compute the transition matrix in constant time, using the divsteps_n_matrix function\n+ *   from section 2, but with its loop replaced by a variant of the constant-time divstep from\n+ *   section 5, extended to handle u, v, q, r:\n+ *\n+ * def divsteps_n_matrix(eta, f, g):\n+ *     \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1 # start with identity matrix\n+ *     for _ in range(N):\n+ *         c1 = eta >> 63\n+ *         # Compute x, y, z as conditionally-negated versions of f, u, v.\n+ *         x, y, z = (f ^ c1) - c1, (u ^ c1) - c1, (v ^ c1) - c1\n+ *         c2 = -(g & 1)\n+ *         # Conditionally add x, y, z to g, q, r.\n+ *         g, q, r = g + (x & c2), q + (y & c2), r + (z & c2)\n+ *         c1 &= c2                     # reusing c1 here for further conditionals\n+ *         eta = (eta ^ c1) - (c1 + 1)  # inlining the unconditional eta decrement here\n+ *         # Conditionally add g, q, r to f, u, v.\n+ *         f, u, v = f + (g & c1), u + (q & c1), v + (r & c1)\n+ *         # When shifting g down, don't shift q, r, as we construct a transition matrix multiplied\n+ *         # by 2^N. Instead, shift f's coefficients u and v up.\n+ *         g, u, v = g >> 1, u << 1, v << 1\n+ *     return eta, (u, v, q, r)\n+ *\n+ * - The functions to update f and g, and d and e, from section 2 and section 4, with the constant-time\n+ *   changes to update_de from section 5:\n+ *\n+ * def update_fg(f, g, t):\n+ *     \"\"\"Multiply matrix t/2^N with [f, g].\"\"\"\n+ *     u, v, q, r = t\n+ *     cf, cg = u*f + v*g, q*f + r*g\n+ *     return cf >> N, cg >> N\n+ *\n+ * def update_de(d, e, t, M, Mi):\n+ *     \"\"\"Multiply matrix t/2^N with [d, e], modulo M.\"\"\"\n+ *     u, v, q, r = t\n+ *     d_sign, e_sign = d >> 257, e >> 257\n+ *     md, me = (u & d_sign) + (v & e_sign), (q & d_sign) + (r & e_sign)\n+ *     cd, ce = (u*d + v*e) % 2**N, (q*d + r*e) % 2**N\n+ *     md -= (Mi*cd + md) % 2**N\n+ *     me -= (Mi*ce + me) % 2**N\n+ *     cd, ce = u*d + v*e + Mi*md, q*d + r*e + Mi*me\n+ *     return cd >> N, ce >> N\n+ *\n+ * - The normalize function from section 4, made constant time as well:\n+ *\n+ * def normalize(sign, v, M):\n+ *     \"\"\"Compute sign*v mod M, where v in (-2*M,M); output in [0,M).\"\"\"\n+ *     v_sign = v >> 257\n+ *     # Conditionally add M to v.\n+ *     v += M & v_sign\n+ *     c = (sign - 1) >> 1\n+ *     # Conditionally negate v.\n+ *     v = (v ^ c) - c\n+ *     v_sign = v >> 257\n+ *     # Conditionally add M to v again.\n+ *     v += M & v_sign\n+ *     return v\n+ *\n+ * - And finally the modinv function too, adapted to use eta instead of delta, and using the fixed\n+ *   iteration count from section 5:\n+ *\n+ * def modinv(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi=1/M mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, M, x, 0, 1\n+ *     for _ in range((724 + N - 1) // N):\n+ *         eta, t = divsteps_n_matrix(-eta, f % 2**N, g % 2**N)\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return normalize(f, d, M)\n+ *\n+ * - To get a variable time version, replace the divsteps_n_matrix function with one that uses the\n+ *   divsteps loop from section 5, and a modinv version that calls it without the fixed iteration\n+ *   count:\n+ *\n+ * NEGINV16 = [15, 5, 3, 9, 7, 13, 11, 1] # NEGINV16[n//2] = (-n)^-1 mod 16, for odd n\n+ * def divsteps_n_matrix_var(eta, f, g):\n+ *     \"\"\"Compute eta and transition matrix t after N divsteps (multiplied by 2^N).\"\"\"\n+ *     u, v, q, r = 1, 0, 0, 1\n+ *     i = N\n+ *     while True:\n+ *         zeros = min(i, count_trailing_zeros(g))\n+ *         eta, i = eta - zeros, i - zeros\n+ *         g, u, v = g >> zeros, u << zeros, v << zeros\n+ *         if i == 0:\n+ *             break\n+ *         if eta < 0:\n+ *             eta, f, u, v, g, q, r = -eta, g, q, r, -f, -u, -v\n+ *         limit = min(min(eta + 1, i), 4)\n+ *         w = (g * NEGINV16[(f & 15) // 2]) % (2**limit)\n+ *         g, q, r = g + w*f, q + w*u, r + w*v\n+ *     return eta, (u, v, q, r)\n+ *\n+ * def modinv_var(M, Mi, x):\n+ *     \"\"\"Compute the modular inverse of x mod M, given Mi = 1/M mod 2^N.\"\"\"\n+ *     eta, f, g, d, e = -1, M, x, 0, 1\n+ *     while g != 0:\n+ *         eta, t = divsteps_n_matrix_var(eta, f % 2**N, g % 2**N)\n+ *         f, g = update_fg(f, g, t)\n+ *         d, e = update_de(d, e, t, M, Mi)\n+ *     return normalize(f, d, Mi)\n+ *\n+ *\n+ * 8. C implementation\n+ * -------------------\n+ *\n+ * What follows is a C implementation of effectively the Python code from section 7, with N=62, and\n+ * the following changes:\n+ *\n+ * - Representing large integers using 5 62-bit singed limbs that callers need to convert their\n+ *   value from/to. Using 62-bit limbs means shifts by 62 bits are very efficient, and the extra\n+ *   space allows faster operations by delaying carries/borrows in some cases.\n+ *\n+ * - Several modulo operations in the Python code are modulo a power of two. These can be replaced\n+ *   with a bitwise AND with ((1 << bits) - 1).\n+ *\n+ * - Similarly, if an entire expression involving multiplications and additions is computed modulo\n+ *   a power of two, that means only the bottom bits of the inputs and intermediary results is\n+ *   needed.\n+ */\n+\n+#ifdef VERIFY\n+/* Helper function to compute the absolute value of an int64_t.\n+ * (we don't use abs/labs/llabs as it depends on the int sizes). */\n+static int64_t secp256k1_modinv64_abs(int64_t v) {\n+    VERIFY_CHECK(v > INT64_MIN);\n+    if (v < 0) return -v;\n+    return v;\n+}\n+\n+static const secp256k1_modinv64_signed62 SECP256K1_SIGNED62_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^62). */\n+static void secp256k1_modinv64_mul_62(secp256k1_modinv64_signed62 *r, const secp256k1_modinv64_signed62 *a, int alen, int64_t factor) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int128_t c = 0;\n+    int i;\n+    for (i = 0; i < 4; ++i) {\n+        if (i < alen) {\n+            c += (factor == 1) ? (int128_t)a->v[i] : (int128_t)a->v[i] * factor;\n+        }\n+        r->v[i] = (int64_t)c & M62; c >>= 62;\n+    }\n+    if (4 < alen) {\n+        c += (factor == 1) ? (int128_t)a->v[4] : (int128_t)a->v[4] * factor;\n+    }\n+    VERIFY_CHECK(c == (int64_t)c);\n+    r->v[4] = (int64_t)c;\n+}\n+\n+/* Compare af with b*bf. */\n+static int secp256k1_modinv64_mul_cmp_62(const secp256k1_modinv64_signed62 *a, int alen, const secp256k1_modinv64_signed62 *b, int64_t factor) {\n+    int i;\n+    secp256k1_modinv64_signed62 am, bm;\n+    secp256k1_modinv64_mul_62(&am, a, alen, 1);\n+    secp256k1_modinv64_mul_62(&bm, b, 5, factor);\n+    for (i = 4; i >= 0; --i) {\n+        if (i != 4) {\n+            VERIFY_CHECK(am.v[i] >> 62 == 0);\n+            VERIFY_CHECK(bm.v[i] >> 62 == 0);\n+        }\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }\n+    return 0;\n+}\n+#endif\n+\n+/* Optionally negate a signed62 number in range (-2*modulus,modulus), and add multiple of modulus to\n+ * bring it to [0,modulus). The input must have limbs in range (-2^62,2^62). The output will have\n+ * limbs in range [0,2^62). */\n+static void secp256k1_modinv64_normalize_62(secp256k1_modinv64_signed62 *r, int64_t cond_negate, const secp256k1_modinv64_modinfo *modinfo) {\n+    const int64_t M62 = (int64_t)(UINT64_MAX >> 2);\n+    int64_t r0 = r->v[0], r1 = r->v[1], r2 = r->v[2], r3 = r->v[3], r4 = r->v[4];\n+    int64_t cond_add;\n+\n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^62,2^62). */\n+    int i;\n+    for (i = 0; i < 5; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M62);\n+        VERIFY_CHECK(r->v[i] <= M62);\n+    }\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, -2) > 0); /* r > -2*modulus */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < modulus */\n+#endif\n+\n+    /* In a first step, add the modulus if the input is negative, and then negate if requested.\n+     * This brings r from range (-2*modulus,modulus) to range (-modulus,modulus). As all input\n+     * limbs are in range (-2^62,2^62), this cannot overflow an int64_t. */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    r0 = (r0 ^ cond_negate) - cond_negate;\n+    r1 = (r1 ^ cond_negate) - cond_negate;\n+    r2 = (r2 ^ cond_negate) - cond_negate;\n+    r3 = (r3 ^ cond_negate) - cond_negate;\n+    r4 = (r4 ^ cond_negate) - cond_negate;\n+    /* Propagate the top bits, to bring limbs back to range (-2^62,2^62). */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    /* In a second step add the modulus again if the result is still negative, bringing\n+     * r to range [0,modulus). */\n+    cond_add = r4 >> 63;\n+    r0 += modinfo->modulus.v[0] & cond_add;\n+    r1 += modinfo->modulus.v[1] & cond_add;\n+    r2 += modinfo->modulus.v[2] & cond_add;\n+    r3 += modinfo->modulus.v[3] & cond_add;\n+    r4 += modinfo->modulus.v[4] & cond_add;\n+    /* And propagate again. */\n+    r1 += r0 >> 62; r0 &= M62;\n+    r2 += r1 >> 62; r1 &= M62;\n+    r3 += r2 >> 62; r2 &= M62;\n+    r4 += r3 >> 62; r3 &= M62;\n+\n+    r->v[0] = r0;\n+    r->v[1] = r1;\n+    r->v[2] = r2;\n+    r->v[3] = r3;\n+    r->v[4] = r4;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv64_mul_cmp_62(r, 5, &modinfo->modulus, 1) < 0); /* r < P */\n+    VERIFY_CHECK(r->v[0] >> 62 == 0);\n+    VERIFY_CHECK(r->v[1] >> 62 == 0);\n+    VERIFY_CHECK(r->v[2] >> 62 == 0);\n+    VERIFY_CHECK(r->v[3] >> 62 == 0);\n+    VERIFY_CHECK(r->v[4] >>  8 == 0);\n+#endif\n+}\n+\n+/* Data type for transition matrices (see section 3 of explanation).\n+ *\n+ * t = [ u  v ]\n+ *     [ q  r ]\n+ */\n+typedef struct {\n+    int64_t u, v, q, r;\n+} secp256k1_modinv64_trans2x2;\n+\n+/* Compute the transition matrix and eta for 62 divsteps.\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* start with identity matrix */\n+    uint64_t c1, c2, f = f0, g = g0, x, y, z;\n+    int i;\n+\n+    for (i = 0; i < 62; ++i) {\n+        VERIFY_CHECK((f & 1) == 1); /* f must always be odd */\n+        VERIFY_CHECK((u * f0 + v * g0) == f << i);\n+        VERIFY_CHECK((q * f0 + r * g0) == g << i);\n+        /* Compute conditional masks for (eta < 0) and for (g & 1). */\n+        c1 = (int64_t)eta >> 63;\n+        c2 = -(g & 1);\n+        /* Compute x,y,z, conditionally negated versions of f,u,v. */\n+        x = (f ^ c1) - c1;\n+        y = (u ^ c1) - c1;\n+        z = (v ^ c1) - c1;\n+        /* Conditionally add x,y,z to g,q,r. */\n+        g += x & c2;\n+        q += y & c2;\n+        r += z & c2;\n+        /* In what follows, c1 is a condition mask for (eta < 0) and (g & 1). */\n+        c1 &= c2;\n+        /* Conditionally negate eta, and unconditionally subtract 1. */\n+        eta = (eta ^ c1) - (c1 + 1);\n+        /* Conditionally add g,q,r to f,u,v. */\n+        f += g & c1;\n+        u += q & c1;\n+        v += r & c1;\n+        /* Shifts */\n+        g >>= 1;\n+        u <<= 1;\n+        v <<= 1;\n+    }\n+    /* Return data in t and return value. */\n+    t->u = (int64_t)u;\n+    t->v = (int64_t)v;\n+    t->q = (int64_t)q;\n+    t->r = (int64_t)r;\n+    return eta;\n+}\n+\n+/* Compute the transition matrix and eta for 62 divsteps (variable time).\n+ *\n+ * Input:  eta: initial eta\n+ *         f0:  bottom limb of initial f\n+ *         g0:  bottom limb of initial g\n+ * Output: t: transition matrix\n+ * Return: final eta\n+ *\n+ * Implements the divsteps_n_matrix_var function from the explanation.\n+ */\n+static uint64_t secp256k1_modinv64_divsteps_62_var(uint64_t eta, uint64_t f0, uint64_t g0, secp256k1_modinv64_trans2x2 *t) {\n+    uint64_t u = 1, v = 0, q = 0, r = 1; /* Start with identity matrix */\n+    uint64_t f = f0, g = g0, m, w, x, y, z;\n+    int i = 62, limit, zeros;\n+\n+    for (;;) {\n+        /* Use a sentinel bit to count zeros only up to i. */\n+        zeros = secp256k1_ctz64_var(g | (UINT64_MAX << i));\n+        /* Perform zeros divsteps at once; they all just divide g by two. */\n+        g >>= zeros;\n+        u <<= zeros;\n+        v <<= zeros;\n+        eta -= zeros;\n+        i -= zeros;\n+        /* We're done once we've done 62 divsteps. */\n+        if (i == 0) break;\n+        VERIFY_CHECK((f & 1) == 1);\n+        VERIFY_CHECK((g & 1) == 1);\n+        VERIFY_CHECK((u * f0 + v * g0) == f << (62 - i));\n+        VERIFY_CHECK((q * f0 + r * g0) == g << (62 - i));\n+        /* If eta is negative, negate it and replace f,g with g,-f. */\n+        if ((int64_t)eta < 0) {\n+            eta = -eta;\n+            x = f; f = g; g = -x;\n+            y = u; u = q; q = -y;\n+            z = v; v = r; r = -z;\n+            /* Use a formula to cancel out up to 6 bits of g. Also, no more than i can be cancelled\n+             * out (as we'd be done before that point), and no more than eta+1 can be done as its\n+             * will flip again once that happens. */\n+            limit = ((int)eta + 1) > i ? i : ((int)eta + 1);\n+            /* m is a mask for the bottom min(limit, 6) bits. */\n+            m = (UINT64_MAX >> (64 - limit)) & 63U;\n+            /* Find what multiple of f must be added to g to cancel its bottom min(limit, 6)\n+             * bits. */\n+            w = (f * g * (f * f - 2)) & m;",
      "path": "src/modinv64_impl.h",
      "position": 262,
      "original_position": 859,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "1e30f79c3807a9c63c6c6f6ae07e7c9445b0f37c",
      "in_reply_to_id": 549203982,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a reference.",
      "created_at": "2021-03-05T22:41:30Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r588766553",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/588766553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 262,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591282848",
      "pull_request_review_id": 608513620,
      "id": 591282848,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTI4Mjg0OA==",
      "diff_hunk": "@@ -20,6 +20,42 @@\n  * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n  */\n \n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        c += (int64_t)a->v[i] * factor;\n+        r->v[i] = (int32_t)c & M30; c >>= 30;\n+    }\n+    c += (int64_t)a->v[8] * factor;\n+    VERIFY_CHECK(c == (int32_t)c);\n+    r->v[8] = (int32_t)c;\n+}\n+\n+/* Compare a with b*factor. */\n+static int secp256k1_modinv32_mul_cmp_30(const secp256k1_modinv32_signed30 *a, const secp256k1_modinv32_signed30 *b, int32_t factor) {\n+    int i;\n+    secp256k1_modinv32_signed30 am, bm;\n+    secp256k1_modinv32_mul_30(&am, a, 1); /* Normalize all but the top limb of a. */\n+    secp256k1_modinv32_mul_30(&bm, b, factor);\n+    for (i = 8; i >= 0; --i) {\n+        if (i != 8) {\n+            /* Verify that all but the top limb of a and b are normalized. */\n+            VERIFY_CHECK(am.v[i] >> 30 == 0);\n+            VERIFY_CHECK(bm.v[i] >> 30 == 0);\n+        }\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 35,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "639769bee4799b4de7416255f22758aca4629f91",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The code doesn't exactly hold the promise in the comment because the loop may terminate early. Maybe do the `VERIFY_CHECK`s in a separate loop before this one?\r\n\r\n(I mean it's obvious from the implementation of `secp256k1_modinv32_mul_30` but I like that you added the `VERIFY_CHECK`s here to check the contract with `secp256k1_modinv32_mul_30`.)",
      "created_at": "2021-03-10T09:44:53Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r591282848",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591282848"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 46,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591286339",
      "pull_request_review_id": 608513620,
      "id": 591286339,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTI4NjMzOQ==",
      "diff_hunk": "@@ -20,6 +20,42 @@\n  * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n  */\n \n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        c += (int64_t)a->v[i] * factor;\n+        r->v[i] = (int32_t)c & M30; c >>= 30;\n+    }\n+    c += (int64_t)a->v[8] * factor;\n+    VERIFY_CHECK(c == (int32_t)c);\n+    r->v[8] = (int32_t)c;\n+}\n+\n+/* Compare a with b*factor. */",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 21,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "639769bee4799b4de7416255f22758aca4629f91",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: maybe specify return value in a sentence. ",
      "created_at": "2021-03-10T09:48:03Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r591286339",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591286339"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591306339",
      "pull_request_review_id": 608513620,
      "id": 591306339,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTMwNjMzOQ==",
      "diff_hunk": "@@ -30,6 +66,17 @@ static void secp256k1_modinv32_normalize_30(secp256k1_modinv32_signed30 *r, int3\n             r5 = r->v[5], r6 = r->v[6], r7 = r->v[7], r8 = r->v[8];\n     int32_t cond_add, cond_negate;\n \n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^30,2^30). */\n+    int i;\n+    for (i = 0; i < 9; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M30);\n+        VERIFY_CHECK(r->v[i] <= M30);",
      "path": "src/modinv32_impl.h",
      "position": 74,
      "original_position": 52,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "639769bee4799b4de7416255f22758aca4629f91",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(-2^30,2^30) or [-2^30,2^30]?",
      "created_at": "2021-03-10T10:07:17Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r591306339",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591306339"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": 70,
      "original_start_line": 70,
      "start_side": "RIGHT",
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591314974",
      "pull_request_review_id": 608513620,
      "id": 591314974,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTMxNDk3NA==",
      "diff_hunk": "@@ -96,6 +143,20 @@ static void secp256k1_modinv32_normalize_30(secp256k1_modinv32_signed30 *r, int3\n     r->v[6] = r6;\n     r->v[7] = r7;\n     r->v[8] = r8;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r0 >> 30 == 0);\n+    VERIFY_CHECK(r1 >> 30 == 0);\n+    VERIFY_CHECK(r2 >> 30 == 0);\n+    VERIFY_CHECK(r3 >> 30 == 0);\n+    VERIFY_CHECK(r4 >> 30 == 0);\n+    VERIFY_CHECK(r5 >> 30 == 0);\n+    VERIFY_CHECK(r6 >> 30 == 0);\n+    VERIFY_CHECK(r7 >> 30 == 0);\n+    VERIFY_CHECK(r8 >> 30 == 0);\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, &modinfo->modulus, 1) < 0); /* r < P */",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 77,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "639769bee4799b4de7416255f22758aca4629f91",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: s/P/modulus",
      "created_at": "2021-03-10T10:15:39Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r591314974",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591314974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 158,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591410020",
      "pull_request_review_id": 608626580,
      "id": 591410020,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTQxMDAyMA==",
      "diff_hunk": "@@ -498,130 +499,91 @@ static SECP256K1_INLINE void secp256k1_fe_from_storage(secp256k1_fe *r, const se\n #endif\n }\n \n-static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *a) {\n-    secp256k1_fe x2, x3, x6, x9, x11, x22, x44, x88, x176, x220, x223, t1;\n-    int j;\n+static void secp256k1_fe_from_signed62(secp256k1_fe *r, const secp256k1_modinv64_signed62 *a) {\n+    const uint64_t M52 = UINT64_MAX >> 12;\n+    const uint64_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4];\n \n-    /** The binary representation of (p - 2) has 5 blocks of 1s, with lengths in\n-     *  { 1, 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n-     *  [1], [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]\n+    /* The output from secp256k1_modinv64{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^62). The modulus is < 2^256, so the top limb must be below 2^(256-62*4).\n      */\n+    VERIFY_CHECK(a0 >> 62 == 0);\n+    VERIFY_CHECK(a1 >> 62 == 0);\n+    VERIFY_CHECK(a2 >> 62 == 0);\n+    VERIFY_CHECK(a3 >> 62 == 0);\n+    VERIFY_CHECK(a4 >> 8 == 0);\n+\n+    r->n[0] =  a0                   & M52;\n+    r->n[1] = (a0 >> 52 | a1 << 10) & M52;\n+    r->n[2] = (a1 >> 42 | a2 << 20) & M52;\n+    r->n[3] = (a2 >> 32 | a3 << 30) & M52;\n+    r->n[4] = (a3 >> 22 | a4 << 40);\n \n-    secp256k1_fe_sqr(&x2, a);\n-    secp256k1_fe_mul(&x2, &x2, a);\n-\n-    secp256k1_fe_sqr(&x3, &x2);\n-    secp256k1_fe_mul(&x3, &x3, a);\n-\n-    x6 = x3;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x6, &x6);\n-    }\n-    secp256k1_fe_mul(&x6, &x6, &x3);\n-\n-    x9 = x6;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x9, &x9);\n-    }\n-    secp256k1_fe_mul(&x9, &x9, &x3);\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n \n-    x11 = x9;\n-    for (j=0; j<2; j++) {\n-        secp256k1_fe_sqr(&x11, &x11);\n-    }\n-    secp256k1_fe_mul(&x11, &x11, &x2);\n+static void secp256k1_fe_to_signed62(secp256k1_modinv64_signed62 *r, const secp256k1_fe *a) {\n+    const uint64_t M62 = UINT64_MAX >> 2;\n+    const uint64_t a0 = a->n[0], a1 = a->n[1], a2 = a->n[2], a3 = a->n[3], a4 = a->n[4];\n \n-    x22 = x11;\n-    for (j=0; j<11; j++) {\n-        secp256k1_fe_sqr(&x22, &x22);\n-    }\n-    secp256k1_fe_mul(&x22, &x22, &x11);\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+#endif\n \n-    x44 = x22;\n-    for (j=0; j<22; j++) {\n-        secp256k1_fe_sqr(&x44, &x44);\n-    }\n-    secp256k1_fe_mul(&x44, &x44, &x22);\n+    r->v[0] = (a0       | a1 << 52) & M62;\n+    r->v[1] = (a1 >> 10 | a2 << 42) & M62;\n+    r->v[2] = (a2 >> 20 | a3 << 32) & M62;\n+    r->v[3] = (a3 >> 30 | a4 << 22) & M62;\n+    r->v[4] =  a4 >> 40;\n+}\n \n-    x88 = x44;\n-    for (j=0; j<44; j++) {\n-        secp256k1_fe_sqr(&x88, &x88);\n-    }\n-    secp256k1_fe_mul(&x88, &x88, &x44);\n+static const secp256k1_modinv64_modinfo secp256k1_const_modinfo_fe = {\n+    {{-0x1000003D1LL, 0, 0, 0, 256}},\n+    0x27C7F6E22DDACACFLL\n+};\n \n-    x176 = x88;\n-    for (j=0; j<88; j++) {\n-        secp256k1_fe_sqr(&x176, &x176);\n-    }\n-    secp256k1_fe_mul(&x176, &x176, &x88);\n+static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv64_signed62 s;\n+#ifdef VERIFY\n+    int zero_in;\n+#endif\n \n-    x220 = x176;\n-    for (j=0; j<44; j++) {\n-        secp256k1_fe_sqr(&x220, &x220);\n-    }\n-    secp256k1_fe_mul(&x220, &x220, &x44);\n+    tmp = *x;\n+    secp256k1_fe_normalize(&tmp);\n+#ifdef VERIFY\n+    zero_in = secp256k1_fe_normalizes_to_zero(&tmp);\n+#endif\n+    secp256k1_fe_to_signed62(&s, &tmp);\n+    secp256k1_modinv64(&s, &secp256k1_const_modinfo_fe);\n+    secp256k1_fe_from_signed62(r, &s);\n \n-    x223 = x220;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x223, &x223);\n-    }\n-    secp256k1_fe_mul(&x223, &x223, &x3);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == zero_in);",
      "path": "src/field_5x52_impl.h",
      "position": null,
      "original_position": 133,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a71a582c46fac1cff02a7855bb836ad2722e7dcc",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this could be written without the aux variable `zero_in`, which would make it possible to get rid of the three #ifdef blocks here.\r\n(Even if we keep `zero_in`, the single #ifdef here is not necessary.)",
      "created_at": "2021-03-10T11:53:05Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r591410020",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591410020"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 565,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591411155",
      "pull_request_review_id": 608626580,
      "id": 591411155,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTQxMTE1NQ==",
      "diff_hunk": "@@ -955,178 +957,73 @@ static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const se\n     r->d[3] = (r->d[3] & mask0) | (a->d[3] & mask1);\n }\n \n-static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n-    secp256k1_scalar *t;\n-    int i;\n-    /* First compute xN as x ^ (2^N - 1) for some values of N,\n-     * and uM as x ^ M for some values of M. */\n-    secp256k1_scalar x2, x3, x6, x8, x14, x28, x56, x112, x126;\n-    secp256k1_scalar u2, u5, u9, u11, u13;\n+static void secp256k1_scalar_from_signed62(secp256k1_scalar *r, const secp256k1_modinv64_signed62 *a) {\n+    const uint64_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4];\n \n-    secp256k1_scalar_sqr(&u2, x);\n-    secp256k1_scalar_mul(&x2, &u2,  x);\n-    secp256k1_scalar_mul(&u5, &u2, &x2);\n-    secp256k1_scalar_mul(&x3, &u5,  &u2);\n-    secp256k1_scalar_mul(&u9, &x3, &u2);\n-    secp256k1_scalar_mul(&u11, &u9, &u2);\n-    secp256k1_scalar_mul(&u13, &u11, &u2);\n+    /* The output from secp256k1_modinv64{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^62). The modulus is < 2^256, so the top limb must be below 2^(256-62*4).\n+     */\n+    VERIFY_CHECK(a0 >> 62 == 0);\n+    VERIFY_CHECK(a1 >> 62 == 0);\n+    VERIFY_CHECK(a2 >> 62 == 0);\n+    VERIFY_CHECK(a3 >> 62 == 0);\n+    VERIFY_CHECK(a4 >> 8 == 0);\n \n-    secp256k1_scalar_sqr(&x6, &u13);\n-    secp256k1_scalar_sqr(&x6, &x6);\n-    secp256k1_scalar_mul(&x6, &x6, &u11);\n+    r->d[0] = a0      | a1 << 62;\n+    r->d[1] = a1 >> 2 | a2 << 60;\n+    r->d[2] = a2 >> 4 | a3 << 58;\n+    r->d[3] = a3 >> 6 | a4 << 56;\n \n-    secp256k1_scalar_sqr(&x8, &x6);\n-    secp256k1_scalar_sqr(&x8, &x8);\n-    secp256k1_scalar_mul(&x8, &x8,  &x2);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif",
      "path": "src/scalar_4x64_impl.h",
      "position": 223,
      "original_position": 52,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a71a582c46fac1cff02a7855bb836ad2722e7dcc",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: no need for #ifdef here ",
      "created_at": "2021-03-10T11:54:17Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r591411155",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591411155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": 811,
      "original_start_line": 977,
      "start_side": "RIGHT",
      "line": 813,
      "original_line": 813,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591411883",
      "pull_request_review_id": 608626580,
      "id": 591411883,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTQxMTg4Mw==",
      "diff_hunk": "@@ -955,178 +957,73 @@ static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const se\n     r->d[3] = (r->d[3] & mask0) | (a->d[3] & mask1);\n }\n \n-static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n-    secp256k1_scalar *t;\n-    int i;\n-    /* First compute xN as x ^ (2^N - 1) for some values of N,\n-     * and uM as x ^ M for some values of M. */\n-    secp256k1_scalar x2, x3, x6, x8, x14, x28, x56, x112, x126;\n-    secp256k1_scalar u2, u5, u9, u11, u13;\n+static void secp256k1_scalar_from_signed62(secp256k1_scalar *r, const secp256k1_modinv64_signed62 *a) {\n+    const uint64_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4];\n \n-    secp256k1_scalar_sqr(&u2, x);\n-    secp256k1_scalar_mul(&x2, &u2,  x);\n-    secp256k1_scalar_mul(&u5, &u2, &x2);\n-    secp256k1_scalar_mul(&x3, &u5,  &u2);\n-    secp256k1_scalar_mul(&u9, &x3, &u2);\n-    secp256k1_scalar_mul(&u11, &u9, &u2);\n-    secp256k1_scalar_mul(&u13, &u11, &u2);\n+    /* The output from secp256k1_modinv64{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^62). The modulus is < 2^256, so the top limb must be below 2^(256-62*4).\n+     */\n+    VERIFY_CHECK(a0 >> 62 == 0);\n+    VERIFY_CHECK(a1 >> 62 == 0);\n+    VERIFY_CHECK(a2 >> 62 == 0);\n+    VERIFY_CHECK(a3 >> 62 == 0);\n+    VERIFY_CHECK(a4 >> 8 == 0);\n \n-    secp256k1_scalar_sqr(&x6, &u13);\n-    secp256k1_scalar_sqr(&x6, &x6);\n-    secp256k1_scalar_mul(&x6, &x6, &u11);\n+    r->d[0] = a0      | a1 << 62;\n+    r->d[1] = a1 >> 2 | a2 << 60;\n+    r->d[2] = a2 >> 4 | a3 << 58;\n+    r->d[3] = a3 >> 6 | a4 << 56;\n \n-    secp256k1_scalar_sqr(&x8, &x6);\n-    secp256k1_scalar_sqr(&x8, &x8);\n-    secp256k1_scalar_mul(&x8, &x8,  &x2);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif\n+}\n \n-    secp256k1_scalar_sqr(&x14, &x8);\n-    for (i = 0; i < 5; i++) {\n-        secp256k1_scalar_sqr(&x14, &x14);\n-    }\n-    secp256k1_scalar_mul(&x14, &x14, &x6);\n+static void secp256k1_scalar_to_signed62(secp256k1_modinv64_signed62 *r, const secp256k1_scalar *a) {\n+    const uint64_t M62 = UINT64_MAX >> 2;\n+    const uint64_t a0 = a->d[0], a1 = a->d[1], a2 = a->d[2], a3 = a->d[3];\n \n-    secp256k1_scalar_sqr(&x28, &x14);\n-    for (i = 0; i < 13; i++) {\n-        secp256k1_scalar_sqr(&x28, &x28);\n-    }\n-    secp256k1_scalar_mul(&x28, &x28, &x14);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(a) == 0);\n+#endif",
      "path": "src/scalar_4x64_impl.h",
      "position": 232,
      "original_position": 71,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a71a582c46fac1cff02a7855bb836ad2722e7dcc",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "same here",
      "created_at": "2021-03-10T11:55:06Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r591411883",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591411883"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": 820,
      "original_start_line": 986,
      "start_side": "RIGHT",
      "line": 822,
      "original_line": 822,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591481174",
      "pull_request_review_id": 608688563,
      "id": 591481174,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTQ4MTE3NA==",
      "diff_hunk": "@@ -2489,6 +2431,169 @@ void run_sqrt(void) {\n     }\n }\n \n+/***** FIELD/SCALAR INVERSE TESTS *****/\n+\n+static const secp256k1_scalar scalar_minus_one = SECP256K1_SCALAR_CONST(\n+    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE,\n+    0xBAAEDCE6, 0xAF48A03B, 0xBFD25E8C, 0xD0364140\n+);\n+\n+static const secp256k1_fe fe_minus_one = SECP256K1_FE_CONST(\n+    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\n+    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFC2E\n+);\n+\n+/* These tests test the following identities:\n+ *\n+ * for x==0: 1/x == 0\n+ * for x!=0: x*(1/x) == 1\n+ * for x!=0 and x!=1: 1/(1/x - 1) + 1 == -1/(x-1)",
      "path": "src/tests.c",
      "position": 952,
      "original_position": 99,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "7cda96e813454171ff6e85ecd9d986af6bd15b76",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Doesn't this hold for x==1 too?",
      "created_at": "2021-03-10T13:04:50Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r591481174",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/591481174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2115,
      "original_line": 2115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592600191",
      "pull_request_review_id": 610091959,
      "id": 592600191,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MjYwMDE5MQ==",
      "diff_hunk": "@@ -30,6 +66,17 @@ static void secp256k1_modinv32_normalize_30(secp256k1_modinv32_signed30 *r, int3\n             r5 = r->v[5], r6 = r->v[6], r7 = r->v[7], r8 = r->v[8];\n     int32_t cond_add, cond_negate;\n \n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^30,2^30). */\n+    int i;\n+    for (i = 0; i < 9; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M30);\n+        VERIFY_CHECK(r->v[i] <= M30);",
      "path": "src/modinv32_impl.h",
      "position": 74,
      "original_position": 52,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "639769bee4799b4de7416255f22758aca4629f91",
      "in_reply_to_id": 591306339,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(-2^20,2^30) is correct. It's even stronger in practice I believe, and the bottom 8 limbs are in [0,2^30), and the top limb is in [-2^18,2^17) or so. Note that `_normalize` is only called on the `d` variable, and `d` is only ever updated through `_update_de` (which produces 8 output limbs masked by M30, and the range of the top limb can be reasoned about through the range of `d` itself).",
      "created_at": "2021-03-11T18:23:42Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r592600191",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592600191"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": 70,
      "original_start_line": 70,
      "start_side": "RIGHT",
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592624785",
      "pull_request_review_id": 610112867,
      "id": 592624785,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MjYyNDc4NQ==",
      "diff_hunk": "@@ -20,6 +20,42 @@\n  * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n  */\n \n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        c += (int64_t)a->v[i] * factor;\n+        r->v[i] = (int32_t)c & M30; c >>= 30;\n+    }\n+    c += (int64_t)a->v[8] * factor;\n+    VERIFY_CHECK(c == (int32_t)c);\n+    r->v[8] = (int32_t)c;\n+}\n+\n+/* Compare a with b*factor. */\n+static int secp256k1_modinv32_mul_cmp_30(const secp256k1_modinv32_signed30 *a, const secp256k1_modinv32_signed30 *b, int32_t factor) {\n+    int i;\n+    secp256k1_modinv32_signed30 am, bm;\n+    secp256k1_modinv32_mul_30(&am, a, 1); /* Normalize all but the top limb of a. */\n+    secp256k1_modinv32_mul_30(&bm, b, factor);\n+    for (i = 8; i >= 0; --i) {\n+        if (i != 8) {\n+            /* Verify that all but the top limb of a and b are normalized. */\n+            VERIFY_CHECK(am.v[i] >> 30 == 0);\n+            VERIFY_CHECK(bm.v[i] >> 30 == 0);\n+        }\n+        if (am.v[i] < bm.v[i]) return -1;\n+        if (am.v[i] > bm.v[i]) return 1;\n+    }",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 35,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "639769bee4799b4de7416255f22758aca4629f91",
      "in_reply_to_id": 591282848,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, moved them to a separate loop.",
      "created_at": "2021-03-11T18:47:46Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r592624785",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592624785"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": 46,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592624905",
      "pull_request_review_id": 610112959,
      "id": 592624905,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MjYyNDkwNQ==",
      "diff_hunk": "@@ -20,6 +20,42 @@\n  * implementation for N=30, using 30-bit signed limbs represented as int32_t.\n  */\n \n+#ifdef VERIFY\n+static const secp256k1_modinv32_signed30 SECP256K1_SIGNED30_ONE = {{1}};\n+\n+/* Compute a*factor and put it in r. All but the top limb in r will be in range [0,2^30). */\n+static void secp256k1_modinv32_mul_30(secp256k1_modinv32_signed30 *r, const secp256k1_modinv32_signed30 *a, int32_t factor) {\n+    const int32_t M30 = (int32_t)(UINT32_MAX >> 2);\n+    int64_t c = 0;\n+    int i;\n+    for (i = 0; i < 8; ++i) {\n+        c += (int64_t)a->v[i] * factor;\n+        r->v[i] = (int32_t)c & M30; c >>= 30;\n+    }\n+    c += (int64_t)a->v[8] * factor;\n+    VERIFY_CHECK(c == (int32_t)c);\n+    r->v[8] = (int32_t)c;\n+}\n+\n+/* Compare a with b*factor. */",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 21,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "639769bee4799b4de7416255f22758aca4629f91",
      "in_reply_to_id": 591286339,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-03-11T18:47:52Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r592624905",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592624905"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592625407",
      "pull_request_review_id": 610113412,
      "id": 592625407,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MjYyNTQwNw==",
      "diff_hunk": "@@ -30,6 +66,17 @@ static void secp256k1_modinv32_normalize_30(secp256k1_modinv32_signed30 *r, int3\n             r5 = r->v[5], r6 = r->v[6], r7 = r->v[7], r8 = r->v[8];\n     int32_t cond_add, cond_negate;\n \n+#ifdef VERIFY\n+    /* Verify that all limbs are in range (-2^30,2^30). */\n+    int i;\n+    for (i = 0; i < 9; ++i) {\n+        VERIFY_CHECK(r->v[i] >= -M30);\n+        VERIFY_CHECK(r->v[i] <= M30);",
      "path": "src/modinv32_impl.h",
      "position": 74,
      "original_position": 52,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "639769bee4799b4de7416255f22758aca4629f91",
      "in_reply_to_id": 591306339,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also, note that M30 is 0x3fffffff, so it's actually checking (-2^30,2^30).",
      "created_at": "2021-03-11T18:48:22Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r592625407",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592625407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": 70,
      "original_start_line": 70,
      "start_side": "RIGHT",
      "line": 74,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592625513",
      "pull_request_review_id": 610113504,
      "id": 592625513,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MjYyNTUxMw==",
      "diff_hunk": "@@ -96,6 +143,20 @@ static void secp256k1_modinv32_normalize_30(secp256k1_modinv32_signed30 *r, int3\n     r->v[6] = r6;\n     r->v[7] = r7;\n     r->v[8] = r8;\n+\n+#ifdef VERIFY\n+    VERIFY_CHECK(r0 >> 30 == 0);\n+    VERIFY_CHECK(r1 >> 30 == 0);\n+    VERIFY_CHECK(r2 >> 30 == 0);\n+    VERIFY_CHECK(r3 >> 30 == 0);\n+    VERIFY_CHECK(r4 >> 30 == 0);\n+    VERIFY_CHECK(r5 >> 30 == 0);\n+    VERIFY_CHECK(r6 >> 30 == 0);\n+    VERIFY_CHECK(r7 >> 30 == 0);\n+    VERIFY_CHECK(r8 >> 30 == 0);\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, &modinfo->modulus, 0) >= 0); /* r >= 0 */\n+    VERIFY_CHECK(secp256k1_modinv32_mul_cmp_30(r, &modinfo->modulus, 1) < 0); /* r < P */",
      "path": "src/modinv32_impl.h",
      "position": null,
      "original_position": 77,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "639769bee4799b4de7416255f22758aca4629f91",
      "in_reply_to_id": 591314974,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-03-11T18:48:30Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r592625513",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592625513"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 158,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592627098",
      "pull_request_review_id": 610114969,
      "id": 592627098,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MjYyNzA5OA==",
      "diff_hunk": "@@ -498,130 +499,91 @@ static SECP256K1_INLINE void secp256k1_fe_from_storage(secp256k1_fe *r, const se\n #endif\n }\n \n-static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *a) {\n-    secp256k1_fe x2, x3, x6, x9, x11, x22, x44, x88, x176, x220, x223, t1;\n-    int j;\n+static void secp256k1_fe_from_signed62(secp256k1_fe *r, const secp256k1_modinv64_signed62 *a) {\n+    const uint64_t M52 = UINT64_MAX >> 12;\n+    const uint64_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4];\n \n-    /** The binary representation of (p - 2) has 5 blocks of 1s, with lengths in\n-     *  { 1, 2, 22, 223 }. Use an addition chain to calculate 2^n - 1 for each block:\n-     *  [1], [2], 3, 6, 9, 11, [22], 44, 88, 176, 220, [223]\n+    /* The output from secp256k1_modinv64{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^62). The modulus is < 2^256, so the top limb must be below 2^(256-62*4).\n      */\n+    VERIFY_CHECK(a0 >> 62 == 0);\n+    VERIFY_CHECK(a1 >> 62 == 0);\n+    VERIFY_CHECK(a2 >> 62 == 0);\n+    VERIFY_CHECK(a3 >> 62 == 0);\n+    VERIFY_CHECK(a4 >> 8 == 0);\n+\n+    r->n[0] =  a0                   & M52;\n+    r->n[1] = (a0 >> 52 | a1 << 10) & M52;\n+    r->n[2] = (a1 >> 42 | a2 << 20) & M52;\n+    r->n[3] = (a2 >> 32 | a3 << 30) & M52;\n+    r->n[4] = (a3 >> 22 | a4 << 40);\n \n-    secp256k1_fe_sqr(&x2, a);\n-    secp256k1_fe_mul(&x2, &x2, a);\n-\n-    secp256k1_fe_sqr(&x3, &x2);\n-    secp256k1_fe_mul(&x3, &x3, a);\n-\n-    x6 = x3;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x6, &x6);\n-    }\n-    secp256k1_fe_mul(&x6, &x6, &x3);\n-\n-    x9 = x6;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x9, &x9);\n-    }\n-    secp256k1_fe_mul(&x9, &x9, &x3);\n+#ifdef VERIFY\n+    r->magnitude = 1;\n+    r->normalized = 1;\n+    secp256k1_fe_verify(r);\n+#endif\n+}\n \n-    x11 = x9;\n-    for (j=0; j<2; j++) {\n-        secp256k1_fe_sqr(&x11, &x11);\n-    }\n-    secp256k1_fe_mul(&x11, &x11, &x2);\n+static void secp256k1_fe_to_signed62(secp256k1_modinv64_signed62 *r, const secp256k1_fe *a) {\n+    const uint64_t M62 = UINT64_MAX >> 2;\n+    const uint64_t a0 = a->n[0], a1 = a->n[1], a2 = a->n[2], a3 = a->n[3], a4 = a->n[4];\n \n-    x22 = x11;\n-    for (j=0; j<11; j++) {\n-        secp256k1_fe_sqr(&x22, &x22);\n-    }\n-    secp256k1_fe_mul(&x22, &x22, &x11);\n+#ifdef VERIFY\n+    VERIFY_CHECK(a->normalized);\n+#endif\n \n-    x44 = x22;\n-    for (j=0; j<22; j++) {\n-        secp256k1_fe_sqr(&x44, &x44);\n-    }\n-    secp256k1_fe_mul(&x44, &x44, &x22);\n+    r->v[0] = (a0       | a1 << 52) & M62;\n+    r->v[1] = (a1 >> 10 | a2 << 42) & M62;\n+    r->v[2] = (a2 >> 20 | a3 << 32) & M62;\n+    r->v[3] = (a3 >> 30 | a4 << 22) & M62;\n+    r->v[4] =  a4 >> 40;\n+}\n \n-    x88 = x44;\n-    for (j=0; j<44; j++) {\n-        secp256k1_fe_sqr(&x88, &x88);\n-    }\n-    secp256k1_fe_mul(&x88, &x88, &x44);\n+static const secp256k1_modinv64_modinfo secp256k1_const_modinfo_fe = {\n+    {{-0x1000003D1LL, 0, 0, 0, 256}},\n+    0x27C7F6E22DDACACFLL\n+};\n \n-    x176 = x88;\n-    for (j=0; j<88; j++) {\n-        secp256k1_fe_sqr(&x176, &x176);\n-    }\n-    secp256k1_fe_mul(&x176, &x176, &x88);\n+static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *x) {\n+    secp256k1_fe tmp;\n+    secp256k1_modinv64_signed62 s;\n+#ifdef VERIFY\n+    int zero_in;\n+#endif\n \n-    x220 = x176;\n-    for (j=0; j<44; j++) {\n-        secp256k1_fe_sqr(&x220, &x220);\n-    }\n-    secp256k1_fe_mul(&x220, &x220, &x44);\n+    tmp = *x;\n+    secp256k1_fe_normalize(&tmp);\n+#ifdef VERIFY\n+    zero_in = secp256k1_fe_normalizes_to_zero(&tmp);\n+#endif\n+    secp256k1_fe_to_signed62(&s, &tmp);\n+    secp256k1_modinv64(&s, &secp256k1_const_modinfo_fe);\n+    secp256k1_fe_from_signed62(r, &s);\n \n-    x223 = x220;\n-    for (j=0; j<3; j++) {\n-        secp256k1_fe_sqr(&x223, &x223);\n-    }\n-    secp256k1_fe_mul(&x223, &x223, &x3);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_fe_normalizes_to_zero(r) == zero_in);",
      "path": "src/field_5x52_impl.h",
      "position": null,
      "original_position": 133,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a71a582c46fac1cff02a7855bb836ad2722e7dcc",
      "in_reply_to_id": 591410020,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. This works in the field code, because there is a temporary copy. In the scalar code that's not the case because we can't assume `r` and `x` don't alias.",
      "created_at": "2021-03-11T18:50:11Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r592627098",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592627098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 565,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592627294",
      "pull_request_review_id": 610115169,
      "id": 592627294,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MjYyNzI5NA==",
      "diff_hunk": "@@ -955,178 +957,73 @@ static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const se\n     r->d[3] = (r->d[3] & mask0) | (a->d[3] & mask1);\n }\n \n-static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n-    secp256k1_scalar *t;\n-    int i;\n-    /* First compute xN as x ^ (2^N - 1) for some values of N,\n-     * and uM as x ^ M for some values of M. */\n-    secp256k1_scalar x2, x3, x6, x8, x14, x28, x56, x112, x126;\n-    secp256k1_scalar u2, u5, u9, u11, u13;\n+static void secp256k1_scalar_from_signed62(secp256k1_scalar *r, const secp256k1_modinv64_signed62 *a) {\n+    const uint64_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4];\n \n-    secp256k1_scalar_sqr(&u2, x);\n-    secp256k1_scalar_mul(&x2, &u2,  x);\n-    secp256k1_scalar_mul(&u5, &u2, &x2);\n-    secp256k1_scalar_mul(&x3, &u5,  &u2);\n-    secp256k1_scalar_mul(&u9, &x3, &u2);\n-    secp256k1_scalar_mul(&u11, &u9, &u2);\n-    secp256k1_scalar_mul(&u13, &u11, &u2);\n+    /* The output from secp256k1_modinv64{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^62). The modulus is < 2^256, so the top limb must be below 2^(256-62*4).\n+     */\n+    VERIFY_CHECK(a0 >> 62 == 0);\n+    VERIFY_CHECK(a1 >> 62 == 0);\n+    VERIFY_CHECK(a2 >> 62 == 0);\n+    VERIFY_CHECK(a3 >> 62 == 0);\n+    VERIFY_CHECK(a4 >> 8 == 0);\n \n-    secp256k1_scalar_sqr(&x6, &u13);\n-    secp256k1_scalar_sqr(&x6, &x6);\n-    secp256k1_scalar_mul(&x6, &x6, &u11);\n+    r->d[0] = a0      | a1 << 62;\n+    r->d[1] = a1 >> 2 | a2 << 60;\n+    r->d[2] = a2 >> 4 | a3 << 58;\n+    r->d[3] = a3 >> 6 | a4 << 56;\n \n-    secp256k1_scalar_sqr(&x8, &x6);\n-    secp256k1_scalar_sqr(&x8, &x8);\n-    secp256k1_scalar_mul(&x8, &x8,  &x2);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif",
      "path": "src/scalar_4x64_impl.h",
      "position": 223,
      "original_position": 52,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a71a582c46fac1cff02a7855bb836ad2722e7dcc",
      "in_reply_to_id": 591411155,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-03-11T18:50:24Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r592627294",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592627294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": 811,
      "original_start_line": 977,
      "start_side": "RIGHT",
      "line": 813,
      "original_line": 813,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592627400",
      "pull_request_review_id": 610115264,
      "id": 592627400,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MjYyNzQwMA==",
      "diff_hunk": "@@ -955,178 +957,73 @@ static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const se\n     r->d[3] = (r->d[3] & mask0) | (a->d[3] & mask1);\n }\n \n-static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n-    secp256k1_scalar *t;\n-    int i;\n-    /* First compute xN as x ^ (2^N - 1) for some values of N,\n-     * and uM as x ^ M for some values of M. */\n-    secp256k1_scalar x2, x3, x6, x8, x14, x28, x56, x112, x126;\n-    secp256k1_scalar u2, u5, u9, u11, u13;\n+static void secp256k1_scalar_from_signed62(secp256k1_scalar *r, const secp256k1_modinv64_signed62 *a) {\n+    const uint64_t a0 = a->v[0], a1 = a->v[1], a2 = a->v[2], a3 = a->v[3], a4 = a->v[4];\n \n-    secp256k1_scalar_sqr(&u2, x);\n-    secp256k1_scalar_mul(&x2, &u2,  x);\n-    secp256k1_scalar_mul(&u5, &u2, &x2);\n-    secp256k1_scalar_mul(&x3, &u5,  &u2);\n-    secp256k1_scalar_mul(&u9, &x3, &u2);\n-    secp256k1_scalar_mul(&u11, &u9, &u2);\n-    secp256k1_scalar_mul(&u13, &u11, &u2);\n+    /* The output from secp256k1_modinv64{_var} should be normalized to range [0,modulus), and\n+     * have limbs in [0,2^62). The modulus is < 2^256, so the top limb must be below 2^(256-62*4).\n+     */\n+    VERIFY_CHECK(a0 >> 62 == 0);\n+    VERIFY_CHECK(a1 >> 62 == 0);\n+    VERIFY_CHECK(a2 >> 62 == 0);\n+    VERIFY_CHECK(a3 >> 62 == 0);\n+    VERIFY_CHECK(a4 >> 8 == 0);\n \n-    secp256k1_scalar_sqr(&x6, &u13);\n-    secp256k1_scalar_sqr(&x6, &x6);\n-    secp256k1_scalar_mul(&x6, &x6, &u11);\n+    r->d[0] = a0      | a1 << 62;\n+    r->d[1] = a1 >> 2 | a2 << 60;\n+    r->d[2] = a2 >> 4 | a3 << 58;\n+    r->d[3] = a3 >> 6 | a4 << 56;\n \n-    secp256k1_scalar_sqr(&x8, &x6);\n-    secp256k1_scalar_sqr(&x8, &x8);\n-    secp256k1_scalar_mul(&x8, &x8,  &x2);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif\n+}\n \n-    secp256k1_scalar_sqr(&x14, &x8);\n-    for (i = 0; i < 5; i++) {\n-        secp256k1_scalar_sqr(&x14, &x14);\n-    }\n-    secp256k1_scalar_mul(&x14, &x14, &x6);\n+static void secp256k1_scalar_to_signed62(secp256k1_modinv64_signed62 *r, const secp256k1_scalar *a) {\n+    const uint64_t M62 = UINT64_MAX >> 2;\n+    const uint64_t a0 = a->d[0], a1 = a->d[1], a2 = a->d[2], a3 = a->d[3];\n \n-    secp256k1_scalar_sqr(&x28, &x14);\n-    for (i = 0; i < 13; i++) {\n-        secp256k1_scalar_sqr(&x28, &x28);\n-    }\n-    secp256k1_scalar_mul(&x28, &x28, &x14);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(a) == 0);\n+#endif",
      "path": "src/scalar_4x64_impl.h",
      "position": 232,
      "original_position": 71,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "a71a582c46fac1cff02a7855bb836ad2722e7dcc",
      "in_reply_to_id": 591411883,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2021-03-11T18:50:31Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r592627400",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592627400"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": 820,
      "original_start_line": 986,
      "start_side": "RIGHT",
      "line": 822,
      "original_line": 822,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592628360",
      "pull_request_review_id": 610116119,
      "id": 592628360,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MjYyODM2MA==",
      "diff_hunk": "@@ -2489,6 +2431,169 @@ void run_sqrt(void) {\n     }\n }\n \n+/***** FIELD/SCALAR INVERSE TESTS *****/\n+\n+static const secp256k1_scalar scalar_minus_one = SECP256K1_SCALAR_CONST(\n+    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE,\n+    0xBAAEDCE6, 0xAF48A03B, 0xBFD25E8C, 0xD0364140\n+);\n+\n+static const secp256k1_fe fe_minus_one = SECP256K1_FE_CONST(\n+    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\n+    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFC2E\n+);\n+\n+/* These tests test the following identities:\n+ *\n+ * for x==0: 1/x == 0\n+ * for x!=0: x*(1/x) == 1\n+ * for x!=0 and x!=1: 1/(1/x - 1) + 1 == -1/(x-1)",
      "path": "src/tests.c",
      "position": 952,
      "original_position": 99,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "7cda96e813454171ff6e85ecd9d986af6bd15b76",
      "in_reply_to_id": 591481174,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No, if we follows 1/0=0 (as implemented by the modinv code), then the left hand side evaluates to 1/(1/1-1)+1 = 1/0+1 = 1, and the right hand side to -1/(1-1) = -1.",
      "created_at": "2021-03-11T18:51:30Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r592628360",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592628360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2115,
      "original_line": 2115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592637692",
      "pull_request_review_id": 610125150,
      "id": 592637692,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MjYzNzY5Mg==",
      "diff_hunk": "@@ -2489,6 +2431,169 @@ void run_sqrt(void) {\n     }\n }\n \n+/***** FIELD/SCALAR INVERSE TESTS *****/\n+\n+static const secp256k1_scalar scalar_minus_one = SECP256K1_SCALAR_CONST(\n+    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE,\n+    0xBAAEDCE6, 0xAF48A03B, 0xBFD25E8C, 0xD0364140\n+);\n+\n+static const secp256k1_fe fe_minus_one = SECP256K1_FE_CONST(\n+    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\n+    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFC2E\n+);\n+\n+/* These tests test the following identities:\n+ *\n+ * for x==0: 1/x == 0\n+ * for x!=0: x*(1/x) == 1\n+ * for x!=0 and x!=1: 1/(1/x - 1) + 1 == -1/(x-1)",
      "path": "src/tests.c",
      "position": 952,
      "original_position": 99,
      "commit_id": "24ad04fc064e71abdf973e061c30eb1f3f78db39",
      "original_commit_id": "7cda96e813454171ff6e85ecd9d986af6bd15b76",
      "in_reply_to_id": 591481174,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "indeed, I had a mistake in my calculation",
      "created_at": "2021-03-11T19:01:49Z",
      "updated_at": "2021-03-15T20:02:06Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/831#discussion_r592637692",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/592637692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/831"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2115,
      "original_line": 2115,
      "side": "RIGHT"
    }
  ]
}