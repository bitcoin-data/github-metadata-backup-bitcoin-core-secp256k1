{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407",
    "id": 1482758685,
    "node_id": "PR_kwDOAP4Jqs5YYRod",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1407.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1407.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1407",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1407/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
    "number": 1407,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Modified fuzz tests about field operations",
    "user": {
      "login": "YafeiXie1",
      "id": 114428701,
      "node_id": "U_kgDOBtILHQ",
      "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/YafeiXie1",
      "html_url": "https://github.com/YafeiXie1",
      "followers_url": "https://api.github.com/users/YafeiXie1/followers",
      "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
      "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
      "repos_url": "https://api.github.com/users/YafeiXie1/repos",
      "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Thanks for the previous review.\r\nThis PR:\r\nAdded a function to construct valid field elements with random magnitude. \r\nAdded the constraint in each field operation test based on the magnitude and normalization.\r\nCould you give me some suggestions?",
    "labels": [
      {
        "id": 165017692,
        "node_id": "MDU6TGFiZWwxNjUwMTc2OTI=",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/assurance",
        "name": "assurance",
        "description": "",
        "color": "A6DF3D",
        "default": false
      }
    ],
    "created_at": "2023-08-21T12:09:04Z",
    "updated_at": "2023-08-29T19:03:52Z",
    "mergeable": true,
    "mergeable_state": "unstable",
    "merge_commit_sha": "59ec2191ca0d3d279abba4d04ce29ea0d82e77c3",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "YafeiXie1:master",
      "ref": "master",
      "sha": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "user": {
        "login": "YafeiXie1",
        "id": 114428701,
        "node_id": "U_kgDOBtILHQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/YafeiXie1",
        "html_url": "https://github.com/YafeiXie1",
        "followers_url": "https://api.github.com/users/YafeiXie1/followers",
        "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
        "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
        "repos_url": "https://api.github.com/users/YafeiXie1/repos",
        "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 667139146,
        "node_id": "R_kgDOJ8O8Sg",
        "name": "secp256k1",
        "full_name": "YafeiXie1/secp256k1",
        "owner": {
          "login": "YafeiXie1",
          "id": 114428701,
          "node_id": "U_kgDOBtILHQ",
          "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/YafeiXie1",
          "html_url": "https://github.com/YafeiXie1",
          "followers_url": "https://api.github.com/users/YafeiXie1/followers",
          "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
          "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
          "repos_url": "https://api.github.com/users/YafeiXie1/repos",
          "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/YafeiXie1/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/YafeiXie1/secp256k1",
        "archive_url": "https://api.github.com/repos/YafeiXie1/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/YafeiXie1/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/YafeiXie1/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/YafeiXie1/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/YafeiXie1/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/YafeiXie1/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/YafeiXie1/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/YafeiXie1/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/YafeiXie1/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/YafeiXie1/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/YafeiXie1/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/YafeiXie1/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/YafeiXie1/secp256k1/events",
        "forks_url": "https://api.github.com/repos/YafeiXie1/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/YafeiXie1/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/YafeiXie1/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/YafeiXie1/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/YafeiXie1/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/YafeiXie1/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/YafeiXie1/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/YafeiXie1/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/YafeiXie1/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/YafeiXie1/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/YafeiXie1/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/YafeiXie1/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/YafeiXie1/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/YafeiXie1/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/YafeiXie1/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/YafeiXie1/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:YafeiXie1/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/YafeiXie1/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/YafeiXie1/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/YafeiXie1/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/YafeiXie1/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/YafeiXie1/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/YafeiXie1/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/YafeiXie1/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/YafeiXie1/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/YafeiXie1/secp256k1/hooks",
        "svn_url": "https://github.com/YafeiXie1/secp256k1",
        "language": "C",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 10509,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-29T14:08:53Z",
        "created_at": "2023-07-16T19:06:56Z",
        "updated_at": "2023-07-27T07:02:29Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "65c79fe2d05d05258eb95a9c51a306841c8febf2",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 986,
        "stargazers_count": 1822,
        "watchers_count": 1822,
        "size": 10498,
        "default_branch": "master",
        "open_issues_count": 139,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-29T14:08:56Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2023-08-29T01:28:39Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
      }
    },
    "author_association": "NONE",
    "draft": false,
    "additions": 1308,
    "deletions": 0,
    "changed_files": 2,
    "commits": 7,
    "review_comments": 16,
    "comments": 2
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDM4NzRhOTM3YTkyNDBmNWM2NTRjYWI4NDQ1MGE2OTdkMTk4MmMyZGM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3874a937a9240f5c654cab84450a697d1982c2dc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3874a937a9240f5c654cab84450a697d1982c2dc",
      "tree": {
        "sha": "b3dbfa7cb0510577eeeac174ae5eed35df47a4c9",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/b3dbfa7cb0510577eeeac174ae5eed35df47a4c9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/6b9507adf684f088f665354608685255d0bd162f",
          "sha": "6b9507adf684f088f665354608685255d0bd162f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/6b9507adf684f088f665354608685255d0bd162f"
        }
      ],
      "message": "modify the fuzzing tests of field operations",
      "committer": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-21T11:48:56Z"
      },
      "author": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-21T11:48:56Z"
      },
      "sha": "3874a937a9240f5c654cab84450a697d1982c2dc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGEwYjNkMGEwZGVlMTE3MWQ4YzAzMzBhOTk3MWUzMzYzZTM1MDU2NjM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a0b3d0a0dee1171d8c0330a9971e3363e3505663",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a0b3d0a0dee1171d8c0330a9971e3363e3505663",
      "tree": {
        "sha": "88fb0b40b1459c7f271b50d89026b72b17f2c822",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/88fb0b40b1459c7f271b50d89026b72b17f2c822"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3874a937a9240f5c654cab84450a697d1982c2dc",
          "sha": "3874a937a9240f5c654cab84450a697d1982c2dc",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3874a937a9240f5c654cab84450a697d1982c2dc"
        }
      ],
      "message": "modified the fuzzing tests of field operations.",
      "committer": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-21T11:57:19Z"
      },
      "author": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-21T11:57:19Z"
      },
      "sha": "a0b3d0a0dee1171d8c0330a9971e3363e3505663"
    },
    {
      "event": "labeled",
      "id": 10145652711,
      "node_id": "LE_lADOAP4Jqs5u0bTdzwAAAAJcul_n",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/10145652711",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-21T13:38:31Z",
      "label": {
        "name": "assurance",
        "color": "A6DF3D"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-21T14:24:51Z",
      "updated_at": "2023-08-21T14:24:51Z",
      "source": {
        "issue": {
          "id": 1823841132,
          "node_id": "PR_kwDOAP4Jqs5WhJEI",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1385",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1385/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1385/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1385/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385",
          "number": 1385,
          "state": "closed",
          "state_reason": null,
          "title": "add fuzz tests about field operations.",
          "body": "Thanks for the previous review. \r\nThis PR:\r\n1. changes on the function names in the scalar operations tests.\r\n2. remove the randomness in fuzz_scalar_shift test, the value is computed from size. \r\n3. add the function that decide the test based on an environment variable.\r\n4. add fuzz tests about field operations.\r\nCould you give me some suggestions?\r\n",
          "user": {
            "login": "YafeiXie1",
            "id": 114428701,
            "node_id": "U_kgDOBtILHQ",
            "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/YafeiXie1",
            "html_url": "https://github.com/YafeiXie1",
            "followers_url": "https://api.github.com/users/YafeiXie1/followers",
            "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
            "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
            "repos_url": "https://api.github.com/users/YafeiXie1/repos",
            "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 165017692,
              "node_id": "MDU6TGFiZWwxNjUwMTc2OTI=",
              "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/assurance",
              "name": "assurance",
              "description": "",
              "color": "A6DF3D",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 1,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1385",
            "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1385",
            "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1385.diff",
            "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1385.patch"
          },
          "closed_at": "2023-08-21T14:24:55Z",
          "created_at": "2023-07-27T08:08:29Z",
          "updated_at": "2023-08-29T13:28:58Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1686436955,
      "node_id": "IC_kwDOAP4Jqs5khPxb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1686436955",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-21T14:25:50Z",
      "updated_at": "2023-08-21T14:25:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "@YafeiXie1 Just FYI, you don't need to open a new pull request when you make changes. You can push again to the same branch with more commits (or if you modified existing commits, you'd need a force push, but it's still possible).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#issuecomment-1686436955",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1407"
    },
    {
      "event": "mentioned",
      "id": 10146241687,
      "node_id": "MEE_lADOAP4Jqs5u0bTdzwAAAAJcw1yX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/10146241687",
      "actor": {
        "login": "YafeiXie1",
        "id": 114428701,
        "node_id": "U_kgDOBtILHQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/YafeiXie1",
        "html_url": "https://github.com/YafeiXie1",
        "followers_url": "https://api.github.com/users/YafeiXie1/followers",
        "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
        "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
        "repos_url": "https://api.github.com/users/YafeiXie1/repos",
        "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-21T14:25:51Z"
    },
    {
      "event": "subscribed",
      "id": 10146241704,
      "node_id": "SE_lADOAP4Jqs5u0bTdzwAAAAJcw1yo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/10146241704",
      "actor": {
        "login": "YafeiXie1",
        "id": 114428701,
        "node_id": "U_kgDOBtILHQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/YafeiXie1",
        "html_url": "https://github.com/YafeiXie1",
        "followers_url": "https://api.github.com/users/YafeiXie1/followers",
        "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
        "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
        "repos_url": "https://api.github.com/users/YafeiXie1/repos",
        "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-21T14:25:51Z"
    },
    {
      "event": "unsubscribed",
      "id": 10156117980,
      "node_id": "UE_lADOAP4Jqs5u0bTdzwAAAAJdWg_c",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/10156117980",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T09:40:00Z"
    },
    {
      "event": "reviewed",
      "id": 1594505938,
      "node_id": "PRR_kwDOAP4Jqs5fCjrS",
      "url": null,
      "actor": null,
      "commit_id": "a0b3d0a0dee1171d8c0330a9971e3363e3505663",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#pullrequestreview-1594505938",
      "submitted_at": "2023-08-24T21:55:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGJkMTlhNWZjZDE4MWY1NjgwMDZmMTM4NjZjNGFiMzRmNWNmMTYzNGY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/bd19a5fcd181f568006f13866c4ab34f5cf1634f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/bd19a5fcd181f568006f13866c4ab34f5cf1634f",
      "tree": {
        "sha": "e4767dbeaf34143ff533a893f5b86183096cc719",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e4767dbeaf34143ff533a893f5b86183096cc719"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e4767dbeaf34143ff533a893f5b86183096cc719\nparent a0b3d0a0dee1171d8c0330a9971e3363e3505663\nparent 65c79fe2d05d05258eb95a9c51a306841c8febf2\nauthor OliverX <114428701+YafeiXie1@users.noreply.github.com> 1693315622 +0100\ncommitter GitHub <noreply@github.com> 1693315622 +0100\n\nMerge branch 'bitcoin-core:master' into master\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJk7fImCRBK7hj4Ov3rIwAAN2AIAF0OAVD2CC0tujCdlaKsHb8D\ntheArsy43zjgu8spO+Ev/mDkPFgG8YO6vW0MhPMz+Cv9COwvN9uKOWiPBkO06Smw\n2ToxZ7bqNyIZnZSO4JJCwu3afVEv06CWEnaya5cK2i6NJdJiX9xvJ5bdcocO9Y4N\nu8V4SbmRot3YtZUv1Zil9ufLT6vkz3cMJ5YA/VHvC4YJTHoAAIrJPRCv0Zcae6AQ\nsF3ozOg3yNTE+JEEyP+h2LBtM1Ao20eG0usRB5oUR2SIrkw6LhiHX03iEzULTDzB\nzL0Uqj8J2PBRMmwVfpWPS0XRCFsFSYy2NDxW1fOckU6rjOIhuMSIYJICjHgoNBM=\n=r1kb\n-----END PGP SIGNATURE-----\n"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a0b3d0a0dee1171d8c0330a9971e3363e3505663",
          "sha": "a0b3d0a0dee1171d8c0330a9971e3363e3505663",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a0b3d0a0dee1171d8c0330a9971e3363e3505663"
        },
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/65c79fe2d05d05258eb95a9c51a306841c8febf2",
          "sha": "65c79fe2d05d05258eb95a9c51a306841c8febf2",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/65c79fe2d05d05258eb95a9c51a306841c8febf2"
        }
      ],
      "message": "Merge branch 'bitcoin-core:master' into master",
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2023-08-29T13:27:02Z"
      },
      "author": {
        "name": "OliverX",
        "email": "114428701+YafeiXie1@users.noreply.github.com",
        "date": "2023-08-29T13:27:02Z"
      },
      "sha": "bd19a5fcd181f568006f13866c4ab34f5cf1634f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGE4OWNjMzgyMmQ2MzEwYjMyZDQ4NmM2YzQxMWJmZTExZTA2MjY2YWM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a89cc3822d6310b32d486c6c411bfe11e06266ac",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a89cc3822d6310b32d486c6c411bfe11e06266ac",
      "tree": {
        "sha": "e4767dbeaf34143ff533a893f5b86183096cc719",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e4767dbeaf34143ff533a893f5b86183096cc719"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/65c79fe2d05d05258eb95a9c51a306841c8febf2",
          "sha": "65c79fe2d05d05258eb95a9c51a306841c8febf2",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/65c79fe2d05d05258eb95a9c51a306841c8febf2"
        },
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a0b3d0a0dee1171d8c0330a9971e3363e3505663",
          "sha": "a0b3d0a0dee1171d8c0330a9971e3363e3505663",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a0b3d0a0dee1171d8c0330a9971e3363e3505663"
        }
      ],
      "message": "Merge branch 'master' of https://github.com/YafeiXie1/secp256k1",
      "committer": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-29T13:30:18Z"
      },
      "author": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-29T13:30:18Z"
      },
      "sha": "a89cc3822d6310b32d486c6c411bfe11e06266ac"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDZmNGY3ODIyOWY3NWNmYmI2ZDMzNzY3MGNlNWI1OTBlMDFjMGI4YjI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/6f4f78229f75cfbb6d337670ce5b590e01c0b8b2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/6f4f78229f75cfbb6d337670ce5b590e01c0b8b2",
      "tree": {
        "sha": "414ac62fbf844e4d477db47730830538c5430be5",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/414ac62fbf844e4d477db47730830538c5430be5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a89cc3822d6310b32d486c6c411bfe11e06266ac",
          "sha": "a89cc3822d6310b32d486c6c411bfe11e06266ac",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a89cc3822d6310b32d486c6c411bfe11e06266ac"
        }
      ],
      "message": "1",
      "committer": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-29T13:41:47Z"
      },
      "author": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-29T13:41:47Z"
      },
      "sha": "6f4f78229f75cfbb6d337670ce5b590e01c0b8b2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGY2OTMwYjIwMmEwMzEzYWNkZjFlYTNhZThjMGI0MzJhZjFiMDBmMzc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f6930b202a0313acdf1ea3ae8c0b432af1b00f37",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f6930b202a0313acdf1ea3ae8c0b432af1b00f37",
      "tree": {
        "sha": "414ac62fbf844e4d477db47730830538c5430be5",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/414ac62fbf844e4d477db47730830538c5430be5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/6f4f78229f75cfbb6d337670ce5b590e01c0b8b2",
          "sha": "6f4f78229f75cfbb6d337670ce5b590e01c0b8b2",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/6f4f78229f75cfbb6d337670ce5b590e01c0b8b2"
        },
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/bd19a5fcd181f568006f13866c4ab34f5cf1634f",
          "sha": "bd19a5fcd181f568006f13866c4ab34f5cf1634f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/bd19a5fcd181f568006f13866c4ab34f5cf1634f"
        }
      ],
      "message": "Merge branch 'master' of https://github.com/YafeiXie1/secp256k1",
      "committer": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-29T13:42:13Z"
      },
      "author": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-29T13:42:13Z"
      },
      "sha": "f6930b202a0313acdf1ea3ae8c0b432af1b00f37"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGViZmIyY2Y2YTRlYjFlNGUxYmU3MjU4NDExN2Q3ODAyMWYzZTEwZjM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "tree": {
        "sha": "e8537f6d36e81312206a26eb3a7fcb5143b3ab51",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e8537f6d36e81312206a26eb3a7fcb5143b3ab51"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f6930b202a0313acdf1ea3ae8c0b432af1b00f37",
          "sha": "f6930b202a0313acdf1ea3ae8c0b432af1b00f37",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f6930b202a0313acdf1ea3ae8c0b432af1b00f37"
        }
      ],
      "message": "modified the function to construct field\nand fuzzing tests of group operations",
      "committer": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-29T14:07:07Z"
      },
      "author": {
        "name": "oliver",
        "email": "yx1569@york.ac.uk",
        "date": "2023-08-29T14:07:07Z"
      },
      "sha": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3"
    },
    {
      "event": "commented",
      "id": 1697523602,
      "node_id": "IC_kwDOAP4Jqs5lLieS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1697523602",
      "actor": {
        "login": "YafeiXie1",
        "id": 114428701,
        "node_id": "U_kgDOBtILHQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/YafeiXie1",
        "html_url": "https://github.com/YafeiXie1",
        "followers_url": "https://api.github.com/users/YafeiXie1/followers",
        "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
        "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
        "repos_url": "https://api.github.com/users/YafeiXie1/repos",
        "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-29T14:12:02Z",
      "updated_at": "2023-08-29T14:12:02Z",
      "author_association": "NONE",
      "body": "Thanks for the previous review.\r\nThis PR:\r\nModified the field construct function to build more valid field elements.\r\nModified and added the fuzzing tests for the group operations.\r\nCould you give me some suggestions?",
      "user": {
        "login": "YafeiXie1",
        "id": 114428701,
        "node_id": "U_kgDOBtILHQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/YafeiXie1",
        "html_url": "https://github.com/YafeiXie1",
        "followers_url": "https://api.github.com/users/YafeiXie1/followers",
        "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
        "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
        "repos_url": "https://api.github.com/users/YafeiXie1/repos",
        "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#issuecomment-1697523602",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1407"
    },
    {
      "event": "reviewed",
      "id": 1600591161,
      "node_id": "PRR_kwDOAP4Jqs5fZxU5",
      "url": null,
      "actor": null,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#pullrequestreview-1600591161",
      "submitted_at": "2023-08-29T19:03:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304899885",
      "pull_request_review_id": 1594505938,
      "id": 1304899885,
      "node_id": "PRRC_kwDOAP4Jqs5NxzEt",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Construct a valid field element from fuzzer with random magnitude  */\n+static void fuzz_field_construct(const uint8_t *data, size_t size, secp256k1_fe *r) {    \n+    if (size>=32) {\n+        secp256k1_fe a, zero;      \n+        secp256k1_fe_set_b32_mod(r, data);\n+        int rand_magnitude = data[31] % 33;\n+        secp256k1_fe_normalize(r);\n+        if (rand_magnitude == 0) {\n+            return;\n+        }\n+        secp256k1_fe_clear(&zero);\n+        secp256k1_fe_negate(&zero, &zero, 0);\n+        secp256k1_fe_mul_int_unchecked(&zero, rand_magnitude - 1);\n+        secp256k1_fe_add(r, &zero);         \n+    }",
      "path": "src/fuzz.c",
      "position": 244,
      "original_position": 220,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "3874a937a9240f5c654cab84450a697d1982c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's unclear where the responsibility lies for making sure the input is big enough:\r\n* Does it lie with the caller (e.g. is it only allowed to call `fuzz_field_construct` when the caller knows `size >= 32`)? If so, then the `if (size>=32) {` branch is unnecessary, and could be replaced with `CHECK(size >= 32);` instead, or the `size` argument could be dropped from this function entirely even.\r\n* Does it lie with the `fuzz_field_construct` function? If so then the function needs to have a means of returning success/failure if the size is too small. Also, in that case `data` and `size` arguments probably need to be made pointers (`const uint8_t **data, size_t *size`), so they can be updated by `fuzz_field_construct` (otherwise the caller is still responsible for updating them).",
      "created_at": "2023-08-24T21:42:18Z",
      "updated_at": "2023-08-24T21:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1304899885",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304899885"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 244,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304900862",
      "pull_request_review_id": 1594505938,
      "id": 1304900862,
      "node_id": "PRRC_kwDOAP4Jqs5NxzT-",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Construct a valid field element from fuzzer with random magnitude  */\n+static void fuzz_field_construct(const uint8_t *data, size_t size, secp256k1_fe *r) {    \n+    if (size>=32) {\n+        secp256k1_fe a, zero;      \n+        secp256k1_fe_set_b32_mod(r, data);\n+        int rand_magnitude = data[31] % 33;\n+        secp256k1_fe_normalize(r);\n+        if (rand_magnitude == 0) {\n+            return;\n+        }\n+        secp256k1_fe_clear(&zero);\n+        secp256k1_fe_negate(&zero, &zero, 0);\n+        secp256k1_fe_mul_int_unchecked(&zero, rand_magnitude - 1);\n+        secp256k1_fe_add(r, &zero);         \n+    }\n+}\n+\n+#ifdef VERIFY",
      "path": "src/fuzz.c",
      "position": null,
      "original_position": 223,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "3874a937a9240f5c654cab84450a697d1982c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why?",
      "created_at": "2023-08-24T21:43:48Z",
      "updated_at": "2023-08-24T21:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1304900862",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304900862"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304903650",
      "pull_request_review_id": 1594505938,
      "id": 1304903650,
      "node_id": "PRRC_kwDOAP4Jqs5Nxz_i",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Construct a valid field element from fuzzer with random magnitude  */\n+static void fuzz_field_construct(const uint8_t *data, size_t size, secp256k1_fe *r) {    \n+    if (size>=32) {\n+        secp256k1_fe a, zero;      \n+        secp256k1_fe_set_b32_mod(r, data);\n+        int rand_magnitude = data[31] % 33;\n+        secp256k1_fe_normalize(r);\n+        if (rand_magnitude == 0) {\n+            return;\n+        }\n+        secp256k1_fe_clear(&zero);\n+        secp256k1_fe_negate(&zero, &zero, 0);\n+        secp256k1_fe_mul_int_unchecked(&zero, rand_magnitude - 1);\n+        secp256k1_fe_add(r, &zero);         \n+    }\n+}\n+\n+#ifdef VERIFY\n+/* Test the field element comparison operations. */\n+static void fuzz_field_comparison(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_fe a;    \n+        fuzz_field_construct(data, size, &a);\n+        if (a.normalized) { ",
      "path": "src/fuzz.c",
      "position": null,
      "original_position": 229,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "3874a937a9240f5c654cab84450a697d1982c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The test could be a lot more efficient if `fuzz_field_construct` had an input argument that can guarantee it only produces normalized field elements (because as-is, in many cases no test will be performed at all). Alternatively, there could be a separate function for just that.",
      "created_at": "2023-08-24T21:47:00Z",
      "updated_at": "2023-08-24T21:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1304903650",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304903650"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304904796",
      "pull_request_review_id": 1594505938,
      "id": 1304904796,
      "node_id": "PRRC_kwDOAP4Jqs5Nx0Rc",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Construct a valid field element from fuzzer with random magnitude  */\n+static void fuzz_field_construct(const uint8_t *data, size_t size, secp256k1_fe *r) {    \n+    if (size>=32) {\n+        secp256k1_fe a, zero;      \n+        secp256k1_fe_set_b32_mod(r, data);\n+        int rand_magnitude = data[31] % 33;\n+        secp256k1_fe_normalize(r);\n+        if (rand_magnitude == 0) {\n+            return;",
      "path": "src/fuzz.c",
      "position": null,
      "original_position": 214,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "3874a937a9240f5c654cab84450a697d1982c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In this case, the returned field element will not have magnitude 0. In fact, it'll be unspecified, making the code that uses it below have undefined behavior. For magnitude 0, you should set the output to just be the 0 field element.",
      "created_at": "2023-08-24T21:48:28Z",
      "updated_at": "2023-08-24T21:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1304904796",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304904796"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304905190",
      "pull_request_review_id": 1594505938,
      "id": 1304905190,
      "node_id": "PRRC_kwDOAP4Jqs5Nx0Xm",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Construct a valid field element from fuzzer with random magnitude  */\n+static void fuzz_field_construct(const uint8_t *data, size_t size, secp256k1_fe *r) {    \n+    if (size>=32) {\n+        secp256k1_fe a, zero;      \n+        secp256k1_fe_set_b32_mod(r, data);\n+        int rand_magnitude = data[31] % 33;",
      "path": "src/fuzz.c",
      "position": null,
      "original_position": 211,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "3874a937a9240f5c654cab84450a697d1982c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think it's a good idea to reuse fuzz input bytes for two distinct meanings (here: magnitude and the lowest byte of the field element representation). It may also be better to let the caller decide the magnitude (or at least max magnitude), and then let the function construct it.",
      "created_at": "2023-08-24T21:49:02Z",
      "updated_at": "2023-08-24T21:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1304905190",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304905190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304906607",
      "pull_request_review_id": 1594505938,
      "id": 1304906607,
      "node_id": "PRRC_kwDOAP4Jqs5Nx0tv",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Construct a valid field element from fuzzer with random magnitude  */\n+static void fuzz_field_construct(const uint8_t *data, size_t size, secp256k1_fe *r) {    \n+    if (size>=32) {\n+        secp256k1_fe a, zero;      \n+        secp256k1_fe_set_b32_mod(r, data);\n+        int rand_magnitude = data[31] % 33;\n+        secp256k1_fe_normalize(r);\n+        if (rand_magnitude == 0) {\n+            return;\n+        }\n+        secp256k1_fe_clear(&zero);\n+        secp256k1_fe_negate(&zero, &zero, 0);\n+        secp256k1_fe_mul_int_unchecked(&zero, rand_magnitude - 1);",
      "path": "src/fuzz.c",
      "position": null,
      "original_position": 218,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "3874a937a9240f5c654cab84450a697d1982c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The approach here does not reach all possible field element representations; only ones that can be represented as \"normalized_number times integer in range 1 to 31\".\r\n\r\nI think it would be better if you'd read a full 40 bytes, and then use masking (using bitwise AND to set certain bits to zero) and/or rejection (just give up if the resulting value has bad magnitude) to obtain field elements of the desired magnitude.",
      "created_at": "2023-08-24T21:50:18Z",
      "updated_at": "2023-08-24T21:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1304906607",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304906607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304908890",
      "pull_request_review_id": 1594505938,
      "id": 1304908890,
      "node_id": "PRRC_kwDOAP4Jqs5Nx1Ra",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Construct a valid field element from fuzzer with random magnitude  */\n+static void fuzz_field_construct(const uint8_t *data, size_t size, secp256k1_fe *r) {    \n+    if (size>=32) {\n+        secp256k1_fe a, zero;      \n+        secp256k1_fe_set_b32_mod(r, data);\n+        int rand_magnitude = data[31] % 33;\n+        secp256k1_fe_normalize(r);\n+        if (rand_magnitude == 0) {\n+            return;\n+        }\n+        secp256k1_fe_clear(&zero);\n+        secp256k1_fe_negate(&zero, &zero, 0);\n+        secp256k1_fe_mul_int_unchecked(&zero, rand_magnitude - 1);\n+        secp256k1_fe_add(r, &zero);         \n+    }\n+}\n+\n+#ifdef VERIFY\n+/* Test the field element comparison operations. */\n+static void fuzz_field_comparison(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_fe a;    \n+        fuzz_field_construct(data, size, &a);\n+        if (a.normalized) { \n+            CHECK(secp256k1_fe_cmp_var(&a, &a) == 0);\n+        }\n+    }\n+}\n+\n+/* Test conversions between 32-byte value and field element */ \n+static void fuzz_field_b32_and_fe(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_fe a, b;\n+        unsigned char b32[32];     \n+        fuzz_field_construct(data, size, &a);  \n+        if (!a.normalized) {\n+            return;\n+        }\n+        secp256k1_fe_get_b32(b32, &a);\n+        secp256k1_fe_set_b32_limit(&b, b32);\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);       \n+    }\n+}\n+\n+/* Test conversions between field element and secp256k1_fe_storage */ \n+static void fuzz_field_fe_and_storage(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_fe a, b;\n+        secp256k1_fe_storage fes; \n+        fuzz_field_construct(data, size, &a);\n+        if (!a.normalized) {\n+            return;\n+        }\n+        secp256k1_fe_to_storage(&fes, &a);\n+        secp256k1_fe_from_storage(&b, &fes);\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+    }\n+}\n+\n+/* Test commutativity of addition on two field elements */ \n+static void fuzz_field_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_fe a, b, r1, r2;\n+        fuzz_field_construct(data, size, &a);\n+        fuzz_field_construct(data + 32, size, &b);         \n+        if (a.magnitude + b.magnitude > 32) {\n+            return;\n+        }    \n+        r1 = a;\n+        secp256k1_fe_add(&r1, &b);\n+        r2 = b;\n+        secp256k1_fe_add(&r2, &a);    \n+        CHECK(r1.magnitude == a.magnitude + b.magnitude);\n+        CHECK(r2.magnitude == r1.magnitude);\n+        secp256k1_fe_normalize(&r1);\n+        secp256k1_fe_normalize(&r2);\n+        CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+    }\n+}\n+\n+/* Test associativity of addition on field elements */\n+static void fuzz_field_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_fe a, b, c, r1, r2;\n+        fuzz_field_construct(data, size, &a);\n+        fuzz_field_construct(data + 32, size, &b);\n+        fuzz_field_construct(data + 64, size, &c);\n+        if (a.magnitude + b.magnitude + c.magnitude > 32) {\n+            return;\n+        }\n+        r1 = a;\n+        secp256k1_fe_add(&r1, &b);\n+        secp256k1_fe_add(&r1, &c);\n+        r2 = c;\n+        secp256k1_fe_add(&r2, &b);\n+        secp256k1_fe_add(&r2, &a);\n+        CHECK(r1.magnitude == a.magnitude + b.magnitude + c.magnitude);\n+        CHECK(r2.magnitude == r1.magnitude);\n+        secp256k1_fe_normalize(&r1);\n+        secp256k1_fe_normalize(&r2);\n+        CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+    }\n+}\n+\n+\n+/* Test identity addition on field elements */ \n+static void fuzz_field_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_fe a, zero, r1;\n+        fuzz_field_construct(data, size, &a);        \n+        secp256k1_fe_clear(&zero);\n+        r1 = a;\n+        secp256k1_fe_add(&r1, &zero);\n+        secp256k1_fe_normalize(&a);\n+        secp256k1_fe_normalize(&r1);\n+        CHECK(secp256k1_fe_cmp_var(&r1, &a) == 0);\n+    }\n+}\n+\n+/* Test addition of field element and its negative value */ \n+static void fuzz_field_add_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_fe a, negate;\n+        fuzz_field_construct(data, size, &a);\n+        if (a.magnitude >= 32) {",
      "path": "src/fuzz.c",
      "position": null,
      "original_position": 330,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "3874a937a9240f5c654cab84450a697d1982c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This test is unnecessary; `fuzz_field_construct` only constructs values with magnitude at most 32.",
      "created_at": "2023-08-24T21:52:50Z",
      "updated_at": "2023-08-24T21:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1304908890",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304908890"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304910405",
      "pull_request_review_id": 1594505938,
      "id": 1304910405,
      "node_id": "PRRC_kwDOAP4Jqs5Nx1pF",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Construct a valid field element from fuzzer with random magnitude  */\n+static void fuzz_field_construct(const uint8_t *data, size_t size, secp256k1_fe *r) {    \n+    if (size>=32) {\n+        secp256k1_fe a, zero;      \n+        secp256k1_fe_set_b32_mod(r, data);\n+        int rand_magnitude = data[31] % 33;\n+        secp256k1_fe_normalize(r);\n+        if (rand_magnitude == 0) {\n+            return;\n+        }\n+        secp256k1_fe_clear(&zero);\n+        secp256k1_fe_negate(&zero, &zero, 0);\n+        secp256k1_fe_mul_int_unchecked(&zero, rand_magnitude - 1);\n+        secp256k1_fe_add(r, &zero);         \n+    }\n+}\n+\n+#ifdef VERIFY\n+/* Test the field element comparison operations. */\n+static void fuzz_field_comparison(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_fe a;    \n+        fuzz_field_construct(data, size, &a);\n+        if (a.normalized) { \n+            CHECK(secp256k1_fe_cmp_var(&a, &a) == 0);\n+        }\n+    }\n+}\n+\n+/* Test conversions between 32-byte value and field element */ \n+static void fuzz_field_b32_and_fe(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_fe a, b;\n+        unsigned char b32[32];     \n+        fuzz_field_construct(data, size, &a);  \n+        if (!a.normalized) {\n+            return;\n+        }\n+        secp256k1_fe_get_b32(b32, &a);\n+        secp256k1_fe_set_b32_limit(&b, b32);\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);       \n+    }\n+}\n+\n+/* Test conversions between field element and secp256k1_fe_storage */ \n+static void fuzz_field_fe_and_storage(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_fe a, b;\n+        secp256k1_fe_storage fes; \n+        fuzz_field_construct(data, size, &a);\n+        if (!a.normalized) {\n+            return;\n+        }\n+        secp256k1_fe_to_storage(&fes, &a);\n+        secp256k1_fe_from_storage(&b, &fes);\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+    }\n+}\n+\n+/* Test commutativity of addition on two field elements */ \n+static void fuzz_field_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_fe a, b, r1, r2;\n+        fuzz_field_construct(data, size, &a);\n+        fuzz_field_construct(data + 32, size, &b);         ",
      "path": "src/fuzz.c",
      "position": null,
      "original_position": 270,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "3874a937a9240f5c654cab84450a697d1982c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The `size` pass here is incorrect, because the array pointed to by `data + 32` only has length `size - 32`. See also my comment about responsibility of guaranteeing length on `fuzz_field_construct`.",
      "created_at": "2023-08-24T21:53:55Z",
      "updated_at": "2023-08-24T21:55:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1304910405",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1304910405"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1305739417",
      "pull_request_review_id": 1595859175,
      "id": 1305739417,
      "node_id": "PRRC_kwDOAP4Jqs5N1ACZ",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/* Construct a valid field element from fuzzer with random magnitude  */\n+static void fuzz_field_construct(const uint8_t *data, size_t size, secp256k1_fe *r) {    \n+    if (size>=32) {\n+        secp256k1_fe a, zero;      \n+        secp256k1_fe_set_b32_mod(r, data);\n+        int rand_magnitude = data[31] % 33;\n+        secp256k1_fe_normalize(r);\n+        if (rand_magnitude == 0) {\n+            return;\n+        }\n+        secp256k1_fe_clear(&zero);\n+        secp256k1_fe_negate(&zero, &zero, 0);\n+        secp256k1_fe_mul_int_unchecked(&zero, rand_magnitude - 1);",
      "path": "src/fuzz.c",
      "position": null,
      "original_position": 218,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "3874a937a9240f5c654cab84450a697d1982c2dc",
      "in_reply_to_id": 1304906607,
      "user": {
        "login": "YafeiXie1",
        "id": 114428701,
        "node_id": "U_kgDOBtILHQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/114428701?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/YafeiXie1",
        "html_url": "https://github.com/YafeiXie1",
        "followers_url": "https://api.github.com/users/YafeiXie1/followers",
        "following_url": "https://api.github.com/users/YafeiXie1/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/YafeiXie1/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/YafeiXie1/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/YafeiXie1/subscriptions",
        "organizations_url": "https://api.github.com/users/YafeiXie1/orgs",
        "repos_url": "https://api.github.com/users/YafeiXie1/repos",
        "events_url": "https://api.github.com/users/YafeiXie1/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/YafeiXie1/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for your suggestions! I will modify this fuzz_field_construct function and other errors. ",
      "created_at": "2023-08-25T14:30:22Z",
      "updated_at": "2023-08-25T14:30:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1305739417",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1305739417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1308929468",
      "pull_request_review_id": 1600591161,
      "id": 1308929468,
      "node_id": "PRRC_kwDOAP4Jqs5OBK28",
      "diff_hunk": "@@ -0,0 +1,5 @@\n+{",
      "path": ".vscode/settings.json",
      "position": 1,
      "original_position": 1,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Don't add this file, please. It's for your local setup, not everyone's.",
      "created_at": "2023-08-29T14:31:03Z",
      "updated_at": "2023-08-29T19:03:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1308929468",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1308929468"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309165644",
      "pull_request_review_id": 1600591161,
      "id": 1309165644,
      "node_id": "PRRC_kwDOAP4Jqs5OCEhM",
      "diff_hunk": "@@ -0,0 +1,1303 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/** Construct a valid field element using 42 bytes data from fuzzer.  \n+*\n+* On input, 'data' must have 42 bytes at least. If 'normalized' != 0, this function will only construct normalized field elements.\n+* If 'normalized' = 0, this function will construct normalized or non-normalized field elements depending on the fuzzer data.\n+* On output, r will be a valid field element\n+**/\n+static void fuzz_field_construct(const uint8_t *data, int normalized, secp256k1_fe *r) {\n+    /* Construct a field element using data[0...39] */\n+    for (int i = 0; i < 5; ++i) {\n+        r->n[i] = 0;\n+        for (int j = 0; j < 8; ++j) {\n+            r->n[i] |= (uint64_t)data[i * 8 + j] << ((7 - j) * 8);\n+        }\n+    }\n+    /* Set a random magnitude depending on the data[40] */\n+    int magnitude = normalized ? (data[40] % 2) : (data[40] % 33);\n+    /* Set a random normalized depending on the data[41] (if magnitude <= 1) */\n+    int n = (data[40] % 33) <= 1 ? (data[41] % 2) : 0;\n+    r->magnitude = magnitude;\n+    r->normalized = normalized ? 1 : n;\n+    int t = r->normalized ? 1 : (2 * magnitude);\n+    if (magnitude == 0){ \n+        for (int i=0; i<5; i++) {\n+            r->n[i] = 0;\n+        }\n+    }  \n+    uint64_t mask1 = 0xFFFFFFFFFFFFFULL * t;\n+    uint64_t mask2 = 0x0FFFFFFFFFFFFULL * t;         \n+    r->n[0] &= mask1;\n+    r->n[1] &= mask1;\n+    r->n[2] &= mask1;\n+    r->n[3] &= mask1;\n+    r->n[4] &= mask2;\n+    if (r->normalized) {\n+        if ((r->n[4] == 0x0FFFFFFFFFFFFULL) && ((r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL)) {\n+            uint64_t mask3 = 0xFFFFEFFFFFC2FULL - 1;\n+            r->n[0] &= mask3;",
      "path": "src/fuzz.c",
      "position": 242,
      "original_position": 242,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe this is inaccurate, as it will unconditionally wipe some bits in `r->n[0]` even when unnecessary, making certain values unreachable. E.g. it'll turn `r->n[0] = 0x1000003d1` into `r->n[0] = 0`.",
      "created_at": "2023-08-29T17:46:46Z",
      "updated_at": "2023-08-29T19:03:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1309165644",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309165644"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 242,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309186482",
      "pull_request_review_id": 1600591161,
      "id": 1309186482,
      "node_id": "PRRC_kwDOAP4Jqs5OCJmy",
      "diff_hunk": "@@ -0,0 +1,1303 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/** Construct a valid field element using 42 bytes data from fuzzer.  \n+*\n+* On input, 'data' must have 42 bytes at least. If 'normalized' != 0, this function will only construct normalized field elements.\n+* If 'normalized' = 0, this function will construct normalized or non-normalized field elements depending on the fuzzer data.\n+* On output, r will be a valid field element\n+**/\n+static void fuzz_field_construct(const uint8_t *data, int normalized, secp256k1_fe *r) {",
      "path": "src/fuzz.c",
      "position": 212,
      "original_position": 212,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think the effectiveness of some of the tests below could be increased further by passing a max magnitude argument to `fuzz_field_construct`, so that things like\r\n\r\n```c\r\n        fuzz_field_construct(data, 0, &a);\r\n        fuzz_field_construct(data + 42, 0, &b);         \r\n        if (a.magnitude + b.magnitude <= 32) {\r\n```\r\n\r\ncould become\r\n\r\n```c\r\n        fuzz_field_construct(data, 0, 32, &a);\r\n        fuzz_field_construct(data + 42, 0, 32 - a.magnitude, &b);\r\n```\r\n\r\nIt'd also remove the need for `fuzz_ge_fe_construct`.",
      "created_at": "2023-08-29T18:08:25Z",
      "updated_at": "2023-08-29T19:03:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1309186482",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309186482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 212,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309192116",
      "pull_request_review_id": 1600591161,
      "id": 1309192116,
      "node_id": "PRRC_kwDOAP4Jqs5OCK-0",
      "diff_hunk": "@@ -0,0 +1,1303 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/** Construct a valid field element using 42 bytes data from fuzzer.  \n+*\n+* On input, 'data' must have 42 bytes at least. If 'normalized' != 0, this function will only construct normalized field elements.\n+* If 'normalized' = 0, this function will construct normalized or non-normalized field elements depending on the fuzzer data.\n+* On output, r will be a valid field element\n+**/\n+static void fuzz_field_construct(const uint8_t *data, int normalized, secp256k1_fe *r) {\n+    /* Construct a field element using data[0...39] */\n+    for (int i = 0; i < 5; ++i) {\n+        r->n[i] = 0;\n+        for (int j = 0; j < 8; ++j) {\n+            r->n[i] |= (uint64_t)data[i * 8 + j] << ((7 - j) * 8);\n+        }\n+    }\n+    /* Set a random magnitude depending on the data[40] */\n+    int magnitude = normalized ? (data[40] % 2) : (data[40] % 33);\n+    /* Set a random normalized depending on the data[41] (if magnitude <= 1) */\n+    int n = (data[40] % 33) <= 1 ? (data[41] % 2) : 0;\n+    r->magnitude = magnitude;\n+    r->normalized = normalized ? 1 : n;\n+    int t = r->normalized ? 1 : (2 * magnitude);\n+    if (magnitude == 0){ \n+        for (int i=0; i<5; i++) {\n+            r->n[i] = 0;\n+        }\n+    }  \n+    uint64_t mask1 = 0xFFFFFFFFFFFFFULL * t;\n+    uint64_t mask2 = 0x0FFFFFFFFFFFFULL * t;         \n+    r->n[0] &= mask1;\n+    r->n[1] &= mask1;\n+    r->n[2] &= mask1;\n+    r->n[3] &= mask1;\n+    r->n[4] &= mask2;\n+    if (r->normalized) {\n+        if ((r->n[4] == 0x0FFFFFFFFFFFFULL) && ((r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL)) {\n+            uint64_t mask3 = 0xFFFFEFFFFFC2FULL - 1;\n+            r->n[0] &= mask3;\n+        }\n+    }\n+}\n+\n+/* Test the field element comparison operations. */\n+static void fuzz_field_comparison(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b;    \n+        fuzz_field_construct(data, 1, &a);\n+        b = a;\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+        secp256k1_fe_add_int(&b, 1);\n+        secp256k1_fe_normalize(&b);\n+        if (!secp256k1_fe_is_zero(&b)) {\n+            CHECK(secp256k1_fe_cmp_var(&a, &b) == -1);\n+            CHECK(secp256k1_fe_cmp_var(&b, &a) == 1);\n+        }       \n+    }\n+}\n+\n+/* Test the equality of field elements. */\n+static void fuzz_field_equal(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b, c;\n+        fuzz_field_construct(data, 1, &a);\n+        if (a.magnitude <= 31) {\n+            b = a;\n+            secp256k1_fe_normalize(&b);\n+            c = a.magnitude <= 1 ? a : b;\n+            CHECK(secp256k1_fe_equal(&c, &a));\n+            secp256k1_fe_add_int(&c, 1);\n+            CHECK(secp256k1_fe_equal(&b, &c) == 0);\n+        }    \n+    }  \n+}\n+\n+/* Test conversions between 32-byte value and field element */ \n+static void fuzz_field_b32_and_fe(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b, c;\n+        unsigned char b32[32];     \n+        fuzz_field_construct(data, 1, &a);  \n+        secp256k1_fe_get_b32(b32, &a);\n+        secp256k1_fe_set_b32_limit(&b, b32);\n+        secp256k1_fe_set_b32_mod(&c, b32);\n+        CHECK(secp256k1_fe_equal(&a, &b));\n+        CHECK(secp256k1_fe_equal(&a, &c));       \n+    }\n+}\n+\n+/* Test conversions between field element and secp256k1_fe_storage */ \n+static void fuzz_field_fe_and_storage(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b;\n+        secp256k1_fe_storage fes; \n+        fuzz_field_construct(data, 1, &a);\n+        secp256k1_fe_to_storage(&fes, &a);\n+        secp256k1_fe_from_storage(&b, &fes);\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+    }\n+}\n+\n+/* Test commutativity of addition on two field elements */ \n+static void fuzz_field_add_commutativty(const uint8_t *data, size_t size) {",
      "path": "src/fuzz.c",
      "position": 306,
      "original_position": 306,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: typo ",
      "created_at": "2023-08-29T18:14:33Z",
      "updated_at": "2023-08-29T19:03:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1309192116",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309192116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 306,
      "original_line": 306,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309196177",
      "pull_request_review_id": 1600591161,
      "id": 1309196177,
      "node_id": "PRRC_kwDOAP4Jqs5OCL-R",
      "diff_hunk": "@@ -0,0 +1,1303 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/** Construct a valid field element using 42 bytes data from fuzzer.  \n+*\n+* On input, 'data' must have 42 bytes at least. If 'normalized' != 0, this function will only construct normalized field elements.\n+* If 'normalized' = 0, this function will construct normalized or non-normalized field elements depending on the fuzzer data.\n+* On output, r will be a valid field element\n+**/\n+static void fuzz_field_construct(const uint8_t *data, int normalized, secp256k1_fe *r) {\n+    /* Construct a field element using data[0...39] */\n+    for (int i = 0; i < 5; ++i) {\n+        r->n[i] = 0;\n+        for (int j = 0; j < 8; ++j) {\n+            r->n[i] |= (uint64_t)data[i * 8 + j] << ((7 - j) * 8);\n+        }\n+    }\n+    /* Set a random magnitude depending on the data[40] */\n+    int magnitude = normalized ? (data[40] % 2) : (data[40] % 33);\n+    /* Set a random normalized depending on the data[41] (if magnitude <= 1) */\n+    int n = (data[40] % 33) <= 1 ? (data[41] % 2) : 0;\n+    r->magnitude = magnitude;\n+    r->normalized = normalized ? 1 : n;\n+    int t = r->normalized ? 1 : (2 * magnitude);\n+    if (magnitude == 0){ \n+        for (int i=0; i<5; i++) {\n+            r->n[i] = 0;\n+        }\n+    }  \n+    uint64_t mask1 = 0xFFFFFFFFFFFFFULL * t;\n+    uint64_t mask2 = 0x0FFFFFFFFFFFFULL * t;         \n+    r->n[0] &= mask1;\n+    r->n[1] &= mask1;\n+    r->n[2] &= mask1;\n+    r->n[3] &= mask1;\n+    r->n[4] &= mask2;\n+    if (r->normalized) {\n+        if ((r->n[4] == 0x0FFFFFFFFFFFFULL) && ((r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL)) {\n+            uint64_t mask3 = 0xFFFFEFFFFFC2FULL - 1;\n+            r->n[0] &= mask3;\n+        }\n+    }\n+}\n+\n+/* Test the field element comparison operations. */\n+static void fuzz_field_comparison(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b;    \n+        fuzz_field_construct(data, 1, &a);\n+        b = a;\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+        secp256k1_fe_add_int(&b, 1);\n+        secp256k1_fe_normalize(&b);\n+        if (!secp256k1_fe_is_zero(&b)) {\n+            CHECK(secp256k1_fe_cmp_var(&a, &b) == -1);\n+            CHECK(secp256k1_fe_cmp_var(&b, &a) == 1);\n+        }       \n+    }\n+}\n+\n+/* Test the equality of field elements. */\n+static void fuzz_field_equal(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b, c;\n+        fuzz_field_construct(data, 1, &a);\n+        if (a.magnitude <= 31) {\n+            b = a;\n+            secp256k1_fe_normalize(&b);\n+            c = a.magnitude <= 1 ? a : b;\n+            CHECK(secp256k1_fe_equal(&c, &a));\n+            secp256k1_fe_add_int(&c, 1);\n+            CHECK(secp256k1_fe_equal(&b, &c) == 0);\n+        }    \n+    }  \n+}\n+\n+/* Test conversions between 32-byte value and field element */ \n+static void fuzz_field_b32_and_fe(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b, c;\n+        unsigned char b32[32];     \n+        fuzz_field_construct(data, 1, &a);  \n+        secp256k1_fe_get_b32(b32, &a);\n+        secp256k1_fe_set_b32_limit(&b, b32);\n+        secp256k1_fe_set_b32_mod(&c, b32);\n+        CHECK(secp256k1_fe_equal(&a, &b));\n+        CHECK(secp256k1_fe_equal(&a, &c));       \n+    }\n+}\n+\n+/* Test conversions between field element and secp256k1_fe_storage */ \n+static void fuzz_field_fe_and_storage(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b;\n+        secp256k1_fe_storage fes; \n+        fuzz_field_construct(data, 1, &a);\n+        secp256k1_fe_to_storage(&fes, &a);\n+        secp256k1_fe_from_storage(&b, &fes);\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+    }\n+}\n+\n+/* Test commutativity of addition on two field elements */ \n+static void fuzz_field_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 84) {        \n+        secp256k1_fe a, b, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);         \n+        if (a.magnitude + b.magnitude <= 32) {\n+            r1 = a;\n+            secp256k1_fe_add(&r1, &b);\n+            r2 = b;\n+            secp256k1_fe_add(&r2, &a);    \n+            CHECK(r1.magnitude == a.magnitude + b.magnitude);\n+            CHECK(r2.magnitude == r1.magnitude);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a + b = b + a */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }    \n+    }\n+}\n+\n+/* Test associativity of addition on field elements */\n+static void fuzz_field_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 126) {     \n+        secp256k1_fe a, b, c, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        fuzz_field_construct(data + 84, 0, &c);\n+        if (a.magnitude + b.magnitude + c.magnitude <= 32) {\n+            r1 = a;\n+            secp256k1_fe_add(&r1, &b);\n+            secp256k1_fe_add(&r1, &c);\n+            r2 = c;\n+            secp256k1_fe_add(&r2, &b);\n+            secp256k1_fe_add(&r2, &a);\n+            CHECK(r1.magnitude == a.magnitude + b.magnitude + c.magnitude);\n+            CHECK(r2.magnitude == r1.magnitude);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a + b + c = a + (b + c) */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test identity addition on field elements */ \n+static void fuzz_field_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, zero, r1;\n+        fuzz_field_construct(data, 0, &a);        \n+        secp256k1_fe_clear(&zero);\n+        r1 = a;\n+        secp256k1_fe_add(&r1, &zero);\n+        secp256k1_fe_normalize(&a);\n+        secp256k1_fe_normalize(&r1);\n+        /* Check a + 0 = a */\n+        CHECK(secp256k1_fe_cmp_var(&r1, &a) == 0);\n+    }\n+}\n+\n+/* Test addition of field element and its negative value */ \n+static void fuzz_field_add_negate(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, negate;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 31) {\n+            secp256k1_fe_negate(&negate, &a, 31);\n+            CHECK(negate.magnitude == 32);\n+            secp256k1_fe_normalize(&a);\n+            secp256k1_fe_normalize(&negate);    \n+            secp256k1_fe_add(&a, &negate);\n+            /* Check a + -a = 0 */\n+            CHECK(secp256k1_fe_normalizes_to_zero(&a));\n+        }\n+    }\n+}\n+\n+/* Test addition of field element and its negative value (unchecked the m) */ \n+static void fuzz_field_add_negate_unchecked(const uint8_t *data, size_t size) {\n+    if (size >= 43) {        \n+        secp256k1_fe a, negate;\n+        fuzz_field_construct(data, 0, &a);\n+        int m = data[42] % 32;\n+        if (a.magnitude <= m) {\n+            secp256k1_fe_negate_unchecked(&negate, &a, m);\n+            CHECK(negate.magnitude == m + 1);\n+            secp256k1_fe_normalize(&a);\n+            secp256k1_fe_normalize(&negate);    \n+            secp256k1_fe_add(&a, &negate);\n+            /* Check a + -a = 0 */\n+            CHECK(secp256k1_fe_normalizes_to_zero(&a));\n+        }\n+    }\n+}\n+\n+\n+/* Test addition of field element and an integer */ \n+static void fuzz_field_add_integer(const uint8_t *data, size_t size) {\n+    if (size >= 43) {        \n+        secp256k1_fe a, r1, r2;\n+        int v = data[42];\n+        fuzz_field_construct(data, 0, &a);\n+        secp256k1_fe_set_int(&r1, v);\n+        if ((a.magnitude + r1.magnitude <= 32) && (a.magnitude <= 31)) {\n+            secp256k1_fe_add(&r1, &a);\n+            r2 = a;\n+            secp256k1_fe_add_int(&r2, v);\n+            CHECK(r2.magnitude == a.magnitude + 1);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test the half value of a field element */ \n+static void fuzz_field_half(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude < 32) {\n+            b = a;\n+            secp256k1_fe_half(&a);\n+            int m = b.magnitude;\n+            CHECK(a.magnitude == (m >> 1) + 1);\n+            secp256k1_fe_normalize(&a);\n+            secp256k1_fe_add(&a, &a);\n+            secp256k1_fe_normalize(&b);\n+            secp256k1_fe_normalize(&a);\n+            CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+        }\n+    }\n+}\n+\n+/* Test commutativity of multiplication on two field elements */\n+static void fuzz_field_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 84) {        \n+        secp256k1_fe a, b, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        if ((a.magnitude <= 8) && (b.magnitude <= 8)) {\n+            secp256k1_fe_mul(&r1, &a, &b);\n+            secp256k1_fe_mul(&r2, &b, &a);\n+            CHECK((r1.magnitude == 1) && (r2.magnitude == 1));\n+            CHECK((r1.normalized == 0) && (r2.normalized == 0));\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a * b = b * a */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }        \n+    }\n+}\n+\n+/* Test associativity of multiplication on field elements */\n+static void fuzz_field_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 126) {     \n+        secp256k1_fe a, b, c, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        fuzz_field_construct(data + 84, 0, &c);\n+        if ((a.magnitude <= 8) && (b.magnitude <= 8) && (c.magnitude <= 8)) {\n+            secp256k1_fe_mul(&r1, &a, &b);\n+            secp256k1_fe_mul(&r1, &r1, &c);\n+            secp256k1_fe_mul(&r2, &b, &c);\n+            secp256k1_fe_mul(&r2, &r2, &a);\n+            CHECK((r1.magnitude == 1) && (r2.magnitude == 1));\n+            CHECK((r1.normalized == 0) && (r2.normalized == 0));\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a * b * c = a * (b * c) */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test distributivity of multiplication on field elements */\n+static void fuzz_field_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 126) {     \n+        secp256k1_fe a, b, c, r1, r2, r3;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        fuzz_field_construct(data + 84, 0, &c);\n+        if ((a.magnitude <= 8) && (b.magnitude <= 8) && (c.magnitude <= 8)) {\n+            r1 = a;       \n+            secp256k1_fe_add(&r1, &b);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_mul(&r1, &r1, &c);\n+            secp256k1_fe_mul(&r2, &a, &c);\n+            secp256k1_fe_mul(&r3, &b, &c);\n+            secp256k1_fe_add(&r2, &r3);\n+            CHECK((r1.magnitude == 1) && (r2.magnitude == 2));\n+            CHECK((r1.normalized == 0) && (r2.normalized == 0));\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a * (b + c) = a * b + a * c */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test field multiplication with 0 */ \n+static void fuzz_field_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, zero, r1;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 8) {\n+            secp256k1_fe_clear(&zero);\n+            secp256k1_fe_mul(&r1, &a, &zero);\n+            CHECK(r1.magnitude == 1);\n+            CHECK(r1.normalized == 0);\n+            secp256k1_fe_normalize(&r1);\n+            CHECK(secp256k1_fe_is_zero(&r1));\n+        }\n+    }\n+}\n+\n+/* Test multiplication of field element with an integer */\n+static void fuzz_field_mul_integer(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 10) {\n+            int m = a.magnitude;\n+            r1 = a;\n+            secp256k1_fe_mul_int(&r1, 3);",
      "path": "src/fuzz.c",
      "position": 529,
      "original_position": 529,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's a bit limiting to only test multiplication by 3.",
      "created_at": "2023-08-29T18:19:04Z",
      "updated_at": "2023-08-29T19:03:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1309196177",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309196177"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 529,
      "original_line": 529,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309243667",
      "pull_request_review_id": 1600591161,
      "id": 1309243667,
      "node_id": "PRRC_kwDOAP4Jqs5OCXkT",
      "diff_hunk": "@@ -0,0 +1,1303 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/** Construct a valid field element using 42 bytes data from fuzzer.  \n+*\n+* On input, 'data' must have 42 bytes at least. If 'normalized' != 0, this function will only construct normalized field elements.\n+* If 'normalized' = 0, this function will construct normalized or non-normalized field elements depending on the fuzzer data.\n+* On output, r will be a valid field element\n+**/\n+static void fuzz_field_construct(const uint8_t *data, int normalized, secp256k1_fe *r) {\n+    /* Construct a field element using data[0...39] */\n+    for (int i = 0; i < 5; ++i) {\n+        r->n[i] = 0;\n+        for (int j = 0; j < 8; ++j) {\n+            r->n[i] |= (uint64_t)data[i * 8 + j] << ((7 - j) * 8);\n+        }\n+    }\n+    /* Set a random magnitude depending on the data[40] */\n+    int magnitude = normalized ? (data[40] % 2) : (data[40] % 33);\n+    /* Set a random normalized depending on the data[41] (if magnitude <= 1) */\n+    int n = (data[40] % 33) <= 1 ? (data[41] % 2) : 0;\n+    r->magnitude = magnitude;\n+    r->normalized = normalized ? 1 : n;\n+    int t = r->normalized ? 1 : (2 * magnitude);\n+    if (magnitude == 0){ \n+        for (int i=0; i<5; i++) {\n+            r->n[i] = 0;\n+        }\n+    }  \n+    uint64_t mask1 = 0xFFFFFFFFFFFFFULL * t;\n+    uint64_t mask2 = 0x0FFFFFFFFFFFFULL * t;         \n+    r->n[0] &= mask1;\n+    r->n[1] &= mask1;\n+    r->n[2] &= mask1;\n+    r->n[3] &= mask1;\n+    r->n[4] &= mask2;\n+    if (r->normalized) {\n+        if ((r->n[4] == 0x0FFFFFFFFFFFFULL) && ((r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL)) {\n+            uint64_t mask3 = 0xFFFFEFFFFFC2FULL - 1;\n+            r->n[0] &= mask3;\n+        }\n+    }\n+}\n+\n+/* Test the field element comparison operations. */\n+static void fuzz_field_comparison(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b;    \n+        fuzz_field_construct(data, 1, &a);\n+        b = a;\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+        secp256k1_fe_add_int(&b, 1);\n+        secp256k1_fe_normalize(&b);\n+        if (!secp256k1_fe_is_zero(&b)) {\n+            CHECK(secp256k1_fe_cmp_var(&a, &b) == -1);\n+            CHECK(secp256k1_fe_cmp_var(&b, &a) == 1);\n+        }       \n+    }\n+}\n+\n+/* Test the equality of field elements. */\n+static void fuzz_field_equal(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b, c;\n+        fuzz_field_construct(data, 1, &a);\n+        if (a.magnitude <= 31) {\n+            b = a;\n+            secp256k1_fe_normalize(&b);\n+            c = a.magnitude <= 1 ? a : b;\n+            CHECK(secp256k1_fe_equal(&c, &a));\n+            secp256k1_fe_add_int(&c, 1);\n+            CHECK(secp256k1_fe_equal(&b, &c) == 0);\n+        }    \n+    }  \n+}\n+\n+/* Test conversions between 32-byte value and field element */ \n+static void fuzz_field_b32_and_fe(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b, c;\n+        unsigned char b32[32];     \n+        fuzz_field_construct(data, 1, &a);  \n+        secp256k1_fe_get_b32(b32, &a);\n+        secp256k1_fe_set_b32_limit(&b, b32);\n+        secp256k1_fe_set_b32_mod(&c, b32);\n+        CHECK(secp256k1_fe_equal(&a, &b));\n+        CHECK(secp256k1_fe_equal(&a, &c));       \n+    }\n+}\n+\n+/* Test conversions between field element and secp256k1_fe_storage */ \n+static void fuzz_field_fe_and_storage(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b;\n+        secp256k1_fe_storage fes; \n+        fuzz_field_construct(data, 1, &a);\n+        secp256k1_fe_to_storage(&fes, &a);\n+        secp256k1_fe_from_storage(&b, &fes);\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+    }\n+}\n+\n+/* Test commutativity of addition on two field elements */ \n+static void fuzz_field_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 84) {        \n+        secp256k1_fe a, b, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);         \n+        if (a.magnitude + b.magnitude <= 32) {\n+            r1 = a;\n+            secp256k1_fe_add(&r1, &b);\n+            r2 = b;\n+            secp256k1_fe_add(&r2, &a);    \n+            CHECK(r1.magnitude == a.magnitude + b.magnitude);\n+            CHECK(r2.magnitude == r1.magnitude);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a + b = b + a */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }    \n+    }\n+}\n+\n+/* Test associativity of addition on field elements */\n+static void fuzz_field_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 126) {     \n+        secp256k1_fe a, b, c, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        fuzz_field_construct(data + 84, 0, &c);\n+        if (a.magnitude + b.magnitude + c.magnitude <= 32) {\n+            r1 = a;\n+            secp256k1_fe_add(&r1, &b);\n+            secp256k1_fe_add(&r1, &c);\n+            r2 = c;\n+            secp256k1_fe_add(&r2, &b);\n+            secp256k1_fe_add(&r2, &a);\n+            CHECK(r1.magnitude == a.magnitude + b.magnitude + c.magnitude);\n+            CHECK(r2.magnitude == r1.magnitude);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a + b + c = a + (b + c) */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test identity addition on field elements */ \n+static void fuzz_field_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, zero, r1;\n+        fuzz_field_construct(data, 0, &a);        \n+        secp256k1_fe_clear(&zero);\n+        r1 = a;\n+        secp256k1_fe_add(&r1, &zero);\n+        secp256k1_fe_normalize(&a);\n+        secp256k1_fe_normalize(&r1);\n+        /* Check a + 0 = a */\n+        CHECK(secp256k1_fe_cmp_var(&r1, &a) == 0);\n+    }\n+}\n+\n+/* Test addition of field element and its negative value */ \n+static void fuzz_field_add_negate(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, negate;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 31) {\n+            secp256k1_fe_negate(&negate, &a, 31);\n+            CHECK(negate.magnitude == 32);\n+            secp256k1_fe_normalize(&a);\n+            secp256k1_fe_normalize(&negate);    \n+            secp256k1_fe_add(&a, &negate);\n+            /* Check a + -a = 0 */\n+            CHECK(secp256k1_fe_normalizes_to_zero(&a));\n+        }\n+    }\n+}\n+\n+/* Test addition of field element and its negative value (unchecked the m) */ \n+static void fuzz_field_add_negate_unchecked(const uint8_t *data, size_t size) {\n+    if (size >= 43) {        \n+        secp256k1_fe a, negate;\n+        fuzz_field_construct(data, 0, &a);\n+        int m = data[42] % 32;\n+        if (a.magnitude <= m) {\n+            secp256k1_fe_negate_unchecked(&negate, &a, m);\n+            CHECK(negate.magnitude == m + 1);\n+            secp256k1_fe_normalize(&a);\n+            secp256k1_fe_normalize(&negate);    \n+            secp256k1_fe_add(&a, &negate);\n+            /* Check a + -a = 0 */\n+            CHECK(secp256k1_fe_normalizes_to_zero(&a));\n+        }\n+    }\n+}\n+\n+\n+/* Test addition of field element and an integer */ \n+static void fuzz_field_add_integer(const uint8_t *data, size_t size) {\n+    if (size >= 43) {        \n+        secp256k1_fe a, r1, r2;\n+        int v = data[42];\n+        fuzz_field_construct(data, 0, &a);\n+        secp256k1_fe_set_int(&r1, v);\n+        if ((a.magnitude + r1.magnitude <= 32) && (a.magnitude <= 31)) {\n+            secp256k1_fe_add(&r1, &a);\n+            r2 = a;\n+            secp256k1_fe_add_int(&r2, v);\n+            CHECK(r2.magnitude == a.magnitude + 1);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test the half value of a field element */ \n+static void fuzz_field_half(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude < 32) {\n+            b = a;\n+            secp256k1_fe_half(&a);\n+            int m = b.magnitude;\n+            CHECK(a.magnitude == (m >> 1) + 1);\n+            secp256k1_fe_normalize(&a);\n+            secp256k1_fe_add(&a, &a);\n+            secp256k1_fe_normalize(&b);\n+            secp256k1_fe_normalize(&a);\n+            CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+        }\n+    }\n+}\n+\n+/* Test commutativity of multiplication on two field elements */\n+static void fuzz_field_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 84) {        \n+        secp256k1_fe a, b, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        if ((a.magnitude <= 8) && (b.magnitude <= 8)) {\n+            secp256k1_fe_mul(&r1, &a, &b);\n+            secp256k1_fe_mul(&r2, &b, &a);\n+            CHECK((r1.magnitude == 1) && (r2.magnitude == 1));\n+            CHECK((r1.normalized == 0) && (r2.normalized == 0));\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a * b = b * a */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }        \n+    }\n+}\n+\n+/* Test associativity of multiplication on field elements */\n+static void fuzz_field_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 126) {     \n+        secp256k1_fe a, b, c, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        fuzz_field_construct(data + 84, 0, &c);\n+        if ((a.magnitude <= 8) && (b.magnitude <= 8) && (c.magnitude <= 8)) {\n+            secp256k1_fe_mul(&r1, &a, &b);\n+            secp256k1_fe_mul(&r1, &r1, &c);\n+            secp256k1_fe_mul(&r2, &b, &c);\n+            secp256k1_fe_mul(&r2, &r2, &a);\n+            CHECK((r1.magnitude == 1) && (r2.magnitude == 1));\n+            CHECK((r1.normalized == 0) && (r2.normalized == 0));\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a * b * c = a * (b * c) */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test distributivity of multiplication on field elements */\n+static void fuzz_field_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 126) {     \n+        secp256k1_fe a, b, c, r1, r2, r3;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        fuzz_field_construct(data + 84, 0, &c);\n+        if ((a.magnitude <= 8) && (b.magnitude <= 8) && (c.magnitude <= 8)) {\n+            r1 = a;       \n+            secp256k1_fe_add(&r1, &b);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_mul(&r1, &r1, &c);\n+            secp256k1_fe_mul(&r2, &a, &c);\n+            secp256k1_fe_mul(&r3, &b, &c);\n+            secp256k1_fe_add(&r2, &r3);\n+            CHECK((r1.magnitude == 1) && (r2.magnitude == 2));\n+            CHECK((r1.normalized == 0) && (r2.normalized == 0));\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a * (b + c) = a * b + a * c */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test field multiplication with 0 */ \n+static void fuzz_field_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, zero, r1;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 8) {\n+            secp256k1_fe_clear(&zero);\n+            secp256k1_fe_mul(&r1, &a, &zero);\n+            CHECK(r1.magnitude == 1);\n+            CHECK(r1.normalized == 0);\n+            secp256k1_fe_normalize(&r1);\n+            CHECK(secp256k1_fe_is_zero(&r1));\n+        }\n+    }\n+}\n+\n+/* Test multiplication of field element with an integer */\n+static void fuzz_field_mul_integer(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 10) {\n+            int m = a.magnitude;\n+            r1 = a;\n+            secp256k1_fe_mul_int(&r1, 3);\n+            CHECK(r1.magnitude == m * 3);\n+            CHECK(r1.normalized == 0);\n+            r2 = a;\n+            secp256k1_fe_add(&r2, &a);\n+            secp256k1_fe_add(&r2, &a);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test square of a field element */\n+static void fuzz_field_sqr(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, negate, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 7) {\n+            secp256k1_fe_sqr(&r1, &a);\n+            secp256k1_fe_negate_unchecked(&negate, &a, a.magnitude);\n+            secp256k1_fe_sqr(&r2, &negate);\n+            CHECK(r1.magnitude == 1);\n+            CHECK(r1.normalized == 0);\n+            CHECK(r2.magnitude == 1);\n+            CHECK(r2.normalized == 0);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+            CHECK(secp256k1_fe_is_square_var(&r1)); \n+        } \n+    }\n+}\n+\n+/* Test square root of a field element */\n+static void fuzz_field_sqrt(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, b, negate, r1, r2, rn;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 8) {\n+            secp256k1_fe_sqr(&b, &a);\n+            secp256k1_fe_negate(&negate, &b, 1);\n+            secp256k1_fe_sqrt(&r1, &b);\n+            secp256k1_fe_sqrt(&rn, &negate);\n+            CHECK(secp256k1_fe_equal(&r1, &rn));\n+            CHECK(r1.magnitude == 1);\n+            CHECK(r1.normalized == 0);  \n+            secp256k1_fe_negate(&r2, &r1, 1);\n+            secp256k1_fe_add(&r1, &a); \n+            secp256k1_fe_add(&r2, &a);\n+            secp256k1_fe_normalize(&r1); \n+            secp256k1_fe_normalize(&r2);\n+            CHECK(secp256k1_fe_is_zero(&r1) || secp256k1_fe_is_zero(&r2));\n+        }\n+    }\n+}\n+\n+\n+/* Test field inverse */\n+static void fuzz_field_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 42) {     \n+        secp256k1_fe a, r1, r2, r3, zero;\n+        fuzz_field_construct(data, 0, &a);\n+        secp256k1_fe_inv(&r1, &a);\n+        if (secp256k1_fe_normalizes_to_zero(&a)) {\n+            CHECK(secp256k1_fe_normalizes_to_zero(&r1));\n+        }\n+        else {\n+            CHECK(r1.magnitude == (a.magnitude != 0));\n+            CHECK(r1.normalized == 1);\n+            if (a.magnitude <= 8) {\n+                secp256k1_fe_mul(&r2, &a, &r1);\n+                secp256k1_fe_clear(&zero);\n+                secp256k1_fe_add_int(&zero, 1);\n+                secp256k1_fe_negate(&zero, &zero, 1);\n+                secp256k1_fe_add(&r2, &zero);\n+                CHECK(secp256k1_fe_normalizes_to_zero(&r2));\n+            }\n+        }\n+    }\n+}\n+\n+/* Test conditional move of field elements */\n+static void fuzz_field_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 85) {        \n+        secp256k1_fe a, b, r1;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        int flag = data[84] % 2;\n+        r1 = a;\n+        secp256k1_fe_cmov(&r1, &b, flag);\n+        CHECK((r1.magnitude == a.magnitude) || (r1.magnitude == b.magnitude));\n+        CHECK((r1.magnitude >= a.magnitude) && (r1.magnitude >= b.magnitude));\n+        CHECK(r1.normalized == (a.normalized && b.normalized));\n+        if (flag) {                        \n+            secp256k1_fe_normalize(&r1); \n+            secp256k1_fe_normalize(&b);\n+            CHECK(secp256k1_fe_cmp_var(&r1, &b) == 0);\n+        } else {\n+            secp256k1_fe_normalize(&r1); \n+            secp256k1_fe_normalize(&a);\n+            CHECK(secp256k1_fe_cmp_var(&r1, &a) == 0);\n+        }\n+    }\n+}\n+\n+/* Test conditional move of fe_storage */\n+static void fuzz_field_storage_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 85) {        \n+        secp256k1_fe a, b;\n+        secp256k1_fe_storage as, bs, rs1;\n+        fuzz_field_construct(data, 1, &a);\n+        fuzz_field_construct(data + 42, 1, &b);\n+        secp256k1_fe_to_storage(&as, &a);\n+        secp256k1_fe_to_storage(&bs, &b);\n+        int flag = data[84] % 2;\n+        rs1 = as;\n+        secp256k1_fe_storage_cmov(&rs1, &bs, flag);\n+        if (flag) {            \n+            CHECK(secp256k1_memcmp_var(&rs1, &bs, 32) == 0);\n+        } else {\n+            CHECK(secp256k1_memcmp_var(&rs1, &as, 32) == 0);\n+        }\n+    }\n+}\n+\n+/* Test the operation of seting magnitude m to a field element. */\n+static void fuzz_field_get_bounds(const uint8_t *data, size_t size) {\n+    if (size >= 43) {\n+        secp256k1_fe a, b;    \n+        fuzz_field_construct(data, 0, &a);\n+        int m = data[42] % 33;\n+        secp256k1_fe_get_bounds(&a,m);\n+        if (m == 0) {\n+            CHECK(a.normalized == 1);\n+        } else {\n+            CHECK(a.magnitude == m);\n+        }\n+    }\n+}\n+\n+\n+/*** Group Operation ***/\n+/** Construct a valid field element to build group elements using 42 bytes data from fuzzer.  \n+*\n+* On input, 'data' must have 42 bytes at least. If 'xy' != 0, this function will construct a field element as x coordinate in ge \n+* (x.magnitude <= 4). If 'xy' = 0, this function will construct a field element as y coordinate in ge (y.magnitude <= 3).\n+* On output, r will be a valid field element.\n+**/\n+static void fuzz_ge_fe_construct(const uint8_t *data, int xy, secp256k1_fe *r) {\n+    /* Construct a field element using data[0...39] */\n+    for (int i = 0; i < 5; ++i) {\n+        r->n[i] = 0;\n+        for (int j = 0; j < 8; ++j) {\n+            r->n[i] |= (uint64_t)data[i * 8 + j] << ((7 - j) * 8);\n+        }\n+    }\n+    /* Set a random magnitude depending on the data[40] */\n+    int magnitude = xy ? (data[40] % 5) : (data[40] % 4);\n+    /* Set a random normalized depending on the data[41] (if magnitude <= 1) */\n+    int n = magnitude <= 1 ? (data[41] % 2) : 0;\n+    r->magnitude = magnitude;\n+    r->normalized = n;\n+    int t = r->normalized ? 1 : (2 * magnitude);\n+    if (magnitude == 0){ \n+        for (int i=0; i<5; i++) {\n+            r->n[i] = 0;\n+        }\n+    }  \n+    uint64_t mask1 = 0xFFFFFFFFFFFFFULL * t;\n+    uint64_t mask2 = 0x0FFFFFFFFFFFFULL * t;         \n+    r->n[0] &= mask1;\n+    r->n[1] &= mask1;\n+    r->n[2] &= mask1;\n+    r->n[3] &= mask1;\n+    r->n[4] &= mask2;\n+    if (r->normalized) {\n+        if ((r->n[4] == 0x0FFFFFFFFFFFFULL) && ((r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL)) {\n+            uint64_t mask3 = 0xFFFFEFFFFFC2FULL - 1;\n+            r->n[0] &= mask3;\n+        }\n+    }\n+}\n+\n+/** Construct a valid group element (on the curve) using 43 bytes data from fuzzer.  \n+*\n+* On input, 'data' must have 43 bytes at least. \n+* On output, if function returns 1, a valid group element (on the curve) r is generated; Otherwise, return 0.\n+**/\n+static int fuzz_ge_construct(const uint8_t *data, secp256k1_ge *r) {\n+    secp256k1_fe x, y;\n+    secp256k1_ge ge;\n+    fuzz_ge_fe_construct(data, 1, &x);\n+    if (secp256k1_ge_x_on_curve_var(&x)) {\n+        int odd = data[42] % 2;\n+        secp256k1_ge_set_xo_var(&ge, &x, odd);           ",
      "path": "src/fuzz.c",
      "position": 724,
      "original_position": 724,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be nice if the `y` coordinate could also be given a nontrivial normalization/magnitude here.\r\n\r\nAs a stretch, it could be interesting to (optionally) also construct the group element by reading the Y coordinate from the fuzz input, and then construct the corresponding X coordinate (it needs a cube root, but that's relatively simple for our field). I can give you some pointers if you're interested in that.",
      "created_at": "2023-08-29T19:02:48Z",
      "updated_at": "2023-08-29T19:03:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1309243667",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309243667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 724,
      "original_line": 724,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309244245",
      "pull_request_review_id": 1600591161,
      "id": 1309244245,
      "node_id": "PRRC_kwDOAP4Jqs5OCXtV",
      "diff_hunk": "@@ -0,0 +1,1303 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <stdbool.h>\n+\n+#include \"secp256k1.c\"\n+\n+/*** Scalar Operation ***/\n+/* Test commutativity of scalar addition */ \n+static void fuzz_scalar_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar addition */\n+static void fuzz_scalar_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_add(&r1, &r1, &c);\n+        secp256k1_scalar_add(&r2, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity addition */ \n+static void fuzz_scalar_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_add(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar addition with its complement */ \n+static void fuzz_scalar_add_complements(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_add(&r2, &a, &r1);\n+        CHECK(secp256k1_scalar_is_zero(&r2));\n+    }\n+}\n+\n+/* Test commutativity of scalar multiplication */\n+static void fuzz_scalar_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r2, &b, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test associativity of scalar multiplication */\n+static void fuzz_scalar_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_mul(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &b, &c);\n+        secp256k1_scalar_mul(&r2, &r2, &a);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test distributivity of scalar multiplication */\n+static void fuzz_scalar_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 96) {     \n+        secp256k1_scalar a, b, c, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        secp256k1_scalar_set_b32(&c, data + 64, NULL);       \n+        secp256k1_scalar_add(&r1, &a, &b);\n+        secp256k1_scalar_mul(&r1, &r1, &c);\n+        secp256k1_scalar_mul(&r2, &a, &c);\n+        secp256k1_scalar_mul(&r3, &b, &c);\n+        secp256k1_scalar_add(&r2, &r2, &r3);\n+        CHECK(secp256k1_scalar_eq(&r1, &r2));\n+    }\n+}\n+\n+/* Test identity multiplication */ \n+static void fuzz_scalar_mul_one(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_one);\n+        CHECK(secp256k1_scalar_eq(&r1, &a));\n+    }\n+}\n+\n+/* Test scalar multiplication with zero */ \n+static void fuzz_scalar_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_mul(&r1, &a, &secp256k1_scalar_zero);\n+        CHECK(secp256k1_scalar_is_zero(&r1));\n+    }\n+}\n+\n+/* Test scalar inverse */\n+static void fuzz_scalar_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+} \n+\n+/* Test scalar inverse (without constant-time guarantee) */\n+static void fuzz_scalar_inverse_var(const uint8_t *data, size_t size) {\n+    if (size >= 32) {     \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_inverse_var(&r1, &a);\n+        if (secp256k1_scalar_is_zero(&a)) {\n+            CHECK(secp256k1_scalar_is_zero(&r1));\n+        } else {\n+            secp256k1_scalar_mul(&r2, &a, &r1);\n+            CHECK(secp256k1_scalar_is_one(&r2));\n+        }\n+    }\n+}             \n+\n+/* Test scalar complement */ \n+static void fuzz_scalar_negate(const uint8_t *data, size_t size) {\n+    if (size >= 32) {        \n+        secp256k1_scalar a, r1, r2;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_negate(&r1, &a);\n+        secp256k1_scalar_negate(&r2, &r1);\n+        CHECK(secp256k1_scalar_eq(&a, &r2));\n+    }\n+}\n+\n+/* Test low bits shifted off */\n+static void fuzz_scalar_shift(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        int bit, r1, r2;     \n+        secp256k1_scalar a;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        bit = 1 + (data[31] % 15);\n+        r2 = a.d[0] % (1ULL << bit);\n+        r1 = secp256k1_scalar_shr_int(&a, bit);\n+        CHECK(r1 == r2);\n+    }\n+}\n+\n+/* Test r1+r2*lambda = a */\n+static void fuzz_scalar_split_lambda(const uint8_t *data, size_t size) {\n+    if (size >= 32) {\n+        secp256k1_scalar a, r1, r2, r3;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_split_lambda(&r1, &r2, &a);\n+        secp256k1_scalar_mul(&r3, &secp256k1_const_lambda, &r2);\n+        secp256k1_scalar_add(&r3, &r3, &r1);\n+        CHECK(secp256k1_scalar_eq(&r3, &a));\n+    }    \n+}\n+\n+/* Test conditional move of scalars  */\n+static void fuzz_scalar_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 64) {        \n+        secp256k1_scalar a, b, r1;\n+        secp256k1_scalar_set_b32(&a, data, NULL);\n+        secp256k1_scalar_set_b32(&b, data + 32, NULL);\n+        int flag = size % 2;\n+        r1 = a;\n+        if (flag) {            \n+            secp256k1_scalar_cmov(&r1, &b, 1);\n+            CHECK(secp256k1_scalar_eq(&r1, &b));\n+        } else {\n+            secp256k1_scalar_cmov(&r1, &b, 0);\n+            CHECK(secp256k1_scalar_eq(&r1, &a));\n+        }\n+    }\n+}\n+\n+/*** Field Operation ***/\n+/** Construct a valid field element using 42 bytes data from fuzzer.  \n+*\n+* On input, 'data' must have 42 bytes at least. If 'normalized' != 0, this function will only construct normalized field elements.\n+* If 'normalized' = 0, this function will construct normalized or non-normalized field elements depending on the fuzzer data.\n+* On output, r will be a valid field element\n+**/\n+static void fuzz_field_construct(const uint8_t *data, int normalized, secp256k1_fe *r) {\n+    /* Construct a field element using data[0...39] */\n+    for (int i = 0; i < 5; ++i) {\n+        r->n[i] = 0;\n+        for (int j = 0; j < 8; ++j) {\n+            r->n[i] |= (uint64_t)data[i * 8 + j] << ((7 - j) * 8);\n+        }\n+    }\n+    /* Set a random magnitude depending on the data[40] */\n+    int magnitude = normalized ? (data[40] % 2) : (data[40] % 33);\n+    /* Set a random normalized depending on the data[41] (if magnitude <= 1) */\n+    int n = (data[40] % 33) <= 1 ? (data[41] % 2) : 0;\n+    r->magnitude = magnitude;\n+    r->normalized = normalized ? 1 : n;\n+    int t = r->normalized ? 1 : (2 * magnitude);\n+    if (magnitude == 0){ \n+        for (int i=0; i<5; i++) {\n+            r->n[i] = 0;\n+        }\n+    }  \n+    uint64_t mask1 = 0xFFFFFFFFFFFFFULL * t;\n+    uint64_t mask2 = 0x0FFFFFFFFFFFFULL * t;         \n+    r->n[0] &= mask1;\n+    r->n[1] &= mask1;\n+    r->n[2] &= mask1;\n+    r->n[3] &= mask1;\n+    r->n[4] &= mask2;\n+    if (r->normalized) {\n+        if ((r->n[4] == 0x0FFFFFFFFFFFFULL) && ((r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL)) {\n+            uint64_t mask3 = 0xFFFFEFFFFFC2FULL - 1;\n+            r->n[0] &= mask3;\n+        }\n+    }\n+}\n+\n+/* Test the field element comparison operations. */\n+static void fuzz_field_comparison(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b;    \n+        fuzz_field_construct(data, 1, &a);\n+        b = a;\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+        secp256k1_fe_add_int(&b, 1);\n+        secp256k1_fe_normalize(&b);\n+        if (!secp256k1_fe_is_zero(&b)) {\n+            CHECK(secp256k1_fe_cmp_var(&a, &b) == -1);\n+            CHECK(secp256k1_fe_cmp_var(&b, &a) == 1);\n+        }       \n+    }\n+}\n+\n+/* Test the equality of field elements. */\n+static void fuzz_field_equal(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b, c;\n+        fuzz_field_construct(data, 1, &a);\n+        if (a.magnitude <= 31) {\n+            b = a;\n+            secp256k1_fe_normalize(&b);\n+            c = a.magnitude <= 1 ? a : b;\n+            CHECK(secp256k1_fe_equal(&c, &a));\n+            secp256k1_fe_add_int(&c, 1);\n+            CHECK(secp256k1_fe_equal(&b, &c) == 0);\n+        }    \n+    }  \n+}\n+\n+/* Test conversions between 32-byte value and field element */ \n+static void fuzz_field_b32_and_fe(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b, c;\n+        unsigned char b32[32];     \n+        fuzz_field_construct(data, 1, &a);  \n+        secp256k1_fe_get_b32(b32, &a);\n+        secp256k1_fe_set_b32_limit(&b, b32);\n+        secp256k1_fe_set_b32_mod(&c, b32);\n+        CHECK(secp256k1_fe_equal(&a, &b));\n+        CHECK(secp256k1_fe_equal(&a, &c));       \n+    }\n+}\n+\n+/* Test conversions between field element and secp256k1_fe_storage */ \n+static void fuzz_field_fe_and_storage(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b;\n+        secp256k1_fe_storage fes; \n+        fuzz_field_construct(data, 1, &a);\n+        secp256k1_fe_to_storage(&fes, &a);\n+        secp256k1_fe_from_storage(&b, &fes);\n+        CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+    }\n+}\n+\n+/* Test commutativity of addition on two field elements */ \n+static void fuzz_field_add_commutativty(const uint8_t *data, size_t size) {\n+    if (size >= 84) {        \n+        secp256k1_fe a, b, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);         \n+        if (a.magnitude + b.magnitude <= 32) {\n+            r1 = a;\n+            secp256k1_fe_add(&r1, &b);\n+            r2 = b;\n+            secp256k1_fe_add(&r2, &a);    \n+            CHECK(r1.magnitude == a.magnitude + b.magnitude);\n+            CHECK(r2.magnitude == r1.magnitude);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a + b = b + a */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }    \n+    }\n+}\n+\n+/* Test associativity of addition on field elements */\n+static void fuzz_field_add_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 126) {     \n+        secp256k1_fe a, b, c, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        fuzz_field_construct(data + 84, 0, &c);\n+        if (a.magnitude + b.magnitude + c.magnitude <= 32) {\n+            r1 = a;\n+            secp256k1_fe_add(&r1, &b);\n+            secp256k1_fe_add(&r1, &c);\n+            r2 = c;\n+            secp256k1_fe_add(&r2, &b);\n+            secp256k1_fe_add(&r2, &a);\n+            CHECK(r1.magnitude == a.magnitude + b.magnitude + c.magnitude);\n+            CHECK(r2.magnitude == r1.magnitude);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a + b + c = a + (b + c) */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test identity addition on field elements */ \n+static void fuzz_field_add_zero(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, zero, r1;\n+        fuzz_field_construct(data, 0, &a);        \n+        secp256k1_fe_clear(&zero);\n+        r1 = a;\n+        secp256k1_fe_add(&r1, &zero);\n+        secp256k1_fe_normalize(&a);\n+        secp256k1_fe_normalize(&r1);\n+        /* Check a + 0 = a */\n+        CHECK(secp256k1_fe_cmp_var(&r1, &a) == 0);\n+    }\n+}\n+\n+/* Test addition of field element and its negative value */ \n+static void fuzz_field_add_negate(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, negate;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 31) {\n+            secp256k1_fe_negate(&negate, &a, 31);\n+            CHECK(negate.magnitude == 32);\n+            secp256k1_fe_normalize(&a);\n+            secp256k1_fe_normalize(&negate);    \n+            secp256k1_fe_add(&a, &negate);\n+            /* Check a + -a = 0 */\n+            CHECK(secp256k1_fe_normalizes_to_zero(&a));\n+        }\n+    }\n+}\n+\n+/* Test addition of field element and its negative value (unchecked the m) */ \n+static void fuzz_field_add_negate_unchecked(const uint8_t *data, size_t size) {\n+    if (size >= 43) {        \n+        secp256k1_fe a, negate;\n+        fuzz_field_construct(data, 0, &a);\n+        int m = data[42] % 32;\n+        if (a.magnitude <= m) {\n+            secp256k1_fe_negate_unchecked(&negate, &a, m);\n+            CHECK(negate.magnitude == m + 1);\n+            secp256k1_fe_normalize(&a);\n+            secp256k1_fe_normalize(&negate);    \n+            secp256k1_fe_add(&a, &negate);\n+            /* Check a + -a = 0 */\n+            CHECK(secp256k1_fe_normalizes_to_zero(&a));\n+        }\n+    }\n+}\n+\n+\n+/* Test addition of field element and an integer */ \n+static void fuzz_field_add_integer(const uint8_t *data, size_t size) {\n+    if (size >= 43) {        \n+        secp256k1_fe a, r1, r2;\n+        int v = data[42];\n+        fuzz_field_construct(data, 0, &a);\n+        secp256k1_fe_set_int(&r1, v);\n+        if ((a.magnitude + r1.magnitude <= 32) && (a.magnitude <= 31)) {\n+            secp256k1_fe_add(&r1, &a);\n+            r2 = a;\n+            secp256k1_fe_add_int(&r2, v);\n+            CHECK(r2.magnitude == a.magnitude + 1);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test the half value of a field element */ \n+static void fuzz_field_half(const uint8_t *data, size_t size) {\n+    if (size >= 42) {\n+        secp256k1_fe a, b;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude < 32) {\n+            b = a;\n+            secp256k1_fe_half(&a);\n+            int m = b.magnitude;\n+            CHECK(a.magnitude == (m >> 1) + 1);\n+            secp256k1_fe_normalize(&a);\n+            secp256k1_fe_add(&a, &a);\n+            secp256k1_fe_normalize(&b);\n+            secp256k1_fe_normalize(&a);\n+            CHECK(secp256k1_fe_cmp_var(&a, &b) == 0);\n+        }\n+    }\n+}\n+\n+/* Test commutativity of multiplication on two field elements */\n+static void fuzz_field_mul_commutativity(const uint8_t *data, size_t size) {\n+    if (size >= 84) {        \n+        secp256k1_fe a, b, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        if ((a.magnitude <= 8) && (b.magnitude <= 8)) {\n+            secp256k1_fe_mul(&r1, &a, &b);\n+            secp256k1_fe_mul(&r2, &b, &a);\n+            CHECK((r1.magnitude == 1) && (r2.magnitude == 1));\n+            CHECK((r1.normalized == 0) && (r2.normalized == 0));\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a * b = b * a */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }        \n+    }\n+}\n+\n+/* Test associativity of multiplication on field elements */\n+static void fuzz_field_mul_associativity(const uint8_t *data, size_t size) {\n+    if (size >= 126) {     \n+        secp256k1_fe a, b, c, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        fuzz_field_construct(data + 84, 0, &c);\n+        if ((a.magnitude <= 8) && (b.magnitude <= 8) && (c.magnitude <= 8)) {\n+            secp256k1_fe_mul(&r1, &a, &b);\n+            secp256k1_fe_mul(&r1, &r1, &c);\n+            secp256k1_fe_mul(&r2, &b, &c);\n+            secp256k1_fe_mul(&r2, &r2, &a);\n+            CHECK((r1.magnitude == 1) && (r2.magnitude == 1));\n+            CHECK((r1.normalized == 0) && (r2.normalized == 0));\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a * b * c = a * (b * c) */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test distributivity of multiplication on field elements */\n+static void fuzz_field_mul_distributivity(const uint8_t *data, size_t size) {\n+    if (size >= 126) {     \n+        secp256k1_fe a, b, c, r1, r2, r3;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        fuzz_field_construct(data + 84, 0, &c);\n+        if ((a.magnitude <= 8) && (b.magnitude <= 8) && (c.magnitude <= 8)) {\n+            r1 = a;       \n+            secp256k1_fe_add(&r1, &b);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_mul(&r1, &r1, &c);\n+            secp256k1_fe_mul(&r2, &a, &c);\n+            secp256k1_fe_mul(&r3, &b, &c);\n+            secp256k1_fe_add(&r2, &r3);\n+            CHECK((r1.magnitude == 1) && (r2.magnitude == 2));\n+            CHECK((r1.normalized == 0) && (r2.normalized == 0));\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            /* Check a * (b + c) = a * b + a * c */\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test field multiplication with 0 */ \n+static void fuzz_field_mul_zero(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, zero, r1;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 8) {\n+            secp256k1_fe_clear(&zero);\n+            secp256k1_fe_mul(&r1, &a, &zero);\n+            CHECK(r1.magnitude == 1);\n+            CHECK(r1.normalized == 0);\n+            secp256k1_fe_normalize(&r1);\n+            CHECK(secp256k1_fe_is_zero(&r1));\n+        }\n+    }\n+}\n+\n+/* Test multiplication of field element with an integer */\n+static void fuzz_field_mul_integer(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 10) {\n+            int m = a.magnitude;\n+            r1 = a;\n+            secp256k1_fe_mul_int(&r1, 3);\n+            CHECK(r1.magnitude == m * 3);\n+            CHECK(r1.normalized == 0);\n+            r2 = a;\n+            secp256k1_fe_add(&r2, &a);\n+            secp256k1_fe_add(&r2, &a);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+        }\n+    }\n+}\n+\n+/* Test square of a field element */\n+static void fuzz_field_sqr(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, negate, r1, r2;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 7) {\n+            secp256k1_fe_sqr(&r1, &a);\n+            secp256k1_fe_negate_unchecked(&negate, &a, a.magnitude);\n+            secp256k1_fe_sqr(&r2, &negate);\n+            CHECK(r1.magnitude == 1);\n+            CHECK(r1.normalized == 0);\n+            CHECK(r2.magnitude == 1);\n+            CHECK(r2.normalized == 0);\n+            secp256k1_fe_normalize(&r1);\n+            secp256k1_fe_normalize(&r2);\n+            CHECK(secp256k1_fe_cmp_var(&r1, &r2) == 0);\n+            CHECK(secp256k1_fe_is_square_var(&r1)); \n+        } \n+    }\n+}\n+\n+/* Test square root of a field element */\n+static void fuzz_field_sqrt(const uint8_t *data, size_t size) {\n+    if (size >= 42) {        \n+        secp256k1_fe a, b, negate, r1, r2, rn;\n+        fuzz_field_construct(data, 0, &a);\n+        if (a.magnitude <= 8) {\n+            secp256k1_fe_sqr(&b, &a);\n+            secp256k1_fe_negate(&negate, &b, 1);\n+            secp256k1_fe_sqrt(&r1, &b);\n+            secp256k1_fe_sqrt(&rn, &negate);\n+            CHECK(secp256k1_fe_equal(&r1, &rn));\n+            CHECK(r1.magnitude == 1);\n+            CHECK(r1.normalized == 0);  \n+            secp256k1_fe_negate(&r2, &r1, 1);\n+            secp256k1_fe_add(&r1, &a); \n+            secp256k1_fe_add(&r2, &a);\n+            secp256k1_fe_normalize(&r1); \n+            secp256k1_fe_normalize(&r2);\n+            CHECK(secp256k1_fe_is_zero(&r1) || secp256k1_fe_is_zero(&r2));\n+        }\n+    }\n+}\n+\n+\n+/* Test field inverse */\n+static void fuzz_field_inverse(const uint8_t *data, size_t size) {\n+    if (size >= 42) {     \n+        secp256k1_fe a, r1, r2, r3, zero;\n+        fuzz_field_construct(data, 0, &a);\n+        secp256k1_fe_inv(&r1, &a);\n+        if (secp256k1_fe_normalizes_to_zero(&a)) {\n+            CHECK(secp256k1_fe_normalizes_to_zero(&r1));\n+        }\n+        else {\n+            CHECK(r1.magnitude == (a.magnitude != 0));\n+            CHECK(r1.normalized == 1);\n+            if (a.magnitude <= 8) {\n+                secp256k1_fe_mul(&r2, &a, &r1);\n+                secp256k1_fe_clear(&zero);\n+                secp256k1_fe_add_int(&zero, 1);\n+                secp256k1_fe_negate(&zero, &zero, 1);\n+                secp256k1_fe_add(&r2, &zero);\n+                CHECK(secp256k1_fe_normalizes_to_zero(&r2));\n+            }\n+        }\n+    }\n+}\n+\n+/* Test conditional move of field elements */\n+static void fuzz_field_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 85) {        \n+        secp256k1_fe a, b, r1;\n+        fuzz_field_construct(data, 0, &a);\n+        fuzz_field_construct(data + 42, 0, &b);\n+        int flag = data[84] % 2;\n+        r1 = a;\n+        secp256k1_fe_cmov(&r1, &b, flag);\n+        CHECK((r1.magnitude == a.magnitude) || (r1.magnitude == b.magnitude));\n+        CHECK((r1.magnitude >= a.magnitude) && (r1.magnitude >= b.magnitude));\n+        CHECK(r1.normalized == (a.normalized && b.normalized));\n+        if (flag) {                        \n+            secp256k1_fe_normalize(&r1); \n+            secp256k1_fe_normalize(&b);\n+            CHECK(secp256k1_fe_cmp_var(&r1, &b) == 0);\n+        } else {\n+            secp256k1_fe_normalize(&r1); \n+            secp256k1_fe_normalize(&a);\n+            CHECK(secp256k1_fe_cmp_var(&r1, &a) == 0);\n+        }\n+    }\n+}\n+\n+/* Test conditional move of fe_storage */\n+static void fuzz_field_storage_cmov(const uint8_t *data, size_t size) {\n+    if (size >= 85) {        \n+        secp256k1_fe a, b;\n+        secp256k1_fe_storage as, bs, rs1;\n+        fuzz_field_construct(data, 1, &a);\n+        fuzz_field_construct(data + 42, 1, &b);\n+        secp256k1_fe_to_storage(&as, &a);\n+        secp256k1_fe_to_storage(&bs, &b);\n+        int flag = data[84] % 2;\n+        rs1 = as;\n+        secp256k1_fe_storage_cmov(&rs1, &bs, flag);\n+        if (flag) {            \n+            CHECK(secp256k1_memcmp_var(&rs1, &bs, 32) == 0);\n+        } else {\n+            CHECK(secp256k1_memcmp_var(&rs1, &as, 32) == 0);\n+        }\n+    }\n+}\n+\n+/* Test the operation of seting magnitude m to a field element. */\n+static void fuzz_field_get_bounds(const uint8_t *data, size_t size) {\n+    if (size >= 43) {\n+        secp256k1_fe a, b;    \n+        fuzz_field_construct(data, 0, &a);\n+        int m = data[42] % 33;\n+        secp256k1_fe_get_bounds(&a,m);\n+        if (m == 0) {\n+            CHECK(a.normalized == 1);\n+        } else {\n+            CHECK(a.magnitude == m);\n+        }\n+    }\n+}\n+\n+\n+/*** Group Operation ***/\n+/** Construct a valid field element to build group elements using 42 bytes data from fuzzer.  \n+*\n+* On input, 'data' must have 42 bytes at least. If 'xy' != 0, this function will construct a field element as x coordinate in ge \n+* (x.magnitude <= 4). If 'xy' = 0, this function will construct a field element as y coordinate in ge (y.magnitude <= 3).\n+* On output, r will be a valid field element.\n+**/\n+static void fuzz_ge_fe_construct(const uint8_t *data, int xy, secp256k1_fe *r) {\n+    /* Construct a field element using data[0...39] */\n+    for (int i = 0; i < 5; ++i) {\n+        r->n[i] = 0;\n+        for (int j = 0; j < 8; ++j) {\n+            r->n[i] |= (uint64_t)data[i * 8 + j] << ((7 - j) * 8);\n+        }\n+    }\n+    /* Set a random magnitude depending on the data[40] */\n+    int magnitude = xy ? (data[40] % 5) : (data[40] % 4);\n+    /* Set a random normalized depending on the data[41] (if magnitude <= 1) */\n+    int n = magnitude <= 1 ? (data[41] % 2) : 0;\n+    r->magnitude = magnitude;\n+    r->normalized = n;\n+    int t = r->normalized ? 1 : (2 * magnitude);\n+    if (magnitude == 0){ \n+        for (int i=0; i<5; i++) {\n+            r->n[i] = 0;\n+        }\n+    }  \n+    uint64_t mask1 = 0xFFFFFFFFFFFFFULL * t;\n+    uint64_t mask2 = 0x0FFFFFFFFFFFFULL * t;         \n+    r->n[0] &= mask1;\n+    r->n[1] &= mask1;\n+    r->n[2] &= mask1;\n+    r->n[3] &= mask1;\n+    r->n[4] &= mask2;\n+    if (r->normalized) {\n+        if ((r->n[4] == 0x0FFFFFFFFFFFFULL) && ((r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL)) {\n+            uint64_t mask3 = 0xFFFFEFFFFFC2FULL - 1;\n+            r->n[0] &= mask3;\n+        }\n+    }\n+}\n+\n+/** Construct a valid group element (on the curve) using 43 bytes data from fuzzer.  \n+*\n+* On input, 'data' must have 43 bytes at least. \n+* On output, if function returns 1, a valid group element (on the curve) r is generated; Otherwise, return 0.\n+**/\n+static int fuzz_ge_construct(const uint8_t *data, secp256k1_ge *r) {\n+    secp256k1_fe x, y;\n+    secp256k1_ge ge;\n+    fuzz_ge_fe_construct(data, 1, &x);\n+    if (secp256k1_ge_x_on_curve_var(&x)) {\n+        int odd = data[42] % 2;\n+        secp256k1_ge_set_xo_var(&ge, &x, odd);           \n+        CHECK(secp256k1_ge_is_valid_var(&ge));\n+        *r = ge;\n+        return 1;\n+    } else {\n+        return 0;\n+    }\n+}\n+\n+/* Check two group elements (affine) for equality */\n+static void fuzz_ge_equal(const secp256k1_ge *a, const secp256k1_ge *b) {\n+    CHECK(a->infinity == b->infinity);\n+    if (a->infinity) {\n+        return;\n+    }\n+    CHECK(secp256k1_fe_equal(&a->x, &b->x));\n+    CHECK(secp256k1_fe_equal(&a->y, &b->y));\n+}\n+\n+/* Test transformation of group element between the affine coordinates and jacobian coordinates */\n+static void fuzz_ge_gef(const uint8_t *data, size_t size) {",
      "path": "src/fuzz.c",
      "position": 744,
      "original_position": 744,
      "commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "original_commit_id": "ebfb2cf6a4eb1e4e1be72584117d78021f3e10f3",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What does `gef` refer to?",
      "created_at": "2023-08-29T19:03:29Z",
      "updated_at": "2023-08-29T19:03:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1407#discussion_r1309244245",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1309244245"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1407"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 744,
      "original_line": 744,
      "side": "RIGHT"
    }
  ]
}