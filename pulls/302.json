{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302",
    "id": 44065341,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NDQwNjUzNDE=",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/302.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/302.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/302",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/302/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/03d4611c81a1bc83e857aded077f31ef1561e3ca",
    "number": 302,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Add sage verification script for the group laws",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This adds a SAGE script for verifying the implemented group laws.\n\nThe output should be:\n\n```\nFormula secp256k1_gej_add_var:\n  add_infinite_ab:\n    branch 0: OK\n  double:\n    branch 2: OK\n  add:\n    branch 4: OK\n  add_infinite_b:\n    branch 1: OK\n  add_infinite_a:\n    branch 0: OK\n  add_opposite:\n    branch 3: OK\n\nFormula secp256k1_gej_add_ge_var:\n  add_infinite_ab:\n    branch 0: OK (assuming Bz - 1 = 0 [b.z=1])\n  double:\n    branch 2: OK (assuming Bz - 1 = 0 [b.z=1])\n  add:\n    branch 4: OK (assuming Bz - 1 = 0 [b.z=1])\n  add_infinite_b:\n    branch 1: OK (assuming Bz - 1 = 0 [b.z=1])\n  add_infinite_a:\n    branch 0: OK (assuming Bz - 1 = 0 [b.z=1])\n  add_opposite:\n    branch 3: OK (assuming Bz - 1 = 0 [b.z=1])\n\nFormula secp256k1_gej_add_zinv_var:\n  add_infinite_ab:\n    branch 0: OK\n  double:\n    branch 2: OK\n  add:\n    branch 4: OK\n  add_infinite_b:\n    branch 0: OK\n  add_infinite_a:\n    branch 1: OK\n  add_opposite:\n    branch 3: OK\n\nFormula secp256k1_gej_add_ge:\n  add_infinite_ab:\n  double:\n    branch 0: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n  add:\n    branch 0: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n    branch 2: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n    branch 3: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n  add_infinite_b:\n  add_infinite_a:\n    branch 4: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n    branch 6: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n    branch 7: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n    branch 13: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n  add_opposite:\n    branch 9: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n\nFormula secp256k1_gej_add_ge_old [should fail]:\n  add_infinite_ab:\n  double:\n    branch 0: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n  add:\n    branch 0: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n    branch 2: FAIL, ['on_curve', 'finite_point', 'colinear_2', 'colinear_1', 'colinear_3'] fails (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n  add_infinite_b:\n  add_infinite_a:\n    branch 1: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n  add_opposite:\n    branch 2: OK (assuming Bz - 1 = 0 [b.z=1], Bi = 0 [b_finite])\n```\n",
    "labels": [],
    "created_at": "2015-09-03T03:04:56Z",
    "updated_at": "2016-04-27T10:14:01Z",
    "closed_at": "2015-12-01T20:02:32Z",
    "mergeable_state": "unknown",
    "merged_at": "2015-12-01T20:02:32Z",
    "merge_commit_sha": "1a27b552eb425cef8cc857872a7e89cbbe7ca2cf",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "sipa:sage",
      "ref": "sage",
      "sha": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 16648672,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODY3Mg==",
        "name": "secp256k1",
        "full_name": "sipa/secp256k1",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/secp256k1",
        "archive_url": "https://api.github.com/repos/sipa/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/sipa/secp256k1/events",
        "forks_url": "https://api.github.com/repos/sipa/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/sipa/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/sipa/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/sipa/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/sipa/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/sipa/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/sipa/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/sipa/secp256k1/hooks",
        "svn_url": "https://github.com/sipa/secp256k1",
        "language": "C",
        "forks_count": 20,
        "stargazers_count": 43,
        "watchers_count": 43,
        "size": 11487,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-05-31T17:42:23Z",
        "created_at": "2014-02-08T17:33:30Z",
        "updated_at": "2023-05-11T11:08:51Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "a9659372900f0a17f94bc9f41c5587aa9bcc3be1",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 948,
        "stargazers_count": 1768,
        "watchers_count": 1768,
        "size": 10062,
        "default_branch": "master",
        "open_issues_count": 142,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-12T16:38:48Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2023-06-12T17:38:13Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 892,
    "deletions": 0,
    "changed_files": 3,
    "commits": 1,
    "review_comments": 42,
    "comments": 9
  },
  "events": [
    {
      "event": "head_ref_force_pushed",
      "id": 400286050,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDAwMjg2MDUw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/400286050",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-09-03T16:45:52Z"
    },
    {
      "event": "commented",
      "id": 137508343,
      "node_id": "MDEyOklzc3VlQ29tbWVudDEzNzUwODM0Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/137508343",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-09-03T16:49:19Z",
      "updated_at": "2015-09-03T16:49:19Z",
      "author_association": "MEMBER",
      "body": "Updated with more comments.\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#issuecomment-137508343",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/302"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 401168538,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDAxMTY4NTM4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/401168538",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-09-04T14:03:17Z"
    },
    {
      "event": "commented",
      "id": 137745724,
      "node_id": "MDEyOklzc3VlQ29tbWVudDEzNzc0NTcyNA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/137745724",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-09-04T14:03:49Z",
      "updated_at": "2015-09-04T14:03:49Z",
      "author_association": "MEMBER",
      "body": "Added exhaustive verification in Z43.\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#issuecomment-137745724",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/302"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 401243730,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDAxMjQzNzMw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/401243730",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-09-04T15:16:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 412407864,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDEyNDA3ODY0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/412407864",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-09-17T18:22:53Z"
    },
    {
      "event": "commented",
      "id": 141175306,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE0MTE3NTMwNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/141175306",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-09-17T18:23:45Z",
      "updated_at": "2015-09-17T18:23:45Z",
      "author_association": "MEMBER",
      "body": "Significantly rewrote the code, it now prints assumptions more explicitly, and can deal with cases involving infinity. On the downside, the exhaustive check is too slow now, so it's disabled.\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#issuecomment-141175306",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/302"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 416226875,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE2MjI2ODc1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/416226875",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-09-22T19:08:46Z"
    },
    {
      "event": "commented",
      "id": 142388612,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE0MjM4ODYxMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/142388612",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-09-22T19:10:02Z",
      "updated_at": "2015-09-22T19:10:02Z",
      "author_association": "MEMBER",
      "body": "Update: make prove_zero call prove_nonzero on the denominators, to prevent 0/0. This shouldn't ever occur in reality, as the formulas should never result in 0/0, and the implementations don't return fractions... but better be safe.\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#issuecomment-142388612",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/302"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 439259713,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDM5MjU5NzEz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/439259713",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-10-19T15:23:18Z"
    },
    {
      "event": "commented",
      "id": 149248482,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE0OTI0ODQ4Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/149248482",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-10-19T15:23:56Z",
      "updated_at": "2015-10-19T15:23:56Z",
      "author_association": "MEMBER",
      "body": "Refactored the code into multiple files, in their own directory, and updated the comments.\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#issuecomment-149248482",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/302"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0MTQ6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0MTY6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0MTg6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0MjM6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0Mjg6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0MzI6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0Mzg6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0Mzk6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NDM6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NDQ6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NDk6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NTA6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NTM6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NTU6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "head_ref_force_pushed",
      "id": 476861974,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDc2ODYxOTc0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/476861974",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-28T17:42:17Z"
    },
    {
      "event": "commented",
      "id": 160323585,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2MDMyMzU4NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/160323585",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-28T17:42:40Z",
      "updated_at": "2015-11-28T17:42:40Z",
      "author_association": "MEMBER",
      "body": "Pushed new version to address @apoelstra's nits.\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#issuecomment-160323585",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/302"
    },
    {
      "event": "mentioned",
      "id": 476862028,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDc2ODYyMDI4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/476862028",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-28T17:42:40Z"
    },
    {
      "event": "subscribed",
      "id": 476862029,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ3Njg2MjAyOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/476862029",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-28T17:42:40Z"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NTg6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NTk6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NjM6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NjU6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "head_ref_force_pushed",
      "id": 476887656,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDc2ODg3NjU2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/476887656",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-28T20:03:34Z"
    },
    {
      "event": "mentioned",
      "id": 476887950,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDc2ODg3OTUw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/476887950",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-28T20:05:35Z"
    },
    {
      "event": "subscribed",
      "id": 476887951,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQ3Njg4Nzk1MQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/476887951",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-28T20:05:35Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 476888860,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDc2ODg4ODYw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/476888860",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-28T20:12:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 476890897,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDc2ODkwODk3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/476890897",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-28T20:24:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 476891312,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDc2ODkxMzEy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/476891312",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-28T20:27:20Z"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0Njc6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NzA6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjE0NzI6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "commented",
      "id": 160342947,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2MDM0Mjk0Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/160342947",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-28T22:35:07Z",
      "updated_at": "2015-11-28T22:35:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "Except for the finite/infinite typos in description strings (I think I noted them all), ACK.\n\nThanks for clarifying the comments!\n",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#issuecomment-160342947",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/302"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MDNkNDYxMWM4MWExYmM4M2U4NTdhZGVkMDc3ZjMxZWYxNTYxZTNjYQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "tree": {
        "sha": "a06681ec62ac81ab42ca509bbe48d6962401d0d0",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/a06681ec62ac81ab42ca509bbe48d6962401d0d0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a9659372900f0a17f94bc9f41c5587aa9bcc3be1",
          "sha": "a9659372900f0a17f94bc9f41c5587aa9bcc3be1",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a9659372900f0a17f94bc9f41c5587aa9bcc3be1"
        }
      ],
      "message": "Add sage verification script for the group laws",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-29T15:03:07Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-08-31T03:08:47Z"
      },
      "sha": "03d4611c81a1bc83e857aded077f31ef1561e3ca"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 477085442,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDc3MDg1NDQy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/477085442",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-29T15:03:15Z"
    },
    {
      "event": "commented",
      "id": 160421313,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2MDQyMTMxMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/160421313",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-29T15:03:32Z",
      "updated_at": "2015-11-29T15:03:32Z",
      "author_association": "MEMBER",
      "body": "Fixed the incorrect finite/infinite descriptions.\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#issuecomment-160421313",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/302"
    },
    {
      "event": "commented",
      "id": 160435580,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2MDQzNTU4MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/160435580",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-11-29T17:42:51Z",
      "updated_at": "2015-11-29T17:42:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK\n",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#issuecomment-160435580",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/302"
    },
    {
      "event": "merged",
      "id": 479387664,
      "node_id": "MDExOk1lcmdlZEV2ZW50NDc5Mzg3NjY0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/479387664",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "created_at": "2015-12-01T20:02:32Z"
    },
    {
      "event": "closed",
      "id": 479387665,
      "node_id": "MDExOkNsb3NlZEV2ZW50NDc5Mzg3NjY1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/479387665",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-01T20:02:32Z"
    },
    {
      "event": "referenced",
      "id": 479387682,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ3OTM4NzY4Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/479387682",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "3026daa095797ffb5371ecf19bbd1de3d3b3eeb7",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/3026daa095797ffb5371ecf19bbd1de3d3b3eeb7",
      "created_at": "2015-12-01T20:02:32Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46063498",
      "pull_request_review_id": null,
      "id": 46063498,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYzNDk4",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 165,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "These double-parens are unnecessary and a bit confusing because you don't always use them (eg the `reduce` call a few lines down does not), and also because the eye tends to match `((` with `))` which is wrong. Recommend removing them everywhere (several calls to `map` are like this; I don't think anything else is).\n",
      "created_at": "2015-11-27T17:37:52Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46063498",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46063498"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46063852",
      "pull_request_review_id": null,
      "id": 46063852,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYzODUy",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 167,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think `len(con.nonzero)` shouldn't be checked here. If one is implied to be zero that's a contradiction by itself.\n\n(I also checked that the result of tests were unchanged by removing the check -- had they not been I'd have been very surprised!)\n",
      "created_at": "2015-11-27T17:44:52Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46063852",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46063852"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 180,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46064624",
      "pull_request_review_id": null,
      "id": 46064624,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0NjI0",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 172,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should this check be here? If so, the previous check implies it and can be removed.\n",
      "created_at": "2015-11-27T18:06:38Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46064624",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46064624"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 192,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46064854",
      "pull_request_review_id": null,
      "id": 46064854,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODU0",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 172,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This check actually weirds me out because it implies that `conflicts(zero, nonzero1)` and `conflicts(zero, nonzero2)` might be OK while `conflicts(zero, nonzero1 union nonzero2)` fails, which is counterintuitive.\n",
      "created_at": "2015-11-27T18:11:01Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46064854",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46064854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 192,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46065336",
      "pull_request_review_id": null,
      "id": 46065336,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MzM2",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 68,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "By `mynumerator(R, x)` do you mean `mynumerator(self.R, x)`? (This is more of a \"how does Python interpret this?\" question than a code nit.)\n",
      "created_at": "2015-11-27T18:23:03Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46065336",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46065336"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46065527",
      "pull_request_review_id": null,
      "id": 46065527,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1NTI3",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 68,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, I think this code is invalid but is never called.\n",
      "created_at": "2015-11-27T18:27:14Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46065527",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46065527"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46067567",
      "pull_request_review_id": null,
      "id": 46067567,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3NTY3",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 132,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This branch is also never called, but I think if `R` is a ring then `x` will equal `numerator(x)` in that case, so I think the branch is unnecessary.\n",
      "created_at": "2015-11-27T19:28:19Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46067567",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46067567"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46067676",
      "pull_request_review_id": null,
      "id": 46067676,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3Njc2",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 132,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh, and without this branch you can `s/mynumerator/numerator/` the whole code :)\n",
      "created_at": "2015-11-27T19:32:28Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46067676",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46067676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46070692",
      "pull_request_review_id": null,
      "id": 46070692,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcwNjky",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 181,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd prefer this check not be here. If a literal zero is in `assume.nonzero` your constraints are inherently inconsistent and should get flagged. If you remove the check then `factor` will throw an exception on the next line, which is I think is fine.\n\nI also think the check is confusingly written, since `R` appears but as I pointed out in the definition of `mynumerator` it is not actually used.\n",
      "created_at": "2015-11-27T21:30:55Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46070692",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46070692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46070733",
      "pull_request_review_id": null,
      "id": 46070733,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcwNzMz",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 180,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We only ever use `nz` as `mynumerator(nz)`. Prefer iterating over `assume.nonzero.map(numerator)` (or whatever the correct Python for that is)\n",
      "created_at": "2015-11-27T21:32:18Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46070733",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46070733"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46070895",
      "pull_request_review_id": null,
      "id": 46070895,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcwODk1",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 185,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If you move the definition of `describe` below `if conflicts(R, assume)` in `check_symbolic`, this function will only ever be called after `conflicts()` has been run, so this check should never trigger.\n\nI'll add a note below to suggest that move. For here, I think it suffices to remove this check and add a comment at the top of the function saying we assume we have consistent assumptions.\n",
      "created_at": "2015-11-27T21:38:49Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46070895",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46070895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46070920",
      "pull_request_review_id": null,
      "id": 46070920,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcwOTIw",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 193,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "change to `map(numerator, assume.zero)` as per above comments about `mynumerator`\n",
      "created_at": "2015-11-27T21:40:18Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46070920",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46070920"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072114",
      "pull_request_review_id": null,
      "id": 46072114,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyMTE0",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 193,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also all the loops over `expr` should be over `expr.map(numerator)`\n",
      "created_at": "2015-11-27T22:38:19Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46072114",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072114"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072137",
      "pull_request_review_id": null,
      "id": 46072137,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyMTM3",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if mynumerator(R, expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: a*b, exprs, fastfrac(R, 1))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 200,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If you did `lambda a, b: numerator(a) * numerator(b)`, you could start with 1, and the function could take a list of numbers (rather than just fastfracs) as `expr`\n",
      "created_at": "2015-11-27T22:39:24Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46072137",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072137"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072181",
      "pull_request_review_id": null,
      "id": 46072181,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyMTgx",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if mynumerator(R, expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: a*b, exprs, fastfrac(R, 1))\n+  for (f, n) in mynumerator(R, allexprs).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(mynumerator(R, allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in mynumerator(R, expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(mynumerator(R, expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)",
      "path": "sage/group_prover.sage",
      "position": 250,
      "original_position": 232,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If `prove_nonzero` could take a dict of numbers as `expr` (which it almost can, see above) then `fastfrac(R, x.bot, 1)` can be replaced with just `x.bot`.\n",
      "created_at": "2015-11-27T22:40:59Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46072181",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072181"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 250,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072196",
      "pull_request_review_id": null,
      "id": 46072196,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyMTk2",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if mynumerator(R, expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: a*b, exprs, fastfrac(R, 1))\n+  for (f, n) in mynumerator(R, allexprs).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(mynumerator(R, allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in mynumerator(R, expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(mynumerator(R, expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 235,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`map(numerator, assume.zero)`\n",
      "created_at": "2015-11-27T22:41:46Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46072196",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072196"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072225",
      "pull_request_review_id": null,
      "id": 46072225,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyMjI1",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if mynumerator(R, expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: a*b, exprs, fastfrac(R, 1))\n+  for (f, n) in mynumerator(R, allexprs).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(mynumerator(R, allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in mynumerator(R, expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(mynumerator(R, expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = reduce((lambda x, y: x * y), assume.nonzero, fastfrac(R, 1))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 236,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can this `reduce` (and all other instances of it) be replaced with the `prod` function?\n",
      "created_at": "2015-11-27T22:43:02Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46072225",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072287",
      "pull_request_review_id": null,
      "id": 46072287,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyMjg3",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if mynumerator(R, expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: a*b, exprs, fastfrac(R, 1))\n+  for (f, n) in mynumerator(R, allexprs).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(mynumerator(R, allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in mynumerator(R, expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(mynumerator(R, expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = reduce((lambda x, y: x * y), assume.nonzero, fastfrac(R, 1))\n+  expl = []\n+  for expr in exprs:\n+    if not (expr * nonzero).iszero(zero):",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 239,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm a little confused by this use of `nonzero` as a witness. I guess the idea is that your ring of fractions is localized at all nonzero expressions (or something algebraic like that). Can you add a comment clarifying this?\n",
      "created_at": "2015-11-27T22:45:58Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46072287",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46072287"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46080933",
      "pull_request_review_id": null,
      "id": 46080933,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgwOTMz",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 68,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in next push.\n",
      "created_at": "2015-11-28T15:41:28Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46080933",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46080933"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46080934",
      "pull_request_review_id": null,
      "id": 46080934,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgwOTM0",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 132,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in next push.\n",
      "created_at": "2015-11-28T15:41:47Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46080934",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46080934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46080969",
      "pull_request_review_id": null,
      "id": 46080969,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgwOTY5",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 165,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in next push.\n",
      "created_at": "2015-11-28T15:44:27Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46080969",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46080969"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46081003",
      "pull_request_review_id": null,
      "id": 46081003,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgxMDAz",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 167,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in next push.\n",
      "created_at": "2015-11-28T15:46:47Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46081003",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46081003"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 180,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082032",
      "pull_request_review_id": null,
      "id": 46082032,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyMDMy",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 172,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's true, however.\n\nSay that you know that either x=0 or y=0. That's represented as putting x*y in the zero set.\n\nKnowing that x is nonzero or y is nonzero individually does not conflict with that. Both at the same time do conflict, however.\n",
      "created_at": "2015-11-28T17:06:48Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082032",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082032"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 192,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082053",
      "pull_request_review_id": null,
      "id": 46082053,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyMDUz",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 172,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a comment in the next push.\n",
      "created_at": "2015-11-28T17:08:36Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082053",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082053"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 192,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082182",
      "pull_request_review_id": null,
      "id": 46082182,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyMTgy",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 180,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done in next push.\n",
      "created_at": "2015-11-28T17:20:01Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082182",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082182"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082183",
      "pull_request_review_id": null,
      "id": 46082183,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyMTgz",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 181,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done in next push.\n",
      "created_at": "2015-11-28T17:20:07Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082183",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082193",
      "pull_request_review_id": null,
      "id": 46082193,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyMTkz",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 185,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done in next push.\n",
      "created_at": "2015-11-28T17:21:00Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082193",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082193"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082211",
      "pull_request_review_id": null,
      "id": 46082211,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyMjEx",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 193,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not possible, as that way you can't find the name in exprs anymore.\n",
      "created_at": "2015-11-28T17:22:44Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082211",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082228",
      "pull_request_review_id": null,
      "id": 46082228,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyMjI4",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if mynumerator(R, expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: a*b, exprs, fastfrac(R, 1))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 200,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done in next push.\n",
      "created_at": "2015-11-28T17:24:07Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082228",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082228"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082283",
      "pull_request_review_id": null,
      "id": 46082283,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyMjgz",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if mynumerator(R, expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: a*b, exprs, fastfrac(R, 1))\n+  for (f, n) in mynumerator(R, allexprs).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(mynumerator(R, allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in mynumerator(R, expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(mynumerator(R, expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)",
      "path": "sage/group_prover.sage",
      "position": 250,
      "original_position": 232,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It seems it can't, will look later.\n",
      "created_at": "2015-11-28T17:28:56Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082283",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082283"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 250,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082288",
      "pull_request_review_id": null,
      "id": 46082288,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyMjg4",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if mynumerator(R, expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: a*b, exprs, fastfrac(R, 1))\n+  for (f, n) in mynumerator(R, allexprs).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(mynumerator(R, allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in mynumerator(R, expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(mynumerator(R, expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 235,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in next push.\n",
      "created_at": "2015-11-28T17:29:40Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082288",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082288"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082312",
      "pull_request_review_id": null,
      "id": 46082312,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyMzEy",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if mynumerator(R, expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: a*b, exprs, fastfrac(R, 1))\n+  for (f, n) in mynumerator(R, allexprs).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(mynumerator(R, allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in mynumerator(R, expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(mynumerator(R, expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = reduce((lambda x, y: x * y), assume.nonzero, fastfrac(R, 1))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 236,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in next push.\n",
      "created_at": "2015-11-28T17:32:57Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082312",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082312"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082384",
      "pull_request_review_id": null,
      "id": 46082384,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyMzg0",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map((lambda x: mynumerator(R, x)), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+def mynumerator(R,x):\n+  \"\"\"Compute the numerator of a fraction.\"\"\"\n+  if parent(x) == R:\n+    return x\n+  return numerator(x)\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), con.zero))\n+  if len(con.nonzero) > 0 and 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = set()\n+  for nz in assume.nonzero:\n+    if mynumerator(R, nz) != 0:\n+      for (f,n) in mynumerator(R, nz).factor():\n+        nonzero.add(f)\n+    rnz = zero.reduce(mynumerator(R, nz))\n+    if rnz != 0:\n+      for (f,n) in rnz.factor():\n+        nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if mynumerator(R, expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: a*b, exprs, fastfrac(R, 1))\n+  for (f, n) in mynumerator(R, allexprs).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(mynumerator(R, allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in mynumerator(R, expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(mynumerator(R, expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map((lambda x: mynumerator(R, x)), assume.zero))\n+  nonzero = reduce((lambda x, y: x * y), assume.nonzero, fastfrac(R, 1))\n+  expl = []\n+  for expr in exprs:\n+    if not (expr * nonzero).iszero(zero):",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 239,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "c7e90388315ee9308cb877a013ac14b3aa77334a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There was a reason for this, but it seems it's no longer needed. Gone in next push.\n",
      "created_at": "2015-11-28T17:41:53Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082384",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082863",
      "pull_request_review_id": null,
      "id": 46082863,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyODYz",
      "diff_hunk": "@@ -0,0 +1,301 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map(lambda x: numerator(x), assumeZero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 68,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "b471a877270d4094ae2448a1d42c9ad877679ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`lambda x: numerator(x)` can just be `numerator` :)\n",
      "created_at": "2015-11-28T18:26:28Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082863",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082868",
      "pull_request_review_id": null,
      "id": 46082868,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyODY4",
      "diff_hunk": "@@ -0,0 +1,301 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map(lambda x: numerator(x), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map(lambda x: numerator(x), con.zero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 159,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "b471a877270d4094ae2448a1d42c9ad877679ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ditto\n",
      "created_at": "2015-11-28T18:26:51Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082868",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082868"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082890",
      "pull_request_review_id": null,
      "id": 46082890,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyODkw",
      "diff_hunk": "@@ -0,0 +1,301 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map(lambda x: numerator(x), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map(lambda x: numerator(x), con.zero))\n+  if 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  # It can be the case that entries in the nonzero set do not individually\n+  # conflict with the zero set, but their combination does. For example, if we\n+  # know that either x or y is zero, x*y would be in the zero set. Having x or y\n+  # individually in the nonzero set is not a conflict, but both simultaneously\n+  # is.",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 169,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "b471a877270d4094ae2448a1d42c9ad877679ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Suppose that our ring is Z, and our zero set is the ideal (6). Then neither 3 nor 2 is zero, but the product is. So I don't get why we can't simultaneously have 3 and 2 in the nonzero set? It seems like you're testing for something stronger than \"for all nonzero things x, x is not zero\".\n",
      "created_at": "2015-11-28T18:28:59Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082890",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082890"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082899",
      "pull_request_review_id": null,
      "id": 46082899,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyODk5",
      "diff_hunk": "@@ -0,0 +1,301 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map(lambda x: numerator(x), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map(lambda x: numerator(x), con.zero))\n+  if 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  # It can be the case that entries in the nonzero set do not individually\n+  # conflict with the zero set, but their combination does. For example, if we\n+  # know that either x or y is zero, x*y would be in the zero set. Having x or y\n+  # individually in the nonzero set is not a conflict, but both simultaneously\n+  # is.\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map(lambda x: numerator(x), assume.zero))\n+  nonzero = set()\n+  for nz in map(numerator, assume.nonzero):\n+    for (f,n) in nz.factor():\n+      nonzero.add(f)\n+    rnz = zero.reduce(nz)\n+    for (f,n) in rnz.factor():\n+      nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if numerator(expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: numerator(a)*numerator(b), exprs, 1)\n+  for (f, n) in allexprs.factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(numerator(allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in numerator(expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(numerator(expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map(lambda x: numerator(x), assume.zero))",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 232,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "b471a877270d4094ae2448a1d42c9ad877679ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`lambda x: numerator(x)` -> `numerator`\n",
      "created_at": "2015-11-28T18:29:44Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46082899",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46082899"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46083788",
      "pull_request_review_id": null,
      "id": 46083788,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNzg4",
      "diff_hunk": "@@ -0,0 +1,301 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map(lambda x: numerator(x), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map(lambda x: numerator(x), con.zero))\n+  if 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  # It can be the case that entries in the nonzero set do not individually\n+  # conflict with the zero set, but their combination does. For example, if we\n+  # know that either x or y is zero, x*y would be in the zero set. Having x or y\n+  # individually in the nonzero set is not a conflict, but both simultaneously\n+  # is.",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 169,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "b471a877270d4094ae2448a1d42c9ad877679ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As @sipa explained to me on IRC, if the zero set is the ideal (6), it will be so because the tester wanted to encode \"2 OR 3 is zero\".\n",
      "created_at": "2015-11-28T20:05:35Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46083788",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46083788"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46083841",
      "pull_request_review_id": null,
      "id": 46083841,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzODQx",
      "diff_hunk": "@@ -0,0 +1,301 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map(lambda x: numerator(x), assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+class constraints:\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map(lambda x: numerator(x), con.zero))\n+  if 1 in zero:\n+    return True\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  # It can be the case that entries in the nonzero set do not individually\n+  # conflict with the zero set, but their combination does. For example, if we\n+  # know that either x or y is zero, x*y would be in the zero set. Having x or y\n+  # individually in the nonzero set is not a conflict, but both simultaneously\n+  # is.",
      "path": "sage/group_prover.sage",
      "position": null,
      "original_position": 169,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "b471a877270d4094ae2448a1d42c9ad877679ce0",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "And since we have a polynomial ring over a finite field, it will have no zero divisors, so this will _always_ be the case. That is, `f(x)*g(x)` being zero is equivalent to either `f(x)` or `g(x)` being zero.\n\nAlso, by design \"being zero\" and \"being in the zero ideal\" mean the same thing in this function. The zero ideal is not some arbitrary ideal; my example with (6) being a zero ideal would mean that somebody literally encoded \"6 = 0\" as a condition on a formula which of course is nonsense.\n",
      "created_at": "2015-11-28T20:10:58Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46083841",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46083841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46084270",
      "pull_request_review_id": null,
      "id": 46084270,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg0Mjcw",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+# Test libsecp256k1' group operation implementations using prover.sage\n+\n+import sys\n+\n+load(\"group_prover.sage\")\n+load(\"weierstrass_prover.sage\")\n+\n+def formula_secp256k1_gej_double_var(a):\n+  \"\"\"libsecp256k1's secp256k1_gej_double_var, used by various addition functions\"\"\"\n+  rz = a.Z * a.Y\n+  rz = rz * 2\n+  t1 = a.X^2\n+  t1 = t1 * 3\n+  t2 = t1^2\n+  t3 = a.Y^2\n+  t3 = t3 * 2\n+  t4 = t3^2\n+  t4 = t4 * 2\n+  t3 = t3 * a.X\n+  rx = t3\n+  rx = rx * 4\n+  rx = -rx\n+  rx = rx + t2\n+  t2 = -t2\n+  t3 = t3 * 6\n+  t3 = t3 + t2\n+  ry = t1 * t3\n+  t2 = -t4\n+  ry = ry + t2\n+  return jacobianpoint(rx, ry, rz)\n+\n+def formula_secp256k1_gej_add_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_var\"\"\"\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={a.Infinity : 'a_finite'}), b)\n+  if branch == 1:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_infinite'}, nonzero={b.Infinity : 'b_infinite'}), a)",
      "path": "sage/secp256k1.sage",
      "position": null,
      "original_position": 37,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "18b717eb53d363a8f4d30ec1383134bcfd145705",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The description string for `a.Infinity` should be `finite`; two lines above `finite` should be `infinite`\n",
      "created_at": "2015-11-28T20:51:04Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46084270",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46084270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46084286",
      "pull_request_review_id": null,
      "id": 46084286,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg0Mjg2",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+# Test libsecp256k1' group operation implementations using prover.sage\n+\n+import sys\n+\n+load(\"group_prover.sage\")\n+load(\"weierstrass_prover.sage\")\n+\n+def formula_secp256k1_gej_double_var(a):\n+  \"\"\"libsecp256k1's secp256k1_gej_double_var, used by various addition functions\"\"\"\n+  rz = a.Z * a.Y\n+  rz = rz * 2\n+  t1 = a.X^2\n+  t1 = t1 * 3\n+  t2 = t1^2\n+  t3 = a.Y^2\n+  t3 = t3 * 2\n+  t4 = t3^2\n+  t4 = t4 * 2\n+  t3 = t3 * a.X\n+  rx = t3\n+  rx = rx * 4\n+  rx = -rx\n+  rx = rx + t2\n+  t2 = -t2\n+  t3 = t3 * 6\n+  t3 = t3 + t2\n+  ry = t1 * t3\n+  t2 = -t4\n+  ry = ry + t2\n+  return jacobianpoint(rx, ry, rz)\n+\n+def formula_secp256k1_gej_add_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_var\"\"\"\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={a.Infinity : 'a_finite'}), b)\n+  if branch == 1:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_infinite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z22 = b.Z^2\n+  z12 = a.Z^2\n+  u1 = a.X * z22\n+  u2 = b.X * z12\n+  s1 = a.Y * z22\n+  s1 = s1 * b.Z\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={h : 'h=0', i : 'i=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={h : 'h=0', a.Infinity : 'a_infinite', b.Infinity : 'b_infinite'}, nonzero={i : 'i!=0'}), point_at_infinity())",
      "path": "sage/secp256k1.sage",
      "position": null,
      "original_position": 54,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "18b717eb53d363a8f4d30ec1383134bcfd145705",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "both `_infinite` here should be `_finite`\n",
      "created_at": "2015-11-28T20:53:16Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46084286",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46084286"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46084295",
      "pull_request_review_id": null,
      "id": 46084295,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg0Mjk1",
      "diff_hunk": "@@ -0,0 +1,306 @@\n+# Test libsecp256k1' group operation implementations using prover.sage\n+\n+import sys\n+\n+load(\"group_prover.sage\")\n+load(\"weierstrass_prover.sage\")\n+\n+def formula_secp256k1_gej_double_var(a):\n+  \"\"\"libsecp256k1's secp256k1_gej_double_var, used by various addition functions\"\"\"\n+  rz = a.Z * a.Y\n+  rz = rz * 2\n+  t1 = a.X^2\n+  t1 = t1 * 3\n+  t2 = t1^2\n+  t3 = a.Y^2\n+  t3 = t3 * 2\n+  t4 = t3^2\n+  t4 = t4 * 2\n+  t3 = t3 * a.X\n+  rx = t3\n+  rx = rx * 4\n+  rx = -rx\n+  rx = rx + t2\n+  t2 = -t2\n+  t3 = t3 * 6\n+  t3 = t3 + t2\n+  ry = t1 * t3\n+  t2 = -t4\n+  ry = ry + t2\n+  return jacobianpoint(rx, ry, rz)\n+\n+def formula_secp256k1_gej_add_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_var\"\"\"\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={a.Infinity : 'a_finite'}), b)\n+  if branch == 1:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_infinite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z22 = b.Z^2\n+  z12 = a.Z^2\n+  u1 = a.X * z22\n+  u2 = b.X * z12\n+  s1 = a.Y * z22\n+  s1 = s1 * b.Z\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={h : 'h=0', i : 'i=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={h : 'h=0', a.Infinity : 'a_infinite', b.Infinity : 'b_infinite'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h2 * h\n+  h = h * b.Z\n+  rz = a.Z * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_ge_var, which assume bz==1\"\"\"\n+  if branch == 0:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(nonzero={a.Infinity : 'a_infinite'}), b)\n+  if branch == 1:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_infinite'}, nonzero={b.Infinity : 'b_infinite'}), a)",
      "path": "sage/secp256k1.sage",
      "position": null,
      "original_position": 79,
      "commit_id": "03d4611c81a1bc83e857aded077f31ef1561e3ca",
      "original_commit_id": "18b717eb53d363a8f4d30ec1383134bcfd145705",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "a_infinite -> a_finite\n",
      "created_at": "2015-11-28T20:54:06Z",
      "updated_at": "2015-11-29T15:03:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/302#discussion_r46084295",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/46084295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/302"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    }
  ]
}