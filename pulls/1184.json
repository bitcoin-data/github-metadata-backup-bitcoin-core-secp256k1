{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184",
    "id": 1180728487,
    "node_id": "PR_kwDOAP4Jqs5GYHyn",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1184.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1184.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/c8eb787cd96995aefa79bf4bab18903c409db026",
    "number": 1184,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Signed-digit based ecmult_const algorithm",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Using some insights learned from #1058, this replaces the fixed-wnaf ecmult_const algorithm with a signed-digit based one. Conceptually both algorithms are very similar, in that they boil down to summing precomputed odd multiples of the input points. Practically however, the new algorithm is simpler because it's just using scalar operations, rather than relying on wnaf machinery with skew terms to guarantee odd multipliers.\r\n\r\nThe idea is that we can compute $q \\cdot A$ as follows:\r\n* Let $s = f(q)$, for some function $f()$.\r\n* Compute $(s_1, s_2)$ such that $s = s_1 + \\lambda s_2$, using `secp256k1_scalar_lambda_split`.\r\n* Let $v_1 = s_1 + 2^{128}$ and $v_2 = s_2 + 2^{128}$ (such that the $v_i$ are positive and $n$ bits long).\r\n* Computing the result as $$\\sum_{i=0}^{n-1} (2v_1[i]-1) 2^i A + \\sum_{i=0}^{n-1} (2v_2[i]-1) 2^i \\lambda A$$ where $x[i]$ stands for the *i*'th bit of $x$, so summing positive and negative powers of two times $A$, based on the bits of $v_1.$\r\n\r\nThe comments in `ecmult_const_impl.h` show that if $f(q) = (q + (1+\\lambda)(2^n - 2^{129} - 1))/2 \\mod n$, the result will equal $q \\cdot A$.\r\n\r\nThis last step can be performed in groups of multiple bits at once, by looking up entries in a precomputed table of odd multiples of $A$ and $\\lambda A$, and then multiplying by a power of two before proceeding to the next group.\r\n\r\nThe result is slightly faster (I measure ~2% speedup), but significantly simpler as it only uses scalar arithmetic to determine the table lookup values. The speedup is due to the fact that no skew corrections at the end are needed, and less overhead to determine table indices. The precomputed table sizes are also made independent from the `ecmult` ones, after observing that the optimal table size is bigger here (which also gives a small speedup).",
    "labels": [
      {
        "id": 4975389731,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI5sIw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/performance",
        "name": "performance",
        "description": "",
        "color": "DE3CCC",
        "default": false
      },
      {
        "id": 5492448291,
        "node_id": "LA_kwDOAP4Jqs8AAAABR2AcIw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/refactor/smell",
        "name": "refactor/smell",
        "description": "",
        "color": "FBCA04",
        "default": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones/5",
      "html_url": "https://github.com/bitcoin-core/secp256k1/milestone/5",
      "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones/5/labels",
      "id": 9880835,
      "node_id": "MI_kwDOAP4Jqs4AlsUD",
      "number": 5,
      "state": "open",
      "title": "0.4.1 or 0.5.0",
      "description": "",
      "creator": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 4,
      "closed_issues": 0,
      "created_at": "2023-09-04T14:30:28Z",
      "updated_at": "2023-09-25T15:04:33Z",
      "due_on": "2023-12-01T08:00:00Z"
    },
    "created_at": "2022-12-30T06:39:21Z",
    "updated_at": "2023-10-25T14:49:47Z",
    "mergeable": true,
    "mergeable_state": "unstable",
    "merge_commit_sha": "d7203bcf56b644de10e6c139c67e93eda8cf3f9d",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202212_sd_ecmult_const",
      "ref": "202212_sd_ecmult_const",
      "sha": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 16648672,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODY3Mg==",
        "name": "secp256k1",
        "full_name": "sipa/secp256k1",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/secp256k1",
        "archive_url": "https://api.github.com/repos/sipa/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/sipa/secp256k1/events",
        "forks_url": "https://api.github.com/repos/sipa/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/sipa/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/sipa/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/sipa/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/sipa/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/sipa/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/sipa/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/sipa/secp256k1/hooks",
        "svn_url": "https://github.com/sipa/secp256k1",
        "language": "C",
        "forks_count": 20,
        "stargazers_count": 43,
        "watchers_count": 43,
        "size": 11842,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-10-23T15:28:10Z",
        "created_at": "2014-02-08T17:33:30Z",
        "updated_at": "2023-05-11T11:08:51Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "b314cf28334a91db2fe144d04f86077e2bfd7a25",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1025,
        "stargazers_count": 1848,
        "watchers_count": 1848,
        "size": 10543,
        "default_branch": "master",
        "open_issues_count": 136,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-10-23T15:49:52Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2023-10-24T12:07:42Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 427,
    "deletions": 330,
    "changed_files": 9,
    "commits": 7,
    "review_comments": 47,
    "comments": 21
  },
  "events": [
    {
      "event": "reviewed",
      "id": 1233022664,
      "node_id": "PRR_kwDOAP4Jqs5Jfm7I",
      "url": null,
      "actor": null,
      "commit_id": "b4387056a50fabc5a36c092a522636b032d4b378",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Whoa nice! The skew correction is really annoying to reason about... \r\n\r\nI just don't know where to get all the review power from.  ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1233022664",
      "submitted_at": "2022-12-30T11:20:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8131820624,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAHksbxQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8131820624",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-30T21:59:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8131827645,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAHksde9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8131827645",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-30T22:03:18Z"
    },
    {
      "event": "commented",
      "id": 1368106389,
      "node_id": "IC_kwDOAP4Jqs5Ri6WV",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1368106389",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-30T22:12:03Z",
      "updated_at": "2022-12-30T22:12:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "Added a commit to remove `secp256k1_scalar_shr_int`, which is now unused apart from tests. It's a net reduction diff now, even with all the comments it adds.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1368106389",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "commented",
      "id": 1371744351,
      "node_id": "IC_kwDOAP4Jqs5Rwyhf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1371744351",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-05T03:30:37Z",
      "updated_at": "2023-01-05T03:30:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "@peterdettman Randomly tagging you, you may find this interesting.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1371744351",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "mentioned",
      "id": 8156621601,
      "node_id": "MEE_lADOAP4Jqs5aQiuazwAAAAHmLCsh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8156621601",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-05T03:30:37Z"
    },
    {
      "event": "subscribed",
      "id": 8156621606,
      "node_id": "SE_lADOAP4Jqs5aQiuazwAAAAHmLCsm",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8156621606",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-05T03:30:37Z"
    },
    {
      "event": "commented",
      "id": 1374492466,
      "node_id": "IC_kwDOAP4Jqs5R7Rcy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1374492466",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-07T14:05:05Z",
      "updated_at": "2023-01-07T14:05:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "Very cool! I wonder if the explanation might be clearer if you said something like \"without any further optimizations, k0 would be 2^n - 1 with n = 256; however we are going to combine this scheme with the GLV endomorphism and do a windowed rather than bitwise approach. So instead we solve for k0\" rather than \"for some constant k0\".\r\n\r\nIn the end I was able to understand what you were doing without much trouble, so what you've written is fine, but it was a bit intimidating to see k0, k1, k2 all introduced at once just as unknowns.",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1374492466",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "reviewed",
      "id": 1239683265,
      "node_id": "PRR_kwDOAP4Jqs5J5BDB",
      "url": null,
      "actor": null,
      "commit_id": "f16c5008ba0975b6111f4c1f1b5a2e3005c00c8f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK f16c5008ba0975b6111f4c1f1b5a2e3005c00c8f",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1239683265",
      "submitted_at": "2023-01-07T16:01:54Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8175225316,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAHnSAnk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8175225316",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-07T18:47:55Z"
    },
    {
      "event": "commented",
      "id": 1374572870,
      "node_id": "IC_kwDOAP4Jqs5R7lFG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1374572870",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-07T18:50:34Z",
      "updated_at": "2023-01-07T18:50:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "@apoelstra I've changed the explanation to introduce the offset terms a bit more gently.\r\n\r\nI've also dropped the `ecmult_const_get_scalar_bit_group` function as `secp256k1_scalar_get_bits_var` can be used instead (the `_var` part is not an issue as it's only variable-time in the offset/length, not the scalar).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1374572870",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "mentioned",
      "id": 8175229329,
      "node_id": "MEE_lADOAP4Jqs5aQiuazwAAAAHnSBmR",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8175229329",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-07T18:50:34Z"
    },
    {
      "event": "subscribed",
      "id": 8175229333,
      "node_id": "SE_lADOAP4Jqs5aQiuazwAAAAHnSBmV",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8175229333",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-07T18:50:34Z"
    },
    {
      "event": "commented",
      "id": 1374859803,
      "node_id": "IC_kwDOAP4Jqs5R8rIb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1374859803",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-08T15:16:23Z",
      "updated_at": "2023-01-08T15:16:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "@sipa this looks way better, thanks!",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1374859803",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "mentioned",
      "id": 8176677465,
      "node_id": "MEE_lADOAP4Jqs5aQiuazwAAAAHnXjJZ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8176677465",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-08T15:16:23Z"
    },
    {
      "event": "subscribed",
      "id": 8176677468,
      "node_id": "SE_lADOAP4Jqs5aQiuazwAAAAHnXjJc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8176677468",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-08T15:16:24Z"
    },
    {
      "event": "reviewed",
      "id": 1239802803,
      "node_id": "PRR_kwDOAP4Jqs5J5eOz",
      "url": null,
      "actor": null,
      "commit_id": "b4ff4ebbb6486756f33c3f2119bc897d1c75179a",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK b4ff4ebbb6486756f33c3f2119bc897d1c75179a",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1239802803",
      "submitted_at": "2023-01-08T15:59:57Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8315964917,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAHvq431",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8315964917",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-19T20:36:32Z"
    },
    {
      "event": "commented",
      "id": 1397570856,
      "node_id": "IC_kwDOAP4Jqs5TTT0o",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1397570856",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-19T20:37:01Z",
      "updated_at": "2023-01-19T20:37:01Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased after merge of #1170 and #1190.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1397570856",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "commented",
      "id": 1399010420,
      "node_id": "IC_kwDOAP4Jqs5TYzR0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1399010420",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-20T22:09:26Z",
      "updated_at": "2023-01-22T15:47:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "~~Mental note: instead of adding $2^{128}$ to the split scalars, I believe it's also possible to (a) conditionally negate the scalar (if it's negative) and then (b) swap the meaning of positive/negate in the table (alternatively, bitwise negate the integers read from the table). This would mean we only need enough table coverage for 128 bits rather than 129, which for window=4 means one fewer addition.~~\r\n\r\nEDIT: no, doesn't work",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1399010420",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8335942651,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAHw3GP7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8335942651",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-23T16:15:43Z"
    },
    {
      "event": "commented",
      "id": 1400614230,
      "node_id": "IC_kwDOAP4Jqs5Te61W",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1400614230",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-23T16:16:13Z",
      "updated_at": "2023-01-23T16:16:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "Oops, my previous rebase accidentally reverted the changes I made to address @apoelstra's comment. Re-rebased.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1400614230",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "mentioned",
      "id": 8335947438,
      "node_id": "MEE_lADOAP4Jqs5aQiuazwAAAAHw3Hau",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8335947438",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-23T16:16:13Z"
    },
    {
      "event": "subscribed",
      "id": 8335947454,
      "node_id": "SE_lADOAP4Jqs5aQiuazwAAAAHw3Ha-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8335947454",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-23T16:16:13Z"
    },
    {
      "event": "reviewed",
      "id": 1292383681,
      "node_id": "PRR_kwDOAP4Jqs5NCDXB",
      "url": null,
      "actor": null,
      "commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1292383681",
      "submitted_at": "2023-02-10T05:10:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "reviewed",
      "id": 1292405565,
      "node_id": "PRR_kwDOAP4Jqs5NCIs9",
      "url": null,
      "actor": null,
      "commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1292405565",
      "submitted_at": "2023-02-10T05:43:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "reviewed",
      "id": 1292417665,
      "node_id": "PRR_kwDOAP4Jqs5NCLqB",
      "url": null,
      "actor": null,
      "commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1292417665",
      "submitted_at": "2023-02-10T05:58:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "reviewed",
      "id": 1292420305,
      "node_id": "PRR_kwDOAP4Jqs5NCMTR",
      "url": null,
      "actor": null,
      "commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1292420305",
      "submitted_at": "2023-02-10T06:01:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "reviewed",
      "id": 1292426271,
      "node_id": "PRR_kwDOAP4Jqs5NCNwf",
      "url": null,
      "actor": null,
      "commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1292426271",
      "submitted_at": "2023-02-10T06:06:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8494070725,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAH6STvF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8494070725",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-10T21:55:37Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8494078810,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAH6SVta",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8494078810",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-10T21:57:16Z"
    },
    {
      "event": "commented",
      "id": 1426623175,
      "node_id": "IC_kwDOAP4Jqs5VCIrH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1426623175",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-11T05:35:37Z",
      "updated_at": "2023-02-11T05:35:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "> ~Mental note: instead of adding 2128 to the split scalars, I believe it's also possible to (a) conditionally negate the scalar (if it's negative) and then (b) swap the meaning of positive/negate in the table (alternatively, bitwise negate the integers read from the table). This would mean we only need enough table coverage for 128 bits rather than 129, which for window=4 means one fewer addition.~\r\n> \r\n> EDIT: no, doesn't work\r\n\r\nAre you able to explain why that doesn't work? ",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1426623175",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "commented",
      "id": 1426655586,
      "node_id": "IC_kwDOAP4Jqs5VCQli",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1426655586",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-11T08:06:41Z",
      "updated_at": "2023-02-11T08:06:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "Nice idea, simple and clear.\r\n\r\n- I would prefer to use 2^128 as the offset, allowing the split to use the full two's complement range of [-2^128, 2^128). That generalizes better to other split schemes (I have in mind the basis reduction of https://ia.cr/2020/454).\r\n- The Straus ladder has the same need to deal with negative split outputs; should the mechanism be unified (one way or the other?)\r\n- I don't have a build to test the performance of the current _scalar_split_lambda, but it's doing quite a bit of unnecessary work compared to the \"original\" non-modular formula, which it seems could be done cmod 2^129 (i.e. 129-bit two's complement representation) - and e.g. avoid calculating the 384 bits that are shifted away. Not to belabor the point, but if the split outputs were in 129-bit two's complement, adding a 2^128 offset is just a bit flip (or maybe a single limb complement).",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1426655586",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8496739597,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAH6cfUN",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8496739597",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-11T15:11:04Z"
    },
    {
      "event": "commented",
      "id": 1426795013,
      "node_id": "IC_kwDOAP4Jqs5VCyoF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1426795013",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-11T15:11:27Z",
      "updated_at": "2023-02-11T15:11:27Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've switched to offset $2^{128}$.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1426795013",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "reviewed",
      "id": 1294587267,
      "node_id": "PRR_kwDOAP4Jqs5NKdWD",
      "url": null,
      "actor": null,
      "commit_id": "dd21e2c5ca2f9e76a2d2717c26a83f6ab4d2651f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1294587267",
      "submitted_at": "2023-02-11T17:07:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "reviewed",
      "id": 1294598462,
      "node_id": "PRR_kwDOAP4Jqs5NKgE-",
      "url": null,
      "actor": null,
      "commit_id": "dd21e2c5ca2f9e76a2d2717c26a83f6ab4d2651f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1294598462",
      "submitted_at": "2023-02-11T18:03:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "commented",
      "id": 1426849018,
      "node_id": "IC_kwDOAP4Jqs5VC_z6",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1426849018",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-11T18:38:45Z",
      "updated_at": "2023-02-11T18:52:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "I think if _scalar_split_lambda just output 129-bit two's complement values (and then sign-extend to ECMULT_CONST_BITS), then they would be directly usable in the comb, no offset needed for s1, s2. Something for the future, perhaps.\r\n",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1426849018",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8497673439,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAH6gDTf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8497673439",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-12T03:23:21Z"
    },
    {
      "event": "commented",
      "id": 1426934580,
      "node_id": "IC_kwDOAP4Jqs5VDUs0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1426934580",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-12T03:40:24Z",
      "updated_at": "2023-02-21T03:21:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Are you able to explain why that doesn't work?\r\n\r\nYeah, the issue is that when using the signed-digit encoding, negating the (final, intended) scalar isn't the same as negating the scalar whose bits are used to drive the point lookups. It's possible of course to negate, but instead it corresponds to complementing the lookup scalar $s$: with $s \\rightarrow 2^l - 1 - s$. This doesn't help you get rid of the 129th bit.\r\n\r\nIt's also possible to see it information theoretically: since $-C_{128}(s_1, P) = C_{128}(2^{128} - 1 - s_1, P)$, negating doesn't \"add\" anything; the $C_{128}$ operation can already represent that with another input. So it's not possible to compute $2^{129} - 1$ different results using $C_{128}$ (which takes a 128-bit input), even with an optional negation of the result at the end.\r\n\r\n> * I would prefer to use 2^128 as the offset, allowing the split to use the full two's complement range of [-2^128, 2^128). That generalizes better to other split schemes (I have in mind the basis reduction of https://ia.cr/2020/454).\r\n\r\nDone.\r\n\r\n> * The Straus ladder has the same need to deal with negative split outputs; should the mechanism be unified (one way or the other?)\r\n\r\nI'd need to look. I think the technique used here is most directly applicable to the Pippenger multi-multiplication code (as it's essentially a constant-time algorithm, except for some small optimizations). I plan to look at that when the code here is done.\r\n\r\n> * I don't have a build to test the performance of the current _scalar_split_lambda, but it's doing quite a bit of unnecessary work compared to the \"original\" non-modular formula, which it seems could be done cmod 2^129 (i.e. 129-bit two's complement representation) - and e.g. avoid calculating the 384 bits that are shifted away. Not to belabor the point, but if the split outputs were in 129-bit two's complement, adding a 2^128 offset is just a bit flip (or maybe a single limb complement).\r\n\r\nOf course, be my guest to optimize the lambda splitting code, but it is just run once per ECDH operation. On my Ryzen 5950X, lambda splitting takes 190 ns (for comparison, a constant time gej+ge point addition takes 320 ns; ECDH takes 51000 ns).\r\n\r\n> I think if _scalar_split_lambda just output 129-bit two's complement values (and then sign-extend to ECMULT_CONST_BITS), then they would be directly usable in the comb, no offset needed for s1, s2. Something for the future, perhaps.\r\n\r\nI believe that's right. There would still need to be an offset/halving before splitting to compensate for the signed-digit representation, but none after splitting.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1426934580",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8963155819,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAIWPudr",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8963155819",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-10T11:44:43Z"
    },
    {
      "event": "commented",
      "id": 1501726338,
      "node_id": "IC_kwDOAP4Jqs5ZgoaC",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1501726338",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-10T11:46:40Z",
      "updated_at": "2023-04-10T11:46:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1501726338",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "unsubscribed",
      "id": 8965044511,
      "node_id": "UE_lADOAP4Jqs5aQiuazwAAAAIWW7kf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8965044511",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-10T16:10:26Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9224803424,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAIl11Rg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9224803424",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-11T17:02:46Z"
    },
    {
      "event": "commented",
      "id": 1544361463,
      "node_id": "IC_kwDOAP4Jqs5cDRX3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1544361463",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-11T17:02:53Z",
      "updated_at": "2023-05-11T17:02:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1544361463",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9224893900,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAIl2LXM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9224893900",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-11T17:11:49Z"
    },
    {
      "event": "labeled",
      "id": 9224986543,
      "node_id": "LE_lADOAP4Jqs5aQiuazwAAAAIl2h-v",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9224986543",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-11T17:22:05Z",
      "label": {
        "name": "performance",
        "color": "DE3CCC"
      }
    },
    {
      "event": "labeled",
      "id": 9224986555,
      "node_id": "LE_lADOAP4Jqs5aQiuazwAAAAIl2h-7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9224986555",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-11T17:22:05Z",
      "label": {
        "name": "refactor",
        "color": "c5def5"
      }
    },
    {
      "event": "reviewed",
      "id": 1480211773,
      "node_id": "PRR_kwDOAP4Jqs5YOj09",
      "url": null,
      "actor": null,
      "commit_id": "f22eb66c078790d075e10c4895e6eaf62e78c2dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK. Besides being simpler than the existing approach I can get a reliable 1.5% speedup on my dev laptop. `ECMULT_CONST_GROUP_SIZE` 4 and 5 are best choices in my benchmarks and approximately equal in performance (with 4 being 0.16% faster).\r\n\r\nI created a [branch](https://github.com/jonasnick/secp256k1/commits/202212_sd_ecmult_const-jn) with a few minor suggestions. Feel free to cherry-pick.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1480211773",
      "submitted_at": "2023-06-15T13:48:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9583981109,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAI7P_I1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9583981109",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T20:28:25Z"
    },
    {
      "event": "commented",
      "id": 1599453424,
      "node_id": "IC_kwDOAP4Jqs5fVbjw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1599453424",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T20:29:53Z",
      "updated_at": "2023-06-20T20:31:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "Made the following changes (includes the fixups and tests by @jonasnick, the latter combined into a separate commit). I didn't include the macro -> function change, as I measure a slight slowdown from it.\r\n\r\n```diff\r\ndiff --git a/CHANGELOG.md b/CHANGELOG.md\r\nindex 69542415..fa027fdb 100644\r\n--- a/CHANGELOG.md\r\n+++ b/CHANGELOG.md\r\n@@ -7,6 +7,9 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\r\n \r\n ## [Unreleased]\r\n \r\n+#### Changed\r\n+ - The point multiplication algorithm used for ECDH operations (module `ecdh`) was replaced with a slightly faster one.\r\n+\r\n ## [0.3.2] - 2023-05-13\r\n We strongly recommend updating to 0.3.2 if you use or plan to use GCC >=13 to compile libsecp256k1. When in doubt, check the GCC version using `gcc -v`.\r\n \r\n@@ -54,7 +57,6 @@ The ABI is compatible with version 0.3.0.\r\n #### Changed\r\n  - Forbade cloning or destroying `secp256k1_context_static`. Create a new context instead of cloning the static context. (If this change breaks your code, your code is probably wrong.)\r\n  - Forbade randomizing (copies of) `secp256k1_context_static`. Randomizing a copy of `secp256k1_context_static` did not have any effect and did not provide defense-in-depth protection against side-channel attacks. Create a new context if you want to benefit from randomization.\r\n- - The point multiplication algorithm used for ECDH operations (module `ecdh`) was replaced with a slightly faster one.\r\n \r\n #### Removed\r\n  - Removed the configuration header `src/libsecp256k1-config.h`. We recommend passing flags to `./configure` or `cmake` to set configuration options (see `./configure --help` or `cmake -LH`). If you cannot or do not want to use one of the supported build systems, pass configuration flags such as `-DSECP256K1_ENABLE_MODULE_SCHNORRSIG` manually to the compiler (see the file `configure.ac` for supported flags).\r\ndiff --git a/src/ecmult_const_impl.h b/src/ecmult_const_impl.h\r\nindex 525d86f0..58cc19a8 100644\r\n--- a/src/ecmult_const_impl.h\r\n+++ b/src/ecmult_const_impl.h\r\n@@ -60,7 +60,7 @@ static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre\r\n     unsigned m = 0; \\\r\n     /* If the top bit of n is 0, we want the negation. */ \\\r\n     volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\r\n-    /* The index is computed by looking the the bottom bits, after making positive. */ \\\r\n+    /* The index is computed by looking at the bottom bits, after making positive. */ \\\r\n     unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\r\n     secp256k1_fe neg_y; \\\r\n     VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\r\n@@ -82,6 +82,25 @@ static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre\r\n     secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\r\n } while(0)\r\n \r\n+/* For K as defined in the comment of secp256k1_ecmult_const, we have several precomputed\r\n+ * formulas/constants.\r\n+ * - in exhaustive test mode, we give an explicit expression to compute it at compile time: */\r\n+#ifdef EXHAUSTIVE_TEST_ORDER\r\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = ((SECP256K1_SCALAR_CONST(0, 0, 0, (1U << (ECMULT_CONST_BITS - 128)) - 2U, 0, 0, 0, 0) + EXHAUSTIVE_TEST_ORDER - 1U) * (1U + EXHAUSTIVE_TEST_LAMBDA)) % EXHAUSTIVE_TEST_ORDER;\r\n+/* - for the real secp256k1 group we have constants for various ECMULT_CONST_BITS values. */\r\n+#elif ECMULT_CONST_BITS == 129\r\n+    /* For GROUP_SIZE = 1,3. */\r\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = SECP256K1_SCALAR_CONST(0xac9c52b3ul, 0x3fa3cf1ful, 0x5ad9e3fdul, 0x77ed9ba4ul, 0xa880b9fcul, 0x8ec739c2ul, 0xe0cfc810ul, 0xb51283ceul);\r\n+#elif ECMULT_CONST_BITS == 130\r\n+    /* For GROUP_SIZE = 2,5. */\r\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = SECP256K1_SCALAR_CONST(0xa4e88a7dul, 0xcb13034eul, 0xc2bdd6bful, 0x7c118d6bul, 0x589ae848ul, 0x26ba29e4ul, 0xb5c2c1dcul, 0xde9798d9ul);\r\n+#elif ECMULT_CONST_BITS == 132\r\n+    /* For GROUP_SIZE = 4,6 */\r\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = SECP256K1_SCALAR_CONST(0x76b1d93dul, 0x0fae3c6bul, 0x3215874bul, 0x94e93813ul, 0x7937fe0dul, 0xb66bcaaful, 0xb3749ca5ul, 0xd7b6171b);\r\n+#else\r\n+#  error \"Unknown ECMULT_CONST_BITS\"\r\n+#endif\r\n+\r\n static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\r\n     /* The approach below combines the signed-digit logic from Mike Hamburg's\r\n      * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\r\n@@ -93,7 +112,7 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\r\n      *\r\n      *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\r\n      *\r\n-     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\r\n+     * Then it holds that C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\r\n      *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\r\n      *                              = (2*v + 1 - 2^l) * A\r\n      *\r\n@@ -150,26 +169,8 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\r\n      */\r\n \r\n     /* The offset to add to s1 and s2 to make them non-negative. Equal to 2^128. */\r\n-    static const secp256k1_scalar S_OFFSET = SECP256K1_SCALAR_CONST(0, 0, 0, 1, 0, 0, 0, 0);\r\n-\r\n-    /* For K, we have several precomputed formulas/constants.\r\n-     * - in exhaustive test mode, we give an explicit expression to compute it at compile time: */\r\n-#ifdef EXHAUSTIVE_TEST_ORDER\r\n-    static const secp256k1_scalar K = ((SECP256K1_SCALAR_CONST(0, 0, 0, (1U << (ECMULT_CONST_BITS - 128)) - 2U, 0, 0, 0, 0) + EXHAUSTIVE_TEST_ORDER - 1U) * (1U + EXHAUSTIVE_TEST_LAMBDA)) % EXHAUSTIVE_TEST_ORDER;\r\n-    /* - for the real secp256k1 group we have constants for various ECMULT_CONST_BITS values. */\r\n-#elif ECMULT_CONST_BITS == 129\r\n-    /* For GROUP_SIZE = 1,3. */\r\n-    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0xac9c52b3ul, 0x3fa3cf1ful, 0x5ad9e3fdul, 0x77ed9ba4ul, 0xa880b9fcul, 0x8ec739c2ul, 0xe0cfc810ul, 0xb51283ceul);\r\n-#elif ECMULT_CONST_BITS == 130\r\n-    /* For GROUP_SIZE = 2,5. */\r\n-    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0xa4e88a7dul, 0xcb13034eul, 0xc2bdd6bful, 0x7c118d6bul, 0x589ae848ul, 0x26ba29e4ul, 0xb5c2c1dcul, 0xde9798d9ul);\r\n-#elif ECMULT_CONST_BITS == 132\r\n-    /* For GROUP_SIZE = 4,6 */\r\n-    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0x76b1d93dul, 0x0fae3c6bul, 0x3215874bul, 0x94e93813ul, 0x7937fe0dul, 0xb66bcaaful, 0xb3749ca5ul, 0xd7b6171b);\r\n-#else\r\n-#  error \"Unknown ECMULT_CONST_BITS\"\r\n-#endif\r\n \r\n+    static const secp256k1_scalar S_OFFSET = SECP256K1_SCALAR_CONST(0, 0, 0, 1, 0, 0, 0, 0);\r\n     secp256k1_scalar s, v1, v2;\r\n     secp256k1_ge pre_a[ECMULT_CONST_TABLE_SIZE];\r\n     secp256k1_ge pre_a_lam[ECMULT_CONST_TABLE_SIZE];\r\n@@ -178,7 +179,7 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\r\n     int group, i;\r\n \r\n     /* Compute v1 and v2. */\r\n-    secp256k1_scalar_add(&s, q, &K);\r\n+    secp256k1_scalar_add(&s, q, &secp256k1_ecmult_const_K);\r\n     secp256k1_scalar_half(&s, &s);\r\n     secp256k1_scalar_split_lambda(&v1, &v2, &s);\r\n     secp256k1_scalar_add(&v1, &v1, &S_OFFSET);\r\n@@ -209,7 +210,6 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\r\n     secp256k1_gej_set_ge(&res, a);\r\n     secp256k1_ecmult_const_odd_multiples_table_globalz(pre_a, &Z, &res);\r\n     for (i = 0; i < ECMULT_CONST_TABLE_SIZE; i++) {\r\n-        secp256k1_fe_normalize_weak(&pre_a[i].y);\r\n         secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\r\n     }\r\n \r\n@@ -219,7 +219,7 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\r\n      * at a time, from high in v1/v2 to low. Call these bits1 (from v1) and bits2 (from v2).\r\n      *\r\n      * Now note that ECMULT_CONST_TABLE_GET_GE(&t, pre_a, bits1) loads into t a point equal\r\n-     * to C_{ECMULT_CONST_GROUP_SIZE}(bits, A), and analogously for pre_lam_a / bits2.\r\n+     * to C_{ECMULT_CONST_GROUP_SIZE}(bits1, A), and analogously for pre_lam_a / bits2.\r\n      * This means that all we need to do is add these looked up values together, multiplied\r\n      * by 2^(ECMULT_GROUP_SIZE * group).\r\n      */\r\ndiff --git a/src/tests.c b/src/tests.c\r\nindex 1887d6aa..3ed8e49c 100644\r\n--- a/src/tests.c\r\n+++ b/src/tests.c\r\n@@ -2375,11 +2375,17 @@ static void run_scalar_tests(void) {\r\n         /* Test that halving and doubling roundtrips on some fixed values. */\r\n         static const secp256k1_scalar HALF_TESTS[] = {\r\n             /* 0 */\r\n-            SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0),\r\n+            secp256k1_scalar_one,\r\n             /* 1 */\r\n-            SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1),\r\n+            secp256k1_scalar_zero,\r\n             /* -1 */\r\n             SECP256K1_SCALAR_CONST(0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffeul, 0xbaaedce6ul, 0xaf48a03bul, 0xbfd25e8cul, 0xd0364140ul),\r\n+            /* -2 (largest odd value) */\r\n+            SECP256K1_SCALAR_CONST(0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffeul, 0xbaaedce6ul, 0xaf48a03bul, 0xbfd25e8cul, 0xd036413Ful),\r\n+            /* Half the secp256k1 order */\r\n+            SECP256K1_SCALAR_CONST(0x7ffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0x5d576e73ul, 0x57a4501dul, 0xdfe92f46ul, 0x681b20a0ul),\r\n+            /* Half the secp256k1 order + 1*/\r\n+            SECP256K1_SCALAR_CONST(0x7ffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0x5d576e73ul, 0x57a4501dul, 0xdfe92f46ul, 0x681b20a1ul),\r\n             /* 2^255 */\r\n             SECP256K1_SCALAR_CONST(0x80000000ul, 0, 0, 0, 0, 0, 0, 0),\r\n             /* 2^255 - 1 */\r\n@@ -4535,25 +4541,75 @@ static void ecmult_const_commutativity(void) {\r\n static void ecmult_const_mult_zero_one(void) {\r\n     secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\r\n     secp256k1_scalar one = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1);\r\n+    secp256k1_scalar s;\r\n     secp256k1_scalar negone;\r\n     secp256k1_gej res1;\r\n     secp256k1_ge res2;\r\n     secp256k1_ge point;\r\n-    secp256k1_scalar_negate(&negone, &one);\r\n+    secp256k1_ge inf;\r\n \r\n+    random_scalar_order_test(&s);\r\n+    secp256k1_scalar_negate(&negone, &one);\r\n     random_group_element_test(&point);\r\n+    secp256k1_ge_set_infinity(&inf);\r\n+\r\n+    /* 0*point */\r\n     secp256k1_ecmult_const(&res1, &point, &zero);\r\n-    secp256k1_ge_set_gej(&res2, &res1);\r\n-    CHECK(secp256k1_ge_is_infinity(&res2));\r\n+    CHECK(secp256k1_gej_is_infinity(&res1));\r\n+\r\n+    /* s*inf */\r\n+    secp256k1_ecmult_const(&res1, &inf, &s);\r\n+    CHECK(secp256k1_gej_is_infinity(&res1));\r\n+\r\n+    /* 1*point */\r\n     secp256k1_ecmult_const(&res1, &point, &one);\r\n     secp256k1_ge_set_gej(&res2, &res1);\r\n     ge_equals_ge(&res2, &point);\r\n+\r\n+    /* -1*point */\r\n     secp256k1_ecmult_const(&res1, &point, &negone);\r\n     secp256k1_gej_neg(&res1, &res1);\r\n     secp256k1_ge_set_gej(&res2, &res1);\r\n     ge_equals_ge(&res2, &point);\r\n }\r\n \r\n+static void ecmult_const_check_result(const secp256k1_ge *A, const secp256k1_scalar* q, const secp256k1_gej *res) {\r\n+    secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\r\n+    secp256k1_gej pointj, res2j;\r\n+    secp256k1_ge res2;\r\n+    secp256k1_gej_set_ge(&pointj, A);\r\n+    secp256k1_ecmult(&res2j, &pointj, q, &zero);\r\n+    secp256k1_ge_set_gej(&res2, &res2j);\r\n+    ge_equals_gej(&res2, res);\r\n+}\r\n+\r\n+static void ecmult_const_mult_edges(void) {\r\n+    secp256k1_scalar q;\r\n+    secp256k1_ge point;\r\n+    secp256k1_gej res;\r\n+    size_t i;\r\n+    size_t cases = 1 + sizeof(scalars_near_split_bounds) / sizeof(scalars_near_split_bounds[0]);\r\n+\r\n+    /* We are trying to reach the following edge cases (variables are defined as\r\n+     * in ecmult_const_impl.h):\r\n+     *   1. i = 0: s = 0 <=> q = -K\r\n+     *   2. i > 0: v1, v2 large values\r\n+     *               <=> s1, s2 large values\r\n+     *               <=> s = scalars_near_split_bounds[i]\r\n+     *               <=> q = 2*scalars_near_split_bounds[i] - K\r\n+     */\r\n+    for (i = 0; i < cases; ++i) {\r\n+        secp256k1_scalar_negate(&q, &secp256k1_ecmult_const_K);\r\n+        if (i > 0) {\r\n+            secp256k1_scalar_add(&q, &q, &scalars_near_split_bounds[i - 1]);\r\n+            secp256k1_scalar_add(&q, &q, &scalars_near_split_bounds[i - 1]);\r\n+        }\r\n+        random_group_element_test(&point);\r\n+        secp256k1_ecmult_const(&res, &point, &q);\r\n+        ecmult_const_check_result(&point, &q, &res);\r\n+    }\r\n+}\r\n+\r\n static void ecmult_const_mult_xonly(void) {\r\n     int i;\r\n \r\n@@ -4644,6 +4700,7 @@ static void ecmult_const_chain_multiply(void) {\r\n \r\n static void run_ecmult_const_tests(void) {\r\n     ecmult_const_mult_zero_one();\r\n+    ecmult_const_mult_edges();\r\n     ecmult_const_random_mult();\r\n     ecmult_const_commutativity();\r\n     ecmult_const_chain_multiply();\r\n ```\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1599453424",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "mentioned",
      "id": 9583991489,
      "node_id": "MEE_lADOAP4Jqs5aQiuazwAAAAI7QBrB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9583991489",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T20:29:53Z"
    },
    {
      "event": "subscribed",
      "id": 9583991502,
      "node_id": "SE_lADOAP4Jqs5aQiuazwAAAAI7QBrO",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9583991502",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T20:29:53Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9584063287,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAI7QTM3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9584063287",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T20:40:13Z"
    },
    {
      "event": "commented",
      "id": 1599465228,
      "node_id": "IC_kwDOAP4Jqs5fVecM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1599465228",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T20:40:46Z",
      "updated_at": "2023-06-20T20:40:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "Fixed compilation error, reverting the following:\r\n\r\n```diff\r\ndiff --git a/src/tests.c b/src/tests.c\r\nindex 3ed8e49c..88b5c3a4 100644\r\n--- a/src/tests.c\r\n+++ b/src/tests.c\r\n@@ -2375,9 +2375,9 @@ static void run_scalar_tests(void) {\r\n         /* Test that halving and doubling roundtrips on some fixed values. */\r\n         static const secp256k1_scalar HALF_TESTS[] = {\r\n             /* 0 */\r\n-            secp256k1_scalar_one,\r\n+            SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0),\r\n             /* 1 */\r\n-            secp256k1_scalar_zero,\r\n+            SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1),\r\n             /* -1 */\r\n             SECP256K1_SCALAR_CONST(0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffeul, 0xbaaedce6ul, 0xaf48a03bul, 0xbfd25e8cul, 0xd0364140ul),\r\n             /* -2 (largest odd value) */\r\n```\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1599465228",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "reviewed",
      "id": 1493351729,
      "node_id": "PRR_kwDOAP4Jqs5ZAr0x",
      "url": null,
      "actor": null,
      "commit_id": "e6b14b947f04e3fbcb48113b942c24b279c59cee",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1493351729",
      "submitted_at": "2023-06-22T14:41:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "reviewed",
      "id": 1494755506,
      "node_id": "PRR_kwDOAP4Jqs5ZGCiy",
      "url": null,
      "actor": null,
      "commit_id": "e6b14b947f04e3fbcb48113b942c24b279c59cee",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1494755506",
      "submitted_at": "2023-06-23T09:05:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9621127214,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAI9dsAu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9621127214",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-23T19:01:48Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9642882516,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAI-wrXU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9642882516",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-26T19:10:37Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-27T07:51:32Z",
      "updated_at": "2023-06-27T07:51:32Z",
      "source": {
        "issue": {
          "id": 1776308298,
          "node_id": "I_kwDOAP4Jqs5p4FBK",
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1360",
          "repository_url": "https://api.github.com/repos/bitcoin-core/secp256k1",
          "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1360/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1360/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1360/events",
          "html_url": "https://github.com/bitcoin-core/secp256k1/issues/1360",
          "number": 1360,
          "state": "closed",
          "state_reason": "completed",
          "title": "scalar: Verify invariants on every entry",
          "body": "We have `secp256k1_ge_verify`, `secp256k1_gej_verify`, and `secp256k1_fe_verify` functions to the invariants of the respective type. We call them on every entry/exit of a function that operates on a respective element.  \r\n\r\nWe should add a similar function for scalars. I think the only invariant is that scalars `a` are reduced mod the group order, i.e., `secp256k1_scalar_check_overflow(a) == 0`.\r\n\r\n(see https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1239566294)\r\n\r\n@stratospher Are you interested in working on this? ",
          "user": {
            "login": "real-or-random",
            "id": 1071625,
            "node_id": "MDQ6VXNlcjEwNzE2MjU=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/real-or-random",
            "html_url": "https://github.com/real-or-random",
            "followers_url": "https://api.github.com/users/real-or-random/followers",
            "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
            "organizations_url": "https://api.github.com/users/real-or-random/orgs",
            "repos_url": "https://api.github.com/users/real-or-random/repos",
            "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/real-or-random/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 165017692,
              "node_id": "MDU6TGFiZWwxNjUwMTc2OTI=",
              "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/assurance",
              "name": "assurance",
              "description": "",
              "color": "A6DF3D",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 2,
          "closed_at": "2023-08-18T09:44:31Z",
          "created_at": "2023-06-27T07:51:32Z",
          "updated_at": "2023-08-18T09:44:31Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1511084315,
      "node_id": "PRR_kwDOAP4Jqs5aEVEb",
      "url": null,
      "actor": null,
      "commit_id": "1a26896eff6bc2f7b2edbcd0313c3e2e574b08a6",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "> I didn't include the macro -> function change, as I measure a slight slowdown from it.\r\n\r\nOh, ok. I did not run benchmarks.\r\n\r\n1a26896eff6bc2f7b2edbcd0313c3e2e574b08a6 looks good ",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1511084315",
      "submitted_at": "2023-07-03T12:22:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9766479035,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAJGIKS7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9766479035",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-09T03:46:09Z"
    },
    {
      "event": "commented",
      "id": 1627726051,
      "node_id": "IC_kwDOAP4Jqs5hBSDj",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1627726051",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-09T14:06:36Z",
      "updated_at": "2023-07-09T14:06:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Needed trivial rebase (`CHANGELOG.md` affected by #1354).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1627726051",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "commented",
      "id": 1691506539,
      "node_id": "IC_kwDOAP4Jqs5k0ldr",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1691506539",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-24T11:32:27Z",
      "updated_at": "2023-08-24T11:32:27Z",
      "author_association": "CONTRIBUTOR",
      "body": "needs rebase (and I plan to have a look soon :))",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1691506539",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10185791780,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAJfHtkk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/10185791780",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-24T20:32:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10185813546,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAJfHy4q",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/10185813546",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-24T20:35:45Z"
    },
    {
      "event": "commented",
      "id": 1692371809,
      "node_id": "IC_kwDOAP4Jqs5k34th",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1692371809",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-24T20:35:59Z",
      "updated_at": "2023-08-24T20:35:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1692371809",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "milestoned",
      "id": 10422734654,
      "node_id": "MIE_lADOAP4Jqs5aQiuazwAAAAJtPk8-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/10422734654",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-20T12:44:15Z",
      "milestone": {
        "title": "0.4.1 or 0.5.0"
      }
    },
    {
      "event": "reviewed",
      "id": 1644626750,
      "node_id": "PRR_kwDOAP4Jqs5iBwM-",
      "url": null,
      "actor": null,
      "commit_id": "f773744172e998786e93877b2109b5d21156fbb5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1644626750",
      "submitted_at": "2023-09-26T16:18:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "reviewed",
      "id": 1691259398,
      "node_id": "PRR_kwDOAP4Jqs5kzpIG",
      "url": null,
      "actor": null,
      "commit_id": "f773744172e998786e93877b2109b5d21156fbb5",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1691259398",
      "submitted_at": "2023-10-21T13:34:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDg3OGI0OTM4M2NkMmMxOTdiZWFlYWFhMTM1NzU0MWUyYjg1YjA1MTU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/878b49383cd2c197beaeaaa1357541e2b85b0515",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/878b49383cd2c197beaeaaa1357541e2b85b0515",
      "tree": {
        "sha": "8c0b0651309a72f7e5297911c1f1c14f9e938a3f",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/8c0b0651309a72f7e5297911c1f1c14f9e938a3f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b314cf28334a91db2fe144d04f86077e2bfd7a25",
          "sha": "b314cf28334a91db2fe144d04f86077e2bfd7a25",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b314cf28334a91db2fe144d04f86077e2bfd7a25"
        }
      ],
      "message": "Add secp256k1_scalar_half for halving scalars (+ tests/benchmarks).\n\nCo-authored-by: Jonas Nick <jonasd.nick@gmail.com>\nCo-authored-by: Tim Ruffing <crypto@timruffing.de>",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-10-23T15:11:35Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-12-29T16:48:06Z"
      },
      "sha": "878b49383cd2c197beaeaaa1357541e2b85b0515"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGZkNTg0NTRmMmJhYWMyYTUzMTdjYWU4OWNiN2JmZDJjOTAzZTNiN2I",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/fd58454f2baac2a5317cae89cb7bfd2c903e3b7b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/fd58454f2baac2a5317cae89cb7bfd2c903e3b7b",
      "tree": {
        "sha": "2f1ac4561876038fb3d2b9759f576c335bc7fc06",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/2f1ac4561876038fb3d2b9759f576c335bc7fc06"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/878b49383cd2c197beaeaaa1357541e2b85b0515",
          "sha": "878b49383cd2c197beaeaaa1357541e2b85b0515",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/878b49383cd2c197beaeaaa1357541e2b85b0515"
        }
      ],
      "message": "make SECP256K1_SCALAR_CONST reduce modulo exhaustive group order",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-10-23T15:11:35Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-12-30T17:13:46Z"
      },
      "sha": "fd58454f2baac2a5317cae89cb7bfd2c903e3b7b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDQwMmIzNzc2YTg5YmIyOTdkNDdhODg3NzE1Mzk4NjFhY2M2ZTdmZDM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/402b3776a89bb297d47a88771539861acc6e7fd3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/402b3776a89bb297d47a88771539861acc6e7fd3",
      "tree": {
        "sha": "fc77b2ea370e229536089ab2f26ffab80461229c",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/fc77b2ea370e229536089ab2f26ffab80461229c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/fd58454f2baac2a5317cae89cb7bfd2c903e3b7b",
          "sha": "fd58454f2baac2a5317cae89cb7bfd2c903e3b7b",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/fd58454f2baac2a5317cae89cb7bfd2c903e3b7b"
        }
      ],
      "message": "Signed-digit based ecmult_const algorithm",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-10-23T15:22:35Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-12-30T19:43:37Z"
      },
      "sha": "402b3776a89bb297d47a88771539861acc6e7fd3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDMxOTY5YjViODFmMjVmM2NiY2YwNGI1OWVmYzlmNzJjMzM4YTAyYmI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/31969b5b81f25f3cbcf04b59efc9f72c338a02bb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/31969b5b81f25f3cbcf04b59efc9f72c338a02bb",
      "tree": {
        "sha": "989c08c9d24bc9eb086da71fe9a96c8cb3d9b4c7",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/989c08c9d24bc9eb086da71fe9a96c8cb3d9b4c7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/402b3776a89bb297d47a88771539861acc6e7fd3",
          "sha": "402b3776a89bb297d47a88771539861acc6e7fd3",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/402b3776a89bb297d47a88771539861acc6e7fd3"
        }
      ],
      "message": "ecmult_const: add/improve tests\n\n* add test case for a=infinity\n\n  The corresponding ecmult_const branch was not tested before this commit.\n\n* add test for edge cases",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-10-23T15:22:39Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2023-06-20T20:16:30Z"
      },
      "sha": "31969b5b81f25f3cbcf04b59efc9f72c338a02bb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDVlODVlMTE2MGEyYmM5MTJkM2Y3MGNiNDU0OGI3ZTI0ZjRjMjNjMjc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/5e85e1160a2bc912d3f70cb4548b7e24f4c23c27",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/5e85e1160a2bc912d3f70cb4548b7e24f4c23c27",
      "tree": {
        "sha": "c2b866c1331e1e30dae0e5ebc5dea14a0fd09f76",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/c2b866c1331e1e30dae0e5ebc5dea14a0fd09f76"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/31969b5b81f25f3cbcf04b59efc9f72c338a02bb",
          "sha": "31969b5b81f25f3cbcf04b59efc9f72c338a02bb",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/31969b5b81f25f3cbcf04b59efc9f72c338a02bb"
        }
      ],
      "message": "Remove unused secp256k1_wnaf_const",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-10-23T15:22:39Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-12-30T19:44:14Z"
      },
      "sha": "5e85e1160a2bc912d3f70cb4548b7e24f4c23c27"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDRjZDYzNzU2YjgyNDk2Yzg1OTU3ZGQ4ZWJmYzI1NTZhYzBlOTE5NmY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4cd63756b82496c85957dd8ebfc2556ac0e9196f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4cd63756b82496c85957dd8ebfc2556ac0e9196f",
      "tree": {
        "sha": "48daef0810f92b2c0cba0d09f4ccc58f25f72025",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/48daef0810f92b2c0cba0d09f4ccc58f25f72025"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/5e85e1160a2bc912d3f70cb4548b7e24f4c23c27",
          "sha": "5e85e1160a2bc912d3f70cb4548b7e24f4c23c27",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/5e85e1160a2bc912d3f70cb4548b7e24f4c23c27"
        }
      ],
      "message": "Remove unused secp256k1_scalar_shr_int",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-10-23T15:22:39Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-12-30T19:17:42Z"
      },
      "sha": "4cd63756b82496c85957dd8ebfc2556ac0e9196f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGM4ZWI3ODdjZDk2OTk1YWVmYTc5YmY0YmFiMTg5MDNjNDA5ZGIwMjY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c8eb787cd96995aefa79bf4bab18903c409db026",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c8eb787cd96995aefa79bf4bab18903c409db026",
      "tree": {
        "sha": "7e72c8e536cfe5bddc9a384d17e1bfbaa7e10ad1",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/7e72c8e536cfe5bddc9a384d17e1bfbaa7e10ad1"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4cd63756b82496c85957dd8ebfc2556ac0e9196f",
          "sha": "4cd63756b82496c85957dd8ebfc2556ac0e9196f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4cd63756b82496c85957dd8ebfc2556ac0e9196f"
        }
      ],
      "message": "Add changelog entry for signed-digit ecmult_const algorithm",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-10-23T15:23:10Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-12-30T20:31:39Z"
      },
      "sha": "c8eb787cd96995aefa79bf4bab18903c409db026"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10742622196,
      "node_id": "HRFPE_lADOAP4Jqs5aQiuazwAAAAKAT2f0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/10742622196",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-23T15:28:15Z"
    },
    {
      "event": "commented",
      "id": 1775463904,
      "node_id": "IC_kwDOAP4Jqs5p023g",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1775463904",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-23T15:29:13Z",
      "updated_at": "2023-10-23T15:29:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased and addressed the comments above.\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#issuecomment-1775463904",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1184"
    },
    {
      "event": "reviewed",
      "id": 1694762656,
      "node_id": "PRR_kwDOAP4Jqs5lBAag",
      "url": null,
      "actor": null,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK mod nits c8eb787cd96995aefa79bf4bab18903c409db026\r\n\r\nI added a couple of (micro-)nit fixups to [my branch](https://github.com/jonasnick/secp256k1/commits/202212_sd_ecmult_const-jn). Most notably, it tries to unify the first iteration in ecmult_const with the loop and adds an explanation for the index computation in `ECMULT_CONST_TABLE_GET_GE`.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#pullrequestreview-1694762656",
      "submitted_at": "2023-10-24T12:53:10Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1059346476",
      "pull_request_review_id": 1233022664,
      "id": 1059346476,
      "node_id": "PRRC_kwDOAP4Jqs4_JFgs",
      "diff_hunk": "@@ -2195,6 +2202,31 @@ void run_scalar_tests(void) {\n         CHECK(secp256k1_scalar_is_zero(&o));\n     }\n \n+    {\n+        /* Test that halving and doubling roundtrips on some fixed values. */\n+        static const secp256k1_scalar HALF_TESTS[] = {\n+            /* 0 */\n+            SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0),\n+            /* 1 */\n+            SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1),\n+            /* -1 */\n+            SECP256K1_SCALAR_CONST(0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffeul, 0xbaaedce6ul, 0xaf48a03bul, 0xbfd25e8cul, 0xd0364140ul),\n+            /* 2^255 */\n+            SECP256K1_SCALAR_CONST(0x80000000ul, 0, 0, 0, 0, 0, 0, 0),\n+            /* 2^255 - 1 */\n+            SECP256K1_SCALAR_CONST(0x7ffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful),\n+        };\n+        for (i = 0; (unsigned)i < sizeof(HALF_TESTS) / sizeof(HALF_TESTS[0]); ++i) {",
      "path": "src/tests.c",
      "position": null,
      "original_position": 32,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "b4387056a50fabc5a36c092a522636b032d4b378",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Maybe introduce a `size_t` instead of reusing `i` and casting it.. Easy given that you anyway open a new scope.  (You could also scope the other uses of `i` properly as a clean up.) ",
      "created_at": "2022-12-30T11:14:24Z",
      "updated_at": "2022-12-30T11:20:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1059346476",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1059346476"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2219,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1059530254",
      "pull_request_review_id": 1233298171,
      "id": 1059530254,
      "node_id": "PRRC_kwDOAP4Jqs4_JyYO",
      "diff_hunk": "@@ -2195,6 +2202,31 @@ void run_scalar_tests(void) {\n         CHECK(secp256k1_scalar_is_zero(&o));\n     }\n \n+    {\n+        /* Test that halving and doubling roundtrips on some fixed values. */\n+        static const secp256k1_scalar HALF_TESTS[] = {\n+            /* 0 */\n+            SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0),\n+            /* 1 */\n+            SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1),\n+            /* -1 */\n+            SECP256K1_SCALAR_CONST(0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffeul, 0xbaaedce6ul, 0xaf48a03bul, 0xbfd25e8cul, 0xd0364140ul),\n+            /* 2^255 */\n+            SECP256K1_SCALAR_CONST(0x80000000ul, 0, 0, 0, 0, 0, 0, 0),\n+            /* 2^255 - 1 */\n+            SECP256K1_SCALAR_CONST(0x7ffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful),\n+        };\n+        for (i = 0; (unsigned)i < sizeof(HALF_TESTS) / sizeof(HALF_TESTS[0]); ++i) {",
      "path": "src/tests.c",
      "position": null,
      "original_position": 32,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "b4387056a50fabc5a36c092a522636b032d4b378",
      "in_reply_to_id": 1059346476,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added an unsigned one.",
      "created_at": "2022-12-30T22:00:15Z",
      "updated_at": "2022-12-30T22:00:15Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1059530254",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1059530254"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2219,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102279813",
      "pull_request_review_id": 1292383681,
      "id": 1102279813,
      "node_id": "PRRC_kwDOAP4Jqs5Bs3SF",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 208,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "~~q1, q2~~ s1, s2",
      "created_at": "2023-02-10T05:10:24Z",
      "updated_at": "2023-02-10T05:10:24Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1102279813",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102279813"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 115,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 116,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102294858",
      "pull_request_review_id": 1292405565,
      "id": 1102294858,
      "node_id": "PRRC_kwDOAP4Jqs5Bs69K",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * The make it work, we apply the corrections to the input scalar, including the division by\n+     * two, before calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128-1 to s1 and s2 after splitting to make sure we end up with positive scalars.\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda((q + k) / 2 mod n)\n+     *   - Let v1 = s1 + 2^128 - 1\n+     *   - Let v2 = s2 + 2^128 - 1\n+     *   - Let R1 = C_l(v1, A)\n+     *   - Let R2 = C_l(v2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * l will thus need to be at least 129, but we may overshoot by a few bits (see\n+     * further), so keep it as a variable.\n+     *\n+     * To solve for k, we reason:\n+     *     q*A = R1 + R2\n+     * <=> q*A = C_l(s1 + 2^128 - 1, A) + C_l(s2 + 2^128 - 1, lambda*A)\n+     * <=> q*A = (2*(s1 + 2^128 - 1) + 1 - 2^l) * A + (2*(s2 + 2^128 - 1) + 1 - 2^l) * lambda*A\n+     * <=> q*A = (2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda)) * A\n+     * <=> q   = 2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = 2*(q + k) / 2 + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = q + k + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> k   = (2^l + 1 - 2^129)*(1 + lambda) mod n\n+     *\n+     * We will process the computation of C_l and C_l in groups of ECMULT_CONST_GROUP_SIZE, so we\n+     * set l to the smallest multiple of ECMULT_CONST_GROUP_SIZE that is not less than 129; this\n+     * equals ECMULT_CONST_BITS.\n+     *\n+     * All together, that means k = (2^ECMULT_CONST_BITS + 1 - 2^129) * (1 + lambda) (mod order).\n+     */\n \n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar, int size) {\n-    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    secp256k1_ge tmpa;\n+    /* The offset to add to s1 and s2 to make them positive. Equal to 2^128 - 1. */\n+    static const secp256k1_scalar S_OFFSET = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful);",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 246,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It seems 2^128 would work just as well for the offset. Is it easier to just add 1 to bit 128 than keep this offset around?",
      "created_at": "2023-02-10T05:43:37Z",
      "updated_at": "2023-02-10T05:43:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1102294858",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102294858"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 150,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102302801",
      "pull_request_review_id": 1292417665,
      "id": 1102302801,
      "node_id": "PRRC_kwDOAP4Jqs5Bs85R",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * The make it work, we apply the corrections to the input scalar, including the division by",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "~The~ To make it work...",
      "created_at": "2023-02-10T05:58:52Z",
      "updated_at": "2023-02-10T05:58:52Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1102302801",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102302801"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102304254",
      "pull_request_review_id": 1292420305,
      "id": 1102304254,
      "node_id": "PRRC_kwDOAP4Jqs5Bs9P-",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * The make it work, we apply the corrections to the input scalar, including the division by\n+     * two, before calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128-1 to s1 and s2 after splitting to make sure we end up with positive scalars.",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 212,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I guess we technically want \"non-negative\" scalars (or rephrase as \"to make sure neither are negative\").\r\n",
      "created_at": "2023-02-10T06:01:27Z",
      "updated_at": "2023-02-10T06:01:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1102304254",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102304254"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102306814",
      "pull_request_review_id": 1292426271,
      "id": 1102306814,
      "node_id": "PRRC_kwDOAP4Jqs5Bs93-",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * The make it work, we apply the corrections to the input scalar, including the division by\n+     * two, before calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128-1 to s1 and s2 after splitting to make sure we end up with positive scalars.\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda((q + k) / 2 mod n)\n+     *   - Let v1 = s1 + 2^128 - 1\n+     *   - Let v2 = s2 + 2^128 - 1\n+     *   - Let R1 = C_l(v1, A)\n+     *   - Let R2 = C_l(v2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * l will thus need to be at least 129, but we may overshoot by a few bits (see\n+     * further), so keep it as a variable.\n+     *\n+     * To solve for k, we reason:\n+     *     q*A = R1 + R2\n+     * <=> q*A = C_l(s1 + 2^128 - 1, A) + C_l(s2 + 2^128 - 1, lambda*A)\n+     * <=> q*A = (2*(s1 + 2^128 - 1) + 1 - 2^l) * A + (2*(s2 + 2^128 - 1) + 1 - 2^l) * lambda*A\n+     * <=> q*A = (2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda)) * A\n+     * <=> q   = 2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = 2*(q + k) / 2 + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = q + k + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> k   = (2^l + 1 - 2^129)*(1 + lambda) mod n\n+     *\n+     * We will process the computation of C_l and C_l in groups of ECMULT_CONST_GROUP_SIZE, so we",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 235,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should this say \"C_l(v1, A) and C_l(v2, lambda*A)\"?",
      "created_at": "2023-02-10T06:06:04Z",
      "updated_at": "2023-02-10T06:06:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1102306814",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102306814"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102321936",
      "pull_request_review_id": 1292452307,
      "id": 1102321936,
      "node_id": "PRRC_kwDOAP4Jqs5BtBkQ",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * The make it work, we apply the corrections to the input scalar, including the division by\n+     * two, before calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128-1 to s1 and s2 after splitting to make sure we end up with positive scalars.\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda((q + k) / 2 mod n)\n+     *   - Let v1 = s1 + 2^128 - 1\n+     *   - Let v2 = s2 + 2^128 - 1\n+     *   - Let R1 = C_l(v1, A)\n+     *   - Let R2 = C_l(v2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * l will thus need to be at least 129, but we may overshoot by a few bits (see\n+     * further), so keep it as a variable.\n+     *\n+     * To solve for k, we reason:\n+     *     q*A = R1 + R2\n+     * <=> q*A = C_l(s1 + 2^128 - 1, A) + C_l(s2 + 2^128 - 1, lambda*A)\n+     * <=> q*A = (2*(s1 + 2^128 - 1) + 1 - 2^l) * A + (2*(s2 + 2^128 - 1) + 1 - 2^l) * lambda*A\n+     * <=> q*A = (2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda)) * A\n+     * <=> q   = 2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = 2*(q + k) / 2 + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = q + k + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> k   = (2^l + 1 - 2^129)*(1 + lambda) mod n\n+     *\n+     * We will process the computation of C_l and C_l in groups of ECMULT_CONST_GROUP_SIZE, so we\n+     * set l to the smallest multiple of ECMULT_CONST_GROUP_SIZE that is not less than 129; this\n+     * equals ECMULT_CONST_BITS.\n+     *\n+     * All together, that means k = (2^ECMULT_CONST_BITS + 1 - 2^129) * (1 + lambda) (mod order).\n+     */\n \n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar, int size) {\n-    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    secp256k1_ge tmpa;\n+    /* The offset to add to s1 and s2 to make them positive. Equal to 2^128 - 1. */\n+    static const secp256k1_scalar S_OFFSET = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful);",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 246,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": 1102294858,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also ~~positive~~ non-negative here.",
      "created_at": "2023-02-10T06:25:59Z",
      "updated_at": "2023-02-10T06:25:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1102321936",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1102321936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 150,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103294410",
      "pull_request_review_id": 1294106243,
      "id": 1103294410,
      "node_id": "PRRC_kwDOAP4Jqs5Bwu_K",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 208,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": 1102279813,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-02-10T21:58:05Z",
      "updated_at": "2023-02-10T21:58:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1103294410",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103294410"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 115,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 116,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103294492",
      "pull_request_review_id": 1294106476,
      "id": 1103294492,
      "node_id": "PRRC_kwDOAP4Jqs5BwvAc",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * The make it work, we apply the corrections to the input scalar, including the division by\n+     * two, before calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128-1 to s1 and s2 after splitting to make sure we end up with positive scalars.\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda((q + k) / 2 mod n)\n+     *   - Let v1 = s1 + 2^128 - 1\n+     *   - Let v2 = s2 + 2^128 - 1\n+     *   - Let R1 = C_l(v1, A)\n+     *   - Let R2 = C_l(v2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * l will thus need to be at least 129, but we may overshoot by a few bits (see\n+     * further), so keep it as a variable.\n+     *\n+     * To solve for k, we reason:\n+     *     q*A = R1 + R2\n+     * <=> q*A = C_l(s1 + 2^128 - 1, A) + C_l(s2 + 2^128 - 1, lambda*A)\n+     * <=> q*A = (2*(s1 + 2^128 - 1) + 1 - 2^l) * A + (2*(s2 + 2^128 - 1) + 1 - 2^l) * lambda*A\n+     * <=> q*A = (2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda)) * A\n+     * <=> q   = 2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = 2*(q + k) / 2 + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = q + k + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> k   = (2^l + 1 - 2^129)*(1 + lambda) mod n\n+     *\n+     * We will process the computation of C_l and C_l in groups of ECMULT_CONST_GROUP_SIZE, so we\n+     * set l to the smallest multiple of ECMULT_CONST_GROUP_SIZE that is not less than 129; this\n+     * equals ECMULT_CONST_BITS.\n+     *\n+     * All together, that means k = (2^ECMULT_CONST_BITS + 1 - 2^129) * (1 + lambda) (mod order).\n+     */\n \n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar, int size) {\n-    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    secp256k1_ge tmpa;\n+    /* The offset to add to s1 and s2 to make them positive. Equal to 2^128 - 1. */\n+    static const secp256k1_scalar S_OFFSET = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful);",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 246,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": 1102294858,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-02-10T21:58:13Z",
      "updated_at": "2023-02-10T21:58:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1103294492",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103294492"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 150,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103294552",
      "pull_request_review_id": 1294106656,
      "id": 1103294552,
      "node_id": "PRRC_kwDOAP4Jqs5BwvBY",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * The make it work, we apply the corrections to the input scalar, including the division by",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 210,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": 1102302801,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-02-10T21:58:19Z",
      "updated_at": "2023-02-10T21:58:19Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1103294552",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103294552"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103294644",
      "pull_request_review_id": 1294106971,
      "id": 1103294644,
      "node_id": "PRRC_kwDOAP4Jqs5BwvC0",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * The make it work, we apply the corrections to the input scalar, including the division by\n+     * two, before calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128-1 to s1 and s2 after splitting to make sure we end up with positive scalars.",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 212,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": 1102304254,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-02-10T21:58:30Z",
      "updated_at": "2023-02-10T21:58:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1103294644",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103294644"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103294704",
      "pull_request_review_id": 1294107171,
      "id": 1103294704,
      "node_id": "PRRC_kwDOAP4Jqs5BwvDw",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * The make it work, we apply the corrections to the input scalar, including the division by\n+     * two, before calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128-1 to s1 and s2 after splitting to make sure we end up with positive scalars.\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda((q + k) / 2 mod n)\n+     *   - Let v1 = s1 + 2^128 - 1\n+     *   - Let v2 = s2 + 2^128 - 1\n+     *   - Let R1 = C_l(v1, A)\n+     *   - Let R2 = C_l(v2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * l will thus need to be at least 129, but we may overshoot by a few bits (see\n+     * further), so keep it as a variable.\n+     *\n+     * To solve for k, we reason:\n+     *     q*A = R1 + R2\n+     * <=> q*A = C_l(s1 + 2^128 - 1, A) + C_l(s2 + 2^128 - 1, lambda*A)\n+     * <=> q*A = (2*(s1 + 2^128 - 1) + 1 - 2^l) * A + (2*(s2 + 2^128 - 1) + 1 - 2^l) * lambda*A\n+     * <=> q*A = (2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda)) * A\n+     * <=> q   = 2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = 2*(q + k) / 2 + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = q + k + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> k   = (2^l + 1 - 2^129)*(1 + lambda) mod n\n+     *\n+     * We will process the computation of C_l and C_l in groups of ECMULT_CONST_GROUP_SIZE, so we",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 235,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": 1102306814,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-02-10T21:58:36Z",
      "updated_at": "2023-02-10T21:58:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1103294704",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103294704"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103296437",
      "pull_request_review_id": 1294112089,
      "id": 1103296437,
      "node_id": "PRRC_kwDOAP4Jqs5Bwve1",
      "diff_hunk": "@@ -12,220 +12,242 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit positive integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while q1 and q2 are small-range numbers, (q1 + 2^256 - 1) / 2 mod n\n+     * and (q2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * The make it work, we apply the corrections to the input scalar, including the division by\n+     * two, before calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128-1 to s1 and s2 after splitting to make sure we end up with positive scalars.\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda((q + k) / 2 mod n)\n+     *   - Let v1 = s1 + 2^128 - 1\n+     *   - Let v2 = s2 + 2^128 - 1\n+     *   - Let R1 = C_l(v1, A)\n+     *   - Let R2 = C_l(v2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * l will thus need to be at least 129, but we may overshoot by a few bits (see\n+     * further), so keep it as a variable.\n+     *\n+     * To solve for k, we reason:\n+     *     q*A = R1 + R2\n+     * <=> q*A = C_l(s1 + 2^128 - 1, A) + C_l(s2 + 2^128 - 1, lambda*A)\n+     * <=> q*A = (2*(s1 + 2^128 - 1) + 1 - 2^l) * A + (2*(s2 + 2^128 - 1) + 1 - 2^l) * lambda*A\n+     * <=> q*A = (2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda)) * A\n+     * <=> q   = 2*(s1 + s2*lambda) + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = 2*(q + k) / 2 + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> q   = q + k + (2^129 - 1 - 2^l)*(1 + lambda) mod n\n+     * <=> k   = (2^l + 1 - 2^129)*(1 + lambda) mod n\n+     *\n+     * We will process the computation of C_l and C_l in groups of ECMULT_CONST_GROUP_SIZE, so we\n+     * set l to the smallest multiple of ECMULT_CONST_GROUP_SIZE that is not less than 129; this\n+     * equals ECMULT_CONST_BITS.\n+     *\n+     * All together, that means k = (2^ECMULT_CONST_BITS + 1 - 2^129) * (1 + lambda) (mod order).\n+     */\n \n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar, int size) {\n-    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    secp256k1_ge tmpa;\n+    /* The offset to add to s1 and s2 to make them positive. Equal to 2^128 - 1. */\n+    static const secp256k1_scalar S_OFFSET = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0xfffffffful, 0xfffffffful, 0xfffffffful, 0xfffffffful);",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 246,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "1c48861222a2293185529ce354f2f27d5d83a4d7",
      "in_reply_to_id": 1102294858,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We don't have scalar code to add just one bit (except `secp256k1_scalar_cadd_bit`, but that doesn't permit overflow), so there is little to gain from using $2^{128}$ instead, I think.\r\n\r\nArguably we could use the exact bounds for the lambda splitting too (see `secp256k1_scalar_split_lambda_verify`).",
      "created_at": "2023-02-10T22:01:23Z",
      "updated_at": "2023-02-10T22:01:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1103296437",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103296437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 150,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103664830",
      "pull_request_review_id": 1294587267,
      "id": 1103664830,
      "node_id": "PRRC_kwDOAP4Jqs5ByJa-",
      "diff_hunk": "@@ -12,220 +12,244 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while s1 and s2 are small-range numbers, (s1 + 2^256 - 1) / 2 mod n\n+     * and (s2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * To make it work, we apply the corrections to the input scalar, including the division by\n+     * two, *before* calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128 to s1 and s2 after splitting to make sure we end up with non-negative scalars\n+     * (a slightly smaller offset would work due to the bounds on the split, but we pick 2^128\n+     * for simplicity).\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda((q + k) / 2 mod n)",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 217,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "dd21e2c5ca2f9e76a2d2717c26a83f6ab4d2651f",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's a bit jarring to see the form of the solution magically appear here as (q + k)/2 mod n. It could just be 't' (or 'f(q)') and the derivation below works out fine, but without the leap.",
      "created_at": "2023-02-11T17:07:01Z",
      "updated_at": "2023-02-11T17:07:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1103664830",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103664830"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103673032",
      "pull_request_review_id": 1294598462,
      "id": 1103673032,
      "node_id": "PRRC_kwDOAP4Jqs5ByLbI",
      "diff_hunk": "@@ -12,220 +12,244 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while s1 and s2 are small-range numbers, (s1 + 2^256 - 1) / 2 mod n\n+     * and (s2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * To make it work, we apply the corrections to the input scalar, including the division by\n+     * two, *before* calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128 to s1 and s2 after splitting to make sure we end up with non-negative scalars\n+     * (a slightly smaller offset would work due to the bounds on the split, but we pick 2^128\n+     * for simplicity).\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda((q + k) / 2 mod n)\n+     *   - Let v1 = s1 + 2^128\n+     *   - Let v2 = s2 + 2^128",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 219,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "dd21e2c5ca2f9e76a2d2717c26a83f6ab4d2651f",
      "in_reply_to_id": null,
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I kinda feel like these should say \"mod n\", but it's not quite clear. `Let R1 = C_256((s1 + 2^256 - 1) / 2, A)` implies that s1 is a 256-bit value so for v1 to become small enough for the following C_l presumably the mod is needed.",
      "created_at": "2023-02-11T18:03:33Z",
      "updated_at": "2023-02-11T18:03:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1103673032",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103673032"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 126,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103728572",
      "pull_request_review_id": 1294649348,
      "id": 1103728572,
      "node_id": "PRRC_kwDOAP4Jqs5ByY-8",
      "diff_hunk": "@@ -12,220 +12,244 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while s1 and s2 are small-range numbers, (s1 + 2^256 - 1) / 2 mod n\n+     * and (s2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * To make it work, we apply the corrections to the input scalar, including the division by\n+     * two, *before* calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128 to s1 and s2 after splitting to make sure we end up with non-negative scalars\n+     * (a slightly smaller offset would work due to the bounds on the split, but we pick 2^128\n+     * for simplicity).\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda((q + k) / 2 mod n)",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 217,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "dd21e2c5ca2f9e76a2d2717c26a83f6ab4d2651f",
      "in_reply_to_id": 1103664830,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good idea, that's a lot easier to follow I imagine. Done.",
      "created_at": "2023-02-12T03:23:38Z",
      "updated_at": "2023-02-12T03:23:38Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1103728572",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103728572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103728778",
      "pull_request_review_id": 1294649460,
      "id": 1103728778,
      "node_id": "PRRC_kwDOAP4Jqs5ByZCK",
      "diff_hunk": "@@ -12,220 +12,244 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n-\n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * signed-digit multi-comb algorithm for multiplication with a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization; the idea that a scalar\n+     * a can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while s1 and s2 are small-range numbers, (s1 + 2^256 - 1) / 2 mod n\n+     * and (s2 + 2^256 - 1) / 2 mod n are not, undoing the benefit of the splitting.\n+     *\n+     * To make it work, we apply the corrections to the input scalar, including the division by\n+     * two, *before* calling split_lambda. Let's introduce an offset k, and solve for it. We also\n+     * add 2^128 to s1 and s2 after splitting to make sure we end up with non-negative scalars\n+     * (a slightly smaller offset would work due to the bounds on the split, but we pick 2^128\n+     * for simplicity).\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda((q + k) / 2 mod n)\n+     *   - Let v1 = s1 + 2^128\n+     *   - Let v2 = s2 + 2^128",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 219,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "dd21e2c5ca2f9e76a2d2717c26a83f6ab4d2651f",
      "in_reply_to_id": 1103673032,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It really depends on whether we think of $s_1$ and $s_2$ as integers (in range $(-2^{128},2^{128})$, or as scalars (either in range $(n-2^{128},n]$ or in range $[0,2^{128})$ ).\r\n\r\nThe code more closely matches the split-range behavior, so I've added `mod n`.",
      "created_at": "2023-02-12T03:26:17Z",
      "updated_at": "2023-02-12T03:26:17Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1103728778",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1103728778"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 126,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230108926",
      "pull_request_review_id": 1480211773,
      "id": 1230108926,
      "node_id": "PRRC_kwDOAP4Jqs5JUfj-",
      "diff_hunk": "@@ -12,208 +12,251 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 183,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "f22eb66c078790d075e10c4895e6eaf62e78c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n     * Then it holds that C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\r\n```",
      "created_at": "2023-06-14T20:08:25Z",
      "updated_at": "2023-06-15T13:48:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1230108926",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230108926"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230109130",
      "pull_request_review_id": 1480211773,
      "id": 1230109130,
      "node_id": "PRRC_kwDOAP4Jqs5JUfnK",
      "diff_hunk": "@@ -12,208 +12,251 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 72,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "f22eb66c078790d075e10c4895e6eaf62e78c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    /* The index is computed by looking the bottom bits, after making positive. */ \\\r\n```",
      "created_at": "2023-06-14T20:08:39Z",
      "updated_at": "2023-06-15T13:48:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1230109130",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230109130"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230109862",
      "pull_request_review_id": 1480211773,
      "id": 1230109862,
      "node_id": "PRRC_kwDOAP4Jqs5JUfym",
      "diff_hunk": "@@ -12,208 +12,251 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * paper's signed-digit multi-comb algorithm for multiplication using a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization: the idea that a scalar\n+     * s can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while s1 and s2 are small-range numbers, (s1 + 2^256 - 1) / 2 (mod n)\n+     * and (s2 + 2^256 - 1) / 2 (mod n) are not, undoing the benefit of the splitting.\n+     *\n+     * To make it work, we want to modify the input scalar q first, before splitting, and then only\n+     * add a 2^128 offset of the split results (so that they end up in the single 129-bit range\n+     * [0,2^129]). A slightly smaller offset would work due to the bounds on the split, but we pick\n+     * 2^128 for simplicity. Let s be the scalar fed to split_lambda, and f(q) the function to\n+     * compute it from q:\n+     *\n+     *   To compute q*A:\n+     *   - Compute s = f(q)\n+     *   - Let s1, s2 = split_lambda(s)\n+     *   - Let v1 = s1 + 2^128 (mod n)\n+     *   - Let v2 = s2 + 2^128 (mod n)\n+     *   - Let R1 = C_l(v1, A)\n+     *   - Let R2 = C_l(v2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * l will thus need to be at least 129, but we may overshoot by a few bits (see\n+     * further), so keep it as a variable.\n+     *\n+     * To solve for s, we reason:\n+     *     q*A  = R1 + R2\n+     * <=> q*A  = C_l(s1 + 2^128, A) + C_l(s2 + 2^128, lambda*A)\n+     * <=> q*A  = (2*(s1 + 2^128) + 1 - 2^l) * A + (2*(s2 + 2^128) + 1 - 2^l) * lambda*A\n+     * <=> q*A  = (2*(s1 + s2*lambda) + (2^129 + 1 - 2^l) * (1 + lambda)) * A\n+     * <=> q    = 2*(s1 + s2*lambda) + (2^129 + 1 - 2^l) * (1 + lambda) (mod n)\n+     * <=> q    = 2*s + (2^129 + 1 - 2^l) * (1 + lambda) (mod n)\n+     * <=> s    = (q + (2^l - 2^129 - 1) * (1 + lambda)) / 2 (mod n)\n+     * <=> f(q) = (q + K) / 2 (mod n)\n+     *            where K = (2^l - 2^129 - 1)*(1 + lambda) (mod n)\n+     *\n+     * We will process the computation of C_l(v1, A) and C_l(v2, lambda*A) in groups of\n+     * ECMULT_CONST_GROUP_SIZE, so we set l to the smallest multiple of ECMULT_CONST_GROUP_SIZE\n+     * that is not less than 129; this equals ECMULT_CONST_BITS.\n+     */\n \n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+    /* The offset to add to s1 and s2 to make them non-negative. Equal to 2^128. */\n+    static const secp256k1_scalar S_OFFSET = SECP256K1_SCALAR_CONST(0, 0, 0, 1, 0, 0, 0, 0);\n+\n+    /* For K, we have several precomputed formulas/constants.\n+     * - in exhaustive test mode, we give an explicit expression to compute it at compile time: */\n+#ifdef EXHAUSTIVE_TEST_ORDER\n+    static const secp256k1_scalar K = ((SECP256K1_SCALAR_CONST(0, 0, 0, (1U << (ECMULT_CONST_BITS - 128)) - 2U, 0, 0, 0, 0) + EXHAUSTIVE_TEST_ORDER - 1U) * (1U + EXHAUSTIVE_TEST_LAMBDA)) % EXHAUSTIVE_TEST_ORDER;\n+    /* - for the real secp256k1 group we have constants for various ECMULT_CONST_BITS values. */\n+#elif ECMULT_CONST_BITS == 129\n+    /* For GROUP_SIZE = 1,3. */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0xac9c52b3ul, 0x3fa3cf1ful, 0x5ad9e3fdul, 0x77ed9ba4ul, 0xa880b9fcul, 0x8ec739c2ul, 0xe0cfc810ul, 0xb51283ceul);\n+#elif ECMULT_CONST_BITS == 130\n+    /* For GROUP_SIZE = 2,5. */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0xa4e88a7dul, 0xcb13034eul, 0xc2bdd6bful, 0x7c118d6bul, 0x589ae848ul, 0x26ba29e4ul, 0xb5c2c1dcul, 0xde9798d9ul);\n+#elif ECMULT_CONST_BITS == 132\n+    /* For GROUP_SIZE = 4,6 */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0x76b1d93dul, 0x0fae3c6bul, 0x3215874bul, 0x94e93813ul, 0x7937fe0dul, 0xb66bcaaful, 0xb3749ca5ul, 0xd7b6171b);\n+#else\n+#  error \"Unknown ECMULT_CONST_BITS\"\n+#endif\n \n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar) {\n-    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    secp256k1_ge tmpa;\n+    secp256k1_scalar s, v1, v2;\n+    secp256k1_ge pre_a[ECMULT_CONST_TABLE_SIZE];\n+    secp256k1_ge pre_a_lam[ECMULT_CONST_TABLE_SIZE];\n     secp256k1_fe Z;\n-\n-    int skew_1;\n-    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n-    int skew_lam;\n-    secp256k1_scalar q_1, q_lam;\n-    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n-\n-    int i;\n-\n+    secp256k1_gej res;\n+    int group, i;\n+\n+    /* Compute v1 and v2. */\n+    secp256k1_scalar_add(&s, q, &K);\n+    secp256k1_scalar_half(&s, &s);\n+    secp256k1_scalar_split_lambda(&v1, &v2, &s);\n+    secp256k1_scalar_add(&v1, &v1, &S_OFFSET);\n+    secp256k1_scalar_add(&v2, &v2, &S_OFFSET);\n+\n+    /* We're allowed to be non-constant time in the point, and the code below (in particular,\n+     * secp256k1_ecmult_const_odd_multiples_table_globalz) cannot deal with infinity in a\n+     * constant-time manner anyway. */\n     if (secp256k1_ge_is_infinity(a)) {\n         secp256k1_gej_set_infinity(r);\n         return;\n     }\n \n-    /* build wnaf representation for q. */\n-    /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n-    secp256k1_scalar_split_lambda(&q_1, &q_lam, scalar);\n-    skew_1   = secp256k1_wnaf_const(wnaf_1,   &q_1,   WINDOW_A - 1, 128);\n-    skew_lam = secp256k1_wnaf_const(wnaf_lam, &q_lam, WINDOW_A - 1, 128);\n+#ifdef VERIFY\n+    /* Verify that v1 and v2 are in range [0, 2^129-1]. */\n+    for (i = 129; i < 256; ++i) {\n+        VERIFY_CHECK(secp256k1_scalar_get_bits(&v1, i, 1) == 0);\n+        VERIFY_CHECK(secp256k1_scalar_get_bits(&v2, i, 1) == 0);\n+    }\n+#endif\n \n-    /* Calculate odd multiples of a.\n+    /* Calculate odd multiples of A and A*lambda.\n      * All multiples are brought to the same Z 'denominator', which is stored\n      * in Z. Due to secp256k1' isomorphism we can do all operations pretending\n      * that the Z coordinate was 1, use affine addition formulae, and correct\n      * the Z coordinate of the result once at the end.\n      */\n-    VERIFY_CHECK(!a->infinity);\n-    secp256k1_gej_set_ge(r, a);\n-    secp256k1_ecmult_odd_multiples_table_globalz_windowa(pre_a, &Z, r);\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n+    secp256k1_gej_set_ge(&res, a);\n+    secp256k1_ecmult_const_odd_multiples_table_globalz(pre_a, &Z, &res);\n+    for (i = 0; i < ECMULT_CONST_TABLE_SIZE; i++) {\n         secp256k1_fe_normalize_weak(&pre_a[i].y);\n-    }\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n         secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n     }\n \n-    /* first loop iteration (separated out so we can directly set r, rather\n-     * than having it start at infinity, get doubled several times, then have\n-     * its new value added to it) */\n-    i = wnaf_1[WNAF_SIZE_BITS(128, WINDOW_A - 1)];\n-    VERIFY_CHECK(i != 0);\n-    ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n-    secp256k1_gej_set_ge(r, &tmpa);\n-    i = wnaf_lam[WNAF_SIZE_BITS(128, WINDOW_A - 1)];\n-    VERIFY_CHECK(i != 0);\n-    ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n-    secp256k1_gej_add_ge(r, r, &tmpa);\n-    /* remaining loop iterations */\n-    for (i = WNAF_SIZE_BITS(128, WINDOW_A - 1) - 1; i >= 0; i--) {\n-        int n;\n-        int j;\n-        for (j = 0; j < WINDOW_A - 1; ++j) {\n-            secp256k1_gej_double(r, r);\n-        }\n+    /* Next, we compute res = C_l(v1, A) + C_l(v2, lambda*A).\n+     *\n+     * We proceed in groups of ECMULT_CONST_GROUP_SIZE bits, operating on that many bits\n+     * at a time, from high in v1/v2 to low. Call these bits1 (from v1) and bits2 (from v2).\n+     *\n+     * Now note that ECMULT_CONST_TABLE_GET_GE(&t, pre_a, bits1) loads into t a point equal\n+     * to C_{ECMULT_CONST_GROUP_SIZE}(bits, A), and analogously for pre_lam_a / bits2.",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 356,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "f22eb66c078790d075e10c4895e6eaf62e78c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n     * to C_{ECMULT_CONST_GROUP_SIZE}(bits1, A), and analogously for pre_lam_a / bits2.\r\n```",
      "created_at": "2023-06-14T20:09:25Z",
      "updated_at": "2023-06-15T13:48:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1230109862",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230109862"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230547315",
      "pull_request_review_id": 1480211773,
      "id": 1230547315,
      "node_id": "PRRC_kwDOAP4Jqs5JWKlz",
      "diff_hunk": "@@ -12,208 +12,251 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * paper's signed-digit multi-comb algorithm for multiplication using a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization: the idea that a scalar\n+     * s can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while s1 and s2 are small-range numbers, (s1 + 2^256 - 1) / 2 (mod n)\n+     * and (s2 + 2^256 - 1) / 2 (mod n) are not, undoing the benefit of the splitting.\n+     *\n+     * To make it work, we want to modify the input scalar q first, before splitting, and then only\n+     * add a 2^128 offset of the split results (so that they end up in the single 129-bit range\n+     * [0,2^129]). A slightly smaller offset would work due to the bounds on the split, but we pick\n+     * 2^128 for simplicity. Let s be the scalar fed to split_lambda, and f(q) the function to\n+     * compute it from q:\n+     *\n+     *   To compute q*A:\n+     *   - Compute s = f(q)\n+     *   - Let s1, s2 = split_lambda(s)\n+     *   - Let v1 = s1 + 2^128 (mod n)\n+     *   - Let v2 = s2 + 2^128 (mod n)\n+     *   - Let R1 = C_l(v1, A)\n+     *   - Let R2 = C_l(v2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * l will thus need to be at least 129, but we may overshoot by a few bits (see\n+     * further), so keep it as a variable.\n+     *\n+     * To solve for s, we reason:\n+     *     q*A  = R1 + R2\n+     * <=> q*A  = C_l(s1 + 2^128, A) + C_l(s2 + 2^128, lambda*A)\n+     * <=> q*A  = (2*(s1 + 2^128) + 1 - 2^l) * A + (2*(s2 + 2^128) + 1 - 2^l) * lambda*A\n+     * <=> q*A  = (2*(s1 + s2*lambda) + (2^129 + 1 - 2^l) * (1 + lambda)) * A\n+     * <=> q    = 2*(s1 + s2*lambda) + (2^129 + 1 - 2^l) * (1 + lambda) (mod n)\n+     * <=> q    = 2*s + (2^129 + 1 - 2^l) * (1 + lambda) (mod n)\n+     * <=> s    = (q + (2^l - 2^129 - 1) * (1 + lambda)) / 2 (mod n)\n+     * <=> f(q) = (q + K) / 2 (mod n)\n+     *            where K = (2^l - 2^129 - 1)*(1 + lambda) (mod n)\n+     *\n+     * We will process the computation of C_l(v1, A) and C_l(v2, lambda*A) in groups of\n+     * ECMULT_CONST_GROUP_SIZE, so we set l to the smallest multiple of ECMULT_CONST_GROUP_SIZE\n+     * that is not less than 129; this equals ECMULT_CONST_BITS.\n+     */\n \n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+    /* The offset to add to s1 and s2 to make them non-negative. Equal to 2^128. */\n+    static const secp256k1_scalar S_OFFSET = SECP256K1_SCALAR_CONST(0, 0, 0, 1, 0, 0, 0, 0);\n+\n+    /* For K, we have several precomputed formulas/constants.\n+     * - in exhaustive test mode, we give an explicit expression to compute it at compile time: */\n+#ifdef EXHAUSTIVE_TEST_ORDER\n+    static const secp256k1_scalar K = ((SECP256K1_SCALAR_CONST(0, 0, 0, (1U << (ECMULT_CONST_BITS - 128)) - 2U, 0, 0, 0, 0) + EXHAUSTIVE_TEST_ORDER - 1U) * (1U + EXHAUSTIVE_TEST_LAMBDA)) % EXHAUSTIVE_TEST_ORDER;\n+    /* - for the real secp256k1 group we have constants for various ECMULT_CONST_BITS values. */\n+#elif ECMULT_CONST_BITS == 129\n+    /* For GROUP_SIZE = 1,3. */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0xac9c52b3ul, 0x3fa3cf1ful, 0x5ad9e3fdul, 0x77ed9ba4ul, 0xa880b9fcul, 0x8ec739c2ul, 0xe0cfc810ul, 0xb51283ceul);\n+#elif ECMULT_CONST_BITS == 130\n+    /* For GROUP_SIZE = 2,5. */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0xa4e88a7dul, 0xcb13034eul, 0xc2bdd6bful, 0x7c118d6bul, 0x589ae848ul, 0x26ba29e4ul, 0xb5c2c1dcul, 0xde9798d9ul);\n+#elif ECMULT_CONST_BITS == 132\n+    /* For GROUP_SIZE = 4,6 */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0x76b1d93dul, 0x0fae3c6bul, 0x3215874bul, 0x94e93813ul, 0x7937fe0dul, 0xb66bcaaful, 0xb3749ca5ul, 0xd7b6171b);\n+#else\n+#  error \"Unknown ECMULT_CONST_BITS\"\n+#endif\n \n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar) {\n-    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    secp256k1_ge tmpa;\n+    secp256k1_scalar s, v1, v2;\n+    secp256k1_ge pre_a[ECMULT_CONST_TABLE_SIZE];\n+    secp256k1_ge pre_a_lam[ECMULT_CONST_TABLE_SIZE];\n     secp256k1_fe Z;\n-\n-    int skew_1;\n-    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n-    int skew_lam;\n-    secp256k1_scalar q_1, q_lam;\n-    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n-\n-    int i;\n-\n+    secp256k1_gej res;\n+    int group, i;\n+\n+    /* Compute v1 and v2. */\n+    secp256k1_scalar_add(&s, q, &K);\n+    secp256k1_scalar_half(&s, &s);\n+    secp256k1_scalar_split_lambda(&v1, &v2, &s);\n+    secp256k1_scalar_add(&v1, &v1, &S_OFFSET);\n+    secp256k1_scalar_add(&v2, &v2, &S_OFFSET);\n+\n+    /* We're allowed to be non-constant time in the point, and the code below (in particular,\n+     * secp256k1_ecmult_const_odd_multiples_table_globalz) cannot deal with infinity in a\n+     * constant-time manner anyway. */\n     if (secp256k1_ge_is_infinity(a)) {\n         secp256k1_gej_set_infinity(r);\n         return;\n     }\n \n-    /* build wnaf representation for q. */\n-    /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n-    secp256k1_scalar_split_lambda(&q_1, &q_lam, scalar);\n-    skew_1   = secp256k1_wnaf_const(wnaf_1,   &q_1,   WINDOW_A - 1, 128);\n-    skew_lam = secp256k1_wnaf_const(wnaf_lam, &q_lam, WINDOW_A - 1, 128);\n+#ifdef VERIFY\n+    /* Verify that v1 and v2 are in range [0, 2^129-1]. */\n+    for (i = 129; i < 256; ++i) {\n+        VERIFY_CHECK(secp256k1_scalar_get_bits(&v1, i, 1) == 0);\n+        VERIFY_CHECK(secp256k1_scalar_get_bits(&v2, i, 1) == 0);\n+    }\n+#endif\n \n-    /* Calculate odd multiples of a.\n+    /* Calculate odd multiples of A and A*lambda.\n      * All multiples are brought to the same Z 'denominator', which is stored\n      * in Z. Due to secp256k1' isomorphism we can do all operations pretending\n      * that the Z coordinate was 1, use affine addition formulae, and correct\n      * the Z coordinate of the result once at the end.\n      */\n-    VERIFY_CHECK(!a->infinity);\n-    secp256k1_gej_set_ge(r, a);\n-    secp256k1_ecmult_odd_multiples_table_globalz_windowa(pre_a, &Z, r);\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n+    secp256k1_gej_set_ge(&res, a);\n+    secp256k1_ecmult_const_odd_multiples_table_globalz(pre_a, &Z, &res);\n+    for (i = 0; i < ECMULT_CONST_TABLE_SIZE; i++) {\n         secp256k1_fe_normalize_weak(&pre_a[i].y);",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 326,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "f22eb66c078790d075e10c4895e6eaf62e78c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why `normalize_weak` here? As far as I can see, `pre_a[i].y` already has magnitude 1.",
      "created_at": "2023-06-15T07:15:34Z",
      "updated_at": "2023-06-15T13:48:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1230547315",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1230547315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1231038381",
      "pull_request_review_id": 1480211773,
      "id": 1231038381,
      "node_id": "PRRC_kwDOAP4Jqs5JYCet",
      "diff_hunk": "@@ -12,208 +12,251 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 73,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "f22eb66c078790d075e10c4895e6eaf62e78c2dc",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Wow, that this is quite a non-obvious way to get the index (but straightforward to see that it works).",
      "created_at": "2023-06-15T13:42:41Z",
      "updated_at": "2023-06-15T13:48:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1231038381",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1231038381"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 63,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235796041",
      "pull_request_review_id": 1488970859,
      "id": 1235796041,
      "node_id": "PRRC_kwDOAP4Jqs5JqMBJ",
      "diff_hunk": "@@ -12,208 +12,251 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * paper's signed-digit multi-comb algorithm for multiplication using a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization: the idea that a scalar\n+     * s can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while s1 and s2 are small-range numbers, (s1 + 2^256 - 1) / 2 (mod n)\n+     * and (s2 + 2^256 - 1) / 2 (mod n) are not, undoing the benefit of the splitting.\n+     *\n+     * To make it work, we want to modify the input scalar q first, before splitting, and then only\n+     * add a 2^128 offset of the split results (so that they end up in the single 129-bit range\n+     * [0,2^129]). A slightly smaller offset would work due to the bounds on the split, but we pick\n+     * 2^128 for simplicity. Let s be the scalar fed to split_lambda, and f(q) the function to\n+     * compute it from q:\n+     *\n+     *   To compute q*A:\n+     *   - Compute s = f(q)\n+     *   - Let s1, s2 = split_lambda(s)\n+     *   - Let v1 = s1 + 2^128 (mod n)\n+     *   - Let v2 = s2 + 2^128 (mod n)\n+     *   - Let R1 = C_l(v1, A)\n+     *   - Let R2 = C_l(v2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * l will thus need to be at least 129, but we may overshoot by a few bits (see\n+     * further), so keep it as a variable.\n+     *\n+     * To solve for s, we reason:\n+     *     q*A  = R1 + R2\n+     * <=> q*A  = C_l(s1 + 2^128, A) + C_l(s2 + 2^128, lambda*A)\n+     * <=> q*A  = (2*(s1 + 2^128) + 1 - 2^l) * A + (2*(s2 + 2^128) + 1 - 2^l) * lambda*A\n+     * <=> q*A  = (2*(s1 + s2*lambda) + (2^129 + 1 - 2^l) * (1 + lambda)) * A\n+     * <=> q    = 2*(s1 + s2*lambda) + (2^129 + 1 - 2^l) * (1 + lambda) (mod n)\n+     * <=> q    = 2*s + (2^129 + 1 - 2^l) * (1 + lambda) (mod n)\n+     * <=> s    = (q + (2^l - 2^129 - 1) * (1 + lambda)) / 2 (mod n)\n+     * <=> f(q) = (q + K) / 2 (mod n)\n+     *            where K = (2^l - 2^129 - 1)*(1 + lambda) (mod n)\n+     *\n+     * We will process the computation of C_l(v1, A) and C_l(v2, lambda*A) in groups of\n+     * ECMULT_CONST_GROUP_SIZE, so we set l to the smallest multiple of ECMULT_CONST_GROUP_SIZE\n+     * that is not less than 129; this equals ECMULT_CONST_BITS.\n+     */\n \n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+    /* The offset to add to s1 and s2 to make them non-negative. Equal to 2^128. */\n+    static const secp256k1_scalar S_OFFSET = SECP256K1_SCALAR_CONST(0, 0, 0, 1, 0, 0, 0, 0);\n+\n+    /* For K, we have several precomputed formulas/constants.\n+     * - in exhaustive test mode, we give an explicit expression to compute it at compile time: */\n+#ifdef EXHAUSTIVE_TEST_ORDER\n+    static const secp256k1_scalar K = ((SECP256K1_SCALAR_CONST(0, 0, 0, (1U << (ECMULT_CONST_BITS - 128)) - 2U, 0, 0, 0, 0) + EXHAUSTIVE_TEST_ORDER - 1U) * (1U + EXHAUSTIVE_TEST_LAMBDA)) % EXHAUSTIVE_TEST_ORDER;\n+    /* - for the real secp256k1 group we have constants for various ECMULT_CONST_BITS values. */\n+#elif ECMULT_CONST_BITS == 129\n+    /* For GROUP_SIZE = 1,3. */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0xac9c52b3ul, 0x3fa3cf1ful, 0x5ad9e3fdul, 0x77ed9ba4ul, 0xa880b9fcul, 0x8ec739c2ul, 0xe0cfc810ul, 0xb51283ceul);\n+#elif ECMULT_CONST_BITS == 130\n+    /* For GROUP_SIZE = 2,5. */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0xa4e88a7dul, 0xcb13034eul, 0xc2bdd6bful, 0x7c118d6bul, 0x589ae848ul, 0x26ba29e4ul, 0xb5c2c1dcul, 0xde9798d9ul);\n+#elif ECMULT_CONST_BITS == 132\n+    /* For GROUP_SIZE = 4,6 */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0x76b1d93dul, 0x0fae3c6bul, 0x3215874bul, 0x94e93813ul, 0x7937fe0dul, 0xb66bcaaful, 0xb3749ca5ul, 0xd7b6171b);\n+#else\n+#  error \"Unknown ECMULT_CONST_BITS\"\n+#endif\n \n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar) {\n-    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    secp256k1_ge tmpa;\n+    secp256k1_scalar s, v1, v2;\n+    secp256k1_ge pre_a[ECMULT_CONST_TABLE_SIZE];\n+    secp256k1_ge pre_a_lam[ECMULT_CONST_TABLE_SIZE];\n     secp256k1_fe Z;\n-\n-    int skew_1;\n-    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n-    int skew_lam;\n-    secp256k1_scalar q_1, q_lam;\n-    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n-\n-    int i;\n-\n+    secp256k1_gej res;\n+    int group, i;\n+\n+    /* Compute v1 and v2. */\n+    secp256k1_scalar_add(&s, q, &K);\n+    secp256k1_scalar_half(&s, &s);\n+    secp256k1_scalar_split_lambda(&v1, &v2, &s);\n+    secp256k1_scalar_add(&v1, &v1, &S_OFFSET);\n+    secp256k1_scalar_add(&v2, &v2, &S_OFFSET);\n+\n+    /* We're allowed to be non-constant time in the point, and the code below (in particular,\n+     * secp256k1_ecmult_const_odd_multiples_table_globalz) cannot deal with infinity in a\n+     * constant-time manner anyway. */\n     if (secp256k1_ge_is_infinity(a)) {\n         secp256k1_gej_set_infinity(r);\n         return;\n     }\n \n-    /* build wnaf representation for q. */\n-    /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n-    secp256k1_scalar_split_lambda(&q_1, &q_lam, scalar);\n-    skew_1   = secp256k1_wnaf_const(wnaf_1,   &q_1,   WINDOW_A - 1, 128);\n-    skew_lam = secp256k1_wnaf_const(wnaf_lam, &q_lam, WINDOW_A - 1, 128);\n+#ifdef VERIFY\n+    /* Verify that v1 and v2 are in range [0, 2^129-1]. */\n+    for (i = 129; i < 256; ++i) {\n+        VERIFY_CHECK(secp256k1_scalar_get_bits(&v1, i, 1) == 0);\n+        VERIFY_CHECK(secp256k1_scalar_get_bits(&v2, i, 1) == 0);\n+    }\n+#endif\n \n-    /* Calculate odd multiples of a.\n+    /* Calculate odd multiples of A and A*lambda.\n      * All multiples are brought to the same Z 'denominator', which is stored\n      * in Z. Due to secp256k1' isomorphism we can do all operations pretending\n      * that the Z coordinate was 1, use affine addition formulae, and correct\n      * the Z coordinate of the result once at the end.\n      */\n-    VERIFY_CHECK(!a->infinity);\n-    secp256k1_gej_set_ge(r, a);\n-    secp256k1_ecmult_odd_multiples_table_globalz_windowa(pre_a, &Z, r);\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n+    secp256k1_gej_set_ge(&res, a);\n+    secp256k1_ecmult_const_odd_multiples_table_globalz(pre_a, &Z, &res);\n+    for (i = 0; i < ECMULT_CONST_TABLE_SIZE; i++) {\n         secp256k1_fe_normalize_weak(&pre_a[i].y);",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 326,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "f22eb66c078790d075e10c4895e6eaf62e78c2dc",
      "in_reply_to_id": 1230547315,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't remember why it was there; it seems unnecessary indeed.",
      "created_at": "2023-06-20T20:30:33Z",
      "updated_at": "2023-06-20T20:30:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1235796041",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235796041"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235796158",
      "pull_request_review_id": 1488971046,
      "id": 1235796158,
      "node_id": "PRRC_kwDOAP4Jqs5JqMC-",
      "diff_hunk": "@@ -12,208 +12,251 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the\n+     * paper's signed-digit multi-comb algorithm for multiplication using a precomputed table.\n+     *\n+     * It is appealing to try to combine this with the GLV optimization: the idea that a scalar\n+     * s can be written as s1 + lambda*s2, where lambda is a curve-specific constant such that\n+     * lambda*A is easy to compute, and where s1 and s2 are small. In particular we have the\n+     * secp256k1_scalar_split_lambda function which performs such a split with the resulting s1\n+     * and s2 in range (-2^128, 2^128) mod n. This does work, but is uninteresting:\n+     *\n+     *   To compute q*A:\n+     *   - Let s1, s2 = split_lambda(q)\n+     *   - Let R1 = C_256((s1 + 2^256 - 1) / 2, A)\n+     *   - Let R2 = C_256((s2 + 2^256 - 1) / 2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * The issue is that while s1 and s2 are small-range numbers, (s1 + 2^256 - 1) / 2 (mod n)\n+     * and (s2 + 2^256 - 1) / 2 (mod n) are not, undoing the benefit of the splitting.\n+     *\n+     * To make it work, we want to modify the input scalar q first, before splitting, and then only\n+     * add a 2^128 offset of the split results (so that they end up in the single 129-bit range\n+     * [0,2^129]). A slightly smaller offset would work due to the bounds on the split, but we pick\n+     * 2^128 for simplicity. Let s be the scalar fed to split_lambda, and f(q) the function to\n+     * compute it from q:\n+     *\n+     *   To compute q*A:\n+     *   - Compute s = f(q)\n+     *   - Let s1, s2 = split_lambda(s)\n+     *   - Let v1 = s1 + 2^128 (mod n)\n+     *   - Let v2 = s2 + 2^128 (mod n)\n+     *   - Let R1 = C_l(v1, A)\n+     *   - Let R2 = C_l(v2, lambda*A)\n+     *   - Return R1 + R2\n+     *\n+     * l will thus need to be at least 129, but we may overshoot by a few bits (see\n+     * further), so keep it as a variable.\n+     *\n+     * To solve for s, we reason:\n+     *     q*A  = R1 + R2\n+     * <=> q*A  = C_l(s1 + 2^128, A) + C_l(s2 + 2^128, lambda*A)\n+     * <=> q*A  = (2*(s1 + 2^128) + 1 - 2^l) * A + (2*(s2 + 2^128) + 1 - 2^l) * lambda*A\n+     * <=> q*A  = (2*(s1 + s2*lambda) + (2^129 + 1 - 2^l) * (1 + lambda)) * A\n+     * <=> q    = 2*(s1 + s2*lambda) + (2^129 + 1 - 2^l) * (1 + lambda) (mod n)\n+     * <=> q    = 2*s + (2^129 + 1 - 2^l) * (1 + lambda) (mod n)\n+     * <=> s    = (q + (2^l - 2^129 - 1) * (1 + lambda)) / 2 (mod n)\n+     * <=> f(q) = (q + K) / 2 (mod n)\n+     *            where K = (2^l - 2^129 - 1)*(1 + lambda) (mod n)\n+     *\n+     * We will process the computation of C_l(v1, A) and C_l(v2, lambda*A) in groups of\n+     * ECMULT_CONST_GROUP_SIZE, so we set l to the smallest multiple of ECMULT_CONST_GROUP_SIZE\n+     * that is not less than 129; this equals ECMULT_CONST_BITS.\n+     */\n \n-    VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n-    VERIFY_CHECK(word == WNAF_SIZE_BITS(size, w));\n-    return skew;\n-}\n+    /* The offset to add to s1 and s2 to make them non-negative. Equal to 2^128. */\n+    static const secp256k1_scalar S_OFFSET = SECP256K1_SCALAR_CONST(0, 0, 0, 1, 0, 0, 0, 0);\n+\n+    /* For K, we have several precomputed formulas/constants.\n+     * - in exhaustive test mode, we give an explicit expression to compute it at compile time: */\n+#ifdef EXHAUSTIVE_TEST_ORDER\n+    static const secp256k1_scalar K = ((SECP256K1_SCALAR_CONST(0, 0, 0, (1U << (ECMULT_CONST_BITS - 128)) - 2U, 0, 0, 0, 0) + EXHAUSTIVE_TEST_ORDER - 1U) * (1U + EXHAUSTIVE_TEST_LAMBDA)) % EXHAUSTIVE_TEST_ORDER;\n+    /* - for the real secp256k1 group we have constants for various ECMULT_CONST_BITS values. */\n+#elif ECMULT_CONST_BITS == 129\n+    /* For GROUP_SIZE = 1,3. */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0xac9c52b3ul, 0x3fa3cf1ful, 0x5ad9e3fdul, 0x77ed9ba4ul, 0xa880b9fcul, 0x8ec739c2ul, 0xe0cfc810ul, 0xb51283ceul);\n+#elif ECMULT_CONST_BITS == 130\n+    /* For GROUP_SIZE = 2,5. */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0xa4e88a7dul, 0xcb13034eul, 0xc2bdd6bful, 0x7c118d6bul, 0x589ae848ul, 0x26ba29e4ul, 0xb5c2c1dcul, 0xde9798d9ul);\n+#elif ECMULT_CONST_BITS == 132\n+    /* For GROUP_SIZE = 4,6 */\n+    static const secp256k1_scalar K = SECP256K1_SCALAR_CONST(0x76b1d93dul, 0x0fae3c6bul, 0x3215874bul, 0x94e93813ul, 0x7937fe0dul, 0xb66bcaaful, 0xb3749ca5ul, 0xd7b6171b);\n+#else\n+#  error \"Unknown ECMULT_CONST_BITS\"\n+#endif\n \n-static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *scalar) {\n-    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    secp256k1_ge tmpa;\n+    secp256k1_scalar s, v1, v2;\n+    secp256k1_ge pre_a[ECMULT_CONST_TABLE_SIZE];\n+    secp256k1_ge pre_a_lam[ECMULT_CONST_TABLE_SIZE];\n     secp256k1_fe Z;\n-\n-    int skew_1;\n-    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n-    int skew_lam;\n-    secp256k1_scalar q_1, q_lam;\n-    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n-\n-    int i;\n-\n+    secp256k1_gej res;\n+    int group, i;\n+\n+    /* Compute v1 and v2. */\n+    secp256k1_scalar_add(&s, q, &K);\n+    secp256k1_scalar_half(&s, &s);\n+    secp256k1_scalar_split_lambda(&v1, &v2, &s);\n+    secp256k1_scalar_add(&v1, &v1, &S_OFFSET);\n+    secp256k1_scalar_add(&v2, &v2, &S_OFFSET);\n+\n+    /* We're allowed to be non-constant time in the point, and the code below (in particular,\n+     * secp256k1_ecmult_const_odd_multiples_table_globalz) cannot deal with infinity in a\n+     * constant-time manner anyway. */\n     if (secp256k1_ge_is_infinity(a)) {\n         secp256k1_gej_set_infinity(r);\n         return;\n     }\n \n-    /* build wnaf representation for q. */\n-    /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n-    secp256k1_scalar_split_lambda(&q_1, &q_lam, scalar);\n-    skew_1   = secp256k1_wnaf_const(wnaf_1,   &q_1,   WINDOW_A - 1, 128);\n-    skew_lam = secp256k1_wnaf_const(wnaf_lam, &q_lam, WINDOW_A - 1, 128);\n+#ifdef VERIFY\n+    /* Verify that v1 and v2 are in range [0, 2^129-1]. */\n+    for (i = 129; i < 256; ++i) {\n+        VERIFY_CHECK(secp256k1_scalar_get_bits(&v1, i, 1) == 0);\n+        VERIFY_CHECK(secp256k1_scalar_get_bits(&v2, i, 1) == 0);\n+    }\n+#endif\n \n-    /* Calculate odd multiples of a.\n+    /* Calculate odd multiples of A and A*lambda.\n      * All multiples are brought to the same Z 'denominator', which is stored\n      * in Z. Due to secp256k1' isomorphism we can do all operations pretending\n      * that the Z coordinate was 1, use affine addition formulae, and correct\n      * the Z coordinate of the result once at the end.\n      */\n-    VERIFY_CHECK(!a->infinity);\n-    secp256k1_gej_set_ge(r, a);\n-    secp256k1_ecmult_odd_multiples_table_globalz_windowa(pre_a, &Z, r);\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n+    secp256k1_gej_set_ge(&res, a);\n+    secp256k1_ecmult_const_odd_multiples_table_globalz(pre_a, &Z, &res);\n+    for (i = 0; i < ECMULT_CONST_TABLE_SIZE; i++) {\n         secp256k1_fe_normalize_weak(&pre_a[i].y);\n-    }\n-    for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n         secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n     }\n \n-    /* first loop iteration (separated out so we can directly set r, rather\n-     * than having it start at infinity, get doubled several times, then have\n-     * its new value added to it) */\n-    i = wnaf_1[WNAF_SIZE_BITS(128, WINDOW_A - 1)];\n-    VERIFY_CHECK(i != 0);\n-    ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n-    secp256k1_gej_set_ge(r, &tmpa);\n-    i = wnaf_lam[WNAF_SIZE_BITS(128, WINDOW_A - 1)];\n-    VERIFY_CHECK(i != 0);\n-    ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n-    secp256k1_gej_add_ge(r, r, &tmpa);\n-    /* remaining loop iterations */\n-    for (i = WNAF_SIZE_BITS(128, WINDOW_A - 1) - 1; i >= 0; i--) {\n-        int n;\n-        int j;\n-        for (j = 0; j < WINDOW_A - 1; ++j) {\n-            secp256k1_gej_double(r, r);\n-        }\n+    /* Next, we compute res = C_l(v1, A) + C_l(v2, lambda*A).\n+     *\n+     * We proceed in groups of ECMULT_CONST_GROUP_SIZE bits, operating on that many bits\n+     * at a time, from high in v1/v2 to low. Call these bits1 (from v1) and bits2 (from v2).\n+     *\n+     * Now note that ECMULT_CONST_TABLE_GET_GE(&t, pre_a, bits1) loads into t a point equal\n+     * to C_{ECMULT_CONST_GROUP_SIZE}(bits, A), and analogously for pre_lam_a / bits2.",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 356,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "f22eb66c078790d075e10c4895e6eaf62e78c2dc",
      "in_reply_to_id": 1230109862,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-06-20T20:30:41Z",
      "updated_at": "2023-06-20T20:30:41Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1235796158",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235796158"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235796607",
      "pull_request_review_id": 1488971715,
      "id": 1235796607,
      "node_id": "PRRC_kwDOAP4Jqs5JqMJ_",
      "diff_hunk": "@@ -12,208 +12,251 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 72,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "f22eb66c078790d075e10c4895e6eaf62e78c2dc",
      "in_reply_to_id": 1230109130,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed (replaced the first `the` with `at` instead).",
      "created_at": "2023-06-20T20:31:10Z",
      "updated_at": "2023-06-20T20:31:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1235796607",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235796607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235796787",
      "pull_request_review_id": 1488971957,
      "id": 1235796787,
      "node_id": "PRRC_kwDOAP4Jqs5JqMMz",
      "diff_hunk": "@@ -12,208 +12,251 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking the the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n-\n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_n(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 183,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "f22eb66c078790d075e10c4895e6eaf62e78c2dc",
      "in_reply_to_id": 1230108926,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-06-20T20:31:21Z",
      "updated_at": "2023-06-20T20:31:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1235796787",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1235796787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1238625064",
      "pull_request_review_id": 1493351729,
      "id": 1238625064,
      "node_id": "PRRC_kwDOAP4Jqs5J0-so",
      "diff_hunk": "@@ -218,6 +218,37 @@ static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar\n     r->d[7] = t & nonzero;\n }\n \n+static void secp256k1_scalar_half(secp256k1_scalar *r, const secp256k1_scalar *a) {",
      "path": "src/scalar_8x32_impl.h",
      "position": 4,
      "original_position": 4,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "e6b14b947f04e3fbcb48113b942c24b279c59cee",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Notes for myself (that could be turned into a comment):\r\n\r\n```\r\nWriting `/` for field division and `//` for integer division, we compute\r\n  a/2 = (a - (a&1))/2 + (a&1)/2\r\n      = (a >> 1) + (a&1 ?    1/2 : 0)\r\n      = (a >> 1) + (a&1 ? n//2+1 : 0),\r\nwhere n is the group order and in the last equality we have used 1/2 = n//2+1 (mod n).\r\nFor n/2, we have the constants SECP256K1_N_H_0, ...\r\n\r\nThe sum does not overflow:\r\nThe interesting case is a = -2, the largest odd scalar. Here, the left summand is\r\n  a >> 1 = (a - a&1)/2  = (n-2-1)//2 = (n-3)//2,\r\nand the right summand is\r\n   a&1 ? n//2+1 : 0 = n//2+1 = (n-1)//2 + 2//2 = (n+1)//2.\r\nIn sum, we have (n-3)//2 + (n+1)//2 = (2n-2)//2 = n - 1 < n.\r\n```",
      "created_at": "2023-06-22T14:35:50Z",
      "updated_at": "2023-06-24T08:07:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1238625064",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1238625064"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 248,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1238630727",
      "pull_request_review_id": 1493351729,
      "id": 1238630727,
      "node_id": "PRRC_kwDOAP4Jqs5J1AFH",
      "diff_hunk": "@@ -218,6 +218,37 @@ static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar\n     r->d[7] = t & nonzero;\n }\n \n+static void secp256k1_scalar_half(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    uint32_t mask = -(uint32_t)(a->d[0] & 1U);\n+    uint64_t t = (uint32_t)((a->d[0] >> 1) | (a->d[1] << 31));\n+    t += (SECP256K1_N_H_0 + 1U) & mask;\n+    r->d[0] = t; t >>= 32;\n+    t += (uint32_t)((a->d[1] >> 1) | (a->d[2] << 31));\n+    t += SECP256K1_N_H_1 & mask;\n+    r->d[1] = t; t >>= 32;\n+    t += (uint32_t)((a->d[2] >> 1) | (a->d[3] << 31));\n+    t += SECP256K1_N_H_2 & mask;\n+    r->d[2] = t; t >>= 32;\n+    t += (uint32_t)((a->d[3] >> 1) | (a->d[4] << 31));\n+    t += SECP256K1_N_H_3 & mask;\n+    r->d[3] = t; t >>= 32;\n+    t += (uint32_t)((a->d[4] >> 1) | (a->d[5] << 31));\n+    t += mask;",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 19,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "e6b14b947f04e3fbcb48113b942c24b279c59cee",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n    t += SECP256K1_N_H_4 & mask;\r\n```\r\nand same below is easier to read and more general.",
      "created_at": "2023-06-22T14:39:46Z",
      "updated_at": "2023-06-22T14:41:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1238630727",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1238630727"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1239566294",
      "pull_request_review_id": 1494755506,
      "id": 1239566294,
      "node_id": "PRRC_kwDOAP4Jqs5J4kfW",
      "diff_hunk": "@@ -218,6 +218,37 @@ static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar\n     r->d[7] = t & nonzero;\n }\n \n+static void secp256k1_scalar_half(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    uint32_t mask = -(uint32_t)(a->d[0] & 1U);\n+    uint64_t t = (uint32_t)((a->d[0] >> 1) | (a->d[1] << 31));\n+    t += (SECP256K1_N_H_0 + 1U) & mask;\n+    r->d[0] = t; t >>= 32;\n+    t += (uint32_t)((a->d[1] >> 1) | (a->d[2] << 31));\n+    t += SECP256K1_N_H_1 & mask;\n+    r->d[1] = t; t >>= 32;\n+    t += (uint32_t)((a->d[2] >> 1) | (a->d[3] << 31));\n+    t += SECP256K1_N_H_2 & mask;\n+    r->d[2] = t; t >>= 32;\n+    t += (uint32_t)((a->d[3] >> 1) | (a->d[4] << 31));\n+    t += SECP256K1_N_H_3 & mask;\n+    r->d[3] = t; t >>= 32;\n+    t += (uint32_t)((a->d[4] >> 1) | (a->d[5] << 31));\n+    t += mask;\n+    r->d[4] = t; t >>= 32;\n+    t += (uint32_t)((a->d[5] >> 1) | (a->d[6] << 31));\n+    t += mask;\n+    r->d[5] = t; t >>= 32;\n+    t += (uint32_t)((a->d[6] >> 1) | (a->d[7] << 31));\n+    t += mask;\n+    r->d[6] = t; t >>= 32;\n+    r->d[7] = (uint32_t)t + (uint32_t)(a->d[7] >> 1) + (SECP256K1_N_H_7 & mask);\n+#ifdef VERIFY\n+    /* The line above only computed the bottom 32 bits of r->d[7]. Redo the computation\n+     * in full 64 bits to make sure no overflow occured. */\n+    VERIFY_CHECK((t + (a->d[7] >> 1) + (SECP256K1_N_H_7 & mask)) >> 32 == 0);\n+#endif",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 32,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "e6b14b947f04e3fbcb48113b942c24b279c59cee",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Add a `VERIFY(secp256k1_scalar_check_overflow(r)) == 0)`? \r\n\r\n(We should probably add a `secp256k1_scalar_verify` and check elements in every function, like for field and group. But that's a separate PR.)",
      "created_at": "2023-06-23T09:05:42Z",
      "updated_at": "2023-06-23T09:05:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1239566294",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1239566294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 245,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1240189732",
      "pull_request_review_id": 1495727466,
      "id": 1240189732,
      "node_id": "PRRC_kwDOAP4Jqs5J68sk",
      "diff_hunk": "@@ -218,6 +218,37 @@ static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar\n     r->d[7] = t & nonzero;\n }\n \n+static void secp256k1_scalar_half(secp256k1_scalar *r, const secp256k1_scalar *a) {",
      "path": "src/scalar_8x32_impl.h",
      "position": 4,
      "original_position": 4,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "e6b14b947f04e3fbcb48113b942c24b279c59cee",
      "in_reply_to_id": 1238625064,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure I understand the `a[255..0]` notation.",
      "created_at": "2023-06-23T18:51:36Z",
      "updated_at": "2023-06-23T18:51:36Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1240189732",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1240189732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 248,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1240202420",
      "pull_request_review_id": 1495747851,
      "id": 1240202420,
      "node_id": "PRRC_kwDOAP4Jqs5J6_y0",
      "diff_hunk": "@@ -218,6 +218,37 @@ static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar\n     r->d[7] = t & nonzero;\n }\n \n+static void secp256k1_scalar_half(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    uint32_t mask = -(uint32_t)(a->d[0] & 1U);\n+    uint64_t t = (uint32_t)((a->d[0] >> 1) | (a->d[1] << 31));\n+    t += (SECP256K1_N_H_0 + 1U) & mask;\n+    r->d[0] = t; t >>= 32;\n+    t += (uint32_t)((a->d[1] >> 1) | (a->d[2] << 31));\n+    t += SECP256K1_N_H_1 & mask;\n+    r->d[1] = t; t >>= 32;\n+    t += (uint32_t)((a->d[2] >> 1) | (a->d[3] << 31));\n+    t += SECP256K1_N_H_2 & mask;\n+    r->d[2] = t; t >>= 32;\n+    t += (uint32_t)((a->d[3] >> 1) | (a->d[4] << 31));\n+    t += SECP256K1_N_H_3 & mask;\n+    r->d[3] = t; t >>= 32;\n+    t += (uint32_t)((a->d[4] >> 1) | (a->d[5] << 31));\n+    t += mask;\n+    r->d[4] = t; t >>= 32;\n+    t += (uint32_t)((a->d[5] >> 1) | (a->d[6] << 31));\n+    t += mask;\n+    r->d[5] = t; t >>= 32;\n+    t += (uint32_t)((a->d[6] >> 1) | (a->d[7] << 31));\n+    t += mask;\n+    r->d[6] = t; t >>= 32;\n+    r->d[7] = (uint32_t)t + (uint32_t)(a->d[7] >> 1) + (SECP256K1_N_H_7 & mask);\n+#ifdef VERIFY\n+    /* The line above only computed the bottom 32 bits of r->d[7]. Redo the computation\n+     * in full 64 bits to make sure no overflow occured. */\n+    VERIFY_CHECK((t + (a->d[7] >> 1) + (SECP256K1_N_H_7 & mask)) >> 32 == 0);\n+#endif",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 32,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "e6b14b947f04e3fbcb48113b942c24b279c59cee",
      "in_reply_to_id": 1239566294,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-23T19:01:47Z",
      "updated_at": "2023-06-23T19:01:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1240202420",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1240202420"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 245,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1240202583",
      "pull_request_review_id": 1495748032,
      "id": 1240202583,
      "node_id": "PRRC_kwDOAP4Jqs5J6_1X",
      "diff_hunk": "@@ -218,6 +218,37 @@ static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar\n     r->d[7] = t & nonzero;\n }\n \n+static void secp256k1_scalar_half(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    uint32_t mask = -(uint32_t)(a->d[0] & 1U);\n+    uint64_t t = (uint32_t)((a->d[0] >> 1) | (a->d[1] << 31));\n+    t += (SECP256K1_N_H_0 + 1U) & mask;\n+    r->d[0] = t; t >>= 32;\n+    t += (uint32_t)((a->d[1] >> 1) | (a->d[2] << 31));\n+    t += SECP256K1_N_H_1 & mask;\n+    r->d[1] = t; t >>= 32;\n+    t += (uint32_t)((a->d[2] >> 1) | (a->d[3] << 31));\n+    t += SECP256K1_N_H_2 & mask;\n+    r->d[2] = t; t >>= 32;\n+    t += (uint32_t)((a->d[3] >> 1) | (a->d[4] << 31));\n+    t += SECP256K1_N_H_3 & mask;\n+    r->d[3] = t; t >>= 32;\n+    t += (uint32_t)((a->d[4] >> 1) | (a->d[5] << 31));\n+    t += mask;",
      "path": "src/scalar_8x32_impl.h",
      "position": null,
      "original_position": 19,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "e6b14b947f04e3fbcb48113b942c24b279c59cee",
      "in_reply_to_id": 1238630727,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-23T19:01:54Z",
      "updated_at": "2023-06-23T19:01:54Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1240202583",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1240202583"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1240637837",
      "pull_request_review_id": 1496413825,
      "id": 1240637837,
      "node_id": "PRRC_kwDOAP4Jqs5J8qGN",
      "diff_hunk": "@@ -218,6 +218,37 @@ static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar\n     r->d[7] = t & nonzero;\n }\n \n+static void secp256k1_scalar_half(secp256k1_scalar *r, const secp256k1_scalar *a) {",
      "path": "src/scalar_8x32_impl.h",
      "position": 4,
      "original_position": 4,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "e6b14b947f04e3fbcb48113b942c24b279c59cee",
      "in_reply_to_id": 1238625064,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, I edited the text to remove it. It was a relic of an earlier draft.",
      "created_at": "2023-06-24T08:09:25Z",
      "updated_at": "2023-06-24T08:09:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1240637837",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1240637837"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 248,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1242644916",
      "pull_request_review_id": 1499231681,
      "id": 1242644916,
      "node_id": "PRRC_kwDOAP4Jqs5KEUG0",
      "diff_hunk": "@@ -218,6 +218,37 @@ static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar\n     r->d[7] = t & nonzero;\n }\n \n+static void secp256k1_scalar_half(secp256k1_scalar *r, const secp256k1_scalar *a) {",
      "path": "src/scalar_8x32_impl.h",
      "position": 4,
      "original_position": 4,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "e6b14b947f04e3fbcb48113b942c24b279c59cee",
      "in_reply_to_id": 1238625064,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Included in the commit with some minor editing.",
      "created_at": "2023-06-26T19:11:04Z",
      "updated_at": "2023-06-26T19:11:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1242644916",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1242644916"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 248,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1337429408",
      "pull_request_review_id": 1644626750,
      "id": 1337429408,
      "node_id": "PRRC_kwDOAP4Jqs5Pt42g",
      "diff_hunk": "@@ -12,45 +12,74 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3",
      "path": "src/ecmult_const_impl.h",
      "position": 18,
      "original_position": 18,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "5dbf2529353b1ec0af311cbd7a91b9859e385077",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is there any reason why the smallest exhaustive group test order of the ones that we typically use (7) is not supported here? Adding it with group size 2, i.e.\r\n```\r\n#  elif EXHAUSTIVE_TEST_ORDER == 7\r\n#    define ECMULT_CONST_GROUP_SIZE 2\r\n```\r\n seems to work at least (adapting EXHAUSTIVE_TEST_ORDER to 7 in ./src/tests_exhaustive.c and running them doesn't return any error)",
      "created_at": "2023-09-26T15:43:38Z",
      "updated_at": "2023-09-26T16:18:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1337429408",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1337429408"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": 21,
      "original_start_line": 21,
      "start_side": "RIGHT",
      "line": 22,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1337436781",
      "pull_request_review_id": 1644626750,
      "id": 1337436781,
      "node_id": "PRRC_kwDOAP4Jqs5Pt6pt",
      "diff_hunk": "@@ -12,45 +12,74 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking at the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 79,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "5dbf2529353b1ec0af311cbd7a91b9859e385077",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: maybe slightly easier to grasp (at least for me), if the intended assertions here are \"n must be in range `[0,2^ECMULT_CONST_GROUP_SIZE[`\" and \"index must be in range `[0,2^(ECMULT_CONST_GROUP_SIZE-1)[`\"?\r\n```suggestion\r\n    VERIFY_CHECK((n) < (1U << ECMULT_CONST_GROUP_SIZE)); \\\r\n    VERIFY_CHECK(index < (1U << (ECMULT_CONST_GROUP_SIZE - 1))); \\\r\n```\r\n(assuming callers of this macro only ever pass unsigned `n`)",
      "created_at": "2023-09-26T15:49:18Z",
      "updated_at": "2023-09-26T16:18:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1337436781",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1337436781"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1367731025",
      "pull_request_review_id": 1691259398,
      "id": 1367731025,
      "node_id": "PRRC_kwDOAP4Jqs5RhetR",
      "diff_hunk": "@@ -12,208 +12,251 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking at the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n+/* For K as defined in the comment of secp256k1_ecmult_const, we have several precomputed\n+ * formulas/constants.\n+ * - in exhaustive test mode, we give an explicit expression to compute it at compile time: */\n+#ifdef EXHAUSTIVE_TEST_ORDER\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = ((SECP256K1_SCALAR_CONST(0, 0, 0, (1U << (ECMULT_CONST_BITS - 128)) - 2U, 0, 0, 0, 0) + EXHAUSTIVE_TEST_ORDER - 1U) * (1U + EXHAUSTIVE_TEST_LAMBDA)) % EXHAUSTIVE_TEST_ORDER;\n+/* - for the real secp256k1 group we have constants for various ECMULT_CONST_BITS values. */\n+#elif ECMULT_CONST_BITS == 129\n+    /* For GROUP_SIZE = 1,3. */\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = SECP256K1_SCALAR_CONST(0xac9c52b3ul, 0x3fa3cf1ful, 0x5ad9e3fdul, 0x77ed9ba4ul, 0xa880b9fcul, 0x8ec739c2ul, 0xe0cfc810ul, 0xb51283ceul);\n+#elif ECMULT_CONST_BITS == 130\n+    /* For GROUP_SIZE = 2,5. */\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = SECP256K1_SCALAR_CONST(0xa4e88a7dul, 0xcb13034eul, 0xc2bdd6bful, 0x7c118d6bul, 0x589ae848ul, 0x26ba29e4ul, 0xb5c2c1dcul, 0xde9798d9ul);\n+#elif ECMULT_CONST_BITS == 132\n+    /* For GROUP_SIZE = 4,6 */\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = SECP256K1_SCALAR_CONST(0x76b1d93dul, 0x0fae3c6bul, 0x3215874bul, 0x94e93813ul, 0x7937fe0dul, 0xb66bcaaful, 0xb3749ca5ul, 0xd7b6171b);\n+#else\n+#  error \"Unknown ECMULT_CONST_BITS\"\n+#endif\n \n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 205,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "f773744172e998786e93877b2109b5d21156fbb5",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n     * Thus, one can compute q*A as C_256((q + 2^256 - 1) / 2, A). This is the basis for the\r\n```",
      "created_at": "2023-10-21T13:33:57Z",
      "updated_at": "2023-10-21T13:34:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1367731025",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1367731025"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1368874418",
      "pull_request_review_id": 1692879841,
      "id": 1368874418,
      "node_id": "PRRC_kwDOAP4Jqs5Rl12y",
      "diff_hunk": "@@ -12,45 +12,74 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3",
      "path": "src/ecmult_const_impl.h",
      "position": 18,
      "original_position": 18,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "5dbf2529353b1ec0af311cbd7a91b9859e385077",
      "in_reply_to_id": 1337429408,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. This PR (or its code) may have predated the test order 7 introduction.",
      "created_at": "2023-10-23T15:28:49Z",
      "updated_at": "2023-10-23T15:28:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1368874418",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1368874418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": 21,
      "original_start_line": 21,
      "start_side": "RIGHT",
      "line": 22,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1368874560",
      "pull_request_review_id": 1692880057,
      "id": 1368874560,
      "node_id": "PRRC_kwDOAP4Jqs5Rl15A",
      "diff_hunk": "@@ -12,45 +12,74 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking at the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 79,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "5dbf2529353b1ec0af311cbd7a91b9859e385077",
      "in_reply_to_id": 1337436781,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-10-23T15:28:55Z",
      "updated_at": "2023-10-23T15:28:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1368874560",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1368874560"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1368874757",
      "pull_request_review_id": 1692880339,
      "id": 1368874757,
      "node_id": "PRRC_kwDOAP4Jqs5Rl18F",
      "diff_hunk": "@@ -12,208 +12,251 @@\n #include \"ecmult_const.h\"\n #include \"ecmult_impl.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need 2^ECMULT_CONST_GROUP_SIZE - 1 to be less than EXHAUSTIVE_TEST_ORDER, because\n+ * the tables cannot have infinities in them (this breaks the effective-affine technique's\n+ * z-ratio tracking) */\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+#    define ECMULT_CONST_GROUP_SIZE 4\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+#    define ECMULT_CONST_GROUP_SIZE 3\n+#  else\n+#    error \"Unknown EXHAUSTIVE_TEST_ORDER\"\n+#  endif\n+#else\n+/* Group size 4 or 5 appears optimal. */\n+#  define ECMULT_CONST_GROUP_SIZE 5\n+#endif\n+\n+#define ECMULT_CONST_TABLE_SIZE (1L << (ECMULT_CONST_GROUP_SIZE - 1))\n+#define ECMULT_CONST_GROUPS ((129 + ECMULT_CONST_GROUP_SIZE - 1) / ECMULT_CONST_GROUP_SIZE)\n+#define ECMULT_CONST_BITS (ECMULT_CONST_GROUPS * ECMULT_CONST_GROUP_SIZE)\n+\n /** Fill a table 'pre' with precomputed odd multiples of a.\n  *\n  *  The resulting point set is brought to a single constant Z denominator, stores the X and Y\n- *  coordinates as ge_storage points in pre, and stores the global Z in globalz.\n- *  It only operates on tables sized for WINDOW_A wnaf multiples.\n+ *  coordinates as ge points in pre, and stores the global Z in globalz.\n+ *\n+ *  'pre' must be an array of size ECMULT_CONST_TABLE_SIZE.\n  */\n-static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n-    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+static void secp256k1_ecmult_const_odd_multiples_table_globalz(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a) {\n+    secp256k1_fe zr[ECMULT_CONST_TABLE_SIZE];\n \n-    secp256k1_ecmult_odd_multiples_table(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr, globalz, a);\n-    secp256k1_ge_table_set_globalz(ECMULT_TABLE_SIZE(WINDOW_A), pre, zr);\n+    secp256k1_ecmult_odd_multiples_table(ECMULT_CONST_TABLE_SIZE, pre, zr, globalz, a);\n+    secp256k1_ge_table_set_globalz(ECMULT_CONST_TABLE_SIZE, pre, zr);\n }\n \n-/* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n-#define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m = 0; \\\n-    /* Extract the sign-bit for a constant time absolute-value. */ \\\n-    int volatile mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n-    int abs_n = ((n) + mask) ^ mask; \\\n-    int idx_n = abs_n >> 1; \\\n+/* Given a table 'pre' with odd multiples of a point, put in r the signed-bit multiplication of n with that point.\n+ *\n+ * For example, if ECMULT_CONST_GROUP_SIZE is 4, then pre is expected to contain 8 entries:\n+ * [1*P, 3*P, 5*P, 7*P, 9*P, 11*P, 13*P, 15*P]. n is then expected to be a 4-bit integer (range 0-15), and its\n+ * bits are interpreted as signs of powers of two to look up.\n+ *\n+ * For example, if n=4, which is 0100 in binary, which is interpreted as [- + - -], so the looked up value is\n+ * [ -(2^3) + (2^2) - (2^1) - (2^0) ]*P = -7*P. Every valid n translates to an odd number in range [-15,15],\n+ * which means we just need to look up one of the precomputed values, and optionally negate it.\n+ */\n+#define ECMULT_CONST_TABLE_GET_GE(r,pre,n) do { \\\n+    unsigned m = 0; \\\n+    /* If the top bit of n is 0, we want the negation. */ \\\n+    volatile unsigned negative = ((n) >> (ECMULT_CONST_GROUP_SIZE - 1)) ^ 1; \\\n+    /* The index is computed by looking at the bottom bits, after making positive. */ \\\n+    unsigned index = ((unsigned)(-negative) ^ n) & ((1U << (ECMULT_CONST_GROUP_SIZE - 1)) - 1U); \\\n     secp256k1_fe neg_y; \\\n-    VERIFY_CHECK(((n) & 1) == 1); \\\n-    VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n-    VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n+    VERIFY_CHECK((n) >> ECMULT_CONST_GROUP_SIZE == 0); \\\n+    VERIFY_CHECK(index >> (ECMULT_CONST_GROUP_SIZE - 1) == 0); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one\n      * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n     (r)->x = (pre)[m].x; \\\n     (r)->y = (pre)[m].y; \\\n-    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    for (m = 1; m < ECMULT_CONST_TABLE_SIZE; m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n-        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n-        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == idx_n); \\\n+        secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == index); \\\n+        secp256k1_fe_cmov(&(r)->y, &(pre)[m].y, m == index); \\\n     } \\\n     (r)->infinity = 0; \\\n     secp256k1_fe_negate(&neg_y, &(r)->y, 1); \\\n-    secp256k1_fe_cmov(&(r)->y, &neg_y, (n) != abs_n); \\\n+    secp256k1_fe_cmov(&(r)->y, &neg_y, negative); \\\n } while(0)\n \n-/** Convert a number to WNAF notation.\n- *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n- *  It has the following guarantees:\n- *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n- *  - each wnaf[i] is nonzero\n- *  - the number of words set is always WNAF_SIZE(w) + 1\n- *\n- *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n- *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n- *\n- *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n- */\n-static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n-    int global_sign;\n-    int skew;\n-    int word = 0;\n-\n-    /* 1 2 3 */\n-    int u_last;\n-    int u;\n-\n-    int flip;\n-    secp256k1_scalar s = *scalar;\n-\n-    VERIFY_CHECK(w > 0);\n-    VERIFY_CHECK(size > 0);\n+/* For K as defined in the comment of secp256k1_ecmult_const, we have several precomputed\n+ * formulas/constants.\n+ * - in exhaustive test mode, we give an explicit expression to compute it at compile time: */\n+#ifdef EXHAUSTIVE_TEST_ORDER\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = ((SECP256K1_SCALAR_CONST(0, 0, 0, (1U << (ECMULT_CONST_BITS - 128)) - 2U, 0, 0, 0, 0) + EXHAUSTIVE_TEST_ORDER - 1U) * (1U + EXHAUSTIVE_TEST_LAMBDA)) % EXHAUSTIVE_TEST_ORDER;\n+/* - for the real secp256k1 group we have constants for various ECMULT_CONST_BITS values. */\n+#elif ECMULT_CONST_BITS == 129\n+    /* For GROUP_SIZE = 1,3. */\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = SECP256K1_SCALAR_CONST(0xac9c52b3ul, 0x3fa3cf1ful, 0x5ad9e3fdul, 0x77ed9ba4ul, 0xa880b9fcul, 0x8ec739c2ul, 0xe0cfc810ul, 0xb51283ceul);\n+#elif ECMULT_CONST_BITS == 130\n+    /* For GROUP_SIZE = 2,5. */\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = SECP256K1_SCALAR_CONST(0xa4e88a7dul, 0xcb13034eul, 0xc2bdd6bful, 0x7c118d6bul, 0x589ae848ul, 0x26ba29e4ul, 0xb5c2c1dcul, 0xde9798d9ul);\n+#elif ECMULT_CONST_BITS == 132\n+    /* For GROUP_SIZE = 4,6 */\n+    static const secp256k1_scalar secp256k1_ecmult_const_K = SECP256K1_SCALAR_CONST(0x76b1d93dul, 0x0fae3c6bul, 0x3215874bul, 0x94e93813ul, 0x7937fe0dul, 0xb66bcaaful, 0xb3749ca5ul, 0xd7b6171b);\n+#else\n+#  error \"Unknown ECMULT_CONST_BITS\"\n+#endif\n \n-    /* Note that we cannot handle even numbers by negating them to be odd, as is\n-     * done in other implementations, since if our scalars were specified to have\n-     * width < 256 for performance reasons, their negations would have width 256\n-     * and we'd lose any performance benefit. Instead, we use a variation of a\n-     * technique from Section 4.2 of the Okeya/Tagaki paper, which is to add 1 to the\n-     * number we are encoding when it is even, returning a skew value indicating\n-     * this, and having the caller compensate after doing the multiplication.\n+static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q) {\n+    /* The approach below combines the signed-digit logic from Mike Hamburg's\n+     * \"Fast and compact elliptic-curve cryptography\" (https://eprint.iacr.org/2012/309)\n+     * Section 3.3, with the GLV endomorphism.\n      *\n-     * In fact, we _do_ want to negate numbers to minimize their bit-lengths (and in\n-     * particular, to ensure that the outputs from the endomorphism-split fit into\n-     * 128 bits). If we negate, the parity of our number flips, affecting whether\n-     * we want to add to the scalar to ensure that it's odd. */\n-    flip = secp256k1_scalar_is_high(&s);\n-    skew = flip ^ secp256k1_scalar_is_even(&s);\n-    secp256k1_scalar_cadd_bit(&s, 0, skew);\n-    global_sign = secp256k1_scalar_cond_negate(&s, flip);\n-\n-    /* 4 */\n-    u_last = secp256k1_scalar_shr_int(&s, w);\n-    do {\n-        int even;\n-\n-        /* 4.1 4.4 */\n-        u = secp256k1_scalar_shr_int(&s, w);\n-        /* 4.2 */\n-        even = ((u & 1) == 0);\n-        /* In contrast to the original algorithm, u_last is always > 0 and\n-         * therefore we do not need to check its sign. In particular, it's easy\n-         * to see that u_last is never < 0 because u is never < 0. Moreover,\n-         * u_last is never = 0 because u is never even after a loop\n-         * iteration. The same holds analogously for the initial value of\n-         * u_last (in the first loop iteration). */\n-        VERIFY_CHECK(u_last > 0);\n-        VERIFY_CHECK((u_last & 1) == 1);\n-        u += even;\n-        u_last -= even * (1 << w);\n-\n-        /* 4.3, adapted for global sign change */\n-        wnaf[word++] = u_last * global_sign;\n-\n-        u_last = u;\n-    } while (word * w < size);\n-    wnaf[word] = u * global_sign;\n+     * The idea there is to interpret the bits of a scalar as signs (1 = +, 0 = -), and compute a\n+     * point multiplication in that fashion. Let v be an n-bit non-negative integer (0 <= v < 2^n),\n+     * and v[i] its i'th bit (so v = sum(v[i] * 2^i, i=0..n-1)). Then define:\n+     *\n+     *   C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *\n+     * Then it holds that C_l(v, A) = sum((2*v[i] - 1) * 2^i*A, i=0..l-1)\n+     *                              = (2*sum(v[i] * 2^i, i=0..l-1) + 1 - 2^l) * A\n+     *                              = (2*v + 1 - 2^l) * A\n+     *\n+     * Thus, one can compute q*A as C_256((q + 2^l - 1) / 2, A). This is the basis for the",
      "path": "src/ecmult_const_impl.h",
      "position": null,
      "original_position": 205,
      "commit_id": "c8eb787cd96995aefa79bf4bab18903c409db026",
      "original_commit_id": "f773744172e998786e93877b2109b5d21156fbb5",
      "in_reply_to_id": 1367731025,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-10-23T15:29:02Z",
      "updated_at": "2023-10-23T15:29:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1184#discussion_r1368874757",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1368874757"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1184"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    }
  ]
}