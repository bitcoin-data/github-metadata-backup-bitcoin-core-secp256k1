{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789",
    "id": 3104383300,
    "node_id": "PR_kwDOAP4Jqs65CSFE",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1789.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1789.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1789",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1789/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
    "number": 1789,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "ecmult_multi: Replace scratch space with malloc, use abcd cost model",
    "user": {
      "login": "fjahr",
      "id": 1322187,
      "node_id": "MDQ6VXNlcjEzMjIxODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjahr",
      "html_url": "https://github.com/fjahr",
      "followers_url": "https://api.github.com/users/fjahr/followers",
      "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
      "organizations_url": "https://api.github.com/users/fjahr/orgs",
      "repos_url": "https://api.github.com/users/fjahr/repos",
      "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/fjahr/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "This is a draft of the discussed changes from an in-person meeting in October. It removes usage of scratch space in batch validation and replaces it with internal malloc usage. It also adds an ABCD cost model for algorithm selection.\r\n\r\nThe API and internals follow the drafted spec from the meeting very closely: https://gist.github.com/fjahr/c2a009487dffe7a1fbf17ca1821976ca There are few minor changes that should not change the intended behavior. The test coverage is currently a bit less than it was previously. I am guessing an adapted form of the `test_ecmult_multi` test should be added back and there are a few TODOs left in the test code which I am planning to address after a first round of conceptual feedback.\r\n\r\nThe second commit demonstrates the calibration tooling that I have been using though it's not exactly what has given me the results that are in the PR. I have still been struggling with the calibration code and seem to never really get a result that just works without manual tweaking. The calibration itself as well as the code added there thus is rather a work in progress. I am assuming some version of the calibration code should be added to the repo and I haven't thought much about what the best place to add it is. Putting it into the benchmark and combining it with the python script was just a convenient way for experimentation. I am very open to suggestions on how to change this.",
    "labels": [],
    "created_at": "2025-12-15T23:47:46Z",
    "updated_at": "2026-01-20T16:29:36Z",
    "mergeable": true,
    "mergeable_state": "unstable",
    "merged": false,
    "merge_commit_sha": "9816b7f8992a47d81107cda6b798dc807bc3493c",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "fjahr:2025-11-mem-multi-var",
      "ref": "2025-11-mem-multi-var",
      "sha": "c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 198311821,
        "node_id": "MDEwOlJlcG9zaXRvcnkxOTgzMTE4MjE=",
        "name": "secp256k1",
        "full_name": "fjahr/secp256k1",
        "owner": {
          "login": "fjahr",
          "id": 1322187,
          "node_id": "MDQ6VXNlcjEzMjIxODc=",
          "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/fjahr",
          "html_url": "https://github.com/fjahr",
          "followers_url": "https://api.github.com/users/fjahr/followers",
          "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
          "organizations_url": "https://api.github.com/users/fjahr/orgs",
          "repos_url": "https://api.github.com/users/fjahr/repos",
          "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/fjahr/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/fjahr/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/fjahr/secp256k1",
        "archive_url": "https://api.github.com/repos/fjahr/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/fjahr/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/fjahr/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/fjahr/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/fjahr/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/fjahr/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/fjahr/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/fjahr/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/fjahr/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/fjahr/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/fjahr/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/fjahr/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/fjahr/secp256k1/events",
        "forks_url": "https://api.github.com/repos/fjahr/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/fjahr/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/fjahr/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/fjahr/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/fjahr/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/fjahr/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/fjahr/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/fjahr/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/fjahr/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/fjahr/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/fjahr/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/fjahr/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/fjahr/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/fjahr/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/fjahr/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/fjahr/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:fjahr/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/fjahr/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/fjahr/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/fjahr/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/fjahr/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/fjahr/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/fjahr/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/fjahr/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/fjahr/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/fjahr/secp256k1/hooks",
        "svn_url": "https://github.com/fjahr/secp256k1",
        "language": "C",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 13039,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-01-20T16:27:54Z",
        "created_at": "2019-07-22T22:39:26Z",
        "updated_at": "2019-07-22T22:39:29Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "4721e077b4ac9a9ab80db3fd9a05d6dda207f5c1",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1117,
        "stargazers_count": 2386,
        "watchers_count": 2386,
        "size": 14003,
        "default_branch": "master",
        "open_issues_count": 171,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-01-11T20:45:11Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2026-01-20T15:05:15Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": true,
    "additions": 716,
    "deletions": 841,
    "changed_files": 7,
    "commits": 2,
    "review_comments": 18,
    "comments": 3
  },
  "events": [
    {
      "event": "head_ref_force_pushed",
      "id": 21602549360,
      "node_id": "HRFPE_lADOAP4Jqs7eeh3jzwAAAAUHnL5w",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21602549360",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "8b62524b0fd69a98612e5151cf8ebf26efe8492a",
      "commit_url": "https://api.github.com/repos/fjahr/secp256k1/commits/8b62524b0fd69a98612e5151cf8ebf26efe8492a",
      "created_at": "2025-12-16T21:21:23Z"
    },
    {
      "event": "reviewed",
      "id": 3613492155,
      "node_id": "PRR_kwDOAP4Jqs7XYYO7",
      "url": null,
      "actor": null,
      "commit_id": "8b62524b0fd69a98612e5151cf8ebf26efe8492a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-26T14:27:15Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#pullrequestreview-3613492155",
      "submitted_at": "2025-12-26T14:27:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
    },
    {
      "event": "reviewed",
      "id": 3614260299,
      "node_id": "PRR_kwDOAP4Jqs7XbTxL",
      "url": null,
      "actor": null,
      "commit_id": "8b62524b0fd69a98612e5151cf8ebf26efe8492a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-27T09:13:04Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#pullrequestreview-3614260299",
      "submitted_at": "2025-12-27T09:13:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
    },
    {
      "event": "reviewed",
      "id": 3614266738,
      "node_id": "PRR_kwDOAP4Jqs7XbVVy",
      "url": null,
      "actor": null,
      "commit_id": "8b62524b0fd69a98612e5151cf8ebf26efe8492a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-27T09:17:04Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#pullrequestreview-3614266738",
      "submitted_at": "2025-12-27T09:17:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
    },
    {
      "event": "commented",
      "id": 3693865902,
      "node_id": "IC_kwDOAP4Jqs7cK-uu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3693865902",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-27T09:38:22Z",
      "updated_at": "2025-12-27T14:12:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "I ran the calibration tool, and I'm getting the following results. It's very close the exisitng results, uptil `PIPPENGER_8` after which the C value increases for me (this shouldn't happen right?). I'll run this a few more times.\r\n<details>\r\n<summary>My ABCD values</summary>\r\n\r\n```\r\nstatic const struct secp256k1_ecmult_multi_abcd secp256k1_ecmult_multi_abcds[SECP256K1_ECMULT_MULTI_NUM_ALGOS] = {\r\n    {0,                                     0,                                     1000,  0     },\r\n    {SECP256K1_STRAUSS_POINT_SIZE,          0,                                     113,   143  },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(1),  SECP256K1_PIPPENGER_FIXED_SIZE(1),  199,   303  },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(2),  SECP256K1_PIPPENGER_FIXED_SIZE(2),  152,   460  },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(3),  SECP256K1_PIPPENGER_FIXED_SIZE(3),  117,   782  },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(4),  SECP256K1_PIPPENGER_FIXED_SIZE(4),  100,   1158 },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(5),  SECP256K1_PIPPENGER_FIXED_SIZE(5),  86,    1837 },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(6),  SECP256K1_PIPPENGER_FIXED_SIZE(6),  77,    3013 },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(7),  SECP256K1_PIPPENGER_FIXED_SIZE(7),  72,    4845 },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(8),  SECP256K1_PIPPENGER_FIXED_SIZE(8),  69,    8775 },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(9),  SECP256K1_PIPPENGER_FIXED_SIZE(9),  73,    14373},\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(10), SECP256K1_PIPPENGER_FIXED_SIZE(10), 78,    26442},\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(11), SECP256K1_PIPPENGER_FIXED_SIZE(11), 80,    48783},\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(12), SECP256K1_PIPPENGER_FIXED_SIZE(12), 106,   88289},\r\n};\r\n```\r\n\r\n</details>\r\n\r\nI’ve visualized the benchmarks for all algorithms (see https://github.com/siv2r/secp256k1/commit/311938612268866bd3dd0cf6c1d006e418518b1d for the diagrams). I’m planning to do a deeper dive into the regression model fit to ensure they align with these results. Will share any useful findings here",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#issuecomment-3693865902",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1789"
    },
    {
      "event": "commented",
      "id": 3694002074,
      "node_id": "IC_kwDOAP4Jqs7cLf-a",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3694002074",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-27T14:11:08Z",
      "updated_at": "2025-12-27T14:11:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "I did some analysis on the linear regression model for the CD values (see https://github.com/siv2r/secp256k1/commit/b5985a60454e68c7f88bfe7a9d41b89a47f2b530). I basically ran `./bench_ecmult calib` twice. Used the first run to compute the linear regression model, and the second run to test it against new benchmark values.\r\n\r\n<details>\r\n<summary>ABCD Values</summary>\r\n\r\n```c\r\nstatic const struct secp256k1_ecmult_multi_abcd secp256k1_ecmult_multi_abcds[SECP256K1_ECMULT_MULTI_NUM_ALGOS] = {\r\n    {0,                                     0,                                     1000,  0     },\r\n    {SECP256K1_STRAUSS_POINT_SIZE,          0,                                     112,   173  },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(1),  SECP256K1_PIPPENGER_FIXED_SIZE(1),  197,   285  },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(2),  SECP256K1_PIPPENGER_FIXED_SIZE(2),  152,   480  },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(3),  SECP256K1_PIPPENGER_FIXED_SIZE(3),  117,   767  },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(4),  SECP256K1_PIPPENGER_FIXED_SIZE(4),  100,   1167 },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(5),  SECP256K1_PIPPENGER_FIXED_SIZE(5),  86,    1887 },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(6),  SECP256K1_PIPPENGER_FIXED_SIZE(6),  78,    3023 },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(7),  SECP256K1_PIPPENGER_FIXED_SIZE(7),  73,    4906 },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(8),  SECP256K1_PIPPENGER_FIXED_SIZE(8),  70,    8889 },\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(9),  SECP256K1_PIPPENGER_FIXED_SIZE(9),  74,    14544},\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(10), SECP256K1_PIPPENGER_FIXED_SIZE(10), 79,    26764},\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(11), SECP256K1_PIPPENGER_FIXED_SIZE(11), 84,    49179},\r\n    {SECP256K1_PIPPENGER_POINT_SIZE(12), SECP256K1_PIPPENGER_FIXED_SIZE(12), 106,   89518},\r\n};\r\n```\r\n\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>Statistical analysis </summary>\r\n\r\nMetric Definitions\r\n\r\n| Metric | Meaning | Good Value for Benchmarking |\r\n|--------|---------|-----------------------------|\r\n| R² | How well the linear model fits (0-1) | > 0.95 (strong linear relationship) |\r\n| Std Error | Uncertainty in slope estimate | Low relative to slope |\r\n| p-value | Probability slope = 0 by chance | < 0.05 (statistically significant) |\r\n| Slope | Time increase per additional n (μs) | Positive, algorithm-dependent |\r\n| Intercept | Fixed overhead time (μs) | Algorithm-dependent |\r\n\r\nPer-Algorithm Metrics\r\n\r\n| Algorithm | R² | Std Error | p-value | Slope | Intercept |\r\n|-----------|------|-----------|---------|-------|----------|\r\n| STRAUSS | 0.983536 | 0.1660 | 1.29e-25 | 6.2956 | -1917.23 |\r\n| PIPPENGER_1 | 0.999995 | 0.0039 | 6.29e-73 | 8.5860 | -133.20 |\r\n| PIPPENGER_2 | 0.999992 | 0.0036 | 9.98e-71 | 6.7066 | -115.04 |\r\n| PIPPENGER_3 | 0.999993 | 0.0026 | 8.15e-71 | 4.9746 | -34.11 |\r\n| PIPPENGER_4 | 0.999996 | 0.0015 | 5.34e-75 | 4.1772 | -13.27 |\r\n| PIPPENGER_5 | 0.999995 | 0.0015 | 1.16e-73 | 3.5473 | 56.56 |\r\n| PIPPENGER_6 | 0.999991 | 0.0019 | 2.30e-69 | 3.1035 | 105.03 |\r\n| PIPPENGER_7 | 0.999994 | 0.0013 | 4.69e-72 | 2.7083 | 219.62 |\r\n| PIPPENGER_8 | 0.999989 | 0.0016 | 2.64e-68 | 2.4879 | 414.58 |\r\n| PIPPENGER_9 | 0.999977 | 0.0021 | 3.76e-64 | 2.2872 | 719.46 |\r\n| PIPPENGER_10 | 0.999953 | 0.0028 | 5.02e-60 | 2.1705 | 1287.92 |\r\n| PIPPENGER_11 | 0.999847 | 0.0049 | 4.73e-53 | 2.0592 | 2321.53 |\r\n| PIPPENGER_12 | 0.999583 | 0.0075 | 3.62e-47 | 1.9331 | 4153.43 |\r\n\r\n</details>\r\n\r\nThe linear fit ($R^2$) and standard error for `STRAUSS` is relatively worse. We can improve this by using smaller batch sizes when calibrating Strauss. I see negative intercepts (i.e., D values) for `PIPPENGER_1..4`, this should be positive. I think this could also be address by capping these algorithms to medium batch sizes during calibration. Otherwise, the calibrated values are excellent!\r\n",
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#issuecomment-3694002074",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1789"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGRkM2VhYTcyZjU4NzVjMmY2ODU5YzRiOTNiODkwM2JiN2I3ZTg1Y2Y",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/dd3eaa72f5875c2f6859c4b93b8903bb7b7e85cf",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/dd3eaa72f5875c2f6859c4b93b8903bb7b7e85cf",
      "tree": {
        "sha": "a7fbcbdc8b855bd541b80a3badd54985fc7e89e5",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/a7fbcbdc8b855bd541b80a3badd54985fc7e89e5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree a7fbcbdc8b855bd541b80a3badd54985fc7e89e5\nparent 4721e077b4ac9a9ab80db3fd9a05d6dda207f5c1\nauthor Fabian Jahr <fjahr@protonmail.com> 1764368681 +0100\ncommitter Fabian Jahr <fjahr@protonmail.com> 1768926031 +0100\n\necmult: Refactor ecmult algo selection\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQJJBAABCgAzFiEEtFq20ghhrCHSdrgm8T0enYkHmM0FAmlvq1AVHGZqYWhyQHBy\nb3Rvbm1haWwuY29tAAoJEPE9Hp2JB5jN9tIQAITMBqQmhrpfF9LPY2DVIr9Wq1hU\nLs0Dns/1ATl9pQhCwAmXT/8P7Yo+jMuL4sVib+Fr1M89z1jna38xFORcoK54d7SV\nx7uvgZL3wHTdUYJXNHcp9k2JShqw+H9W8PL5jYdy4AqKD35SEC9WVoOf2tRfIQRl\nroryfpkTC4APJlOxTI/TedSaRDHhhjYPMTlZCTsnTb1Jv9XXBfW6d4ltkWOijFh/\n0I3nWmmh1KgemZJsWvRvPb4xbfudFzwQwsWI69YxrNJyRs04Zk6okSKc5xt0Q0rY\nBGfY7bfMwYdSMaFgk+/hP1oaQhndlWgfOjo8JtEjktn4SrjkOjEyWn0OORZ3tzL3\nNVpKwMwYixq5qAFR7QI76K9IAQ4Ta3ucW96oMjUDDOj0jU12fJcu5nKX3PoMsian\nwwJjyuaR9HUC1kKJ1c37oGhcz3ZTfj2xyrk5DHrcHvXI/GQaxB9uCOYfe+ZnXWvS\nSlbOb/MVGnWZktDybuMK8JMueIXDXTP5oKk/Kf3zinWTCXT00zw3y330oKS3XoDQ\nTRHDimJcR2At2NJve3+iGxBzUtTn4/Fi6WgskF4dhoKg/HuH5K/ek8rzPu/F0ABu\nm0LiA2CR0jx1m6TAJDe0x5Ut64HWYsrbGGPdVYOXd7tO5qEQJCs2ZTAstHV+eRLS\n4eX+hY8eHxXtQChF\n=dcx1\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4721e077b4ac9a9ab80db3fd9a05d6dda207f5c1",
          "sha": "4721e077b4ac9a9ab80db3fd9a05d6dda207f5c1",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4721e077b4ac9a9ab80db3fd9a05d6dda207f5c1"
        }
      ],
      "message": "ecmult: Refactor ecmult algo selection",
      "committer": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2026-01-20T16:20:31Z"
      },
      "author": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2025-11-28T22:24:41Z"
      },
      "sha": "dd3eaa72f5875c2f6859c4b93b8903bb7b7e85cf"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22166198155,
      "node_id": "HRFPE_lADOAP4Jqs7eeh3jzwAAAAUpNVeL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22166198155",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "72fd3e8859882d958f16dc04edf8c6b046db2aa0",
      "commit_url": "https://api.github.com/repos/fjahr/secp256k1/commits/72fd3e8859882d958f16dc04edf8c6b046db2aa0",
      "created_at": "2026-01-20T16:26:18Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGMyYzliYzJjODA1NWQzOGY3OTMyODhiZmJjODRlMzdjZWY0YWZlMGU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "tree": {
        "sha": "a1382a3e313cd5e8435b49203ee874813ee6b66e",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/a1382a3e313cd5e8435b49203ee874813ee6b66e"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree a1382a3e313cd5e8435b49203ee874813ee6b66e\nparent dd3eaa72f5875c2f6859c4b93b8903bb7b7e85cf\nauthor Fabian Jahr <fjahr@protonmail.com> 1765808148 +0100\ncommitter Fabian Jahr <fjahr@protonmail.com> 1768926459 +0100\n\nWIP: Tooling for algo selection abcd calibration\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQJJBAABCgAzFiEEtFq20ghhrCHSdrgm8T0enYkHmM0FAmlvrPsVHGZqYWhyQHBy\nb3Rvbm1haWwuY29tAAoJEPE9Hp2JB5jNtrUP/1xcjBN67mFjv7fG27at4/m1cmcz\nXq6X6sW/PYMHi0/va/Rg5JDAY8WvVhNTXz8z92WdFJY8tK09MA79A+BcLF0NGyDO\nFytm6yfU0ysFYD3HZjpMSj0JyZf/5M4jUUbqlPajO597kHrngX4c+EvqfjWb2ZKx\nTfEq6Y24w3C827V0E8WRioo3+CHKzL2p6YoDzYtKFcz65b+8/6rwy5RJNqaSPrem\nggzwPG8WbEG57OSTzLibff3H9H8i1AJitHLKlbMA7vgj3cnAwzg+JRxWjVeYA4gU\npUzvrWFg8pVExdlozkHuvF9ZGzyDhLM6AUi8T3fmOn9Xkpk8cnE9gkqfIBU8YshI\nDx2sq8l0HI/vYwxfqTYnZHtGI+22+rGYm62k+tV0ahBcQARVdfyJFtzi5kkkZmA2\nvXIn0EKWBs0SoXyVuWOdJt1OPpPkRtjwy38h8FtCjI3bhEnM2c3q/9hCQOp+3W6p\ndAcgN1NtTyhGBIoODxWvUKdfs3MDDM20zJB8iJWPU1orq9k4Qsi8jkfgGjM5Ui4W\n4VfS1Fv3MFjkqJSZrowDfJfLHGz1hTK0It0ZxTFHicOPD8hZ+Elc5VMXa0xCmnC9\nEXB/IgQUixn4J4STzuBlHBll/USWToQ2cC0RkuGi3jcHchLYFEsgYO5ISlnG4nIT\nUygggajPx3kh2se+\n=YPbf\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/dd3eaa72f5875c2f6859c4b93b8903bb7b7e85cf",
          "sha": "dd3eaa72f5875c2f6859c4b93b8903bb7b7e85cf",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/dd3eaa72f5875c2f6859c4b93b8903bb7b7e85cf"
        }
      ],
      "message": "WIP: Tooling for algo selection abcd calibration",
      "committer": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2026-01-20T16:27:39Z"
      },
      "author": {
        "name": "Fabian Jahr",
        "email": "fjahr@protonmail.com",
        "date": "2025-12-15T14:15:48Z"
      },
      "sha": "c2c9bc2c8055d38f793288bfbc84e37cef4afe0e"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22166237048,
      "node_id": "HRFPE_lADOAP4Jqs7eeh3jzwAAAAUpNe94",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22166237048",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "commit_url": "https://api.github.com/repos/fjahr/secp256k1/commits/c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "created_at": "2026-01-20T16:27:56Z"
    },
    {
      "event": "commented",
      "id": 3773824493,
      "node_id": "IC_kwDOAP4Jqs7g7_3t",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3773824493",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-20T16:29:36Z",
      "updated_at": "2026-01-20T16:29:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Addressed the comments on the implementation code and rebased, thanks a lot for the review @siv2r ! I need a little more time to think about the calibration again, but will comment on that asap.",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#issuecomment-3773824493",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1789"
    },
    {
      "event": "mentioned",
      "id": 22166277066,
      "node_id": "MEE_lADOAP4Jqs7eeh3jzwAAAAUpNovK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22166277066",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-20T16:29:37Z"
    },
    {
      "event": "subscribed",
      "id": 22166277091,
      "node_id": "SE_lADOAP4Jqs7eeh3jzwAAAAUpNovj",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22166277091",
      "actor": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-20T16:29:37Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648251146",
      "pull_request_review_id": 3613492155,
      "id": 2648251146,
      "node_id": "PRRC_kwDOAP4Jqs6d2RsK",
      "diff_hunk": "@@ -149,26 +149,13 @@ typedef struct {\n     secp256k1_ge second_pk;\n } secp256k1_musig_pubkey_agg_ecmult_data;\n \n-/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n-static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n-    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n-    int ret;\n-    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n-#ifdef VERIFY\n-    /* pubkey_load can't fail because the same pks have already been loaded in\n-     * `musig_compute_pks_hash` (and we test this). */\n-    VERIFY_CHECK(ret);\n-#else\n-    (void) ret;\n-#endif\n-    secp256k1_musig_keyaggcoef_internal(sc, ctx->pks_hash, pt, &ctx->second_pk);\n-    return 1;\n-}\n-\n int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 20,
      "original_position": 20,
      "commit_id": "c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It might be better to pass `mem_limit` as an input argument rather than defining it internally",
      "created_at": "2025-12-26T13:33:12Z",
      "updated_at": "2025-12-26T14:27:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2648251146",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648251146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 152,
      "original_line": 152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648271415",
      "pull_request_review_id": 3613492155,
      "id": 2648271415,
      "node_id": "PRRC_kwDOAP4Jqs6d2Wo3",
      "diff_hunk": "@@ -199,14 +183,36 @@ int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pub\n     if (!secp256k1_musig_compute_pks_hash(ctx, ecmult_data.pks_hash, pubkeys, n_pubkeys)) {\n         return 0;\n     }\n-    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n-     * scratch space */\n-    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n-        /* In order to reach this line with the current implementation of\n-         * ecmult_multi_var one would need to provide a callback that can\n-         * fail. */\n+\n+    /* TODO: This follows the discussed approach of letting the users use\n+     * malloc instead of scratch space. However there could also be a simple\n+     * wrapper that abstracts the malloc stuff away. This could be cleaner. */\n+    points = (secp256k1_ge *)checked_malloc(&ctx->error_callback, n_pubkeys * sizeof(secp256k1_ge));\n+    scalars = (secp256k1_scalar *)checked_malloc(&ctx->error_callback, n_pubkeys * sizeof(secp256k1_scalar));\n+\n+    for (i = 0; i < n_pubkeys; i++) {\n+#ifdef VERIFY\n+        /* pubkey_load can't fail because the same pks have already been loaded\n+         * in `musig_compute_pks_hash` (and we test this). */\n+        VERIFY_CHECK(secp256k1_pubkey_load(ctx, &points[i], pubkeys[i]));\n+#else\n+        (void) secp256k1_pubkey_load(ctx, &points[i], pubkeys[i]);\n+#endif\n+        secp256k1_musig_keyaggcoef_internal(&scalars[i], ecmult_data.pks_hash, &points[i], &ecmult_data.second_pk);\n+    }\n+\n+    /* TODO: Previously this just used TRIVIAL algorithm by not providing\n+     * scratch space. To be discussed if this should be changed. */\n+    mem_limit = n_pubkeys * (sizeof(secp256k1_ge) + sizeof(secp256k1_scalar)) * 4;",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 1,
      "original_position": 70,
      "commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: Why the constant 4? I assume it covers internal overhead. I'm wondering whether we can define a ratio `k` such that `mem_limit = n_points * (sizeof(secp256k1_ge) + sizeof(secp256k1_scalar)) * k` yields a batch size of `n_points` when given to `_ecmult_multi_batch_size()`",
      "created_at": "2025-12-26T13:51:30Z",
      "updated_at": "2025-12-26T14:27:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2648271415",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648271415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648277571",
      "pull_request_review_id": 3613492155,
      "id": 2648277571,
      "node_id": "PRRC_kwDOAP4Jqs6d2YJD",
      "diff_hunk": "@@ -199,14 +183,36 @@ int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pub\n     if (!secp256k1_musig_compute_pks_hash(ctx, ecmult_data.pks_hash, pubkeys, n_pubkeys)) {\n         return 0;\n     }\n-    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n-     * scratch space */\n-    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n-        /* In order to reach this line with the current implementation of\n-         * ecmult_multi_var one would need to provide a callback that can\n-         * fail. */\n+\n+    /* TODO: This follows the discussed approach of letting the users use\n+     * malloc instead of scratch space. However there could also be a simple\n+     * wrapper that abstracts the malloc stuff away. This could be cleaner. */\n+    points = (secp256k1_ge *)checked_malloc(&ctx->error_callback, n_pubkeys * sizeof(secp256k1_ge));\n+    scalars = (secp256k1_scalar *)checked_malloc(&ctx->error_callback, n_pubkeys * sizeof(secp256k1_scalar));\n+\n+    for (i = 0; i < n_pubkeys; i++) {\n+#ifdef VERIFY\n+        /* pubkey_load can't fail because the same pks have already been loaded\n+         * in `musig_compute_pks_hash` (and we test this). */\n+        VERIFY_CHECK(secp256k1_pubkey_load(ctx, &points[i], pubkeys[i]));\n+#else\n+        (void) secp256k1_pubkey_load(ctx, &points[i], pubkeys[i]);\n+#endif\n+        secp256k1_musig_keyaggcoef_internal(&scalars[i], ecmult_data.pks_hash, &points[i], &ecmult_data.second_pk);\n+    }\n+\n+    /* TODO: Previously this just used TRIVIAL algorithm by not providing\n+     * scratch space. To be discussed if this should be changed. */\n+    mem_limit = n_pubkeys * (sizeof(secp256k1_ge) + sizeof(secp256k1_scalar)) * 4;",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 1,
      "original_position": 70,
      "commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": 2648271415,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Hmm, we could probably do `mem_limit = max(STRAUSS_POINT_SIZE * n, PIPPENGER_POINT_SIZE * n + PIPPENGER_FIXED_SIZE)`. Just thinking out loud, not suggesting a change here.",
      "created_at": "2025-12-26T13:57:28Z",
      "updated_at": "2025-12-26T14:27:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2648277571",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648277571"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648282791",
      "pull_request_review_id": 3613492155,
      "id": 2648282791,
      "node_id": "PRRC_kwDOAP4Jqs6d2Zan",
      "diff_hunk": "@@ -186,17 +186,13 @@ typedef struct {\n     secp256k1_ge pt[2];\n } ecmult_multi_data;",
      "path": "src/tests_exhaustive.c",
      "position": 1,
      "original_position": 2,
      "commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "We can probably remove this data structure. In the old code, I only see this acting as `cbdata` (initialized using local scalars and points arrays) to the `ecmult_multi_var`",
      "created_at": "2025-12-26T14:02:25Z",
      "updated_at": "2025-12-26T14:27:51Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2648282791",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648282791"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": 184,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 187,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648294345",
      "pull_request_review_id": 3613492155,
      "id": 2648294345,
      "node_id": "PRRC_kwDOAP4Jqs6d2cPJ",
      "diff_hunk": "@@ -306,11 +333,11 @@ static void run_ecmult_multi_bench(bench_data* data, size_t count, int includes_\n int main(int argc, char **argv) {\n     bench_data data;\n     int i, p;\n-    size_t scratch_size;\n \n     int iters = get_iters(10000);\n \n-    data.ecmult_multi = secp256k1_ecmult_multi_var;\n+    data.forced_algo = -1;",
      "path": "src/bench_ecmult.c",
      "position": 1,
      "original_position": 121,
      "commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: We could define `#define BENCH_ALGO_AUTO (-1)` to make this more readable. Then, the check on line 252 would be: `if (data->forced_algo != BENCH_ALGO_AUTO)`",
      "created_at": "2025-12-26T14:09:04Z",
      "updated_at": "2025-12-26T14:27:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2648294345",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648294345"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 339,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648301540",
      "pull_request_review_id": 3613492155,
      "id": 2648301540,
      "node_id": "PRRC_kwDOAP4Jqs6d2d_k",
      "diff_hunk": "@@ -657,212 +545,376 @@ SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, s\n }\n \n /**\n- * Returns the scratch size required for a given number of points (excluding\n- * base point G) without considering alignment.\n+ * Algorithm Selection: ABCD Model\n+ *\n+ * For each possible batch algorithm choice, memory usage is\n+ * m(x) = A*x + B and running time is\n+ * c(x) = C*x + D, where x is the batch size.\n+ *\n+ * A = per-point memory (bytes)\n+ * B = fixed memory overhead (bytes)\n+ * C = per-point time cost\n+ * D = fixed time overhead\n  */\n-static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n-    size_t entries = 2*n_points + 2;\n-    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n-    return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n-}\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n-    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n-    /* Use 2(n+1) with the endomorphism, when calculating batch\n-     * sizes. The reason for +1 is that we add the G scalar to the list of\n-     * other scalars. */\n-    size_t entries = 2*n_points + 2;\n-    secp256k1_ge *points;\n-    secp256k1_scalar *scalars;\n-    secp256k1_gej *buckets;\n-    struct secp256k1_pippenger_state *state_space;\n-    size_t idx = 0;\n-    size_t point_idx = 0;\n-    int bucket_window;\n+struct secp256k1_ecmult_multi_abcd {\n+    size_t A;\n+    size_t B;\n+    size_t C;\n+    size_t D;\n+};\n \n-    secp256k1_gej_set_infinity(r);\n-    if (inp_g_sc == NULL && n_points == 0) {\n-        return 1;\n-    }\n-    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-\n-    /* We allocate PIPPENGER_SCRATCH_OBJECTS objects on the scratch space. If\n-     * these allocations change, make sure to update the\n-     * PIPPENGER_SCRATCH_OBJECTS constant and pippenger_scratch_size\n-     * accordingly. */\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n-    if (points == NULL || scalars == NULL || state_space == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, ((size_t)1 << bucket_window) * sizeof(*buckets));\n-    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n+/* Strauss per-point memory */\n+#define SECP256K1_STRAUSS_POINT_SIZE \\\n+    ((sizeof(secp256k1_ge) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) \\\n+     + sizeof(struct secp256k1_strauss_point_state) \\\n+     + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar))\n \n-    if (inp_g_sc != NULL) {\n-        scalars[0] = *inp_g_sc;\n-        points[0] = secp256k1_ge_const_g;\n-        idx++;\n-        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n-        idx++;\n-    }\n+/* Pippenger per-entry memory */\n+#define SECP256K1_PIPPENGER_ENTRY_SIZE(w) \\\n+    (sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) \\\n+     + sizeof(struct secp256k1_pippenger_point_state) \\\n+     + (WNAF_SIZE((w)+1) + 1) * sizeof(int))\n \n-    while (point_idx < n_points) {\n-        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-            return 0;\n+/* Pippenger per-point memory: 2 entries due to endomorphism */\n+#define SECP256K1_PIPPENGER_POINT_SIZE(w) (2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/* Pippenger fixed overhead: buckets + state + 2 extra entries */\n+#define SECP256K1_PIPPENGER_FIXED_SIZE(w) \\\n+    ((sizeof(secp256k1_gej) << (w)) \\\n+     + sizeof(struct secp256k1_pippenger_state) \\\n+     + 2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))",
      "path": "src/ecmult_impl.h",
      "position": 227,
      "original_position": 232,
      "commit_id": "c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n#define SECP256K1_PIPPENGER_FIXED_SIZE(w) \\\n    ((sizeof(secp256k1_gej) << (w)) \\\n     + 2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n```\n\nWe can remove the `pippenger_state` since it's a stack variable. IIUC, the old code allocated this variable on the heap, hence it included it in the size calculation.",
      "created_at": "2025-12-26T14:15:48Z",
      "updated_at": "2025-12-26T14:27:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2648301540",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648301540"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": 583,
      "original_start_line": 583,
      "start_side": "RIGHT",
      "line": 585,
      "original_line": 585,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648307770",
      "pull_request_review_id": 3613492155,
      "id": 2648307770,
      "node_id": "PRRC_kwDOAP4Jqs6d2fg6",
      "diff_hunk": "@@ -657,212 +545,376 @@ SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, s\n }\n \n /**\n- * Returns the scratch size required for a given number of points (excluding\n- * base point G) without considering alignment.\n+ * Algorithm Selection: ABCD Model\n+ *\n+ * For each possible batch algorithm choice, memory usage is\n+ * m(x) = A*x + B and running time is\n+ * c(x) = C*x + D, where x is the batch size.\n+ *\n+ * A = per-point memory (bytes)\n+ * B = fixed memory overhead (bytes)\n+ * C = per-point time cost\n+ * D = fixed time overhead\n  */\n-static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n-    size_t entries = 2*n_points + 2;\n-    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n-    return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n-}\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n-    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n-    /* Use 2(n+1) with the endomorphism, when calculating batch\n-     * sizes. The reason for +1 is that we add the G scalar to the list of\n-     * other scalars. */\n-    size_t entries = 2*n_points + 2;\n-    secp256k1_ge *points;\n-    secp256k1_scalar *scalars;\n-    secp256k1_gej *buckets;\n-    struct secp256k1_pippenger_state *state_space;\n-    size_t idx = 0;\n-    size_t point_idx = 0;\n-    int bucket_window;\n+struct secp256k1_ecmult_multi_abcd {\n+    size_t A;\n+    size_t B;\n+    size_t C;\n+    size_t D;\n+};\n \n-    secp256k1_gej_set_infinity(r);\n-    if (inp_g_sc == NULL && n_points == 0) {\n-        return 1;\n-    }\n-    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-\n-    /* We allocate PIPPENGER_SCRATCH_OBJECTS objects on the scratch space. If\n-     * these allocations change, make sure to update the\n-     * PIPPENGER_SCRATCH_OBJECTS constant and pippenger_scratch_size\n-     * accordingly. */\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n-    if (points == NULL || scalars == NULL || state_space == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, ((size_t)1 << bucket_window) * sizeof(*buckets));\n-    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n+/* Strauss per-point memory */\n+#define SECP256K1_STRAUSS_POINT_SIZE \\\n+    ((sizeof(secp256k1_ge) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) \\\n+     + sizeof(struct secp256k1_strauss_point_state) \\\n+     + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar))\n \n-    if (inp_g_sc != NULL) {\n-        scalars[0] = *inp_g_sc;\n-        points[0] = secp256k1_ge_const_g;\n-        idx++;\n-        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n-        idx++;\n-    }\n+/* Pippenger per-entry memory */\n+#define SECP256K1_PIPPENGER_ENTRY_SIZE(w) \\\n+    (sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) \\\n+     + sizeof(struct secp256k1_pippenger_point_state) \\\n+     + (WNAF_SIZE((w)+1) + 1) * sizeof(int))\n \n-    while (point_idx < n_points) {\n-        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-            return 0;\n+/* Pippenger per-point memory: 2 entries due to endomorphism */\n+#define SECP256K1_PIPPENGER_POINT_SIZE(w) (2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/* Pippenger fixed overhead: buckets + state + 2 extra entries */\n+#define SECP256K1_PIPPENGER_FIXED_SIZE(w) \\\n+    ((sizeof(secp256k1_gej) << (w)) \\\n+     + sizeof(struct secp256k1_pippenger_state) \\\n+     + 2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/*\n+ * ABCD constants for all batch algorithms.\n+ *\n+ * Index 0    = TRIVIAL (no memory, very slow)\n+ * Index 1    = STRAUSS (efficient for small batche sizes)\n+ * Index 2-13 = PIPPENGER with window sizes 1-12\n+ */\n+static const struct secp256k1_ecmult_multi_abcd secp256k1_ecmult_multi_abcds[SECP256K1_ECMULT_MULTI_NUM_ALGOS] = {\n+/*  A (per-point bytes)                     B (fixed bytes)                        C        D           */\n+    {0,                                     0,                                     1000,    0      },\n+    {SECP256K1_STRAUSS_POINT_SIZE,          0,                                     100,     0      },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(1),     SECP256K1_PIPPENGER_FIXED_SIZE(1),     500 /* manually disabled */,     181    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(2),     SECP256K1_PIPPENGER_FIXED_SIZE(2),     400 /* manually disabled */,     434    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(3),     SECP256K1_PIPPENGER_FIXED_SIZE(3),     117,     811    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(4),     SECP256K1_PIPPENGER_FIXED_SIZE(4),     100,     1231   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(5),     SECP256K1_PIPPENGER_FIXED_SIZE(5),     86,      1973   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(6),     SECP256K1_PIPPENGER_FIXED_SIZE(6),     76,      3123   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(7),     SECP256K1_PIPPENGER_FIXED_SIZE(7),     68,      5234   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(8),     SECP256K1_PIPPENGER_FIXED_SIZE(8),     64,      9269   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(9),     SECP256K1_PIPPENGER_FIXED_SIZE(9),     60,      15746  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(10),    SECP256K1_PIPPENGER_FIXED_SIZE(10),    62,      28723  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(11),    SECP256K1_PIPPENGER_FIXED_SIZE(11),    57,      51876  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(12),    SECP256K1_PIPPENGER_FIXED_SIZE(12),    61,      92195  },\n+};\n+\n+static size_t secp256k1_ecmult_multi_batch_size(size_t mem_limit) {\n+    /* We are implicitly using the TRIVIAL algorithm as a fallback\n+     * but we will only use it if no other algorithm fits. If that\n+     * is the case we can use max points as the batch size. */\n+    size_t best_batch_size = ECMULT_MAX_POINTS_PER_BATCH;\n+    size_t min_optime = SIZE_MAX;\n+    int i;\n+\n+    for (i = 1 /* ignores TRIVIAL */; i < SECP256K1_ECMULT_MULTI_NUM_ALGOS; i++) {\n+        const struct secp256k1_ecmult_multi_abcd *p = &secp256k1_ecmult_multi_abcds[i];\n+        size_t A = p->A, B = p->B, C = p->C, D = p->D, optime, batch_size;\n+\n+        if (mem_limit <= B) continue;\n+\n+        batch_size = (mem_limit - B) / A;\n+\n+        if (batch_size == 0) continue;\n+\n+        optime = C + D / batch_size;\n+\n+        if (optime < min_optime) {\n+            min_optime = optime;\n+            best_batch_size = batch_size;\n         }\n-        idx++;\n-        secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n-        idx++;\n-        point_idx++;\n     }\n \n-    secp256k1_ecmult_pippenger_wnaf(buckets, bucket_window, state_space, r, scalars, points, idx);\n-    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-    return 1;\n+    return best_batch_size;\n }\n \n-/* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n-}\n+static secp256k1_ecmult_multi_algo secp256k1_ecmult_multi_select(size_t mem_limit, size_t batch_size) {\n+    secp256k1_ecmult_multi_algo best_algo = SECP256K1_ECMULT_MULTI_ALGO_TRIVIAL;\n+    size_t min_optime = SIZE_MAX;\n+    int i;\n \n-/**\n- * Returns the maximum number of points in addition to G that can be used with\n- * a given scratch space. The function ensures that fewer points may also be\n- * used.\n- */\n-static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n-    size_t max_alloc = secp256k1_scratch_max_allocation(error_callback, scratch, PIPPENGER_SCRATCH_OBJECTS);\n-    int bucket_window;\n-    size_t res = 0;\n-\n-    for (bucket_window = 1; bucket_window <= PIPPENGER_MAX_BUCKET_WINDOW; bucket_window++) {\n-        size_t n_points;\n-        size_t max_points = secp256k1_pippenger_bucket_window_inv(bucket_window);\n-        size_t space_for_points;\n-        size_t space_overhead;\n-        size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n-\n-        entry_size = 2*entry_size;\n-        space_overhead = (sizeof(secp256k1_gej) << bucket_window) + entry_size + sizeof(struct secp256k1_pippenger_state);\n-        if (space_overhead > max_alloc) {\n-            break;\n-        }\n-        space_for_points = max_alloc - space_overhead;\n+    /* Use TRIVIAL fallback */\n+    if (batch_size == 0) return best_algo;\n \n-        n_points = space_for_points/entry_size;\n-        n_points = n_points > max_points ? max_points : n_points;\n-        if (n_points > res) {\n-            res = n_points;\n-        }\n-        if (n_points < max_points) {\n-            /* A larger bucket_window may support even more points. But if we\n-             * would choose that then the caller couldn't safely use any number\n-             * smaller than what this function returns */\n-            break;\n+    for (i = 0; i < SECP256K1_ECMULT_MULTI_NUM_ALGOS; i++) {\n+        const struct secp256k1_ecmult_multi_abcd *p = &secp256k1_ecmult_multi_abcds[i];\n+        size_t A = p->A, B = p->B, C = p->C, D = p->D, optime;\n+        size_t mem_usage = A * batch_size + B;\n+\n+        if (mem_usage > mem_limit) continue;\n+\n+        optime = C + D / batch_size;\n+\n+        if (optime < min_optime) {\n+            min_optime = optime;\n+            best_algo = (secp256k1_ecmult_multi_algo)i;\n         }\n     }\n-    return res;\n+\n+    return best_algo;\n }\n \n-/* Computes ecmult_multi by simply multiplying and adding each point. Does not\n- * require a scratch space */\n-static int secp256k1_ecmult_multi_simple_var(secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n-    size_t point_idx;\n+/* Trivial algorithm: Computes ecmult_multi by simply multiplying and adding each point. */\n+static int secp256k1_ecmult_multi_trivial(\n+    secp256k1_gej *r,\n+    size_t n,\n+    const secp256k1_ge *points,\n+    const secp256k1_scalar *scalars,\n+    const secp256k1_scalar *scalar_g\n+) {\n+    size_t i;\n     secp256k1_gej tmpj;\n \n     secp256k1_gej_set_infinity(r);\n-    secp256k1_gej_set_infinity(&tmpj);\n-    /* r = inp_g_sc*G */\n-    secp256k1_ecmult(r, &tmpj, &secp256k1_scalar_zero, inp_g_sc);\n-    for (point_idx = 0; point_idx < n_points; point_idx++) {\n-        secp256k1_ge point;\n+\n+    if (scalar_g != NULL) {\n+        secp256k1_gej_set_infinity(&tmpj);\n+        secp256k1_ecmult(r, &tmpj, &secp256k1_scalar_zero, scalar_g);\n+    }\n+\n+    for (i = 0; i < n; i++) {\n         secp256k1_gej pointj;\n-        secp256k1_scalar scalar;\n-        if (!cb(&scalar, &point, point_idx, cbdata)) {\n-            return 0;\n+        if (secp256k1_ge_is_infinity(&points[i])) {\n+            continue;\n         }\n-        /* r += scalar*point */\n-        secp256k1_gej_set_ge(&pointj, &point);\n-        secp256k1_ecmult(&tmpj, &pointj, &scalar, NULL);\n+        secp256k1_gej_set_ge(&pointj, &points[i]);\n+        secp256k1_ecmult(&tmpj, &pointj, &scalars[i], NULL);\n         secp256k1_gej_add_var(r, r, &tmpj, NULL);\n     }\n+\n     return 1;\n }\n \n-/* Compute the number of batches and the batch size given the maximum batch size and the\n- * total number of points */\n-static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n_batch_points, size_t max_n_batch_points, size_t n) {\n-    if (max_n_batch_points == 0) {\n-        return 0;\n-    }\n-    if (max_n_batch_points > ECMULT_MAX_POINTS_PER_BATCH) {\n-        max_n_batch_points = ECMULT_MAX_POINTS_PER_BATCH;\n-    }\n-    if (n == 0) {\n-        *n_batches = 0;\n-        *n_batch_points = 0;\n+static int secp256k1_ecmult_multi_strauss(\n+    const secp256k1_callback *error_callback,\n+    secp256k1_gej *r,\n+    size_t n,\n+    const secp256k1_ge *points,\n+    const secp256k1_scalar *scalars,\n+    const secp256k1_scalar *scalar_g\n+) {\n+    struct secp256k1_strauss_state state;\n+    secp256k1_gej *points_gej = NULL;\n+    secp256k1_scalar *scalars_copy = NULL;\n+    size_t i;\n+    int ret = 0;\n+\n+    state.aux = NULL;\n+    state.pre_a = NULL;\n+    state.ps = NULL;\n+\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (scalar_g == NULL && n == 0) {\n         return 1;\n     }\n-    /* Compute ceil(n/max_n_batch_points) and ceil(n/n_batches) */\n-    *n_batches = CEIL_DIV(n, max_n_batch_points);\n-    *n_batch_points = CEIL_DIV(n, *n_batches);\n-    return 1;\n+\n+    if (n > 0) {\n+        state.aux = (secp256k1_fe *)checked_malloc(error_callback,\n+            n * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+        state.pre_a = (secp256k1_ge *)checked_malloc(error_callback,\n+            n * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+        state.ps = (struct secp256k1_strauss_point_state *)checked_malloc(error_callback,\n+            n * sizeof(struct secp256k1_strauss_point_state));\n+        points_gej = (secp256k1_gej *)checked_malloc(error_callback,\n+            n * sizeof(secp256k1_gej));\n+        scalars_copy = (secp256k1_scalar *)checked_malloc(error_callback,",
      "path": "src/ecmult_impl.h",
      "position": 1,
      "original_position": 454,
      "commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Is there a specific reason for copying the scalars here? Since they are managed by the upper layer (like batch verification or MuSig), could we just pass the pointer to `_strauss_wnaf` directly?",
      "created_at": "2025-12-26T14:22:03Z",
      "updated_at": "2025-12-26T14:27:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2648307770",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648307770"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 732,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648310997",
      "pull_request_review_id": 3613492155,
      "id": 2648310997,
      "node_id": "PRRC_kwDOAP4Jqs6d2gTV",
      "diff_hunk": "@@ -657,212 +545,376 @@ SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, s\n }\n \n /**\n- * Returns the scratch size required for a given number of points (excluding\n- * base point G) without considering alignment.\n+ * Algorithm Selection: ABCD Model\n+ *\n+ * For each possible batch algorithm choice, memory usage is\n+ * m(x) = A*x + B and running time is\n+ * c(x) = C*x + D, where x is the batch size.\n+ *\n+ * A = per-point memory (bytes)\n+ * B = fixed memory overhead (bytes)\n+ * C = per-point time cost\n+ * D = fixed time overhead\n  */\n-static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n-    size_t entries = 2*n_points + 2;\n-    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n-    return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n-}\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n-    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n-    /* Use 2(n+1) with the endomorphism, when calculating batch\n-     * sizes. The reason for +1 is that we add the G scalar to the list of\n-     * other scalars. */\n-    size_t entries = 2*n_points + 2;\n-    secp256k1_ge *points;\n-    secp256k1_scalar *scalars;\n-    secp256k1_gej *buckets;\n-    struct secp256k1_pippenger_state *state_space;\n-    size_t idx = 0;\n-    size_t point_idx = 0;\n-    int bucket_window;\n+struct secp256k1_ecmult_multi_abcd {\n+    size_t A;\n+    size_t B;\n+    size_t C;\n+    size_t D;\n+};\n \n-    secp256k1_gej_set_infinity(r);\n-    if (inp_g_sc == NULL && n_points == 0) {\n-        return 1;\n-    }\n-    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-\n-    /* We allocate PIPPENGER_SCRATCH_OBJECTS objects on the scratch space. If\n-     * these allocations change, make sure to update the\n-     * PIPPENGER_SCRATCH_OBJECTS constant and pippenger_scratch_size\n-     * accordingly. */\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n-    if (points == NULL || scalars == NULL || state_space == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, ((size_t)1 << bucket_window) * sizeof(*buckets));\n-    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n+/* Strauss per-point memory */\n+#define SECP256K1_STRAUSS_POINT_SIZE \\\n+    ((sizeof(secp256k1_ge) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) \\\n+     + sizeof(struct secp256k1_strauss_point_state) \\\n+     + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar))\n \n-    if (inp_g_sc != NULL) {\n-        scalars[0] = *inp_g_sc;\n-        points[0] = secp256k1_ge_const_g;\n-        idx++;\n-        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n-        idx++;\n-    }\n+/* Pippenger per-entry memory */\n+#define SECP256K1_PIPPENGER_ENTRY_SIZE(w) \\\n+    (sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) \\\n+     + sizeof(struct secp256k1_pippenger_point_state) \\\n+     + (WNAF_SIZE((w)+1) + 1) * sizeof(int))\n \n-    while (point_idx < n_points) {\n-        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-            return 0;\n+/* Pippenger per-point memory: 2 entries due to endomorphism */\n+#define SECP256K1_PIPPENGER_POINT_SIZE(w) (2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/* Pippenger fixed overhead: buckets + state + 2 extra entries */\n+#define SECP256K1_PIPPENGER_FIXED_SIZE(w) \\\n+    ((sizeof(secp256k1_gej) << (w)) \\\n+     + sizeof(struct secp256k1_pippenger_state) \\\n+     + 2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/*\n+ * ABCD constants for all batch algorithms.\n+ *\n+ * Index 0    = TRIVIAL (no memory, very slow)\n+ * Index 1    = STRAUSS (efficient for small batche sizes)\n+ * Index 2-13 = PIPPENGER with window sizes 1-12\n+ */\n+static const struct secp256k1_ecmult_multi_abcd secp256k1_ecmult_multi_abcds[SECP256K1_ECMULT_MULTI_NUM_ALGOS] = {\n+/*  A (per-point bytes)                     B (fixed bytes)                        C        D           */\n+    {0,                                     0,                                     1000,    0      },\n+    {SECP256K1_STRAUSS_POINT_SIZE,          0,                                     100,     0      },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(1),     SECP256K1_PIPPENGER_FIXED_SIZE(1),     500 /* manually disabled */,     181    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(2),     SECP256K1_PIPPENGER_FIXED_SIZE(2),     400 /* manually disabled */,     434    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(3),     SECP256K1_PIPPENGER_FIXED_SIZE(3),     117,     811    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(4),     SECP256K1_PIPPENGER_FIXED_SIZE(4),     100,     1231   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(5),     SECP256K1_PIPPENGER_FIXED_SIZE(5),     86,      1973   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(6),     SECP256K1_PIPPENGER_FIXED_SIZE(6),     76,      3123   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(7),     SECP256K1_PIPPENGER_FIXED_SIZE(7),     68,      5234   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(8),     SECP256K1_PIPPENGER_FIXED_SIZE(8),     64,      9269   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(9),     SECP256K1_PIPPENGER_FIXED_SIZE(9),     60,      15746  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(10),    SECP256K1_PIPPENGER_FIXED_SIZE(10),    62,      28723  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(11),    SECP256K1_PIPPENGER_FIXED_SIZE(11),    57,      51876  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(12),    SECP256K1_PIPPENGER_FIXED_SIZE(12),    61,      92195  },\n+};\n+\n+static size_t secp256k1_ecmult_multi_batch_size(size_t mem_limit) {\n+    /* We are implicitly using the TRIVIAL algorithm as a fallback\n+     * but we will only use it if no other algorithm fits. If that\n+     * is the case we can use max points as the batch size. */\n+    size_t best_batch_size = ECMULT_MAX_POINTS_PER_BATCH;\n+    size_t min_optime = SIZE_MAX;\n+    int i;\n+\n+    for (i = 1 /* ignores TRIVIAL */; i < SECP256K1_ECMULT_MULTI_NUM_ALGOS; i++) {\n+        const struct secp256k1_ecmult_multi_abcd *p = &secp256k1_ecmult_multi_abcds[i];\n+        size_t A = p->A, B = p->B, C = p->C, D = p->D, optime, batch_size;\n+\n+        if (mem_limit <= B) continue;\n+\n+        batch_size = (mem_limit - B) / A;\n+\n+        if (batch_size == 0) continue;\n+\n+        optime = C + D / batch_size;\n+\n+        if (optime < min_optime) {\n+            min_optime = optime;\n+            best_batch_size = batch_size;\n         }\n-        idx++;\n-        secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n-        idx++;\n-        point_idx++;\n     }\n \n-    secp256k1_ecmult_pippenger_wnaf(buckets, bucket_window, state_space, r, scalars, points, idx);\n-    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-    return 1;\n+    return best_batch_size;\n }\n \n-/* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n-}\n+static secp256k1_ecmult_multi_algo secp256k1_ecmult_multi_select(size_t mem_limit, size_t batch_size) {\n+    secp256k1_ecmult_multi_algo best_algo = SECP256K1_ECMULT_MULTI_ALGO_TRIVIAL;\n+    size_t min_optime = SIZE_MAX;\n+    int i;\n \n-/**\n- * Returns the maximum number of points in addition to G that can be used with\n- * a given scratch space. The function ensures that fewer points may also be\n- * used.\n- */\n-static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n-    size_t max_alloc = secp256k1_scratch_max_allocation(error_callback, scratch, PIPPENGER_SCRATCH_OBJECTS);\n-    int bucket_window;\n-    size_t res = 0;\n-\n-    for (bucket_window = 1; bucket_window <= PIPPENGER_MAX_BUCKET_WINDOW; bucket_window++) {\n-        size_t n_points;\n-        size_t max_points = secp256k1_pippenger_bucket_window_inv(bucket_window);\n-        size_t space_for_points;\n-        size_t space_overhead;\n-        size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n-\n-        entry_size = 2*entry_size;\n-        space_overhead = (sizeof(secp256k1_gej) << bucket_window) + entry_size + sizeof(struct secp256k1_pippenger_state);\n-        if (space_overhead > max_alloc) {\n-            break;\n-        }\n-        space_for_points = max_alloc - space_overhead;\n+    /* Use TRIVIAL fallback */\n+    if (batch_size == 0) return best_algo;\n \n-        n_points = space_for_points/entry_size;\n-        n_points = n_points > max_points ? max_points : n_points;\n-        if (n_points > res) {\n-            res = n_points;\n-        }\n-        if (n_points < max_points) {\n-            /* A larger bucket_window may support even more points. But if we\n-             * would choose that then the caller couldn't safely use any number\n-             * smaller than what this function returns */\n-            break;\n+    for (i = 0; i < SECP256K1_ECMULT_MULTI_NUM_ALGOS; i++) {\n+        const struct secp256k1_ecmult_multi_abcd *p = &secp256k1_ecmult_multi_abcds[i];\n+        size_t A = p->A, B = p->B, C = p->C, D = p->D, optime;\n+        size_t mem_usage = A * batch_size + B;\n+\n+        if (mem_usage > mem_limit) continue;\n+\n+        optime = C + D / batch_size;\n+\n+        if (optime < min_optime) {\n+            min_optime = optime;\n+            best_algo = (secp256k1_ecmult_multi_algo)i;\n         }\n     }\n-    return res;\n+\n+    return best_algo;\n }\n \n-/* Computes ecmult_multi by simply multiplying and adding each point. Does not\n- * require a scratch space */\n-static int secp256k1_ecmult_multi_simple_var(secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n-    size_t point_idx;\n+/* Trivial algorithm: Computes ecmult_multi by simply multiplying and adding each point. */\n+static int secp256k1_ecmult_multi_trivial(\n+    secp256k1_gej *r,\n+    size_t n,\n+    const secp256k1_ge *points,\n+    const secp256k1_scalar *scalars,\n+    const secp256k1_scalar *scalar_g\n+) {\n+    size_t i;\n     secp256k1_gej tmpj;\n \n     secp256k1_gej_set_infinity(r);\n-    secp256k1_gej_set_infinity(&tmpj);\n-    /* r = inp_g_sc*G */\n-    secp256k1_ecmult(r, &tmpj, &secp256k1_scalar_zero, inp_g_sc);\n-    for (point_idx = 0; point_idx < n_points; point_idx++) {\n-        secp256k1_ge point;\n+\n+    if (scalar_g != NULL) {\n+        secp256k1_gej_set_infinity(&tmpj);\n+        secp256k1_ecmult(r, &tmpj, &secp256k1_scalar_zero, scalar_g);\n+    }\n+\n+    for (i = 0; i < n; i++) {\n         secp256k1_gej pointj;\n-        secp256k1_scalar scalar;\n-        if (!cb(&scalar, &point, point_idx, cbdata)) {\n-            return 0;\n+        if (secp256k1_ge_is_infinity(&points[i])) {\n+            continue;\n         }\n-        /* r += scalar*point */\n-        secp256k1_gej_set_ge(&pointj, &point);\n-        secp256k1_ecmult(&tmpj, &pointj, &scalar, NULL);\n+        secp256k1_gej_set_ge(&pointj, &points[i]);\n+        secp256k1_ecmult(&tmpj, &pointj, &scalars[i], NULL);\n         secp256k1_gej_add_var(r, r, &tmpj, NULL);\n     }\n+\n     return 1;\n }\n \n-/* Compute the number of batches and the batch size given the maximum batch size and the\n- * total number of points */\n-static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n_batch_points, size_t max_n_batch_points, size_t n) {\n-    if (max_n_batch_points == 0) {\n-        return 0;\n-    }\n-    if (max_n_batch_points > ECMULT_MAX_POINTS_PER_BATCH) {\n-        max_n_batch_points = ECMULT_MAX_POINTS_PER_BATCH;\n-    }\n-    if (n == 0) {\n-        *n_batches = 0;\n-        *n_batch_points = 0;\n+static int secp256k1_ecmult_multi_strauss(\n+    const secp256k1_callback *error_callback,\n+    secp256k1_gej *r,\n+    size_t n,\n+    const secp256k1_ge *points,\n+    const secp256k1_scalar *scalars,\n+    const secp256k1_scalar *scalar_g\n+) {\n+    struct secp256k1_strauss_state state;\n+    secp256k1_gej *points_gej = NULL;\n+    secp256k1_scalar *scalars_copy = NULL;\n+    size_t i;\n+    int ret = 0;\n+\n+    state.aux = NULL;\n+    state.pre_a = NULL;\n+    state.ps = NULL;\n+\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (scalar_g == NULL && n == 0) {\n         return 1;\n     }\n-    /* Compute ceil(n/max_n_batch_points) and ceil(n/n_batches) */\n-    *n_batches = CEIL_DIV(n, max_n_batch_points);\n-    *n_batch_points = CEIL_DIV(n, *n_batches);\n-    return 1;\n+\n+    if (n > 0) {\n+        state.aux = (secp256k1_fe *)checked_malloc(error_callback,\n+            n * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+        state.pre_a = (secp256k1_ge *)checked_malloc(error_callback,\n+            n * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+        state.ps = (struct secp256k1_strauss_point_state *)checked_malloc(error_callback,\n+            n * sizeof(struct secp256k1_strauss_point_state));\n+        points_gej = (secp256k1_gej *)checked_malloc(error_callback,\n+            n * sizeof(secp256k1_gej));\n+        scalars_copy = (secp256k1_scalar *)checked_malloc(error_callback,\n+            n * sizeof(secp256k1_scalar));\n+\n+        if (state.aux == NULL || state.pre_a == NULL || state.ps == NULL ||\n+            points_gej == NULL || scalars_copy == NULL) {\n+            goto cleanup;\n+        }\n+\n+        for (i = 0; i < n; i++) {\n+            secp256k1_gej_set_ge(&points_gej[i], &points[i]);\n+            scalars_copy[i] = scalars[i];\n+        }\n+\n+        secp256k1_ecmult_strauss_wnaf(&state, r, n, points_gej, scalars_copy, scalar_g);\n+    } else {\n+        secp256k1_gej tmpj;\n+        secp256k1_gej_set_infinity(&tmpj);\n+        secp256k1_ecmult(r, &tmpj, &secp256k1_scalar_zero, scalar_g);\n+    }",
      "path": "src/ecmult_impl.h",
      "position": 1,
      "original_position": 472,
      "commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "We can probably remove this else block. The `n=0` case is already handled by the call to `ecmult_strauss_wnaf` in the preceding if block. Plus, `secp256k1_ecmult` calls `strauss_wnaf` internally, so this seems redundant.",
      "created_at": "2025-12-26T14:25:28Z",
      "updated_at": "2025-12-26T14:27:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2648310997",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2648310997"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": 746,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 750,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2649041440",
      "pull_request_review_id": 3614260299,
      "id": 2649041440,
      "node_id": "PRRC_kwDOAP4Jqs6d5Sog",
      "diff_hunk": "@@ -657,212 +545,376 @@ SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, s\n }\n \n /**\n- * Returns the scratch size required for a given number of points (excluding\n- * base point G) without considering alignment.\n+ * Algorithm Selection: ABCD Model\n+ *\n+ * For each possible batch algorithm choice, memory usage is\n+ * m(x) = A*x + B and running time is\n+ * c(x) = C*x + D, where x is the batch size.\n+ *\n+ * A = per-point memory (bytes)\n+ * B = fixed memory overhead (bytes)\n+ * C = per-point time cost\n+ * D = fixed time overhead\n  */\n-static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n-    size_t entries = 2*n_points + 2;\n-    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n-    return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n-}\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n-    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n-    /* Use 2(n+1) with the endomorphism, when calculating batch\n-     * sizes. The reason for +1 is that we add the G scalar to the list of\n-     * other scalars. */\n-    size_t entries = 2*n_points + 2;\n-    secp256k1_ge *points;\n-    secp256k1_scalar *scalars;\n-    secp256k1_gej *buckets;\n-    struct secp256k1_pippenger_state *state_space;\n-    size_t idx = 0;\n-    size_t point_idx = 0;\n-    int bucket_window;\n+struct secp256k1_ecmult_multi_abcd {\n+    size_t A;\n+    size_t B;\n+    size_t C;\n+    size_t D;\n+};\n \n-    secp256k1_gej_set_infinity(r);\n-    if (inp_g_sc == NULL && n_points == 0) {\n-        return 1;\n-    }\n-    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-\n-    /* We allocate PIPPENGER_SCRATCH_OBJECTS objects on the scratch space. If\n-     * these allocations change, make sure to update the\n-     * PIPPENGER_SCRATCH_OBJECTS constant and pippenger_scratch_size\n-     * accordingly. */\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n-    if (points == NULL || scalars == NULL || state_space == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, ((size_t)1 << bucket_window) * sizeof(*buckets));\n-    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n+/* Strauss per-point memory */\n+#define SECP256K1_STRAUSS_POINT_SIZE \\\n+    ((sizeof(secp256k1_ge) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) \\\n+     + sizeof(struct secp256k1_strauss_point_state) \\\n+     + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar))\n \n-    if (inp_g_sc != NULL) {\n-        scalars[0] = *inp_g_sc;\n-        points[0] = secp256k1_ge_const_g;\n-        idx++;\n-        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n-        idx++;\n-    }\n+/* Pippenger per-entry memory */\n+#define SECP256K1_PIPPENGER_ENTRY_SIZE(w) \\\n+    (sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) \\\n+     + sizeof(struct secp256k1_pippenger_point_state) \\\n+     + (WNAF_SIZE((w)+1) + 1) * sizeof(int))\n \n-    while (point_idx < n_points) {\n-        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-            return 0;\n+/* Pippenger per-point memory: 2 entries due to endomorphism */\n+#define SECP256K1_PIPPENGER_POINT_SIZE(w) (2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/* Pippenger fixed overhead: buckets + state + 2 extra entries */\n+#define SECP256K1_PIPPENGER_FIXED_SIZE(w) \\\n+    ((sizeof(secp256k1_gej) << (w)) \\\n+     + sizeof(struct secp256k1_pippenger_state) \\\n+     + 2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/*\n+ * ABCD constants for all batch algorithms.\n+ *\n+ * Index 0    = TRIVIAL (no memory, very slow)\n+ * Index 1    = STRAUSS (efficient for small batche sizes)\n+ * Index 2-13 = PIPPENGER with window sizes 1-12\n+ */\n+static const struct secp256k1_ecmult_multi_abcd secp256k1_ecmult_multi_abcds[SECP256K1_ECMULT_MULTI_NUM_ALGOS] = {\n+/*  A (per-point bytes)                     B (fixed bytes)                        C        D           */\n+    {0,                                     0,                                     1000,    0      },\n+    {SECP256K1_STRAUSS_POINT_SIZE,          0,                                     100,     0      },",
      "path": "src/ecmult_impl.h",
      "position": 239,
      "original_position": 244,
      "commit_id": "c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`D` shouldn't be 0 here right?",
      "created_at": "2025-12-27T09:00:59Z",
      "updated_at": "2025-12-27T09:13:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2649041440",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2649041440"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 597,
      "original_line": 597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2649048710",
      "pull_request_review_id": 3614266738,
      "id": 2649048710,
      "node_id": "PRRC_kwDOAP4Jqs6d5UaG",
      "diff_hunk": "@@ -59,6 +65,110 @@ typedef struct {\n     secp256k1_fe* output_xonly;\n } bench_data;\n \n+/*\n+ * ABCD Calibration Benchmarks\n+ *\n+ * Measures the performance of each algorithm at various batch sizes and\n+ * outputs. Use tools/ecmult_multi_calib.py to calculate optimal C and D\n+ * values from the output.\n+ */\n+static void run_ecmult_multi_calib(bench_data* data) {\n+    static const size_t batch_sizes[] = {10, 20, 30, 50, 75, 100, 150, 200, 300, 500, 750, 1000, 1500, 2000, 3000, 5000, 7500, 10000, 15000, 20000, 30000};",
      "path": "src/bench_ecmult.c",
      "position": 61,
      "original_position": 59,
      "commit_id": "c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "original_commit_id": "8b62524b0fd69a98612e5151cf8ebf26efe8492a",
      "in_reply_to_id": null,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think it woulbe nice to have more batch sizes in the crossover region of strauss and pippenger (~80-150 points). So, something like this:\n```\n    static const size_t batch_sizes[] = {\n        /* Small (Strauss region) */\n        5, 10, 15, 20, 30, 50, 70,\n        /* Crossover region */\n        85, 88, 90, 100, 120, 150, 175,\n        /* Medium (Pippenger small windows, w=6..8) */\n        200, 300, 500, 750, 1000, 1200,\n        /* Large (Pippenger large windows, w=9..12) */\n        1500, 2000, 3000, 5000, 7500,\n        10000, 15000, 20000, 30000\n    };\n```",
      "created_at": "2025-12-27T09:17:04Z",
      "updated_at": "2025-12-27T09:17:04Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2649048710",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2649048710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 81,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2649052108",
      "pull_request_review_id": 3614268882,
      "id": 2649052108,
      "node_id": "PRRC_kwDOAP4Jqs6d5VPM",
      "diff_hunk": "@@ -59,6 +65,110 @@ typedef struct {\n     secp256k1_fe* output_xonly;\n } bench_data;\n \n+/*\n+ * ABCD Calibration Benchmarks\n+ *\n+ * Measures the performance of each algorithm at various batch sizes and\n+ * outputs. Use tools/ecmult_multi_calib.py to calculate optimal C and D\n+ * values from the output.\n+ */\n+static void run_ecmult_multi_calib(bench_data* data) {\n+    static const size_t batch_sizes[] = {10, 20, 30, 50, 75, 100, 150, 200, 300, 500, 750, 1000, 1500, 2000, 3000, 5000, 7500, 10000, 15000, 20000, 30000};",
      "path": "src/bench_ecmult.c",
      "position": 61,
      "original_position": 59,
      "commit_id": "c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "original_commit_id": "8b62524b0fd69a98612e5151cf8ebf26efe8492a",
      "in_reply_to_id": 2649048710,
      "user": {
        "login": "siv2r",
        "id": 56887198,
        "node_id": "MDQ6VXNlcjU2ODg3MTk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/56887198?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/siv2r",
        "html_url": "https://github.com/siv2r",
        "followers_url": "https://api.github.com/users/siv2r/followers",
        "following_url": "https://api.github.com/users/siv2r/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/siv2r/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/siv2r/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/siv2r/subscriptions",
        "organizations_url": "https://api.github.com/users/siv2r/orgs",
        "repos_url": "https://api.github.com/users/siv2r/repos",
        "events_url": "https://api.github.com/users/siv2r/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/siv2r/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "We should probably cap the batch size for Strauss calibration (7,500 or less?). At higher sizes, the benchmark results curve and become outliers, which will skew the linear regression model. Since `ecmult_multi_select` won't choose Strauss for large batches anyway, we can avoid these sizes. I've attached a visualization below.\r\n\r\n<img width=\"640\" height=\"480\" alt=\"STRAUSS\" src=\"https://github.com/user-attachments/assets/b251b0c9-1323-4e6e-8f2f-eee6246c7e26\" />\r\n",
      "created_at": "2025-12-27T09:26:31Z",
      "updated_at": "2025-12-27T12:08:54Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2649052108",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2649052108"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 81,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709121298",
      "pull_request_review_id": 3683107204,
      "id": 2709121298,
      "node_id": "PRRC_kwDOAP4Jqs6heekS",
      "diff_hunk": "@@ -149,26 +149,13 @@ typedef struct {\n     secp256k1_ge second_pk;\n } secp256k1_musig_pubkey_agg_ecmult_data;\n \n-/* Callback for batch EC multiplication to compute keyaggcoef_0*P0 + keyaggcoef_1*P1 + ...  */\n-static int secp256k1_musig_pubkey_agg_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data) {\n-    secp256k1_musig_pubkey_agg_ecmult_data *ctx = (secp256k1_musig_pubkey_agg_ecmult_data *) data;\n-    int ret;\n-    ret = secp256k1_pubkey_load(ctx->ctx, pt, ctx->pks[idx]);\n-#ifdef VERIFY\n-    /* pubkey_load can't fail because the same pks have already been loaded in\n-     * `musig_compute_pks_hash` (and we test this). */\n-    VERIFY_CHECK(ret);\n-#else\n-    (void) ret;\n-#endif\n-    secp256k1_musig_keyaggcoef_internal(sc, ctx->pks_hash, pt, &ctx->second_pk);\n-    return 1;\n-}\n-\n int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pubkey *agg_pk, secp256k1_musig_keyagg_cache *keyagg_cache, const secp256k1_pubkey * const* pubkeys, size_t n_pubkeys) {",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 20,
      "original_position": 20,
      "commit_id": "c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": 2648251146,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Hm, I see the point that this would align with the batch validation API that has been discussed but I am not sure that this justifies changing the existing API of musig. It would probably better to have this in a separate/follow-up PR but I will wait a bit to see what other reviewers think about this.",
      "created_at": "2026-01-20T16:26:32Z",
      "updated_at": "2026-01-20T16:26:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2709121298",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709121298"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 152,
      "original_line": 152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709121553",
      "pull_request_review_id": 3683107547,
      "id": 2709121553,
      "node_id": "PRRC_kwDOAP4Jqs6heeoR",
      "diff_hunk": "@@ -199,14 +183,36 @@ int secp256k1_musig_pubkey_agg(const secp256k1_context* ctx, secp256k1_xonly_pub\n     if (!secp256k1_musig_compute_pks_hash(ctx, ecmult_data.pks_hash, pubkeys, n_pubkeys)) {\n         return 0;\n     }\n-    /* TODO: actually use optimized ecmult_multi algorithms by providing a\n-     * scratch space */\n-    if (!secp256k1_ecmult_multi_var(&ctx->error_callback, NULL, &pkj, NULL, secp256k1_musig_pubkey_agg_callback, (void *) &ecmult_data, n_pubkeys)) {\n-        /* In order to reach this line with the current implementation of\n-         * ecmult_multi_var one would need to provide a callback that can\n-         * fail. */\n+\n+    /* TODO: This follows the discussed approach of letting the users use\n+     * malloc instead of scratch space. However there could also be a simple\n+     * wrapper that abstracts the malloc stuff away. This could be cleaner. */\n+    points = (secp256k1_ge *)checked_malloc(&ctx->error_callback, n_pubkeys * sizeof(secp256k1_ge));\n+    scalars = (secp256k1_scalar *)checked_malloc(&ctx->error_callback, n_pubkeys * sizeof(secp256k1_scalar));\n+\n+    for (i = 0; i < n_pubkeys; i++) {\n+#ifdef VERIFY\n+        /* pubkey_load can't fail because the same pks have already been loaded\n+         * in `musig_compute_pks_hash` (and we test this). */\n+        VERIFY_CHECK(secp256k1_pubkey_load(ctx, &points[i], pubkeys[i]));\n+#else\n+        (void) secp256k1_pubkey_load(ctx, &points[i], pubkeys[i]);\n+#endif\n+        secp256k1_musig_keyaggcoef_internal(&scalars[i], ecmult_data.pks_hash, &points[i], &ecmult_data.second_pk);\n+    }\n+\n+    /* TODO: Previously this just used TRIVIAL algorithm by not providing\n+     * scratch space. To be discussed if this should be changed. */\n+    mem_limit = n_pubkeys * (sizeof(secp256k1_ge) + sizeof(secp256k1_scalar)) * 4;",
      "path": "src/modules/musig/keyagg_impl.h",
      "position": 1,
      "original_position": 70,
      "commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": 2648271415,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This was just a rough heuristic that I put not much thought in because of the TODO above which I am still unsure about. Your suggestions are interesting and I think we could actually just do `mem_limit = SECP256K1_STRAUSS_POINT_SIZE * n_pubkeys;` because in 99.9% of musig cases Strauss should be the optimal algorithm anyway and this makes the reasoning of the code easier as well. Let me know what you think, I have updated the code with this for now.",
      "created_at": "2026-01-20T16:26:37Z",
      "updated_at": "2026-01-20T16:26:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2709121553",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709121553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709122186",
      "pull_request_review_id": 3683108296,
      "id": 2709122186,
      "node_id": "PRRC_kwDOAP4Jqs6heeyK",
      "diff_hunk": "@@ -306,11 +333,11 @@ static void run_ecmult_multi_bench(bench_data* data, size_t count, int includes_\n int main(int argc, char **argv) {\n     bench_data data;\n     int i, p;\n-    size_t scratch_size;\n \n     int iters = get_iters(10000);\n \n-    data.ecmult_multi = secp256k1_ecmult_multi_var;\n+    data.forced_algo = -1;",
      "path": "src/bench_ecmult.c",
      "position": 1,
      "original_position": 121,
      "commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": 2648294345,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Sounds good, taken.",
      "created_at": "2026-01-20T16:26:47Z",
      "updated_at": "2026-01-20T16:26:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2709122186",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709122186"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 339,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709122436",
      "pull_request_review_id": 3683108599,
      "id": 2709122436,
      "node_id": "PRRC_kwDOAP4Jqs6hee2E",
      "diff_hunk": "@@ -186,17 +186,13 @@ typedef struct {\n     secp256k1_ge pt[2];\n } ecmult_multi_data;",
      "path": "src/tests_exhaustive.c",
      "position": 1,
      "original_position": 2,
      "commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": 2648282791,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Oh, true, good catch!",
      "created_at": "2026-01-20T16:26:50Z",
      "updated_at": "2026-01-20T16:26:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2709122436",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709122436"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": 184,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 187,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709122783",
      "pull_request_review_id": 3683109035,
      "id": 2709122783,
      "node_id": "PRRC_kwDOAP4Jqs6hee7f",
      "diff_hunk": "@@ -657,212 +545,376 @@ SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, s\n }\n \n /**\n- * Returns the scratch size required for a given number of points (excluding\n- * base point G) without considering alignment.\n+ * Algorithm Selection: ABCD Model\n+ *\n+ * For each possible batch algorithm choice, memory usage is\n+ * m(x) = A*x + B and running time is\n+ * c(x) = C*x + D, where x is the batch size.\n+ *\n+ * A = per-point memory (bytes)\n+ * B = fixed memory overhead (bytes)\n+ * C = per-point time cost\n+ * D = fixed time overhead\n  */\n-static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n-    size_t entries = 2*n_points + 2;\n-    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n-    return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n-}\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n-    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n-    /* Use 2(n+1) with the endomorphism, when calculating batch\n-     * sizes. The reason for +1 is that we add the G scalar to the list of\n-     * other scalars. */\n-    size_t entries = 2*n_points + 2;\n-    secp256k1_ge *points;\n-    secp256k1_scalar *scalars;\n-    secp256k1_gej *buckets;\n-    struct secp256k1_pippenger_state *state_space;\n-    size_t idx = 0;\n-    size_t point_idx = 0;\n-    int bucket_window;\n+struct secp256k1_ecmult_multi_abcd {\n+    size_t A;\n+    size_t B;\n+    size_t C;\n+    size_t D;\n+};\n \n-    secp256k1_gej_set_infinity(r);\n-    if (inp_g_sc == NULL && n_points == 0) {\n-        return 1;\n-    }\n-    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-\n-    /* We allocate PIPPENGER_SCRATCH_OBJECTS objects on the scratch space. If\n-     * these allocations change, make sure to update the\n-     * PIPPENGER_SCRATCH_OBJECTS constant and pippenger_scratch_size\n-     * accordingly. */\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n-    if (points == NULL || scalars == NULL || state_space == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, ((size_t)1 << bucket_window) * sizeof(*buckets));\n-    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n+/* Strauss per-point memory */\n+#define SECP256K1_STRAUSS_POINT_SIZE \\\n+    ((sizeof(secp256k1_ge) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) \\\n+     + sizeof(struct secp256k1_strauss_point_state) \\\n+     + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar))\n \n-    if (inp_g_sc != NULL) {\n-        scalars[0] = *inp_g_sc;\n-        points[0] = secp256k1_ge_const_g;\n-        idx++;\n-        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n-        idx++;\n-    }\n+/* Pippenger per-entry memory */\n+#define SECP256K1_PIPPENGER_ENTRY_SIZE(w) \\\n+    (sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) \\\n+     + sizeof(struct secp256k1_pippenger_point_state) \\\n+     + (WNAF_SIZE((w)+1) + 1) * sizeof(int))\n \n-    while (point_idx < n_points) {\n-        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-            return 0;\n+/* Pippenger per-point memory: 2 entries due to endomorphism */\n+#define SECP256K1_PIPPENGER_POINT_SIZE(w) (2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/* Pippenger fixed overhead: buckets + state + 2 extra entries */\n+#define SECP256K1_PIPPENGER_FIXED_SIZE(w) \\\n+    ((sizeof(secp256k1_gej) << (w)) \\\n+     + sizeof(struct secp256k1_pippenger_state) \\\n+     + 2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))",
      "path": "src/ecmult_impl.h",
      "position": 227,
      "original_position": 232,
      "commit_id": "c2c9bc2c8055d38f793288bfbc84e37cef4afe0e",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": 2648301540,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "That looks correct to me, taken!",
      "created_at": "2026-01-20T16:26:55Z",
      "updated_at": "2026-01-20T16:26:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2709122783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709122783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": 583,
      "original_start_line": 583,
      "start_side": "RIGHT",
      "line": 585,
      "original_line": 585,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709123184",
      "pull_request_review_id": 3683109498,
      "id": 2709123184,
      "node_id": "PRRC_kwDOAP4Jqs6hefBw",
      "diff_hunk": "@@ -657,212 +545,376 @@ SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, s\n }\n \n /**\n- * Returns the scratch size required for a given number of points (excluding\n- * base point G) without considering alignment.\n+ * Algorithm Selection: ABCD Model\n+ *\n+ * For each possible batch algorithm choice, memory usage is\n+ * m(x) = A*x + B and running time is\n+ * c(x) = C*x + D, where x is the batch size.\n+ *\n+ * A = per-point memory (bytes)\n+ * B = fixed memory overhead (bytes)\n+ * C = per-point time cost\n+ * D = fixed time overhead\n  */\n-static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n-    size_t entries = 2*n_points + 2;\n-    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n-    return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n-}\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n-    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n-    /* Use 2(n+1) with the endomorphism, when calculating batch\n-     * sizes. The reason for +1 is that we add the G scalar to the list of\n-     * other scalars. */\n-    size_t entries = 2*n_points + 2;\n-    secp256k1_ge *points;\n-    secp256k1_scalar *scalars;\n-    secp256k1_gej *buckets;\n-    struct secp256k1_pippenger_state *state_space;\n-    size_t idx = 0;\n-    size_t point_idx = 0;\n-    int bucket_window;\n+struct secp256k1_ecmult_multi_abcd {\n+    size_t A;\n+    size_t B;\n+    size_t C;\n+    size_t D;\n+};\n \n-    secp256k1_gej_set_infinity(r);\n-    if (inp_g_sc == NULL && n_points == 0) {\n-        return 1;\n-    }\n-    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-\n-    /* We allocate PIPPENGER_SCRATCH_OBJECTS objects on the scratch space. If\n-     * these allocations change, make sure to update the\n-     * PIPPENGER_SCRATCH_OBJECTS constant and pippenger_scratch_size\n-     * accordingly. */\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n-    if (points == NULL || scalars == NULL || state_space == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, ((size_t)1 << bucket_window) * sizeof(*buckets));\n-    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n+/* Strauss per-point memory */\n+#define SECP256K1_STRAUSS_POINT_SIZE \\\n+    ((sizeof(secp256k1_ge) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) \\\n+     + sizeof(struct secp256k1_strauss_point_state) \\\n+     + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar))\n \n-    if (inp_g_sc != NULL) {\n-        scalars[0] = *inp_g_sc;\n-        points[0] = secp256k1_ge_const_g;\n-        idx++;\n-        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n-        idx++;\n-    }\n+/* Pippenger per-entry memory */\n+#define SECP256K1_PIPPENGER_ENTRY_SIZE(w) \\\n+    (sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) \\\n+     + sizeof(struct secp256k1_pippenger_point_state) \\\n+     + (WNAF_SIZE((w)+1) + 1) * sizeof(int))\n \n-    while (point_idx < n_points) {\n-        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-            return 0;\n+/* Pippenger per-point memory: 2 entries due to endomorphism */\n+#define SECP256K1_PIPPENGER_POINT_SIZE(w) (2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/* Pippenger fixed overhead: buckets + state + 2 extra entries */\n+#define SECP256K1_PIPPENGER_FIXED_SIZE(w) \\\n+    ((sizeof(secp256k1_gej) << (w)) \\\n+     + sizeof(struct secp256k1_pippenger_state) \\\n+     + 2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/*\n+ * ABCD constants for all batch algorithms.\n+ *\n+ * Index 0    = TRIVIAL (no memory, very slow)\n+ * Index 1    = STRAUSS (efficient for small batche sizes)\n+ * Index 2-13 = PIPPENGER with window sizes 1-12\n+ */\n+static const struct secp256k1_ecmult_multi_abcd secp256k1_ecmult_multi_abcds[SECP256K1_ECMULT_MULTI_NUM_ALGOS] = {\n+/*  A (per-point bytes)                     B (fixed bytes)                        C        D           */\n+    {0,                                     0,                                     1000,    0      },\n+    {SECP256K1_STRAUSS_POINT_SIZE,          0,                                     100,     0      },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(1),     SECP256K1_PIPPENGER_FIXED_SIZE(1),     500 /* manually disabled */,     181    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(2),     SECP256K1_PIPPENGER_FIXED_SIZE(2),     400 /* manually disabled */,     434    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(3),     SECP256K1_PIPPENGER_FIXED_SIZE(3),     117,     811    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(4),     SECP256K1_PIPPENGER_FIXED_SIZE(4),     100,     1231   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(5),     SECP256K1_PIPPENGER_FIXED_SIZE(5),     86,      1973   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(6),     SECP256K1_PIPPENGER_FIXED_SIZE(6),     76,      3123   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(7),     SECP256K1_PIPPENGER_FIXED_SIZE(7),     68,      5234   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(8),     SECP256K1_PIPPENGER_FIXED_SIZE(8),     64,      9269   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(9),     SECP256K1_PIPPENGER_FIXED_SIZE(9),     60,      15746  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(10),    SECP256K1_PIPPENGER_FIXED_SIZE(10),    62,      28723  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(11),    SECP256K1_PIPPENGER_FIXED_SIZE(11),    57,      51876  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(12),    SECP256K1_PIPPENGER_FIXED_SIZE(12),    61,      92195  },\n+};\n+\n+static size_t secp256k1_ecmult_multi_batch_size(size_t mem_limit) {\n+    /* We are implicitly using the TRIVIAL algorithm as a fallback\n+     * but we will only use it if no other algorithm fits. If that\n+     * is the case we can use max points as the batch size. */\n+    size_t best_batch_size = ECMULT_MAX_POINTS_PER_BATCH;\n+    size_t min_optime = SIZE_MAX;\n+    int i;\n+\n+    for (i = 1 /* ignores TRIVIAL */; i < SECP256K1_ECMULT_MULTI_NUM_ALGOS; i++) {\n+        const struct secp256k1_ecmult_multi_abcd *p = &secp256k1_ecmult_multi_abcds[i];\n+        size_t A = p->A, B = p->B, C = p->C, D = p->D, optime, batch_size;\n+\n+        if (mem_limit <= B) continue;\n+\n+        batch_size = (mem_limit - B) / A;\n+\n+        if (batch_size == 0) continue;\n+\n+        optime = C + D / batch_size;\n+\n+        if (optime < min_optime) {\n+            min_optime = optime;\n+            best_batch_size = batch_size;\n         }\n-        idx++;\n-        secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n-        idx++;\n-        point_idx++;\n     }\n \n-    secp256k1_ecmult_pippenger_wnaf(buckets, bucket_window, state_space, r, scalars, points, idx);\n-    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-    return 1;\n+    return best_batch_size;\n }\n \n-/* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n-}\n+static secp256k1_ecmult_multi_algo secp256k1_ecmult_multi_select(size_t mem_limit, size_t batch_size) {\n+    secp256k1_ecmult_multi_algo best_algo = SECP256K1_ECMULT_MULTI_ALGO_TRIVIAL;\n+    size_t min_optime = SIZE_MAX;\n+    int i;\n \n-/**\n- * Returns the maximum number of points in addition to G that can be used with\n- * a given scratch space. The function ensures that fewer points may also be\n- * used.\n- */\n-static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n-    size_t max_alloc = secp256k1_scratch_max_allocation(error_callback, scratch, PIPPENGER_SCRATCH_OBJECTS);\n-    int bucket_window;\n-    size_t res = 0;\n-\n-    for (bucket_window = 1; bucket_window <= PIPPENGER_MAX_BUCKET_WINDOW; bucket_window++) {\n-        size_t n_points;\n-        size_t max_points = secp256k1_pippenger_bucket_window_inv(bucket_window);\n-        size_t space_for_points;\n-        size_t space_overhead;\n-        size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n-\n-        entry_size = 2*entry_size;\n-        space_overhead = (sizeof(secp256k1_gej) << bucket_window) + entry_size + sizeof(struct secp256k1_pippenger_state);\n-        if (space_overhead > max_alloc) {\n-            break;\n-        }\n-        space_for_points = max_alloc - space_overhead;\n+    /* Use TRIVIAL fallback */\n+    if (batch_size == 0) return best_algo;\n \n-        n_points = space_for_points/entry_size;\n-        n_points = n_points > max_points ? max_points : n_points;\n-        if (n_points > res) {\n-            res = n_points;\n-        }\n-        if (n_points < max_points) {\n-            /* A larger bucket_window may support even more points. But if we\n-             * would choose that then the caller couldn't safely use any number\n-             * smaller than what this function returns */\n-            break;\n+    for (i = 0; i < SECP256K1_ECMULT_MULTI_NUM_ALGOS; i++) {\n+        const struct secp256k1_ecmult_multi_abcd *p = &secp256k1_ecmult_multi_abcds[i];\n+        size_t A = p->A, B = p->B, C = p->C, D = p->D, optime;\n+        size_t mem_usage = A * batch_size + B;\n+\n+        if (mem_usage > mem_limit) continue;\n+\n+        optime = C + D / batch_size;\n+\n+        if (optime < min_optime) {\n+            min_optime = optime;\n+            best_algo = (secp256k1_ecmult_multi_algo)i;\n         }\n     }\n-    return res;\n+\n+    return best_algo;\n }\n \n-/* Computes ecmult_multi by simply multiplying and adding each point. Does not\n- * require a scratch space */\n-static int secp256k1_ecmult_multi_simple_var(secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n-    size_t point_idx;\n+/* Trivial algorithm: Computes ecmult_multi by simply multiplying and adding each point. */\n+static int secp256k1_ecmult_multi_trivial(\n+    secp256k1_gej *r,\n+    size_t n,\n+    const secp256k1_ge *points,\n+    const secp256k1_scalar *scalars,\n+    const secp256k1_scalar *scalar_g\n+) {\n+    size_t i;\n     secp256k1_gej tmpj;\n \n     secp256k1_gej_set_infinity(r);\n-    secp256k1_gej_set_infinity(&tmpj);\n-    /* r = inp_g_sc*G */\n-    secp256k1_ecmult(r, &tmpj, &secp256k1_scalar_zero, inp_g_sc);\n-    for (point_idx = 0; point_idx < n_points; point_idx++) {\n-        secp256k1_ge point;\n+\n+    if (scalar_g != NULL) {\n+        secp256k1_gej_set_infinity(&tmpj);\n+        secp256k1_ecmult(r, &tmpj, &secp256k1_scalar_zero, scalar_g);\n+    }\n+\n+    for (i = 0; i < n; i++) {\n         secp256k1_gej pointj;\n-        secp256k1_scalar scalar;\n-        if (!cb(&scalar, &point, point_idx, cbdata)) {\n-            return 0;\n+        if (secp256k1_ge_is_infinity(&points[i])) {\n+            continue;\n         }\n-        /* r += scalar*point */\n-        secp256k1_gej_set_ge(&pointj, &point);\n-        secp256k1_ecmult(&tmpj, &pointj, &scalar, NULL);\n+        secp256k1_gej_set_ge(&pointj, &points[i]);\n+        secp256k1_ecmult(&tmpj, &pointj, &scalars[i], NULL);\n         secp256k1_gej_add_var(r, r, &tmpj, NULL);\n     }\n+\n     return 1;\n }\n \n-/* Compute the number of batches and the batch size given the maximum batch size and the\n- * total number of points */\n-static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n_batch_points, size_t max_n_batch_points, size_t n) {\n-    if (max_n_batch_points == 0) {\n-        return 0;\n-    }\n-    if (max_n_batch_points > ECMULT_MAX_POINTS_PER_BATCH) {\n-        max_n_batch_points = ECMULT_MAX_POINTS_PER_BATCH;\n-    }\n-    if (n == 0) {\n-        *n_batches = 0;\n-        *n_batch_points = 0;\n+static int secp256k1_ecmult_multi_strauss(\n+    const secp256k1_callback *error_callback,\n+    secp256k1_gej *r,\n+    size_t n,\n+    const secp256k1_ge *points,\n+    const secp256k1_scalar *scalars,\n+    const secp256k1_scalar *scalar_g\n+) {\n+    struct secp256k1_strauss_state state;\n+    secp256k1_gej *points_gej = NULL;\n+    secp256k1_scalar *scalars_copy = NULL;\n+    size_t i;\n+    int ret = 0;\n+\n+    state.aux = NULL;\n+    state.pre_a = NULL;\n+    state.ps = NULL;\n+\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (scalar_g == NULL && n == 0) {\n         return 1;\n     }\n-    /* Compute ceil(n/max_n_batch_points) and ceil(n/n_batches) */\n-    *n_batches = CEIL_DIV(n, max_n_batch_points);\n-    *n_batch_points = CEIL_DIV(n, *n_batches);\n-    return 1;\n+\n+    if (n > 0) {\n+        state.aux = (secp256k1_fe *)checked_malloc(error_callback,\n+            n * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+        state.pre_a = (secp256k1_ge *)checked_malloc(error_callback,\n+            n * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+        state.ps = (struct secp256k1_strauss_point_state *)checked_malloc(error_callback,\n+            n * sizeof(struct secp256k1_strauss_point_state));\n+        points_gej = (secp256k1_gej *)checked_malloc(error_callback,\n+            n * sizeof(secp256k1_gej));\n+        scalars_copy = (secp256k1_scalar *)checked_malloc(error_callback,\n+            n * sizeof(secp256k1_scalar));\n+\n+        if (state.aux == NULL || state.pre_a == NULL || state.ps == NULL ||\n+            points_gej == NULL || scalars_copy == NULL) {\n+            goto cleanup;\n+        }\n+\n+        for (i = 0; i < n; i++) {\n+            secp256k1_gej_set_ge(&points_gej[i], &points[i]);\n+            scalars_copy[i] = scalars[i];\n+        }\n+\n+        secp256k1_ecmult_strauss_wnaf(&state, r, n, points_gej, scalars_copy, scalar_g);\n+    } else {\n+        secp256k1_gej tmpj;\n+        secp256k1_gej_set_infinity(&tmpj);\n+        secp256k1_ecmult(r, &tmpj, &secp256k1_scalar_zero, scalar_g);\n+    }",
      "path": "src/ecmult_impl.h",
      "position": 1,
      "original_position": 472,
      "commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": 2648310997,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "You are correct! Removing it.",
      "created_at": "2026-01-20T16:27:00Z",
      "updated_at": "2026-01-20T16:27:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2709123184",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709123184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": 746,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 750,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709123860",
      "pull_request_review_id": 3683110297,
      "id": 2709123860,
      "node_id": "PRRC_kwDOAP4Jqs6hefMU",
      "diff_hunk": "@@ -657,212 +545,376 @@ SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, s\n }\n \n /**\n- * Returns the scratch size required for a given number of points (excluding\n- * base point G) without considering alignment.\n+ * Algorithm Selection: ABCD Model\n+ *\n+ * For each possible batch algorithm choice, memory usage is\n+ * m(x) = A*x + B and running time is\n+ * c(x) = C*x + D, where x is the batch size.\n+ *\n+ * A = per-point memory (bytes)\n+ * B = fixed memory overhead (bytes)\n+ * C = per-point time cost\n+ * D = fixed time overhead\n  */\n-static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n-    size_t entries = 2*n_points + 2;\n-    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n-    return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n-}\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n-    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n-    /* Use 2(n+1) with the endomorphism, when calculating batch\n-     * sizes. The reason for +1 is that we add the G scalar to the list of\n-     * other scalars. */\n-    size_t entries = 2*n_points + 2;\n-    secp256k1_ge *points;\n-    secp256k1_scalar *scalars;\n-    secp256k1_gej *buckets;\n-    struct secp256k1_pippenger_state *state_space;\n-    size_t idx = 0;\n-    size_t point_idx = 0;\n-    int bucket_window;\n+struct secp256k1_ecmult_multi_abcd {\n+    size_t A;\n+    size_t B;\n+    size_t C;\n+    size_t D;\n+};\n \n-    secp256k1_gej_set_infinity(r);\n-    if (inp_g_sc == NULL && n_points == 0) {\n-        return 1;\n-    }\n-    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-\n-    /* We allocate PIPPENGER_SCRATCH_OBJECTS objects on the scratch space. If\n-     * these allocations change, make sure to update the\n-     * PIPPENGER_SCRATCH_OBJECTS constant and pippenger_scratch_size\n-     * accordingly. */\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n-    if (points == NULL || scalars == NULL || state_space == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, ((size_t)1 << bucket_window) * sizeof(*buckets));\n-    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n-        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-        return 0;\n-    }\n+/* Strauss per-point memory */\n+#define SECP256K1_STRAUSS_POINT_SIZE \\\n+    ((sizeof(secp256k1_ge) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) \\\n+     + sizeof(struct secp256k1_strauss_point_state) \\\n+     + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar))\n \n-    if (inp_g_sc != NULL) {\n-        scalars[0] = *inp_g_sc;\n-        points[0] = secp256k1_ge_const_g;\n-        idx++;\n-        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n-        idx++;\n-    }\n+/* Pippenger per-entry memory */\n+#define SECP256K1_PIPPENGER_ENTRY_SIZE(w) \\\n+    (sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) \\\n+     + sizeof(struct secp256k1_pippenger_point_state) \\\n+     + (WNAF_SIZE((w)+1) + 1) * sizeof(int))\n \n-    while (point_idx < n_points) {\n-        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-            return 0;\n+/* Pippenger per-point memory: 2 entries due to endomorphism */\n+#define SECP256K1_PIPPENGER_POINT_SIZE(w) (2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/* Pippenger fixed overhead: buckets + state + 2 extra entries */\n+#define SECP256K1_PIPPENGER_FIXED_SIZE(w) \\\n+    ((sizeof(secp256k1_gej) << (w)) \\\n+     + sizeof(struct secp256k1_pippenger_state) \\\n+     + 2 * SECP256K1_PIPPENGER_ENTRY_SIZE(w))\n+\n+/*\n+ * ABCD constants for all batch algorithms.\n+ *\n+ * Index 0    = TRIVIAL (no memory, very slow)\n+ * Index 1    = STRAUSS (efficient for small batche sizes)\n+ * Index 2-13 = PIPPENGER with window sizes 1-12\n+ */\n+static const struct secp256k1_ecmult_multi_abcd secp256k1_ecmult_multi_abcds[SECP256K1_ECMULT_MULTI_NUM_ALGOS] = {\n+/*  A (per-point bytes)                     B (fixed bytes)                        C        D           */\n+    {0,                                     0,                                     1000,    0      },\n+    {SECP256K1_STRAUSS_POINT_SIZE,          0,                                     100,     0      },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(1),     SECP256K1_PIPPENGER_FIXED_SIZE(1),     500 /* manually disabled */,     181    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(2),     SECP256K1_PIPPENGER_FIXED_SIZE(2),     400 /* manually disabled */,     434    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(3),     SECP256K1_PIPPENGER_FIXED_SIZE(3),     117,     811    },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(4),     SECP256K1_PIPPENGER_FIXED_SIZE(4),     100,     1231   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(5),     SECP256K1_PIPPENGER_FIXED_SIZE(5),     86,      1973   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(6),     SECP256K1_PIPPENGER_FIXED_SIZE(6),     76,      3123   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(7),     SECP256K1_PIPPENGER_FIXED_SIZE(7),     68,      5234   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(8),     SECP256K1_PIPPENGER_FIXED_SIZE(8),     64,      9269   },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(9),     SECP256K1_PIPPENGER_FIXED_SIZE(9),     60,      15746  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(10),    SECP256K1_PIPPENGER_FIXED_SIZE(10),    62,      28723  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(11),    SECP256K1_PIPPENGER_FIXED_SIZE(11),    57,      51876  },\n+    {SECP256K1_PIPPENGER_POINT_SIZE(12),    SECP256K1_PIPPENGER_FIXED_SIZE(12),    61,      92195  },\n+};\n+\n+static size_t secp256k1_ecmult_multi_batch_size(size_t mem_limit) {\n+    /* We are implicitly using the TRIVIAL algorithm as a fallback\n+     * but we will only use it if no other algorithm fits. If that\n+     * is the case we can use max points as the batch size. */\n+    size_t best_batch_size = ECMULT_MAX_POINTS_PER_BATCH;\n+    size_t min_optime = SIZE_MAX;\n+    int i;\n+\n+    for (i = 1 /* ignores TRIVIAL */; i < SECP256K1_ECMULT_MULTI_NUM_ALGOS; i++) {\n+        const struct secp256k1_ecmult_multi_abcd *p = &secp256k1_ecmult_multi_abcds[i];\n+        size_t A = p->A, B = p->B, C = p->C, D = p->D, optime, batch_size;\n+\n+        if (mem_limit <= B) continue;\n+\n+        batch_size = (mem_limit - B) / A;\n+\n+        if (batch_size == 0) continue;\n+\n+        optime = C + D / batch_size;\n+\n+        if (optime < min_optime) {\n+            min_optime = optime;\n+            best_batch_size = batch_size;\n         }\n-        idx++;\n-        secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n-        idx++;\n-        point_idx++;\n     }\n \n-    secp256k1_ecmult_pippenger_wnaf(buckets, bucket_window, state_space, r, scalars, points, idx);\n-    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n-    return 1;\n+    return best_batch_size;\n }\n \n-/* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(error_callback, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n-}\n+static secp256k1_ecmult_multi_algo secp256k1_ecmult_multi_select(size_t mem_limit, size_t batch_size) {\n+    secp256k1_ecmult_multi_algo best_algo = SECP256K1_ECMULT_MULTI_ALGO_TRIVIAL;\n+    size_t min_optime = SIZE_MAX;\n+    int i;\n \n-/**\n- * Returns the maximum number of points in addition to G that can be used with\n- * a given scratch space. The function ensures that fewer points may also be\n- * used.\n- */\n-static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n-    size_t max_alloc = secp256k1_scratch_max_allocation(error_callback, scratch, PIPPENGER_SCRATCH_OBJECTS);\n-    int bucket_window;\n-    size_t res = 0;\n-\n-    for (bucket_window = 1; bucket_window <= PIPPENGER_MAX_BUCKET_WINDOW; bucket_window++) {\n-        size_t n_points;\n-        size_t max_points = secp256k1_pippenger_bucket_window_inv(bucket_window);\n-        size_t space_for_points;\n-        size_t space_overhead;\n-        size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n-\n-        entry_size = 2*entry_size;\n-        space_overhead = (sizeof(secp256k1_gej) << bucket_window) + entry_size + sizeof(struct secp256k1_pippenger_state);\n-        if (space_overhead > max_alloc) {\n-            break;\n-        }\n-        space_for_points = max_alloc - space_overhead;\n+    /* Use TRIVIAL fallback */\n+    if (batch_size == 0) return best_algo;\n \n-        n_points = space_for_points/entry_size;\n-        n_points = n_points > max_points ? max_points : n_points;\n-        if (n_points > res) {\n-            res = n_points;\n-        }\n-        if (n_points < max_points) {\n-            /* A larger bucket_window may support even more points. But if we\n-             * would choose that then the caller couldn't safely use any number\n-             * smaller than what this function returns */\n-            break;\n+    for (i = 0; i < SECP256K1_ECMULT_MULTI_NUM_ALGOS; i++) {\n+        const struct secp256k1_ecmult_multi_abcd *p = &secp256k1_ecmult_multi_abcds[i];\n+        size_t A = p->A, B = p->B, C = p->C, D = p->D, optime;\n+        size_t mem_usage = A * batch_size + B;\n+\n+        if (mem_usage > mem_limit) continue;\n+\n+        optime = C + D / batch_size;\n+\n+        if (optime < min_optime) {\n+            min_optime = optime;\n+            best_algo = (secp256k1_ecmult_multi_algo)i;\n         }\n     }\n-    return res;\n+\n+    return best_algo;\n }\n \n-/* Computes ecmult_multi by simply multiplying and adding each point. Does not\n- * require a scratch space */\n-static int secp256k1_ecmult_multi_simple_var(secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points) {\n-    size_t point_idx;\n+/* Trivial algorithm: Computes ecmult_multi by simply multiplying and adding each point. */\n+static int secp256k1_ecmult_multi_trivial(\n+    secp256k1_gej *r,\n+    size_t n,\n+    const secp256k1_ge *points,\n+    const secp256k1_scalar *scalars,\n+    const secp256k1_scalar *scalar_g\n+) {\n+    size_t i;\n     secp256k1_gej tmpj;\n \n     secp256k1_gej_set_infinity(r);\n-    secp256k1_gej_set_infinity(&tmpj);\n-    /* r = inp_g_sc*G */\n-    secp256k1_ecmult(r, &tmpj, &secp256k1_scalar_zero, inp_g_sc);\n-    for (point_idx = 0; point_idx < n_points; point_idx++) {\n-        secp256k1_ge point;\n+\n+    if (scalar_g != NULL) {\n+        secp256k1_gej_set_infinity(&tmpj);\n+        secp256k1_ecmult(r, &tmpj, &secp256k1_scalar_zero, scalar_g);\n+    }\n+\n+    for (i = 0; i < n; i++) {\n         secp256k1_gej pointj;\n-        secp256k1_scalar scalar;\n-        if (!cb(&scalar, &point, point_idx, cbdata)) {\n-            return 0;\n+        if (secp256k1_ge_is_infinity(&points[i])) {\n+            continue;\n         }\n-        /* r += scalar*point */\n-        secp256k1_gej_set_ge(&pointj, &point);\n-        secp256k1_ecmult(&tmpj, &pointj, &scalar, NULL);\n+        secp256k1_gej_set_ge(&pointj, &points[i]);\n+        secp256k1_ecmult(&tmpj, &pointj, &scalars[i], NULL);\n         secp256k1_gej_add_var(r, r, &tmpj, NULL);\n     }\n+\n     return 1;\n }\n \n-/* Compute the number of batches and the batch size given the maximum batch size and the\n- * total number of points */\n-static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n_batch_points, size_t max_n_batch_points, size_t n) {\n-    if (max_n_batch_points == 0) {\n-        return 0;\n-    }\n-    if (max_n_batch_points > ECMULT_MAX_POINTS_PER_BATCH) {\n-        max_n_batch_points = ECMULT_MAX_POINTS_PER_BATCH;\n-    }\n-    if (n == 0) {\n-        *n_batches = 0;\n-        *n_batch_points = 0;\n+static int secp256k1_ecmult_multi_strauss(\n+    const secp256k1_callback *error_callback,\n+    secp256k1_gej *r,\n+    size_t n,\n+    const secp256k1_ge *points,\n+    const secp256k1_scalar *scalars,\n+    const secp256k1_scalar *scalar_g\n+) {\n+    struct secp256k1_strauss_state state;\n+    secp256k1_gej *points_gej = NULL;\n+    secp256k1_scalar *scalars_copy = NULL;\n+    size_t i;\n+    int ret = 0;\n+\n+    state.aux = NULL;\n+    state.pre_a = NULL;\n+    state.ps = NULL;\n+\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (scalar_g == NULL && n == 0) {\n         return 1;\n     }\n-    /* Compute ceil(n/max_n_batch_points) and ceil(n/n_batches) */\n-    *n_batches = CEIL_DIV(n, max_n_batch_points);\n-    *n_batch_points = CEIL_DIV(n, *n_batches);\n-    return 1;\n+\n+    if (n > 0) {\n+        state.aux = (secp256k1_fe *)checked_malloc(error_callback,\n+            n * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+        state.pre_a = (secp256k1_ge *)checked_malloc(error_callback,\n+            n * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+        state.ps = (struct secp256k1_strauss_point_state *)checked_malloc(error_callback,\n+            n * sizeof(struct secp256k1_strauss_point_state));\n+        points_gej = (secp256k1_gej *)checked_malloc(error_callback,\n+            n * sizeof(secp256k1_gej));\n+        scalars_copy = (secp256k1_scalar *)checked_malloc(error_callback,",
      "path": "src/ecmult_impl.h",
      "position": 1,
      "original_position": 454,
      "commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "original_commit_id": "8760b3c148028555d95f110a1e059f75f0c96cce",
      "in_reply_to_id": 2648307770,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think you are correct, I have removed it.",
      "created_at": "2026-01-20T16:27:11Z",
      "updated_at": "2026-01-20T16:27:11Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1789#discussion_r2709123860",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2709123860"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1789"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 732,
      "side": "RIGHT"
    }
  ]
}