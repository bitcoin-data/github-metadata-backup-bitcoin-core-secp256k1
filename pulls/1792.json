{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792",
    "id": 3133472087,
    "node_id": "PR_kwDOAP4Jqs66xP1X",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1792.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1792.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1792",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1792/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
    "number": 1792,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Add \"silentpayments\" module implementing BIP352 (take 5, using \"LabelSet\" scanning approach)",
    "user": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "### Summary\r\n\r\nThis PR implements [BIP352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki) with scanning limited to full-nodes. Compared to #1765, an alternative scanning method called the \"LabelSet approach\" (initially [proposed by @w0xlt](https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3592403663)) is used, with the primary goal of fixing the [worst-case scanning attack](https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3341766084), discovered and discussed at length in previous takes 3 and 4. In constrast to the previously used \"BIP approach\", the scanning cost depends primarily on the number of labels (something the user can control and the module can set a limit on), rather than the number of transaction outputs (limited only by Bitcoin's consensus rules, i.e. the block weight limit). See https://gist.github.com/theStack/25c77747838610931e8bbeb9d76faf78 for a high-level comparison between the two approaches with benchmarks, and a [Python implementation](https://github.com/theStack/secp256k1lab/blob/add_bip352_module_review_helper/src/secp256k1lab/bip352.py) based on secp256k1lab.\r\n\r\n### Pros and cons\r\nOther than mitigating adversarial scanning scenarios, the LabelSet approach offers additional advantages:\r\n* simpler API: passing an explicit list of labels to scan for is much simpler than having to maintain a label cache data structure and provide a callback function; passing the transaction outputs as raw 32-byte x-only pubkeys is also simpler for the user, as no prior `secp256k1_xonly_pubkey_parse` calls are needed anymore (see https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3677024453 for more details about API and implementation between the two approaches)\r\n* faster also for the common case (i.e. no match), if the number of labels used is reasonably small, as recent [benchmarks](https://gist.github.com/theStack/25c77747838610931e8bbeb9d76faf78?permalink_comment_id=5892266#gistcomment-5892266) indicate (in theory, the LabelSet approach should be faster whenever the number of labels L is smaller than twice the number of the scanned tx's taproot outputs N, i.e. if L < 2 * N).\r\n* simpler implementation: scanning resembles the flow on the sender side (i.e. start with unlabeled public key, end with the taproot output), and there is no need to handle the missing y-parity information in x-only public keys (by trying both)\r\n\r\nThe main drawback of the LabelSet approach is that every additional label increases the scanning cost by at least one EC point addition. As a result, it is definitely not suitable for use cases that require a large number of labels.\r\n\r\n### Limiting the number of labels\r\nTo be on the safe side and still avoid the worst-case scanning attack, it was suggested to limit the number of supported labels in the module. Currently, this limit is not enforced in code; it only appears as a WARNING in the API header documentation, with the recommendation to not use more than 20 (that's the number where the worst-case takes about a second on my machine, see benchmarks below). It is unclear whether this is sufficient. We may want to enforce a hard limit instead, or introduce a configurable limit (for example at compile time or via an API call). This would better communicate that using values outside the recommended range is done at the user's own risk.\r\n\r\nFor a minimalist solution, one could in theory support only a single label for now. That's of course very restrictive, but would still comply with the minimum BIP requirements (see https://github.com/bitcoin/bips/blob/fc00f51c229088c447b3694cca9bf14ace0e1a96/bip-0352.mediawiki?plain=1#L131). The advantage would be that it would result in the simplest possible API and implementation, and expectations would be very clearly expressed to the user, if the parameter might be even called e.g. `change_label`.\r\n\r\n### Benchmarks\r\n\r\nBenchmarks have been updated to show average scenarios over a N/L matrix (N...number of tx outputs, L... number of labels) as well as the worst case scenario:\r\n<details>\r\n<summary>Results on my machine</summary>\r\n\r\n```\r\n$ ./build/bin/bench silentpayments\r\nBenchmark                               ,    Min(us)    ,    Avg(us)    ,    Max(us)\r\n\r\nsilentpayments_scan_nomatch_N=10_L=0    ,    41.1       ,    41.1       ,    41.2\r\nsilentpayments_scan_nomatch_N=10_L=1    ,    42.1       ,    42.1       ,    42.2\r\nsilentpayments_scan_nomatch_N=10_L=2    ,    43.1       ,    43.2       ,    43.2\r\nsilentpayments_scan_nomatch_N=10_L=5    ,    46.1       ,    46.2       ,    46.2\r\nsilentpayments_scan_nomatch_N=10_L=10   ,    51.6       ,    51.6       ,    51.7\r\nsilentpayments_scan_nomatch_N=10_L=20   ,    62.6       ,    62.7       ,    62.7\r\nsilentpayments_scan_nomatch_N=10_L=50   ,    96.4       ,    96.5       ,    96.6\r\nsilentpayments_scan_nomatch_N=10_L=100  ,   153.0       ,   153.0       ,   153.0\r\n\r\nsilentpayments_scan_nomatch_N=100_L=0   ,    43.5       ,    43.5       ,    43.5\r\nsilentpayments_scan_nomatch_N=100_L=1   ,    44.4       ,    44.5       ,    44.5\r\nsilentpayments_scan_nomatch_N=100_L=2   ,    45.5       ,    45.5       ,    45.5\r\nsilentpayments_scan_nomatch_N=100_L=5   ,    48.5       ,    48.5       ,    48.6\r\nsilentpayments_scan_nomatch_N=100_L=10  ,    53.9       ,    54.0       ,    54.0\r\nsilentpayments_scan_nomatch_N=100_L=20  ,    65.0       ,    65.0       ,    65.1\r\nsilentpayments_scan_nomatch_N=100_L=50  ,    99.0       ,    99.0       ,    99.1\r\nsilentpayments_scan_nomatch_N=100_L=100 ,   156.0       ,   156.0       ,   156.0\r\n\r\nsilentpayments_scan_nomatch_N=2325_L=0  ,   220.0       ,   221.0       ,   222.0\r\nsilentpayments_scan_nomatch_N=2325_L=1  ,   221.0       ,   222.0       ,   223.0\r\nsilentpayments_scan_nomatch_N=2325_L=2  ,   222.0       ,   223.0       ,   223.0\r\nsilentpayments_scan_nomatch_N=2325_L=5  ,   226.0       ,   227.0       ,   228.0\r\nsilentpayments_scan_nomatch_N=2325_L=10 ,   232.0       ,   233.0       ,   234.0\r\nsilentpayments_scan_nomatch_N=2325_L=20 ,   243.0       ,   244.0       ,   245.0\r\nsilentpayments_scan_nomatch_N=2325_L=50 ,   279.0       ,   280.0       ,   280.0\r\nsilentpayments_scan_nomatch_N=2325_L=100,   339.0       ,   339.0       ,   340.0\r\n\r\nsilentpayments_scan_worstcase_L=1       , 416567.0       , 416567.0       , 416567.0\r\nsilentpayments_scan_worstcase_L=2       , 444503.0       , 444503.0       , 444503.0\r\nsilentpayments_scan_worstcase_L=5       , 531165.0       , 531165.0       , 531165.0\r\nsilentpayments_scan_worstcase_L=10      , 674923.0       , 674923.0       , 674923.0\r\nsilentpayments_scan_worstcase_L=20      , 961857.0       , 961857.0       , 961857.0\r\nsilentpayments_scan_worstcase_L=50      , 1820950.0       , 1820950.0       , 1820950.0\r\nsilentpayments_scan_worstcase_L=100     , 3249931.0       , 3249931.0       , 3249931.0\r\n```\r\n</details>\r\n\r\n### History and details about the \"BIP approach\"\r\n\r\nPrior takes of the \"silentpayments\" module (PRs #1471, #1519, #1698, #1765)  implemented scanning for labels [as suggested in BIP352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki#user-content-Scanning) (the \"BIP approach\"): for each taproot output, subtract the unlabeled output candidate and check if the result is in a pre-calculated label cache. This method has the useful property of being performance-independent of the number of labels to scan for, as the lookups in the label cache are constant and fast, if implemented in a proper efficient data structure like a hash map (even hundreds of thousands of labels can be checked without a noticeable loss in performance, see the showcase in https://groups.google.com/g/bitcoindev/c/bP6ktUyCOJI/m/HGCF9YxNAQAJ).\r\n\r\nOne drawback of the BIP approach is that it scales poorly for pathological transactions containing a large number of outputs, all corresponding to Silent Payments recipients sharing the same scan key. In the worst-case scenario of a single, very large transaction filling an entire block (note that such a transaction would be non-standard, but still consensus-valid), scanning could take several minutes for the targeted recipient (see https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3341766084). Proposed mitigations in takes 3 and 4 that were based on the BIP approach turned out to be insufficient to fix the problem, and it is currently believed that this is an inherent problem that could only be solved by a protocol change (by e.g. limiting the Silent Payments eligible transactions to a smaller number of outputs).\r\n\r\nTherefore, a different way of scanning has been proposed that works in the opposite direction: iterate over a list of explicitly passed labels, add the unlabeled output candidate and check if the result is in the list of taproot outputs (via binary search to be efficient), i.e. the \"LabelSet approach\".\r\n\r\n### Recommended review music\r\nhttps://www.youtube.com/watch?v=Hm-q80gA7NI",
    "labels": [],
    "created_at": "2025-12-29T03:24:40Z",
    "updated_at": "2026-02-04T19:07:37Z",
    "mergeable": true,
    "mergeable_state": "unstable",
    "merged": false,
    "merge_commit_sha": "b3bdd637ac561a410d5cc9738e64f496e0fe6596",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "theStack:silentpayments_module_fullnode_only-LabelSet-scan",
      "ref": "silentpayments_module_fullnode_only-LabelSet-scan",
      "sha": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 452762907,
        "node_id": "R_kgDOGvydGw",
        "name": "secp256k1",
        "full_name": "theStack/secp256k1",
        "owner": {
          "login": "theStack",
          "id": 91535,
          "node_id": "MDQ6VXNlcjkxNTM1",
          "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/theStack",
          "html_url": "https://github.com/theStack",
          "followers_url": "https://api.github.com/users/theStack/followers",
          "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
          "organizations_url": "https://api.github.com/users/theStack/orgs",
          "repos_url": "https://api.github.com/users/theStack/repos",
          "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/theStack/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/theStack/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/theStack/secp256k1",
        "archive_url": "https://api.github.com/repos/theStack/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/theStack/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/theStack/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/theStack/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/theStack/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/theStack/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/theStack/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/theStack/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/theStack/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/theStack/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/theStack/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/theStack/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/theStack/secp256k1/events",
        "forks_url": "https://api.github.com/repos/theStack/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/theStack/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/theStack/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/theStack/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/theStack/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/theStack/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/theStack/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/theStack/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/theStack/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/theStack/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/theStack/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/theStack/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/theStack/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/theStack/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/theStack/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/theStack/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:theStack/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/theStack/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/theStack/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/theStack/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/theStack/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/theStack/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/theStack/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/theStack/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/theStack/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/theStack/secp256k1/hooks",
        "svn_url": "https://github.com/theStack/secp256k1",
        "language": "C",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 13259,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-02-04T14:08:17Z",
        "created_at": "2022-01-27T16:42:12Z",
        "updated_at": "2025-09-14T19:27:22Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "f9a944ff2dbcd7ff1829880636f861caf0a91392",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1121,
        "stargazers_count": 2397,
        "watchers_count": 2397,
        "size": 14052,
        "default_branch": "master",
        "open_issues_count": 165,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-02-04T19:25:01Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2026-02-04T19:35:03Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 8127,
    "deletions": 35,
    "changed_files": 23,
    "commits": 11,
    "review_comments": 6,
    "comments": 7
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDRmOWYyYzY1ZDNkZWQwOTFmMmM0NmNmNmVlY2JjNDZhYTBjNWY3MjU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4f9f2c65d3ded091f2c46cf6eecbc46aa0c5f725",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4f9f2c65d3ded091f2c46cf6eecbc46aa0c5f725",
      "tree": {
        "sha": "1effc2b9489453df5bbb54b2fffb42e5b5ec77b6",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/1effc2b9489453df5bbb54b2fffb42e5b5ec77b6"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f9a944ff2dbcd7ff1829880636f861caf0a91392",
          "sha": "f9a944ff2dbcd7ff1829880636f861caf0a91392",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f9a944ff2dbcd7ff1829880636f861caf0a91392"
        }
      ],
      "message": "build: add skeleton for new silentpayments (BIP352) module",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-27T15:52:33Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2023-09-27T15:22:14Z"
      },
      "sha": "4f9f2c65d3ded091f2c46cf6eecbc46aa0c5f725"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDc4YjI1OWZjNDNiNmU0YTU0MzEwYWQ5MDg4MDI1YjdkOGZkYmZlNzk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/78b259fc43b6e4a54310ad9088025b7d8fdbfe79",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/78b259fc43b6e4a54310ad9088025b7d8fdbfe79",
      "tree": {
        "sha": "e697b0acb828b3fb679fd82762b837f2495bafe8",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e697b0acb828b3fb679fd82762b837f2495bafe8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4f9f2c65d3ded091f2c46cf6eecbc46aa0c5f725",
          "sha": "4f9f2c65d3ded091f2c46cf6eecbc46aa0c5f725",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4f9f2c65d3ded091f2c46cf6eecbc46aa0c5f725"
        }
      ],
      "message": "silentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-28T02:29:50Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-03-25T16:23:37Z"
      },
      "sha": "78b259fc43b6e4a54310ad9088025b7d8fdbfe79"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDVkYWMyNjQ4NTRjNmE2MGZiMWE0M2NhNGFmOTE0Y2E5M2ZjM2U2YTI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/5dac264854c6a60fb1a43ca4af914ca93fc3e6a2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/5dac264854c6a60fb1a43ca4af914ca93fc3e6a2",
      "tree": {
        "sha": "e224c9b0ca2df37945f65b1be8eea2098bb9f798",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e224c9b0ca2df37945f65b1be8eea2098bb9f798"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/78b259fc43b6e4a54310ad9088025b7d8fdbfe79",
          "sha": "78b259fc43b6e4a54310ad9088025b7d8fdbfe79",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/78b259fc43b6e4a54310ad9088025b7d8fdbfe79"
        }
      ],
      "message": "silentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labeled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labeled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labeled\nsilent payment address.\n\nAdd tests for the label API.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-28T02:31:06Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-01-22T17:56:05Z"
      },
      "sha": "5dac264854c6a60fb1a43ca4af914ca93fc3e6a2"
    },
    {
      "event": "commented",
      "id": 3696593947,
      "node_id": "IC_kwDOAP4Jqs7cVYwb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3696593947",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-29T13:51:50Z",
      "updated_at": "2025-12-29T13:51:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK per [my rationale in the take 4 PR](https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3684588782) \r\n\r\n> To be on the safe side and still avoid the worst-case scanning attack, it was suggested to limit the number of supported labels in the module. Currently, this limit is not enforced in code; it only appears as a WARNING in the API header documentation, with the recommendation to not use more than 20 (that's the number where the worst-case takes about a second on my machine, see benchmarks below). It is unclear whether this is sufficient. We may want to enforce a hard limit instead, or introduce a configurable limit (for example at compile time or via an API call). \r\n\r\nI think it's good to add this documentation and warn of the performance penalties with a specific number as a reference is good but I still think we should probably add a hard limit too which can be higher. I was thinking of the order of 1000 without having run any actual benchmarks. From a high level perspective I think such a number implies that the user probably doesn't generate new labels manually and uses the static sp addresses in different places (the typical usage pattern we mostly expect I think). Instead such a user may have some kind of automation in place that churns out new sp addresses with new labels and that the number of labels may potentially grow unbounded. The goal would be that such a user runs into this limit rather than that their servers are brought to their knees unexpectedly, which should be the better outcome in my mind. But curious what others think.",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#issuecomment-3696593947",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1792"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21819238037,
      "node_id": "HRFPE_lADOAP4Jqs7gfWKizwAAAAUUhyaV",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21819238037",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "8b196ef60d06637e6e50485cf5a5e52423b87505",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/8b196ef60d06637e6e50485cf5a5e52423b87505",
      "created_at": "2026-01-01T15:20:51Z"
    },
    {
      "event": "commented",
      "id": 3703820072,
      "node_id": "IC_kwDOAP4Jqs7cw88o",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3703820072",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-01T15:21:15Z",
      "updated_at": "2026-01-01T15:40:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "@fjahr: Sounds reasonable. I've added a hard limit on the number of labels as suggested, defined by a public API constant `SECP256K1_SILENTPAYMENTS_MAX_LABELS`, currently set to 500 [1] (very arbitrary, no idea if 15 seconds is still okay or not, but more than that seems definitely too much in my opinion). The `n_label_entries` parameter for the scan function is `ARG_CHECK`ed against that, i.e. any values exceeding that are treated as illegal. \r\n\r\nSome optional ideas on top that came to my mind:\r\n* we could wrap the limit `#define` in a conditional `#ifndef` block in order to allow the user to override the limit at compile-time; if that's the case, one could emit a warning in the `#else` block via `#warning` to notify the user that this is outside of the recommended range and could lead to very high worst-case scanning times (EDIT: I guess this doesn't work in general, considering that it would need a recompilation of the silentpayments module for the user-defined limit to take effect).\r\n* we could limit the number of labels already at label creation time, in the sense that only values in the range of $0..MAX-1$ are allowed to be passed as $m$ parameter to `_label_create`. This would allow to limit labels as early as possible (it's kind of bad if one can create labeled addresses, but then not be able to scan for them), but on the other hand that assumes that labels are only ever created in a contiguous range starting from zero. The currently proposed sp() output descriptor format allows to specify arbitrary ranges, see https://github.com/bitcoin/bips/pull/2047#issuecomment-3685534829. Considering that, limiting the $m$ values to one range seems a bit too restrictive.\r\n\r\n[1] worst-case benchmarks on my machine:\r\n```\r\n$ ./build/bin/bench silentpayments_scan_worstcase\r\nBenchmark                               ,    Min(us)    ,    Avg(us)    ,    Max(us)\r\n\r\nsilentpayments_scan_worstcase_L=1       , 415553.0       , 415553.0       , 415553.0\r\nsilentpayments_scan_worstcase_L=2       , 444280.0       , 444280.0       , 444280.0\r\nsilentpayments_scan_worstcase_L=5       , 529870.0       , 529870.0       , 529870.0\r\nsilentpayments_scan_worstcase_L=10      , 672437.0       , 672437.0       , 672437.0\r\nsilentpayments_scan_worstcase_L=20      , 956493.0       , 956493.0       , 956493.0\r\nsilentpayments_scan_worstcase_L=50      , 1808294.0       , 1808294.0       , 1808294.0\r\nsilentpayments_scan_worstcase_L=100     , 3224289.0       , 3224289.0       , 3224289.0\r\nsilentpayments_scan_worstcase_L=200     , 6058590.0       , 6058590.0       , 6058590.0\r\nsilentpayments_scan_worstcase_L=500     , 14562453.0       , 14562453.0       , 14562453.0\r\n```",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#issuecomment-3703820072",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1792"
    },
    {
      "event": "mentioned",
      "id": 21819241440,
      "node_id": "MEE_lADOAP4Jqs7gfWKizwAAAAUUhzPg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21819241440",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-01T15:21:16Z"
    },
    {
      "event": "subscribed",
      "id": 21819241451,
      "node_id": "SE_lADOAP4Jqs7gfWKizwAAAAUUhzPr",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21819241451",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-01T15:21:16Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGFhZDM1NzNhOWEyOTU5MThiYzhkOGY0YzA2OTUxNjdmZWFmZjk3NmQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/aad3573a9a295918bc8d8f4c0695167feaff976d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/aad3573a9a295918bc8d8f4c0695167feaff976d",
      "tree": {
        "sha": "a9bfcba542411c95b06e546a488bce3841de3aab",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/a9bfcba542411c95b06e546a488bce3841de3aab"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/5dac264854c6a60fb1a43ca4af914ca93fc3e6a2",
          "sha": "5dac264854c6a60fb1a43ca4af914ca93fc3e6a2",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/5dac264854c6a60fb1a43ca4af914ca93fc3e6a2"
        }
      ],
      "message": "silentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\nexpliticly passing in a list of (label, label_tweak) entries and\nneeds access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is provided in a future release.\n\nAdd an opaque data type for passing around the prevout public key sum\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply the scan_key * input_hash before doing ECDH.\n\nFinally, add test coverage for the receiving API.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-01-01T16:04:06Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-10-02T14:18:13Z"
      },
      "sha": "aad3573a9a295918bc8d8f4c0695167feaff976d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGRiZjNjYWZjMjIyZTI2Mzk2N2YwZWU1YWZhNmE4MmZkNTU0YzExZDU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/dbf3cafc222e263967f0ee5afa6a82fd554c11d5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/dbf3cafc222e263967f0ee5afa6a82fd554c11d5",
      "tree": {
        "sha": "56d13743aba832d837298e1a13cd57cb7084b227",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/56d13743aba832d837298e1a13cd57cb7084b227"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/aad3573a9a295918bc8d8f4c0695167feaff976d",
          "sha": "aad3573a9a295918bc8d8f4c0695167feaff976d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/aad3573a9a295918bc8d8f4c0695167feaff976d"
        }
      ],
      "message": "silentpayments: add examples/silentpayments.c\n\nDemonstrate sending and scanning on full nodes.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-01-01T16:04:09Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-15T17:36:29Z"
      },
      "sha": "dbf3cafc222e263967f0ee5afa6a82fd554c11d5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGMwNDI2ZTk0MzBjODZhZGYzZjNjNGM4OGY1ODQ3ZDQ4ZDM1NzhlNGY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c0426e9430c86adf3f3c4c88f5847d48d3578e4f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c0426e9430c86adf3f3c4c88f5847d48d3578e4f",
      "tree": {
        "sha": "30935b37314e85bbb4c3106532255f28313eec08",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/30935b37314e85bbb4c3106532255f28313eec08"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/dbf3cafc222e263967f0ee5afa6a82fd554c11d5",
          "sha": "dbf3cafc222e263967f0ee5afa6a82fd554c11d5",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/dbf3cafc222e263967f0ee5afa6a82fd554c11d5"
        }
      ],
      "message": "silentpayments: add benchmarks for scanning\n\nAdd benchmarks for a full transaction scan, over a L/N matrix\n(L/N, L...number of labels, N...number of tx outputs) for the\ncommon case and worst-case.\n\nOnly benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.\n\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-01-01T16:04:09Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-25T17:33:35Z"
      },
      "sha": "c0426e9430c86adf3f3c4c88f5847d48d3578e4f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDk1N2ZiMzU0ZTA1OGE1ZGVmMDFiNDNkZjgwMDZkOTUxNWI4ZjU2NTk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/957fb354e058a5def01b43df8006d9515b8f5659",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/957fb354e058a5def01b43df8006d9515b8f5659",
      "tree": {
        "sha": "c310140518becf528436b23b2d3c0fe84075743d",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/c310140518becf528436b23b2d3c0fe84075743d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c0426e9430c86adf3f3c4c88f5847d48d3578e4f",
          "sha": "c0426e9430c86adf3f3c4c88f5847d48d3578e4f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c0426e9430c86adf3f3c4c88f5847d48d3578e4f"
        }
      ],
      "message": "tests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h\n\nCo-authored-by: Ron <4712150+macgyver13@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\nCo-authored-by: Tim Ruffing <1071625+real-or-random@users.noreply.github.com>",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-01-01T16:04:09Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-02T17:45:43Z"
      },
      "sha": "957fb354e058a5def01b43df8006d9515b8f5659"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGJiN2NjY2Q5ZGQ2MzNjMDZhNTc3YzVjZjU2ZjI3OWUzMmMyY2JlYjI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/bb7cccd9dd633c06a577c5cf56f279e32c2cbeb2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/bb7cccd9dd633c06a577c5cf56f279e32c2cbeb2",
      "tree": {
        "sha": "647ad1090e48d1684fc6111d3ed69fcaf868c88c",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/647ad1090e48d1684fc6111d3ed69fcaf868c88c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/957fb354e058a5def01b43df8006d9515b8f5659",
          "sha": "957fb354e058a5def01b43df8006d9515b8f5659",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/957fb354e058a5def01b43df8006d9515b8f5659"
        }
      ],
      "message": "tests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-01-01T16:04:09Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-11-07T12:18:59Z"
      },
      "sha": "bb7cccd9dd633c06a577c5cf56f279e32c2cbeb2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDBjZTkzZjRhY2RlZTBjZjJkOTc2Njg5ZjM5OGVlZDA2ZDFmODNjYWU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0ce93f4acdee0cf2d976689f398eed06d1f83cae",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0ce93f4acdee0cf2d976689f398eed06d1f83cae",
      "tree": {
        "sha": "da64b78ad75562652d3ef700e387960ea137ffca",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/da64b78ad75562652d3ef700e387960ea137ffca"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/bb7cccd9dd633c06a577c5cf56f279e32c2cbeb2",
          "sha": "bb7cccd9dd633c06a577c5cf56f279e32c2cbeb2",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/bb7cccd9dd633c06a577c5cf56f279e32c2cbeb2"
        }
      ],
      "message": "tests: add sha256 tag test\n\nTest midstate tags used in silent payments.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-01-01T16:04:09Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T08:46:46Z"
      },
      "sha": "0ce93f4acdee0cf2d976689f398eed06d1f83cae"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDhlNzQyMzZhYTg4MmY3MTUyNjdlZjQzM2EzM2Q0OTJiYjY1OTgxMDM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8e74236aa882f715267ef433a33d492bb6598103",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8e74236aa882f715267ef433a33d492bb6598103",
      "tree": {
        "sha": "d92566f799289f0d5f6a682ac1d7dcb750642471",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/d92566f799289f0d5f6a682ac1d7dcb750642471"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0ce93f4acdee0cf2d976689f398eed06d1f83cae",
          "sha": "0ce93f4acdee0cf2d976689f398eed06d1f83cae",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0ce93f4acdee0cf2d976689f398eed06d1f83cae"
        }
      ],
      "message": "ci: enable silentpayments module",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-01-01T16:04:09Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-02-22T23:25:41Z"
      },
      "sha": "8e74236aa882f715267ef433a33d492bb6598103"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGMyMDYxZGZkNWZmYzc4YTk3ZWYxZDkxZmM2NmQ1ZDBkZWQ5ZWZmMjc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "tree": {
        "sha": "b9c525cfdc3e07003a7349c78d9e5f9746b7299f",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/b9c525cfdc3e07003a7349c78d9e5f9746b7299f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8e74236aa882f715267ef433a33d492bb6598103",
          "sha": "8e74236aa882f715267ef433a33d492bb6598103",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8e74236aa882f715267ef433a33d492bb6598103"
        }
      ],
      "message": "docs: update README",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-01-01T16:04:09Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-12T12:57:54Z"
      },
      "sha": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21819469170,
      "node_id": "HRFPE_lADOAP4Jqs7gfWKizwAAAAUUiq1y",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21819469170",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "created_at": "2026-01-01T16:04:21Z"
    },
    {
      "event": "reviewed",
      "id": 3622988276,
      "node_id": "PRR_kwDOAP4Jqs7X8mn0",
      "url": null,
      "actor": null,
      "commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-02T11:44:57Z",
      "author_association": "NONE",
      "body": "Approach ACK. Will review in detail soon.\r\n\r\nFor the reasons outlined in the \"Pros and cons\" section of the PR description, particularly the simpler API, improved common-case performance for small label sets and mitigation of the worst-case scanning attackthe LabelSet approach seems like the right default choice. \r\n\r\nGiven that most users are expected to have a relatively small number of labels (likely well within the `SECP256K1_SILENTPAYMENTS_MAX_LABELS` bound), this should cover the typical use case nicely. \r\n\r\nIf there's sufficient demand, a [hybrid approach](https://github.com/w0xlt/secp256k1/commit/6c76c7c5fa30c5fa7676511de22c47953ee76bd1) could always be explored in a future iteration to accommodate more specialized scenarios.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#pullrequestreview-3622988276",
      "submitted_at": "2026-01-02T11:44:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792"
    },
    {
      "event": "commented",
      "id": 3709076530,
      "node_id": "IC_kwDOAP4Jqs7dFAQy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3709076530",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-05T06:15:39Z",
      "updated_at": "2026-01-05T06:17:47Z",
      "author_association": "MEMBER",
      "body": "It might be good to have a separate Github issue to discuss this.\r\n\r\nI think it's fine to initially go for the LabelSet approach, since many current implementations are mobile, which means they benefit from the safety this provides and won't run into the label limit anytime soon.\r\n\r\nTo reduce review burden on this PR, we can add the hybrid approach in a followup, where we pick the BIP mechanism based on e.g. the `8 * n_tx_outputs < n_labels + 2` heuristic (https://github.com/w0xlt/secp256k1/commit/6c76c7c5fa30c5fa7676511de22c47953ee76bd1#diff-4d053be8d1f6d948b412f26ae89711a9dcd2a2683da581cb52b9f6757480361b).\r\n\r\nI do think that hybrid approach is useful. Someone who goes through the trouble of automating label generation might happily add some CPU cores if lets them avoid the complexity of splitting their users across multiple watch keys. Especially if the cost of an attack far outweighs the cost to deal with it.\r\n\r\nWe could document the hardware required to guarantee that a worst case block takes less than 10 minutes to process. For the hybrid approach that's just a single number IIUC. For the LabelSet approach it's a function of L. With that in place a warning should be enough IMO, for `L > ?` based on lower end hardware (mobile) and e.g. a 10 second worst case.\r\n",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#issuecomment-3709076530",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1792"
    },
    {
      "event": "commented",
      "id": 3728203838,
      "node_id": "IC_kwDOAP4Jqs7eN-A-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3728203838",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-09T10:02:10Z",
      "updated_at": "2026-01-09T10:16:17Z",
      "author_association": "NONE",
      "body": "I had an offline conversation with @RubenSomsen about this. The conversations around the scanning approaches have been focused on the time it takes to complete a tx scan, but it's also important that we consider the time it takes to scan an entire Block.\r\n\r\nBIP-style scanning scales with the number of outputs, independently of the number of transactions.\r\n\r\nLabelSet scanning scales with the number of labels * the number of transactions. LabelSet will be Fast when you scan Blocks with few transactions and few labels, but it will get slower compared to BIP-style scanning as the number of transactions increases, even without an increase in the number of labels.\r\n\r\nI think we should do more Block scanning benchmarks. I am interested in doing this myself next week. I can use LabelSet scanning in https://github.com/bitcoin/bitcoin/pull/32966 and benchmark Block scanning times.",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#issuecomment-3728203838",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1792"
    },
    {
      "event": "mentioned",
      "id": 21943705329,
      "node_id": "MEE_lADOAP4Jqs7gfWKizwAAAAUb8l7x",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21943705329",
      "actor": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-09T10:02:11Z"
    },
    {
      "event": "subscribed",
      "id": 21943705361,
      "node_id": "SE_lADOAP4Jqs7gfWKizwAAAAUb8l8R",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21943705361",
      "actor": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-09T10:02:11Z"
    },
    {
      "event": "commented",
      "id": 3733950808,
      "node_id": "IC_kwDOAP4Jqs7ej5FY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3733950808",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-11T03:42:41Z",
      "updated_at": "2026-01-11T03:42:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "@Sjors: @Eunovo: I've opened issue #1799 for general discussions about the different scanning approaches and replied to your comments there, to keep the discussion this PR focused on the concrete implementation of the LabelSet approach.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#issuecomment-3733950808",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1792"
    },
    {
      "event": "mentioned",
      "id": 21967801682,
      "node_id": "MEE_lADOAP4Jqs7gfWKizwAAAAUdYg1S",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21967801682",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-11T03:42:43Z"
    },
    {
      "event": "subscribed",
      "id": 21967801685,
      "node_id": "SE_lADOAP4Jqs7gfWKizwAAAAUdYg1V",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21967801685",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-11T03:42:43Z"
    },
    {
      "event": "mentioned",
      "id": 21967801688,
      "node_id": "MEE_lADOAP4Jqs7gfWKizwAAAAUdYg1Y",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21967801688",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-11T03:42:43Z"
    },
    {
      "event": "subscribed",
      "id": 21967801690,
      "node_id": "SE_lADOAP4Jqs7gfWKizwAAAAUdYg1a",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21967801690",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-11T03:42:43Z"
    },
    {
      "event": "commented",
      "id": 3736787940,
      "node_id": "IC_kwDOAP4Jqs7eutvk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3736787940",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-12T03:50:17Z",
      "updated_at": "2026-01-12T03:50:34Z",
      "author_association": "MEMBER",
      "body": "@theStack would it also make sense to split everything pre-label out of this PR so it can be merged earlier? Or is it too entangled?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#issuecomment-3736787940",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1792"
    },
    {
      "event": "mentioned",
      "id": 21979903256,
      "node_id": "MEE_lADOAP4Jqs7gfWKizwAAAAUeGrUY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21979903256",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-12T03:50:18Z"
    },
    {
      "event": "subscribed",
      "id": 21979903265,
      "node_id": "SE_lADOAP4Jqs7gfWKizwAAAAUeGrUh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21979903265",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-12T03:50:19Z"
    },
    {
      "event": "commented",
      "id": 3750150915,
      "node_id": "IC_kwDOAP4Jqs7fhsMD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3750150915",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-14T15:38:57Z",
      "updated_at": "2026-01-14T15:38:57Z",
      "author_association": "CONTRIBUTOR",
      "body": "> @theStack would it also make sense to split everything pre-label out of this PR so it can be merged earlier? Or is it too entangled?\r\n\r\nThe two scanning approaches have very different APIs. We could in theory add a dedicated API function for no-labels scanning that is shared in both PRs (and create a separate PR that only contains that), but considering that there is a strong recommendation in the BIP to always scan at least for the change label (m=0), I don't think it would be very useful in practice.\r\nSo the only splitting possibility I see would be a PR that contains only sending capabilities (previously suggested in take 3, see https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3144198707). ",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#issuecomment-3750150915",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1792"
    },
    {
      "event": "mentioned",
      "id": 22046727432,
      "node_id": "MEE_lADOAP4Jqs7gfWKizwAAAAUiFl0I",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22046727432",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-14T15:38:58Z"
    },
    {
      "event": "subscribed",
      "id": 22046727471,
      "node_id": "SE_lADOAP4Jqs7gfWKizwAAAAUiFl0v",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22046727471",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-14T15:38:58Z"
    },
    {
      "event": "reviewed",
      "id": 3752788767,
      "node_id": "PRR_kwDOAP4Jqs7frwMf",
      "url": null,
      "actor": null,
      "commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-02-04T19:07:37Z",
      "author_association": "NONE",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#pullrequestreview-3752788767",
      "submitted_at": "2026-02-04T19:07:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765515160",
      "pull_request_review_id": 3752788767,
      "id": 2765515160,
      "node_id": "PRRC_kwDOAP4Jqs6k1mmY",
      "diff_hunk": "@@ -0,0 +1,751 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, uint32_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash\n+     * function, this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e.,\n+     * spend_pubkey = (_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t j, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys,\n+     * i.e., a_sum = a_sum * input_hash. By multiplying the scalars together first, we can save an elliptic curve\n+     * multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient\n+     * group, where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (j = 0; j < n_recipients; j++) {\n+        if ((j == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[j]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[j]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[j]->index], shared_secret, &recipients[j]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[j]->scan_pubkey;\n+        k++;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    ret &= secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &label_tweak_scalar, &label_ge, label_tweak32);\n+    secp256k1_silentpayments_label_save(label, &label_ge);\n+\n+    secp256k1_scalar_clear(&label_tweak_scalar);\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_silentpayments_label *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key, return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_silentpayments_label_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  Note that `_recipient_prevouts_summary_create` always creates a prevouts_summary object\n+ *  with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+        for (i = 0; i < n_xonly_pubkeys; i++) {\n+            ARG_CHECK(xonly_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+        for (i = 0; i < n_plain_pubkeys; i++) {\n+            ARG_CHECK(plain_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+/* Compare function needed for lexicographicaly sorting a list of taproot outputs\n+ * (constisting of raw 32 bytes x-only public keys each). */\n+static int secp256k1_silentpayments_tx_outputs_sort_cmp(const void* out1, const void* out2, void *cmp_data) {\n+    (void)cmp_data;\n+    return secp256k1_memcmp_var(*(const unsigned char**)out1, *(const unsigned char**)out2, 32);\n+}\n+\n+/* Given a list of sorted taproot outputs (consisting of raw 32 bytes x-only public keys each)\n+ * and a single taproot output to look for, find the index of that output via binary search.\n+ * Returns -1 if nothing was found. */\n+static int secp256k1_silentpayments_tx_output_find(const unsigned char **tx_outputs_sorted, size_t n_tx_outputs, const unsigned char *tx_output) {\n+    size_t low = 0;\n+    size_t high = n_tx_outputs;\n+\n+    while (low < high) {\n+        size_t mid = (low + high) / 2;\n+        int cmp = secp256k1_memcmp_var(tx_output, tx_outputs_sorted[mid], 32);\n+        if (cmp == 0) {\n+            return (int)mid;\n+        } else if (cmp < 0) {\n+            high = mid;\n+        } else {\n+            low = mid + 1;\n+        }\n+    }\n+    return -1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, uint32_t *n_found_outputs,\n+    const unsigned char **tx_outputs, uint32_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_silentpayments_label_entry * const *label_entries,\n+    size_t n_label_entries\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge unlabeled_spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    unsigned char shared_secret[33];\n+    uint32_t k;\n+    size_t i, li;\n+    int found_idx;\n+    int combined, valid_scan_key, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    for (i = 0; i < n_tx_outputs; i++) {\n+        ARG_CHECK(found_outputs[i] != NULL);\n+        ARG_CHECK(tx_outputs[i] != NULL);\n+    }\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    if (label_entries != NULL) {\n+        ARG_CHECK(n_label_entries > 0);\n+        ARG_CHECK(n_label_entries <= SECP256K1_SILENTPAYMENTS_MAX_LABELS);\n+        for (i = 0; i < n_label_entries; i++) {\n+            ARG_CHECK(label_entries[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_label_entries == 0);\n+    }\n+\n+    valid_scan_key = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &valid_scan_key, sizeof(valid_scan_key));\n+    if (!valid_scan_key) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &unlabeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    /* Creating the shared secret requires that the public and secret components are\n+     * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+     * scan secret key, and prevouts public key sum) have all been verified at this point,\n+     * assuming that the user hasn't tampered with the `prevouts_summary` object manually. */\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+    /* Clear the scan_key_scalar since we no longer need it and leaking this value would break\n+     * indistinguishability of the transaction. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+\n+    /* Sort transaction outputs to find them fast using binary search */\n+    secp256k1_hsort(tx_outputs, n_tx_outputs, sizeof(*tx_outputs), secp256k1_silentpayments_tx_outputs_sort_cmp, NULL);\n+\n+    for (k = 0; k < n_tx_outputs; k++) {\n+        secp256k1_ge unlabeled_output_ge = unlabeled_spend_pubkey_ge;\n+        unsigned char unlabeled_output_xonly[32];\n+        int labeled_match = 0;\n+        /* Calculate the output_tweak and convert it to a scalar.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal\n+         * to the curve order, which is statistically improbable. Returning an error here results in an untestable\n+         * branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = unlabeled_spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only with negligible\n+         * probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&unlabeled_output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        secp256k1_fe_normalize_var(&unlabeled_output_ge.x);\n+        secp256k1_fe_get_b32(unlabeled_output_xonly, &unlabeled_output_ge.x);\n+        found_idx = secp256k1_silentpayments_tx_output_find(tx_outputs, n_tx_outputs, unlabeled_output_xonly);\n+        if (found_idx != -1) {\n+            memcpy(found_outputs[k]->output, unlabeled_output_xonly, 32);\n+            secp256k1_scalar_get_b32(found_outputs[k]->tweak, &output_tweak_scalar);\n+            found_outputs[k]->found_with_label = 0;\n+            /* Set the label with an invalid value. */\n+            memset(&found_outputs[k]->label, 0, sizeof(secp256k1_silentpayments_label));\n+            continue; /* we had a direct match, continue with next k value */\n+        }\n+\n+        /* Check for label matches by iterating through all passed entries and look\n+         * up each candidate in the list of tx outputs */\n+        for (li = 0; li < n_label_entries; li++) {\n+            /* TODO: optimize label scanning loop by using batch inversion */\n+            secp256k1_ge label_ge, labeled_output_ge;\n+            secp256k1_gej labeled_output_gej;\n+            unsigned char labeled_output_xonly[32];\n+\n+            /* calculate labeled_output = unlabeled_output + label */\n+            secp256k1_silentpayments_label_load(ctx, &label_ge, &label_entries[li]->label);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 705,
      "original_position": 705,
      "commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "original_commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n            if (!secp256k1_silentpayments_label_load(ctx, &label_ge, &label_entries[li]->label)) {\n                 /* Clear the shared_secret and output_tweak before returning. */\n                secp256k1_memclear_explicit(shared_secret, sizeof(shared_secret));\n                secp256k1_scalar_clear(&output_tweak_scalar);\n                return 0;\n            }\n```",
      "created_at": "2026-02-04T18:52:13Z",
      "updated_at": "2026-02-04T19:07:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#discussion_r2765515160",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765515160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 705,
      "original_line": 705,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765516680",
      "pull_request_review_id": 3752788767,
      "id": 2765516680,
      "node_id": "PRRC_kwDOAP4Jqs6k1m-I",
      "diff_hunk": "@@ -0,0 +1,751 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, uint32_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash\n+     * function, this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e.,\n+     * spend_pubkey = (_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t j, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys,\n+     * i.e., a_sum = a_sum * input_hash. By multiplying the scalars together first, we can save an elliptic curve\n+     * multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient\n+     * group, where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (j = 0; j < n_recipients; j++) {\n+        if ((j == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[j]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[j]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[j]->index], shared_secret, &recipients[j]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[j]->scan_pubkey;\n+        k++;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    ret &= secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &label_tweak_scalar, &label_ge, label_tweak32);\n+    secp256k1_silentpayments_label_save(label, &label_ge);\n+\n+    secp256k1_scalar_clear(&label_tweak_scalar);\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_silentpayments_label *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key, return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_silentpayments_label_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  Note that `_recipient_prevouts_summary_create` always creates a prevouts_summary object\n+ *  with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+        for (i = 0; i < n_xonly_pubkeys; i++) {\n+            ARG_CHECK(xonly_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+        for (i = 0; i < n_plain_pubkeys; i++) {\n+            ARG_CHECK(plain_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+/* Compare function needed for lexicographicaly sorting a list of taproot outputs\n+ * (constisting of raw 32 bytes x-only public keys each). */\n+static int secp256k1_silentpayments_tx_outputs_sort_cmp(const void* out1, const void* out2, void *cmp_data) {\n+    (void)cmp_data;\n+    return secp256k1_memcmp_var(*(const unsigned char**)out1, *(const unsigned char**)out2, 32);\n+}\n+\n+/* Given a list of sorted taproot outputs (consisting of raw 32 bytes x-only public keys each)\n+ * and a single taproot output to look for, find the index of that output via binary search.\n+ * Returns -1 if nothing was found. */\n+static int secp256k1_silentpayments_tx_output_find(const unsigned char **tx_outputs_sorted, size_t n_tx_outputs, const unsigned char *tx_output) {\n+    size_t low = 0;\n+    size_t high = n_tx_outputs;\n+\n+    while (low < high) {\n+        size_t mid = (low + high) / 2;\n+        int cmp = secp256k1_memcmp_var(tx_output, tx_outputs_sorted[mid], 32);\n+        if (cmp == 0) {\n+            return (int)mid;\n+        } else if (cmp < 0) {\n+            high = mid;\n+        } else {\n+            low = mid + 1;\n+        }\n+    }\n+    return -1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, uint32_t *n_found_outputs,\n+    const unsigned char **tx_outputs, uint32_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_silentpayments_label_entry * const *label_entries,\n+    size_t n_label_entries\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge unlabeled_spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    unsigned char shared_secret[33];\n+    uint32_t k;\n+    size_t i, li;\n+    int found_idx;\n+    int combined, valid_scan_key, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    for (i = 0; i < n_tx_outputs; i++) {\n+        ARG_CHECK(found_outputs[i] != NULL);\n+        ARG_CHECK(tx_outputs[i] != NULL);\n+    }\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    if (label_entries != NULL) {\n+        ARG_CHECK(n_label_entries > 0);\n+        ARG_CHECK(n_label_entries <= SECP256K1_SILENTPAYMENTS_MAX_LABELS);\n+        for (i = 0; i < n_label_entries; i++) {\n+            ARG_CHECK(label_entries[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_label_entries == 0);\n+    }\n+\n+    valid_scan_key = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &valid_scan_key, sizeof(valid_scan_key));\n+    if (!valid_scan_key) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &unlabeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    /* Creating the shared secret requires that the public and secret components are\n+     * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+     * scan secret key, and prevouts public key sum) have all been verified at this point,\n+     * assuming that the user hasn't tampered with the `prevouts_summary` object manually. */\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+    /* Clear the scan_key_scalar since we no longer need it and leaking this value would break\n+     * indistinguishability of the transaction. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+\n+    /* Sort transaction outputs to find them fast using binary search */\n+    secp256k1_hsort(tx_outputs, n_tx_outputs, sizeof(*tx_outputs), secp256k1_silentpayments_tx_outputs_sort_cmp, NULL);\n+\n+    for (k = 0; k < n_tx_outputs; k++) {\n+        secp256k1_ge unlabeled_output_ge = unlabeled_spend_pubkey_ge;\n+        unsigned char unlabeled_output_xonly[32];\n+        int labeled_match = 0;\n+        /* Calculate the output_tweak and convert it to a scalar.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal\n+         * to the curve order, which is statistically improbable. Returning an error here results in an untestable\n+         * branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = unlabeled_spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only with negligible\n+         * probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&unlabeled_output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        secp256k1_fe_normalize_var(&unlabeled_output_ge.x);\n+        secp256k1_fe_get_b32(unlabeled_output_xonly, &unlabeled_output_ge.x);\n+        found_idx = secp256k1_silentpayments_tx_output_find(tx_outputs, n_tx_outputs, unlabeled_output_xonly);\n+        if (found_idx != -1) {\n+            memcpy(found_outputs[k]->output, unlabeled_output_xonly, 32);\n+            secp256k1_scalar_get_b32(found_outputs[k]->tweak, &output_tweak_scalar);\n+            found_outputs[k]->found_with_label = 0;\n+            /* Set the label with an invalid value. */\n+            memset(&found_outputs[k]->label, 0, sizeof(secp256k1_silentpayments_label));\n+            continue; /* we had a direct match, continue with next k value */\n+        }\n+\n+        /* Check for label matches by iterating through all passed entries and look\n+         * up each candidate in the list of tx outputs */\n+        for (li = 0; li < n_label_entries; li++) {\n+            /* TODO: optimize label scanning loop by using batch inversion */\n+            secp256k1_ge label_ge, labeled_output_ge;\n+            secp256k1_gej labeled_output_gej;\n+            unsigned char labeled_output_xonly[32];\n+\n+            /* calculate labeled_output = unlabeled_output + label */\n+            secp256k1_silentpayments_label_load(ctx, &label_ge, &label_entries[li]->label);\n+            secp256k1_gej_set_ge(&labeled_output_gej, &unlabeled_output_ge);\n+            secp256k1_gej_add_ge_var(&labeled_output_gej, &labeled_output_gej, &label_ge, NULL);\n+            if (secp256k1_gej_is_infinity(&labeled_output_gej)) {\n+                /* \"point at infinity\" is not a valid x-only output candidate, so skip early */\n+                continue;\n+            }\n+            secp256k1_ge_set_gej_var(&labeled_output_ge, &labeled_output_gej);\n+            secp256k1_fe_normalize_var(&labeled_output_ge.x);\n+            secp256k1_fe_get_b32(labeled_output_xonly, &labeled_output_ge.x);\n+            found_idx = secp256k1_silentpayments_tx_output_find(tx_outputs, n_tx_outputs, labeled_output_xonly);\n+            if (found_idx != -1) {\n+                memcpy(found_outputs[k]->output, labeled_output_xonly, 32);\n+                secp256k1_scalar_get_b32(found_outputs[k]->tweak, &output_tweak_scalar);\n+                found_outputs[k]->found_with_label = 1;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 719,
      "original_position": 719,
      "commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "original_commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n                found_outputs[k]->found_with_label = 1;\n                found_outputs[k]->label = label_entries[li]->label;\n```",
      "created_at": "2026-02-04T18:52:39Z",
      "updated_at": "2026-02-04T19:07:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#discussion_r2765516680",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765516680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 719,
      "original_line": 719,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765519554",
      "pull_request_review_id": 3752788767,
      "id": 2765519554,
      "node_id": "PRRC_kwDOAP4Jqs6k1nrC",
      "diff_hunk": "@@ -0,0 +1,371 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payments outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public key\n+ *  must be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    uint32_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payments outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each Silent Payments\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from Silent Payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  When creating more than one generated output, all of the generated outputs\n+ *  MUST be included in the final transaction. Dropping any of the generated\n+ *  outputs from the final transaction may make all or some of the outputs\n+ *  unfindable by the recipient.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 on failure. This is expected only with an adversarially chosen\n+ *           recipient spend key. Specifically, failure occurs when:\n+ *             - Input secret keys sum to 0 or the negation of a spend key\n+ *               (negligible probability if at least one of the input secret\n+ *               keys is uniformly random and independent of all other keys)\n+ *             - A hash output is not a valid scalar (negligible probability\n+ *               per hash evaluation)\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `secp256k1_silentpayments_recipient` object\n+ *                            with index = 0.\n+ *  In:           recipients: pointer to an array of pointers to Silent Payments\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct Silent\n+ *                            Payments addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the size of the recipients array.\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the size of taproot_seckeys array.\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the size of the plain_seckeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always",
      "path": "include/secp256k1_silentpayments.h",
      "position": 154,
      "original_position": 154,
      "commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "original_commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n *  Returns: 1 if the label could be serialized, 0 otherwise.\n```",
      "created_at": "2026-02-04T18:53:25Z",
      "updated_at": "2026-02-04T19:07:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#discussion_r2765519554",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765519554"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 154,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765531739",
      "pull_request_review_id": 3752788767,
      "id": 2765531739,
      "node_id": "PRRC_kwDOAP4Jqs6k1qpb",
      "diff_hunk": "@@ -0,0 +1,371 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payments outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public key\n+ *  must be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    uint32_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payments outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each Silent Payments\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from Silent Payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  When creating more than one generated output, all of the generated outputs\n+ *  MUST be included in the final transaction. Dropping any of the generated\n+ *  outputs from the final transaction may make all or some of the outputs\n+ *  unfindable by the recipient.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 on failure. This is expected only with an adversarially chosen\n+ *           recipient spend key. Specifically, failure occurs when:\n+ *             - Input secret keys sum to 0 or the negation of a spend key\n+ *               (negligible probability if at least one of the input secret\n+ *               keys is uniformly random and independent of all other keys)\n+ *             - A hash output is not a valid scalar (negligible probability\n+ *               per hash evaluation)\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `secp256k1_silentpayments_recipient` object\n+ *                            with index = 0.\n+ *  In:           recipients: pointer to an array of pointers to Silent Payments\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct Silent\n+ *                            Payments addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the size of the recipients array.\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the size of taproot_seckeys array.\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the size of the plain_seckeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out33: pointer to a 33-byte array to store the serialized label\n+ *  In:    label: pointer to the label\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_label_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out33,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payments labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payments address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if spend pubkey and label sum to zero (negligible probability for\n+ *             labels created according to BIP352).\n+ *\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds Silent Payments prevouts summary data.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 101 bytes in size, and can be safely copied/moved.\n+ *  This structure does not contain secret data. It can be created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payments prevouts summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each Silent Payments\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side.\n+ *\n+ *  Returns: 1 if prevouts summary creation was successful.\n+ *           0 if the transaction is not a Silent Payments transaction.\n+ *\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the size of the xonly_pubkeys array.\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the size of the plain_pubkeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Label entry struct\n+ *\n+ *  Struct for passing label and label tweak data pairs to the scanning function.\n+ */\n+typedef struct secp256k1_silentpayments_label_entry {\n+    secp256k1_silentpayments_label label;\n+    unsigned char label_tweak[32];\n+} secp256k1_silentpayments_label_entry;\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the serialized x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set to a valid value.\n+ *             label: the label used. If found_with_label = false, this is set to\n+ *                    an invalid value.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    unsigned char output[32];\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_silentpayments_label label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Hard limit on the number of labels that are allowed to be used for scanning. */\n+#define SECP256K1_SILENTPAYMENTS_MAX_LABELS 500\n+\n+/** Scan for Silent Payments transaction outputs.\n+ *\n+ *  WARNING: This function implements scanning in a way that is optimized for a\n+ *  smaller number of labels. Each additional label to scan for adds a small but\n+ *  noticable computational burden to the scanning process. Therefore, it is strongly\n+ *  discouraged to pass in more than 50 label entries. To avoid stalling the wallet\n+ *  for several minutes for pathological transactions (\"worst-case scanning attack\"),\n+ *  a hard limit is defined by SECP256K1_SILENTPAYMENTS_MAX_LABELS; values greater\n+ *  than that for the `n_label_entries` parameter are treated as illegal.\n+ *\n+ *  A different way of scanning (the one recommended in the BIP), where the\n+ *  performance is independent of the number of labels, might be available in a\n+ *  future release.\n+ *\n+ *  Given a prevouts_summary object, a recipient's 32 byte scan key and spend public\n+ *  key, the list of label entries to scan for, and the relevant transaction outputs,\n+ *  scan for outputs belonging to the recipient and return the tweak(s) needed for\n+ *  spending the output(s).\n+ *",
      "path": "include/secp256k1_silentpayments.h",
      "position": 325,
      "original_position": 325,
      "commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "original_commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n *  Note: This function sorts the pointer array `tx_outputs` in-place (by output\n *  bytes) to allow fast lookups via binary search.\n```",
      "created_at": "2026-02-04T18:57:02Z",
      "updated_at": "2026-02-04T19:07:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#discussion_r2765531739",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765531739"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 325,
      "original_line": 325,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765537770",
      "pull_request_review_id": 3752788767,
      "id": 2765537770,
      "node_id": "PRRC_kwDOAP4Jqs6k1sHq",
      "diff_hunk": "@@ -0,0 +1,742 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../unit_test.h\"\n+#include \"../../../src/modules/silentpayments/vectors.h\"\n+\n+/** Constants\n+ *\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f,\n+        0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11,\n+        0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed,\n+        0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7,\n+        0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46, 0x0d, 0x68, 0x08, 0x65, 0x64, 0x45, 0xee,\n+    0x4d, 0x4e, 0xc0, 0x8e, 0xba, 0x8a, 0x66, 0xea,\n+    0x66, 0x8e, 0x4e, 0x12, 0x98, 0x9a, 0x0e, 0x60,\n+    0x4b, 0x5c, 0x36, 0x0e, 0x43, 0xf5, 0x5a, 0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0x4b, 0x81, 0x34, 0x5d, 0x53, 0x89, 0xba, 0xa3,\n+    0xd8, 0x93, 0xe2, 0xfb, 0xe7, 0x08, 0xdd, 0x6d,\n+    0x82, 0xdc, 0xd8, 0x49, 0xab, 0x03, 0xc1, 0xdb,\n+    0x68, 0xbe, 0xc7, 0xe9, 0x2a, 0x45, 0xfa, 0xc5\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0xb7, 0xf3, 0xc6, 0x79, 0x30, 0x4a, 0xef, 0x8c,\n+    0xc0, 0xc7, 0x61, 0xf1, 0x00, 0x99, 0xdd, 0x7b,\n+    0x20, 0x65, 0x20, 0xd7, 0x11, 0x6f, 0xb7, 0x91,\n+    0xee, 0x74, 0x54, 0xa2, 0xfc, 0x22, 0x79, 0xf4\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea, 0xdc, 0x78, 0x16, 0x5f, 0xf1, 0xf8, 0xea,\n+    0x94, 0xad, 0x7c, 0xfd, 0xc5, 0x49, 0x90, 0x73,\n+    0x8a, 0x4c, 0x53, 0xf6, 0xe0, 0x50, 0x7b, 0x42,\n+    0x15, 0x42, 0x01, 0xb8, 0xe5, 0xdf, 0xf3, 0xb1\n+};\n+/* sha256(\"message\") */\n+static unsigned char MSG32[32] = {\n+    0xab,0x53,0x0a,0x13,0xe4,0x59,0x14,0x98,\n+    0x2b,0x79,0xf9,0xb7,0xe3,0xfb,0xa9,0x94,\n+    0xcf,0xd1,0xf3,0xfb,0x22,0xf7,0x1c,0xea,\n+    0x1a,0xfb,0xf0,0x2b,0x46,0x0c,0x6d,0x1d\n+};\n+/* sha256(\"random auxiliary data\") */\n+static unsigned char AUX32[32] = {\n+    0x0b,0x3f,0xdd,0xfd,0x67,0xbf,0x76,0xae,\n+    0x76,0x39,0xee,0x73,0x5b,0x70,0xff,0x15,\n+    0x83,0xfd,0x92,0x48,0xc0,0x57,0xd2,0x86,\n+    0x07,0xa2,0x15,0xf4,0x0b,0x0a,0x3e,0xcc\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret == 1);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}\n+\n+static void test_send_api(void) {\n+    unsigned char (*sp_addresses[2])[2][33];\n+    unsigned char const *p[1];\n+    secp256k1_keypair const *t[1];\n+    secp256k1_silentpayments_recipient r[2];\n+    const secp256k1_silentpayments_recipient *rp[2];\n+    secp256k1_xonly_pubkey o[2];\n+    secp256k1_xonly_pubkey *op[2];\n+    secp256k1_keypair taproot;\n+    size_t i;\n+\n+    /* Set up Bob and Carol as the recipients */\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].spend_pubkey,(*sp_addresses[i])[1], 33));\n+        /* Set the index value incorrectly */\n+        r[i].index = 0;\n+        rp[i] = &r[i];\n+        op[i] = &o[i];\n+    }\n+    /* Set up a taproot key and a plain key for Alice */\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    t[0] = &taproot;\n+    p[0] = ALICE_SECKEY;\n+\n+    /* Fails if the index is set incorrectly */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Set the index correctly for the next tests */\n+    for (i = 0; i < 2; i++) {\n+        r[i].index = i;\n+    }\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that NULL in \"array of pointers\" arguments is not allowed */\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_xonly_pubkey *original_ptr_xpk = op[i];\n+        const secp256k1_silentpayments_recipient *original_ptr_rec = rp[i];\n+\n+        op[i] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+        op[i] = original_ptr_xpk;\n+\n+        rp[i] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+        rp[i] = original_ptr_rec;\n+    }\n+    {\n+        secp256k1_keypair const *original_ptr = t[0];\n+        t[0] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 0));\n+        t[0] = original_ptr;\n+    }\n+    {\n+        unsigned char const *original_ptr = p[0];\n+        p[0] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+        p[0] = original_ptr;\n+    }\n+\n+    /* Check that null arguments are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, NULL, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, NULL, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, NULL, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 1));\n+\n+    /* Check correct context is used */\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_silentpayments_sender_create_outputs(STATIC_CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that array arguments are verified */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, NULL, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 0, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 0));\n+\n+    /* Create malformed keys for Alice by using a key that will overflow */\n+    CHECK(secp256k1_ec_seckey_verify(CTX, secp256k1_group_order_bytes) == 0);\n+    p[0] = secp256k1_group_order_bytes;\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    /* Malleate the keypair object so that the secret key is all zeros. We need to keep\n+     * public key as is since it is loaded first and would hit an ARG_CHECK if invalid.\n+     */\n+    memset(&taproot.data[0], 0, 32);\n+    /* Check that an invalid plain secret key is caught */\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    /* Check that an invalid keypair is caught */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 0));\n+    /* Create malformed keys for Alice by using a zero'd seckey */\n+    p[0] = MALFORMED_SECKEY;\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    p[0] = ALICE_SECKEY;\n+    /* Create malformed recipients by setting all of the public key bytes to zero.\n+     * Realistically, this would never happen since a bad public key would get caught when\n+     * trying to parse the public key with _ec_pubkey_parse\n+     */\n+    {\n+         secp256k1_pubkey tmp = r[1].spend_pubkey;\n+         memset(&r[1].spend_pubkey, 0, sizeof(r[1].spend_pubkey));\n+         CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+         r[1].spend_pubkey = tmp;\n+    }\n+    {\n+        secp256k1_pubkey tmp = r[1].scan_pubkey;\n+        int32_t ecount = 0;\n+\n+        memset(&r[1].scan_pubkey, 0, sizeof(r[1].scan_pubkey));\n+        secp256k1_context_set_illegal_callback(CTX, counting_callback_fn, &ecount);\n+        CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+        CHECK(ecount == 2);\n+        secp256k1_context_set_illegal_callback(CTX, NULL, NULL);\n+        r[1].scan_pubkey = tmp;\n+    }\n+    {\n+        unsigned char malformed_spend_key[32] = {\n+                0x83, 0xe1, 0x79, 0xdf, 0x51, 0xbb, 0xc9, 0x6f,\n+                0xfb, 0x59, 0xb6, 0x2e, 0x57, 0xcf, 0x4e, 0x54,\n+                0x71, 0x79, 0x04, 0x9c, 0x01, 0x47, 0x00, 0xfe,\n+                0x52, 0xef, 0x5f, 0x53, 0x76, 0x39, 0xec, 0xe0\n+        };\n+        secp256k1_pubkey neg_spend_pubkey;\n+        CHECK(secp256k1_ec_pubkey_create(CTX, &neg_spend_pubkey, malformed_spend_key));\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &neg_spend_pubkey));\n+        r[0].spend_pubkey = neg_spend_pubkey;\n+        for (i = 0; i < 2; i++) {\n+            r[i].index = i;\n+            rp[i] = &r[i];\n+        }\n+        CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    }\n+}\n+\n+static void test_label_api(void) {\n+    secp256k1_silentpayments_label l;\n+    secp256k1_pubkey s, ls, e;   /* spend pk, labeled spend pk, expected labeled spend pk */\n+    unsigned char lt[32];        /* label tweak */\n+    unsigned char label_ser[33]; /* serialized label */\n+    const unsigned char expected[33] = {\n+        0x03, 0xdc, 0x7f, 0x09, 0x9a, 0xbe, 0x95, 0x7a,\n+        0x58, 0x43, 0xd2, 0xb6, 0xbb, 0x35, 0x79, 0x61,\n+        0x5c, 0x60, 0x36, 0xa4, 0x9b, 0x86, 0xf4, 0xbe,\n+        0x46, 0x38, 0x60, 0x28, 0xa8, 0x1a, 0x77, 0xd4,\n+        0x91\n+    };\n+\n+    /* Create a label and labeled spend public key, verify we get the expected result */\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &s, BOB_ADDRESS[1], 33));\n+    CHECK(secp256k1_silentpayments_recipient_label_create(CTX, &l, lt, ALICE_SECKEY, 1));\n+    CHECK(secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &l));\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &e, expected, 33));\n+    CHECK(secp256k1_ec_pubkey_cmp(CTX, &ls, &e) == 0);\n+\n+    /* Check label (de)serialization round-trip */\n+    {\n+        secp256k1_silentpayments_label parsed_label;\n+        unsigned char parsed_label_ser[33];\n+\n+        CHECK(secp256k1_silentpayments_recipient_label_serialize(CTX, label_ser, &l));\n+        CHECK(secp256k1_silentpayments_recipient_label_parse(CTX, &parsed_label, label_ser));\n+        CHECK(secp256k1_silentpayments_recipient_label_serialize(CTX, parsed_label_ser, &parsed_label));\n+        CHECK(secp256k1_memcmp_var(label_ser, parsed_label_ser, 33) == 0);\n+    }\n+\n+    /* Check null values are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_create(CTX, NULL, lt, ALICE_SECKEY, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_create(CTX, &l, NULL, ALICE_SECKEY, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_create(CTX, &l, lt, NULL, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_parse(CTX, NULL, expected));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_parse(CTX, &l, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_serialize(CTX, NULL, &l));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_serialize(CTX, label_ser, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, NULL, &s, &l));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, NULL, &l));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, NULL));\n+    /* Check that creating a label with an invalid scan key fails */\n+    CHECK(secp256k1_silentpayments_recipient_label_create(CTX, &l, lt, MALFORMED_SECKEY, 1) == 0);\n+    CHECK(secp256k1_silentpayments_recipient_label_create(CTX, &l, lt, secp256k1_group_order_bytes, 1) == 0);\n+    /* Check for malformed spend public key and label, i.e., any single pubkey is malformed or the public\n+     * keys are valid but sum up to zero.\n+     */\n+    {\n+        secp256k1_pubkey neg_spend_pubkey = s;\n+        unsigned char neg_spend_label_ser[33];\n+        size_t serlen = 33;\n+        secp256k1_silentpayments_label neg_spend_label;\n+\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &neg_spend_pubkey));\n+        CHECK(secp256k1_ec_pubkey_serialize(CTX, neg_spend_label_ser, &serlen, &neg_spend_pubkey, SECP256K1_EC_COMPRESSED));\n+        CHECK(secp256k1_silentpayments_recipient_label_parse(CTX, &neg_spend_label, neg_spend_label_ser));\n+\n+        CHECK(secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &neg_spend_label) == 0);\n+        /* Also test with a malformed spend public key. */\n+        memset(&s, 0, sizeof(s));\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &neg_spend_label));\n+        /* Reset s back to a valid public key for the next test. */\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &s, BOB_ADDRESS[1], 33));\n+        memset(&l, 0, sizeof(l));\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &l));\n+        /* Reset l back to a valid public key for the next test */\n+        CHECK(secp256k1_silentpayments_recipient_label_create(CTX, &l, lt, ALICE_SECKEY, 1));\n+        memset(&s, 0, sizeof(s));\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &l));\n+    }\n+}\n+\n+static void test_recipient_api(void) {\n+    secp256k1_silentpayments_prevouts_summary ps; /* prevouts_summary */\n+    secp256k1_silentpayments_prevouts_summary md; /* malformed prevouts_summary */\n+    secp256k1_silentpayments_found_output f;      /* a silent payment found output */\n+    secp256k1_silentpayments_found_output *fp[1]; /* array of pointers to found outputs */\n+    secp256k1_silentpayments_label_entry le[1];   /* label entries */\n+    const secp256k1_silentpayments_label_entry *lep[1]; /* array of pointers to label entries */\n+    secp256k1_xonly_pubkey t;                     /* taproot x-only public key */\n+    unsigned char t_ser[32];                      /* serialized taproot x-only public key */\n+    secp256k1_xonly_pubkey malformed_t;           /* malformed x-only public key */\n+    secp256k1_xonly_pubkey const *tp[1];          /* array of pointers to xonly pks */\n+    const unsigned char *tp_ser[1];                     /* array of pointers to serialized xonly pks */\n+    secp256k1_pubkey p;                           /* plain public key */\n+    secp256k1_pubkey malformed_p;                 /* malformed public key */\n+    secp256k1_pubkey const *pp[1];                /* array of pointers to plain pks */\n+    uint32_t n_f;                                 /* number of found outputs */\n+\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &p, BOB_ADDRESS[0], 33));\n+    memset(&malformed_p, 0, sizeof(malformed_p));\n+    memset(&malformed_t, 0, sizeof(malformed_t));\n+    memset(&md, 0, sizeof(md));\n+    md.data[4] = 1;\n+    CHECK(secp256k1_xonly_pubkey_parse(CTX, &t, &BOB_ADDRESS[0][1]));\n+    memcpy(t_ser, &BOB_ADDRESS[0][1], 32);\n+    tp[0] = &t;\n+    tp_ser[0] = &t_ser[0];\n+    pp[0] = &p;\n+    fp[0] = &f;\n+    /* create label entry */\n+    CHECK(secp256k1_silentpayments_recipient_label_create(CTX, &le[0].label, &le[0].label_tweak[0], ALICE_SECKEY, 0));\n+    lep[0] = &le[0];\n+    CHECK(secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+    /* Check that malformed input public keys are caught. Input public keys summing to zero is tested later,\n+     * in the BIP0352 test vectors.\n+     */\n+    pp[0] = &malformed_p;\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+    pp[0] = &p;\n+    /* Check that malformed x-only input public keys are caught. */\n+    tp[0] = &malformed_t;\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+    tp[0] = &t;\n+\n+    /* Check that NULL in \"array of pointers\" arguments is not allowed */\n+    {\n+        secp256k1_xonly_pubkey const *original_ptr = tp[0];\n+        tp[0] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+        tp[0] = original_ptr;\n+    }\n+    {\n+        secp256k1_pubkey const *original_ptr = pp[0];\n+        pp[0] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+        pp[0] = original_ptr;\n+    }\n+\n+    /* Check null values are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, NULL, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, NULL, tp, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, NULL, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, NULL, 1));\n+\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 0, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, NULL, 0, pp, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, NULL, 0, NULL, 0));\n+\n+    /* check the _recipient_scan_outputs cornercase where internal tweaking would fail;\n+       this is the case if the recipient spend public key is P = -(create_output_tweak(shared_secret, k))*G */\n+    {\n+        unsigned char output_tweak[32] = {\n+            0x96, 0x32, 0xb4, 0x06, 0xeb, 0x56, 0xcc, 0xb2,\n+            0x0f, 0xc6, 0xe5, 0x2c, 0x41, 0xd5, 0x73, 0xb2,\n+            0xae, 0xa0, 0x45, 0x07, 0x63, 0xf1, 0xf6, 0x22,\n+            0xfa, 0x87, 0xc2, 0x4c, 0x7d, 0x80, 0x58, 0x62,\n+        };\n+        secp256k1_pubkey neg_spend_pubkey;\n+        CHECK(secp256k1_ec_pubkey_create(CTX, &neg_spend_pubkey, output_tweak));\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &neg_spend_pubkey));\n+        CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp_ser, 1, ALICE_SECKEY, &ps, &neg_spend_pubkey, lep, 1) == 0);\n+    }\n+    /* check the _recipients_scan_outputs cornercase where the output_tweak is the negation of the label_tweak */\n+    {\n+        unsigned char output_tweak[32] = {\n+            0x96, 0x32, 0xb4, 0x06, 0xeb, 0x56, 0xcc, 0xb2,\n+            0x0f, 0xc6, 0xe5, 0x2c, 0x41, 0xd5, 0x73, 0xb2,\n+            0xae, 0xa0, 0x45, 0x07, 0x63, 0xf1, 0xf6, 0x22,\n+            0xfa, 0x87, 0xc2, 0x4c, 0x7d, 0x80, 0x58, 0x62,\n+        };\n+        unsigned char label_ser[33];\n+        static const unsigned char zero[32] = {0};\n+        secp256k1_pubkey spk, neg_label_pubkey;\n+        secp256k1_xonly_pubkey output_xonly;\n+        unsigned char output_xonly_ser[32];\n+        const unsigned char *output_xonly_ser_ptrs[1];\n+        size_t len = 33;\n+        uint32_t found;\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &spk, BOB_ADDRESS[0], 33));\n+        CHECK(secp256k1_xonly_pubkey_from_pubkey(CTX, &output_xonly, NULL, &spk));\n+        CHECK(secp256k1_xonly_pubkey_serialize(CTX, output_xonly_ser, &output_xonly));\n+        output_xonly_ser_ptrs[0] = &output_xonly_ser[0];\n+        CHECK(secp256k1_ec_seckey_negate(CTX, output_tweak));\n+        CHECK(secp256k1_ec_pubkey_create(CTX, &neg_label_pubkey, output_tweak));\n+        CHECK(secp256k1_ec_pubkey_serialize(CTX, label_ser, &len, &neg_label_pubkey, SECP256K1_EC_COMPRESSED));\n+        CHECK(secp256k1_silentpayments_recipient_label_parse(CTX, &le[0].label, label_ser));\n+        memcpy(le[0].label_tweak, output_tweak, 32);\n+        found = 0;\n+        CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &found, output_xonly_ser_ptrs, 1, ALICE_SECKEY, &ps, &spk, lep, 1));\n+        CHECK(found == 1);",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 486,
      "original_position": 486,
      "commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "original_commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n        CHECK(found == 1);\n        CHECK(fp[0]->found_with_label == 1);\n        CHECK(secp256k1_memcmp_var(&fp[0]->label, &le[0].label, sizeof(fp[0]->label)) == 0);\n```",
      "created_at": "2026-02-04T18:58:39Z",
      "updated_at": "2026-02-04T19:07:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#discussion_r2765537770",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765537770"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 486,
      "original_line": 486,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765572782",
      "pull_request_review_id": 3752788767,
      "id": 2765572782,
      "node_id": "PRRC_kwDOAP4Jqs6k10qu",
      "diff_hunk": "@@ -0,0 +1,742 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../unit_test.h\"\n+#include \"../../../src/modules/silentpayments/vectors.h\"\n+\n+/** Constants\n+ *\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f,\n+        0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11,\n+        0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed,\n+        0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7,\n+        0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46, 0x0d, 0x68, 0x08, 0x65, 0x64, 0x45, 0xee,\n+    0x4d, 0x4e, 0xc0, 0x8e, 0xba, 0x8a, 0x66, 0xea,\n+    0x66, 0x8e, 0x4e, 0x12, 0x98, 0x9a, 0x0e, 0x60,\n+    0x4b, 0x5c, 0x36, 0x0e, 0x43, 0xf5, 0x5a, 0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0x4b, 0x81, 0x34, 0x5d, 0x53, 0x89, 0xba, 0xa3,\n+    0xd8, 0x93, 0xe2, 0xfb, 0xe7, 0x08, 0xdd, 0x6d,\n+    0x82, 0xdc, 0xd8, 0x49, 0xab, 0x03, 0xc1, 0xdb,\n+    0x68, 0xbe, 0xc7, 0xe9, 0x2a, 0x45, 0xfa, 0xc5\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0xb7, 0xf3, 0xc6, 0x79, 0x30, 0x4a, 0xef, 0x8c,\n+    0xc0, 0xc7, 0x61, 0xf1, 0x00, 0x99, 0xdd, 0x7b,\n+    0x20, 0x65, 0x20, 0xd7, 0x11, 0x6f, 0xb7, 0x91,\n+    0xee, 0x74, 0x54, 0xa2, 0xfc, 0x22, 0x79, 0xf4\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea, 0xdc, 0x78, 0x16, 0x5f, 0xf1, 0xf8, 0xea,\n+    0x94, 0xad, 0x7c, 0xfd, 0xc5, 0x49, 0x90, 0x73,\n+    0x8a, 0x4c, 0x53, 0xf6, 0xe0, 0x50, 0x7b, 0x42,\n+    0x15, 0x42, 0x01, 0xb8, 0xe5, 0xdf, 0xf3, 0xb1\n+};\n+/* sha256(\"message\") */\n+static unsigned char MSG32[32] = {\n+    0xab,0x53,0x0a,0x13,0xe4,0x59,0x14,0x98,\n+    0x2b,0x79,0xf9,0xb7,0xe3,0xfb,0xa9,0x94,\n+    0xcf,0xd1,0xf3,0xfb,0x22,0xf7,0x1c,0xea,\n+    0x1a,0xfb,0xf0,0x2b,0x46,0x0c,0x6d,0x1d\n+};\n+/* sha256(\"random auxiliary data\") */\n+static unsigned char AUX32[32] = {\n+    0x0b,0x3f,0xdd,0xfd,0x67,0xbf,0x76,0xae,\n+    0x76,0x39,0xee,0x73,0x5b,0x70,0xff,0x15,\n+    0x83,0xfd,0x92,0x48,0xc0,0x57,0xd2,0x86,\n+    0x07,0xa2,0x15,0xf4,0x0b,0x0a,0x3e,0xcc\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret == 1);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}\n+\n+static void test_send_api(void) {\n+    unsigned char (*sp_addresses[2])[2][33];\n+    unsigned char const *p[1];\n+    secp256k1_keypair const *t[1];\n+    secp256k1_silentpayments_recipient r[2];\n+    const secp256k1_silentpayments_recipient *rp[2];\n+    secp256k1_xonly_pubkey o[2];\n+    secp256k1_xonly_pubkey *op[2];\n+    secp256k1_keypair taproot;\n+    size_t i;\n+\n+    /* Set up Bob and Carol as the recipients */\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    for (i = 0; i < 2; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].spend_pubkey,(*sp_addresses[i])[1], 33));\n+        /* Set the index value incorrectly */\n+        r[i].index = 0;\n+        rp[i] = &r[i];\n+        op[i] = &o[i];\n+    }\n+    /* Set up a taproot key and a plain key for Alice */\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    t[0] = &taproot;\n+    p[0] = ALICE_SECKEY;\n+\n+    /* Fails if the index is set incorrectly */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Set the index correctly for the next tests */\n+    for (i = 0; i < 2; i++) {\n+        r[i].index = i;\n+    }\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that NULL in \"array of pointers\" arguments is not allowed */\n+    for (i = 0; i < 2; i++) {\n+        secp256k1_xonly_pubkey *original_ptr_xpk = op[i];\n+        const secp256k1_silentpayments_recipient *original_ptr_rec = rp[i];\n+\n+        op[i] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+        op[i] = original_ptr_xpk;\n+\n+        rp[i] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+        rp[i] = original_ptr_rec;\n+    }\n+    {\n+        secp256k1_keypair const *original_ptr = t[0];\n+        t[0] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 0));\n+        t[0] = original_ptr;\n+    }\n+    {\n+        unsigned char const *original_ptr = p[0];\n+        p[0] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+        p[0] = original_ptr;\n+    }\n+\n+    /* Check that null arguments are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, NULL, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, NULL, 2, SMALLEST_OUTPOINT, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, NULL, t, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 1, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 1));\n+\n+    /* Check correct context is used */\n+    CHECK_ILLEGAL(STATIC_CTX, secp256k1_silentpayments_sender_create_outputs(STATIC_CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+\n+    /* Check that array arguments are verified */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, NULL, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 0, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 0, p, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, p, 0));\n+\n+    /* Create malformed keys for Alice by using a key that will overflow */\n+    CHECK(secp256k1_ec_seckey_verify(CTX, secp256k1_group_order_bytes) == 0);\n+    p[0] = secp256k1_group_order_bytes;\n+    CHECK(secp256k1_keypair_create(CTX, &taproot, ALICE_SECKEY));\n+    /* Malleate the keypair object so that the secret key is all zeros. We need to keep\n+     * public key as is since it is loaded first and would hit an ARG_CHECK if invalid.\n+     */\n+    memset(&taproot.data[0], 0, 32);\n+    /* Check that an invalid plain secret key is caught */\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    /* Check that an invalid keypair is caught */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, t, 1, NULL, 0));\n+    /* Create malformed keys for Alice by using a zero'd seckey */\n+    p[0] = MALFORMED_SECKEY;\n+    CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    p[0] = ALICE_SECKEY;\n+    /* Create malformed recipients by setting all of the public key bytes to zero.\n+     * Realistically, this would never happen since a bad public key would get caught when\n+     * trying to parse the public key with _ec_pubkey_parse\n+     */\n+    {\n+         secp256k1_pubkey tmp = r[1].spend_pubkey;\n+         memset(&r[1].spend_pubkey, 0, sizeof(r[1].spend_pubkey));\n+         CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\n+         r[1].spend_pubkey = tmp;\n+    }\n+    {\n+        secp256k1_pubkey tmp = r[1].scan_pubkey;\n+        int32_t ecount = 0;\n+\n+        memset(&r[1].scan_pubkey, 0, sizeof(r[1].scan_pubkey));\n+        secp256k1_context_set_illegal_callback(CTX, counting_callback_fn, &ecount);\n+        CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+        CHECK(ecount == 2);\n+        secp256k1_context_set_illegal_callback(CTX, NULL, NULL);\n+        r[1].scan_pubkey = tmp;\n+    }\n+    {\n+        unsigned char malformed_spend_key[32] = {\n+                0x83, 0xe1, 0x79, 0xdf, 0x51, 0xbb, 0xc9, 0x6f,\n+                0xfb, 0x59, 0xb6, 0x2e, 0x57, 0xcf, 0x4e, 0x54,\n+                0x71, 0x79, 0x04, 0x9c, 0x01, 0x47, 0x00, 0xfe,\n+                0x52, 0xef, 0x5f, 0x53, 0x76, 0x39, 0xec, 0xe0\n+        };\n+        secp256k1_pubkey neg_spend_pubkey;\n+        CHECK(secp256k1_ec_pubkey_create(CTX, &neg_spend_pubkey, malformed_spend_key));\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &neg_spend_pubkey));\n+        r[0].spend_pubkey = neg_spend_pubkey;\n+        for (i = 0; i < 2; i++) {\n+            r[i].index = i;\n+            rp[i] = &r[i];\n+        }\n+        CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\n+    }\n+}\n+\n+static void test_label_api(void) {\n+    secp256k1_silentpayments_label l;\n+    secp256k1_pubkey s, ls, e;   /* spend pk, labeled spend pk, expected labeled spend pk */\n+    unsigned char lt[32];        /* label tweak */\n+    unsigned char label_ser[33]; /* serialized label */\n+    const unsigned char expected[33] = {\n+        0x03, 0xdc, 0x7f, 0x09, 0x9a, 0xbe, 0x95, 0x7a,\n+        0x58, 0x43, 0xd2, 0xb6, 0xbb, 0x35, 0x79, 0x61,\n+        0x5c, 0x60, 0x36, 0xa4, 0x9b, 0x86, 0xf4, 0xbe,\n+        0x46, 0x38, 0x60, 0x28, 0xa8, 0x1a, 0x77, 0xd4,\n+        0x91\n+    };\n+\n+    /* Create a label and labeled spend public key, verify we get the expected result */\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &s, BOB_ADDRESS[1], 33));\n+    CHECK(secp256k1_silentpayments_recipient_label_create(CTX, &l, lt, ALICE_SECKEY, 1));\n+    CHECK(secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &l));\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &e, expected, 33));\n+    CHECK(secp256k1_ec_pubkey_cmp(CTX, &ls, &e) == 0);\n+\n+    /* Check label (de)serialization round-trip */\n+    {\n+        secp256k1_silentpayments_label parsed_label;\n+        unsigned char parsed_label_ser[33];\n+\n+        CHECK(secp256k1_silentpayments_recipient_label_serialize(CTX, label_ser, &l));\n+        CHECK(secp256k1_silentpayments_recipient_label_parse(CTX, &parsed_label, label_ser));\n+        CHECK(secp256k1_silentpayments_recipient_label_serialize(CTX, parsed_label_ser, &parsed_label));\n+        CHECK(secp256k1_memcmp_var(label_ser, parsed_label_ser, 33) == 0);\n+    }\n+\n+    /* Check null values are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_create(CTX, NULL, lt, ALICE_SECKEY, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_create(CTX, &l, NULL, ALICE_SECKEY, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_create(CTX, &l, lt, NULL, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_parse(CTX, NULL, expected));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_parse(CTX, &l, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_serialize(CTX, NULL, &l));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_label_serialize(CTX, label_ser, NULL));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, NULL, &s, &l));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, NULL, &l));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, NULL));\n+    /* Check that creating a label with an invalid scan key fails */\n+    CHECK(secp256k1_silentpayments_recipient_label_create(CTX, &l, lt, MALFORMED_SECKEY, 1) == 0);\n+    CHECK(secp256k1_silentpayments_recipient_label_create(CTX, &l, lt, secp256k1_group_order_bytes, 1) == 0);\n+    /* Check for malformed spend public key and label, i.e., any single pubkey is malformed or the public\n+     * keys are valid but sum up to zero.\n+     */\n+    {\n+        secp256k1_pubkey neg_spend_pubkey = s;\n+        unsigned char neg_spend_label_ser[33];\n+        size_t serlen = 33;\n+        secp256k1_silentpayments_label neg_spend_label;\n+\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &neg_spend_pubkey));\n+        CHECK(secp256k1_ec_pubkey_serialize(CTX, neg_spend_label_ser, &serlen, &neg_spend_pubkey, SECP256K1_EC_COMPRESSED));\n+        CHECK(secp256k1_silentpayments_recipient_label_parse(CTX, &neg_spend_label, neg_spend_label_ser));\n+\n+        CHECK(secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &neg_spend_label) == 0);\n+        /* Also test with a malformed spend public key. */\n+        memset(&s, 0, sizeof(s));\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &neg_spend_label));\n+        /* Reset s back to a valid public key for the next test. */\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &s, BOB_ADDRESS[1], 33));\n+        memset(&l, 0, sizeof(l));\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &l));\n+        /* Reset l back to a valid public key for the next test */\n+        CHECK(secp256k1_silentpayments_recipient_label_create(CTX, &l, lt, ALICE_SECKEY, 1));\n+        memset(&s, 0, sizeof(s));\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(CTX, &ls, &s, &l));\n+    }\n+}\n+\n+static void test_recipient_api(void) {\n+    secp256k1_silentpayments_prevouts_summary ps; /* prevouts_summary */\n+    secp256k1_silentpayments_prevouts_summary md; /* malformed prevouts_summary */\n+    secp256k1_silentpayments_found_output f;      /* a silent payment found output */\n+    secp256k1_silentpayments_found_output *fp[1]; /* array of pointers to found outputs */\n+    secp256k1_silentpayments_label_entry le[1];   /* label entries */\n+    const secp256k1_silentpayments_label_entry *lep[1]; /* array of pointers to label entries */\n+    secp256k1_xonly_pubkey t;                     /* taproot x-only public key */\n+    unsigned char t_ser[32];                      /* serialized taproot x-only public key */\n+    secp256k1_xonly_pubkey malformed_t;           /* malformed x-only public key */\n+    secp256k1_xonly_pubkey const *tp[1];          /* array of pointers to xonly pks */\n+    const unsigned char *tp_ser[1];                     /* array of pointers to serialized xonly pks */\n+    secp256k1_pubkey p;                           /* plain public key */\n+    secp256k1_pubkey malformed_p;                 /* malformed public key */\n+    secp256k1_pubkey const *pp[1];                /* array of pointers to plain pks */\n+    uint32_t n_f;                                 /* number of found outputs */\n+\n+    CHECK(secp256k1_ec_pubkey_parse(CTX, &p, BOB_ADDRESS[0], 33));\n+    memset(&malformed_p, 0, sizeof(malformed_p));\n+    memset(&malformed_t, 0, sizeof(malformed_t));\n+    memset(&md, 0, sizeof(md));\n+    md.data[4] = 1;\n+    CHECK(secp256k1_xonly_pubkey_parse(CTX, &t, &BOB_ADDRESS[0][1]));\n+    memcpy(t_ser, &BOB_ADDRESS[0][1], 32);\n+    tp[0] = &t;\n+    tp_ser[0] = &t_ser[0];\n+    pp[0] = &p;\n+    fp[0] = &f;\n+    /* create label entry */\n+    CHECK(secp256k1_silentpayments_recipient_label_create(CTX, &le[0].label, &le[0].label_tweak[0], ALICE_SECKEY, 0));\n+    lep[0] = &le[0];\n+    CHECK(secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+    /* Check that malformed input public keys are caught. Input public keys summing to zero is tested later,\n+     * in the BIP0352 test vectors.\n+     */\n+    pp[0] = &malformed_p;\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+    pp[0] = &p;\n+    /* Check that malformed x-only input public keys are caught. */\n+    tp[0] = &malformed_t;\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+    tp[0] = &t;\n+\n+    /* Check that NULL in \"array of pointers\" arguments is not allowed */\n+    {\n+        secp256k1_xonly_pubkey const *original_ptr = tp[0];\n+        tp[0] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+        tp[0] = original_ptr;\n+    }\n+    {\n+        secp256k1_pubkey const *original_ptr = pp[0];\n+        pp[0] = NULL;\n+        CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+        pp[0] = original_ptr;\n+    }\n+\n+    /* Check null values are handled */\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, NULL, SMALLEST_OUTPOINT, tp, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, NULL, tp, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, NULL, 1, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, NULL, 1));\n+\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 0, pp, 1));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, tp, 1, pp, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, NULL, 0, pp, 0));\n+    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_prevouts_summary_create(CTX, &ps, SMALLEST_OUTPOINT, NULL, 0, NULL, 0));\n+\n+    /* check the _recipient_scan_outputs cornercase where internal tweaking would fail;\n+       this is the case if the recipient spend public key is P = -(create_output_tweak(shared_secret, k))*G */\n+    {\n+        unsigned char output_tweak[32] = {\n+            0x96, 0x32, 0xb4, 0x06, 0xeb, 0x56, 0xcc, 0xb2,\n+            0x0f, 0xc6, 0xe5, 0x2c, 0x41, 0xd5, 0x73, 0xb2,\n+            0xae, 0xa0, 0x45, 0x07, 0x63, 0xf1, 0xf6, 0x22,\n+            0xfa, 0x87, 0xc2, 0x4c, 0x7d, 0x80, 0x58, 0x62,\n+        };\n+        secp256k1_pubkey neg_spend_pubkey;\n+        CHECK(secp256k1_ec_pubkey_create(CTX, &neg_spend_pubkey, output_tweak));\n+        CHECK(secp256k1_ec_pubkey_negate(CTX, &neg_spend_pubkey));\n+        CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &n_f, tp_ser, 1, ALICE_SECKEY, &ps, &neg_spend_pubkey, lep, 1) == 0);\n+    }\n+    /* check the _recipients_scan_outputs cornercase where the output_tweak is the negation of the label_tweak */\n+    {\n+        unsigned char output_tweak[32] = {\n+            0x96, 0x32, 0xb4, 0x06, 0xeb, 0x56, 0xcc, 0xb2,\n+            0x0f, 0xc6, 0xe5, 0x2c, 0x41, 0xd5, 0x73, 0xb2,\n+            0xae, 0xa0, 0x45, 0x07, 0x63, 0xf1, 0xf6, 0x22,\n+            0xfa, 0x87, 0xc2, 0x4c, 0x7d, 0x80, 0x58, 0x62,\n+        };\n+        unsigned char label_ser[33];\n+        static const unsigned char zero[32] = {0};\n+        secp256k1_pubkey spk, neg_label_pubkey;\n+        secp256k1_xonly_pubkey output_xonly;\n+        unsigned char output_xonly_ser[32];\n+        const unsigned char *output_xonly_ser_ptrs[1];\n+        size_t len = 33;\n+        uint32_t found;\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &spk, BOB_ADDRESS[0], 33));\n+        CHECK(secp256k1_xonly_pubkey_from_pubkey(CTX, &output_xonly, NULL, &spk));\n+        CHECK(secp256k1_xonly_pubkey_serialize(CTX, output_xonly_ser, &output_xonly));\n+        output_xonly_ser_ptrs[0] = &output_xonly_ser[0];\n+        CHECK(secp256k1_ec_seckey_negate(CTX, output_tweak));\n+        CHECK(secp256k1_ec_pubkey_create(CTX, &neg_label_pubkey, output_tweak));\n+        CHECK(secp256k1_ec_pubkey_serialize(CTX, label_ser, &len, &neg_label_pubkey, SECP256K1_EC_COMPRESSED));\n+        CHECK(secp256k1_silentpayments_recipient_label_parse(CTX, &le[0].label, label_ser));\n+        memcpy(le[0].label_tweak, output_tweak, 32);\n+        found = 0;\n+        CHECK(secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &found, output_xonly_ser_ptrs, 1, ALICE_SECKEY, &ps, &spk, lep, 1));\n+        CHECK(found == 1);\n+        CHECK(secp256k1_memcmp_var(fp[0]->tweak, zero, 32) == 0);",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 487,
      "original_position": 487,
      "commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "original_commit_id": "c2061dfd5ffc78a97ef1d91fc66d5d0ded9eff27",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n        CHECK(secp256k1_memcmp_var(fp[0]->tweak, zero, 32) == 0);\n        /* Check that malformed labels are caught. */\n        {\n            secp256k1_silentpayments_label_entry bad_le = le[0];\n            const secp256k1_silentpayments_label_entry *bad_lep[1];\n            bad_lep[0] = &bad_le;\n            memset(&bad_le.label, 0, sizeof(bad_le.label));\n            CHECK_ILLEGAL(CTX, secp256k1_silentpayments_recipient_scan_outputs(CTX, fp, &found, output_xonly_ser_ptrs, 1, ALICE_SECKEY, &ps, &spk, bad_lep, 1));\n        }\n```",
      "created_at": "2026-02-04T19:07:27Z",
      "updated_at": "2026-02-04T19:07:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1792#discussion_r2765572782",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2765572782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1792"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 487,
      "original_line": 487,
      "side": "RIGHT"
    }
  ]
}