{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765",
    "id": 2966544424,
    "node_id": "PR_kwDOAP4Jqs6w0eAo",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1765.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1765.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/25980e82651b8bb3316112ada8ddfb9592b69caf",
    "number": 1765,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Add \"silentpayments\" module implementing BIP352 (take 4, limited to full-node scanning)",
    "user": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "### Description\r\n\r\nThis PR implements [BIP352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki) with scanning limited to full-nodes. Light-client scanning is planned to be added in a separate PR in the future. The following 7 API functions are currently introduced:\r\n\r\nSender side [[BIP description](https://github.com/bitcoin/bips/blob/c9a6ca6297eb8de850f6b64dafb8e60ee9b64d66/bip-0352.mediawiki?plain=1#L297-L312)]: \r\n* `secp256k1_silentpayments_sender_create_outputs`: given a list of $n$ secret keys $a_1 ... a_n$, a serialized outpoint, and a list of recipients (each consisting of silent payments scan pubkey and spend pubkey), create the corresponding transaction outputs (x-only public keys) for the sending transaction \r\n\r\nReceiver side, label creation [[BIP description](https://github.com/bitcoin/bips/blob/c9a6ca6297eb8de850f6b64dafb8e60ee9b64d66/bip-0352.mediawiki?plain=1#L200)]:\r\n* `secp256k1_silentpayments_recipient_label_create`: given a scan secret key and label integer, calculate the corresponding label tweak and label object\r\n* `secp256k1_silentpayments_recipient_label_serialize`: given a label object, create the corresponding 33-byte serialization\r\n* `secp256k1_silentpayments_recipient_label_parse`: given a 33-byte label representation, create the corresponding label object\r\n* `secp256k1_silentpayments_recipient_create_labeled_spend_pubkey`: given a spend public key and a label object, create the corresponding labeled spend public key\r\n\r\nReceiver side, scanning [[BIP description](https://github.com/bitcoin/bips/blob/c9a6ca6297eb8de850f6b64dafb8e60ee9b64d66/bip-0352.mediawiki?plain=1#L334)]: \r\n* `secp256k1_silentpayments_recipient_prevouts_summary_create`: given a list of $n$ public keys $A_1 ... A_n$ and a serialized outpoint, create a `prevouts_summary` object needed for scanning\r\n* `secp256k1_silentpayments_recipient_scan_outputs`: given a `prevouts_summary` object, a recipients scan secret key and spend public key, and the relevant transaction outputs (x-only public keys), scan for outputs belonging to the recipients and and return the tweak(s) needed for spending the output(s). Optionally, a label_lookup callback function can be provided to also scan for labels.\r\n\r\nFor a higher-level overview on what these functions exactly do, it's suggested to look at a corresponding [Python implementation](https://github.com/theStack/secp256k1lab/blob/add_bip352_module_review_helper/src/secp256k1lab/bip352.py) that was created based on the secp256k1lab project (it passes the test vectors, so this \"executable pseudo-code\" should be correct).\r\n\r\n### Changes to the previous take\r\n\r\nBased on the latest state of the previous PR #1698 (take 3), the following changes have been made:\r\n* rebased on master (adapting to the new unit test framework added in #1734; thanks to furszy for his [mini-guide](https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3340808550))\r\n* removed functionality that is only relevant for light clients (`_prevout_summary_{parse,serialize}`, `__recipient_create_output_pubkeys`), adapted tests and benchmark accordingly\r\n* adapted examples to have both Bob and Carol do full-node scanning, with a TODO to switch the latter to light-client scanning once available in the future\r\n* addressed various review comments, if still relevant (https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2433803533, https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2433808769, https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2433811927, https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2433817223)\r\n\r\nThe scope reduction isn't immediately visible in commit count (only one commit was _only_ introducing light-client relevant functionality and could be completely removed), but the review burden compared #1698 is still significantly lower in terms of LOC, especially in the receiving commit.\r\n\r\n### Open questions / TODOs\r\n* ~~Recent proposals of reducing the worst-case scanning time (see posts by w0xlt and jonasnick, https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3448610022 ff.) are not taken into account yet.~~ :arrow_right: solved by marking already-found outputs, see https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3577161237 :heavy_check_mark: \r\n* ~~Not providing `prevouts_summary` (de)serialization functionality yet in the API poses the risk that users try to do it anyway by treating the opaque object as \"serialized\". How to cope with that? Is adding a \"don't do this\" comment in API header sufficient?~~ :arrow_right: solved by mentioning a \"don't do this\" comment in the API header (same phrasing as in other modules), see https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3533591506 :heavy_check_mark: ",
    "labels": [
      {
        "id": 4975353639,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI3fJw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/feature",
        "name": "feature",
        "description": "",
        "color": "731E95",
        "default": false
      }
    ],
    "created_at": "2025-10-31T12:06:04Z",
    "updated_at": "2026-02-18T18:40:49Z",
    "mergeable": true,
    "mergeable_state": "unstable",
    "merged": false,
    "merge_commit_sha": "61471633b0d4f6d5ac9c04da35d40373ddb6cdbe",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "theStack:silentpayments_module_fullnode_only",
      "ref": "silentpayments_module_fullnode_only",
      "sha": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 452762907,
        "node_id": "R_kgDOGvydGw",
        "name": "secp256k1",
        "full_name": "theStack/secp256k1",
        "owner": {
          "login": "theStack",
          "id": 91535,
          "node_id": "MDQ6VXNlcjkxNTM1",
          "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/theStack",
          "html_url": "https://github.com/theStack",
          "followers_url": "https://api.github.com/users/theStack/followers",
          "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
          "organizations_url": "https://api.github.com/users/theStack/orgs",
          "repos_url": "https://api.github.com/users/theStack/repos",
          "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/theStack/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/theStack/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/theStack/secp256k1",
        "archive_url": "https://api.github.com/repos/theStack/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/theStack/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/theStack/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/theStack/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/theStack/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/theStack/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/theStack/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/theStack/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/theStack/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/theStack/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/theStack/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/theStack/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/theStack/secp256k1/events",
        "forks_url": "https://api.github.com/repos/theStack/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/theStack/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/theStack/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/theStack/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/theStack/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/theStack/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/theStack/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/theStack/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/theStack/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/theStack/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/theStack/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/theStack/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/theStack/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/theStack/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/theStack/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/theStack/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:theStack/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/theStack/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/theStack/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/theStack/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/theStack/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/theStack/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/theStack/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/theStack/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/theStack/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/theStack/secp256k1/hooks",
        "svn_url": "https://github.com/theStack/secp256k1",
        "language": "C",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 13422,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-02-18T18:23:00Z",
        "created_at": "2022-01-27T16:42:12Z",
        "updated_at": "2025-09-14T19:27:22Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "c7a7f732bd17c71499341af77966c7ee2e75956c",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1124,
        "stargazers_count": 2403,
        "watchers_count": 2403,
        "size": 14062,
        "default_branch": "master",
        "open_issues_count": 167,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-02-17T09:40:27Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2026-02-18T14:20:09Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": true,
    "additions": 8279,
    "deletions": 36,
    "changed_files": 23,
    "commits": 13,
    "review_comments": 63,
    "comments": 57
  },
  "events": [
    {
      "event": "labeled",
      "id": 20764376070,
      "node_id": "LE_lADOAP4Jqs7VEWwNzwAAAATVpzwG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20764376070",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-06T16:09:29Z",
      "label": {
        "name": "feature",
        "color": "731E95"
      }
    },
    {
      "event": "commented",
      "id": 3499455867,
      "node_id": "IC_kwDOAP4Jqs7QlXV7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3499455867",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-06T21:27:50Z",
      "updated_at": "2025-11-06T21:27:50Z",
      "author_association": "NONE",
      "body": "Added the optimized version on top of this PR:\r\nhttps://github.com/w0xlt/secp256k1/commit/8d16914cad57ba07da09d104f0c605ae6284462f\r\n\r\nFor more context:\r\nhttps://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3462891318",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3499455867",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3500144381,
      "node_id": "IC_kwDOAP4Jqs7Qn_b9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3500144381",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-07T01:58:22Z",
      "updated_at": "2025-11-07T01:58:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "Small supplementary update: I've created a corresponding Python implementation of the provided API functions based on secp256k1lab (https://github.com/theStack/secp256k1lab/blob/add_bip352_module_review_helper/src/secp256k1lab/bip352.py) (also linked in the PR description). The hope is that this makes reviewing this PR a bit easier by having a less noisy, \"executable pseudo-code\"-like description on what happens under the hood. The code passes the BIP352 test vectors and hence should be correct.\r\n\r\n> Added the optimized version on top of this PR: [w0xlt@8d16914](https://github.com/w0xlt/secp256k1/commit/8d16914cad57ba07da09d104f0c605ae6284462f)\r\n> \r\n> For more context: [#1698 (comment)](https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3462891318)\r\n\r\nThanks for rebasing on top of this PR, much appreciated! I will take a closer look within the next days.\r\n",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3500144381",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "subscribed",
      "id": 20780027146,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATWlg0K",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20780027146",
      "actor": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-07T07:32:48Z"
    },
    {
      "event": "reviewed",
      "id": 3462461331,
      "node_id": "PRR_kwDOAP4Jqs7OYPeT",
      "url": null,
      "actor": null,
      "commit_id": "c11d30c25f75776920797b017a568ea0cfc28882",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-14T02:04:05Z",
      "author_association": "NONE",
      "body": "Nit: Not related to optimization, but the diff below removes some redundant public-key serialization code:\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\nindex 106da20..922433d 100644\r\n--- a/src/modules/silentpayments/main_impl.h\r\n+++ b/src/modules/silentpayments/main_impl.h\r\n@@ -21,6 +21,19 @@\r\n /** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\r\n static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\r\n \r\n+/* Serialize a ge to compressed 33 bytes. Keeps eckey_pubkey_serialize usage uniform\r\n+ * (expects non-const ge*), and centralizes the VERIFY_CHECK. */\r\n+static SECP256K1_INLINE void secp256k1_sp_ge_serialize33(const secp256k1_ge* in, unsigned char out33[33]) {\r\n+    size_t len = 33;\r\n+    secp256k1_ge tmp = *in;\r\n+    int ok = secp256k1_eckey_pubkey_serialize(&tmp, out33, &len, 1);\r\n+#ifdef VERIFY\r\n+    VERIFY_CHECK(ok && len == 33);\r\n+#else\r\n+    (void)ok;\r\n+#endif\r\n+}\r\n+\r\n /** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\r\n  *  ensure the correct values of k are used when creating multiple outputs for a recipient.\r\n  *\r\n@@ -68,13 +81,11 @@ static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar\r\n     secp256k1_sha256 hash;\r\n     unsigned char pubkey_sum_ser[33];\r\n     unsigned char input_hash[32];\r\n-    size_t len;\r\n     int ret, overflow;\r\n \r\n     secp256k1_silentpayments_sha256_init_inputs(&hash);\r\n     secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\r\n-    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\r\n-    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\r\n+    secp256k1_sp_ge_serialize33(pubkey_sum, pubkey_sum_ser);\r\n     secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\r\n     secp256k1_sha256_finalize(&hash, input_hash);\r\n     /* Convert input_hash to a scalar.\r\n@@ -85,15 +96,13 @@ static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar\r\n      * an error to ensure strict compliance with BIP0352.\r\n      */\r\n     secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\r\n-    ret &= !secp256k1_scalar_is_zero(input_hash_scalar);\r\n+    ret = !secp256k1_scalar_is_zero(input_hash_scalar);\r\n     return ret & !overflow;\r\n }\r\n \r\n static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\r\n     secp256k1_gej ss_j;\r\n     secp256k1_ge ss;\r\n-    size_t len;\r\n-    int ret;\r\n \r\n     secp256k1_ecmult_const(&ss_j, public_component, secret_component);\r\n     secp256k1_ge_set_gej(&ss, &ss_j);\r\n@@ -103,12 +112,7 @@ static void secp256k1_silentpayments_create_shared_secret(const secp256k1_contex\r\n      * impossible at this point considering we have already validated the public key and\r\n      * the secret key.\r\n      */\r\n-    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\r\n-#ifdef VERIFY\r\n-    VERIFY_CHECK(ret && len == 33);\r\n-#else\r\n-    (void)ret;\r\n-#endif\r\n+    secp256k1_sp_ge_serialize33(&ss, shared_secret33);\r\n \r\n     /* Leaking these values would break indistinguishability of the transaction, so clear them. */\r\n     secp256k1_ge_clear(&ss);\r\n@@ -585,7 +589,6 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n                 secp256k1_ge output_negated_ge, tx_output_ge;\r\n                 secp256k1_gej tx_output_gej, label_gej;\r\n                 unsigned char label33[33];\r\n-                size_t len;\r\n \r\n                 secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[j]);\r\n                 secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\r\n@@ -595,7 +598,6 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n                 secp256k1_ge_neg(&output_negated_ge, &output_ge);\r\n                 secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\r\n                 secp256k1_ge_set_gej_var(&label_ge, &label_gej);\r\n-                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\r\n                 /* Serialize must succeed because the point was just loaded.\r\n                  *\r\n                  * Note: serialize will also fail if label_ge is the point at infinity, but we know\r\n@@ -603,7 +605,7 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n                  * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\r\n                  * point at infinity.\r\n                  */\r\n-                VERIFY_CHECK(ret && len == 33);\r\n+                secp256k1_sp_ge_serialize33(&label_ge, label33);\r\n                 label_tweak = label_lookup(label33, label_context);\r\n                 if (label_tweak != NULL) {\r\n                     found = 1;\r\n@@ -617,7 +619,6 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n                 secp256k1_gej_neg(&label_gej, &tx_output_gej);\r\n                 secp256k1_gej_add_ge_var(&label_gej, &label_gej, &output_negated_ge, NULL);\r\n                 secp256k1_ge_set_gej_var(&label_ge, &label_gej);\r\n-                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\r\n                 /* Serialize must succeed because the point was just loaded.\r\n                  *\r\n                  * Note: serialize will also fail if label_ge is the point at infinity, but we know\r\n@@ -625,7 +626,7 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n                  * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\r\n                  * point at infinity.\r\n                  */\r\n-                VERIFY_CHECK(ret && len == 33);\r\n+                secp256k1_sp_ge_serialize33(&label_ge, label33);\r\n                 label_tweak = label_lookup(label33, label_context);\r\n                 if (label_tweak != NULL) {\r\n                     found = 1;\r\n``` ",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3462461331",
      "submitted_at": "2025-11-14T02:04:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "reviewed",
      "id": 3462502369,
      "node_id": "PRR_kwDOAP4Jqs7OYZfh",
      "url": null,
      "actor": null,
      "commit_id": "c11d30c25f75776920797b017a568ea0cfc28882",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-14T02:25:07Z",
      "author_association": "NONE",
      "body": "nit: The following diff removes the implicit cast and clarifies that k is 4 bytes\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\nindex 922433d..d94aed6 100644\r\n--- a/src/modules/silentpayments/main_impl.h\r\n+++ b/src/modules/silentpayments/main_impl.h\r\n@@ -512,7 +512,8 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n     secp256k1_xonly_pubkey output_xonly;\r\n     unsigned char shared_secret[33];\r\n     const unsigned char *label_tweak = NULL;\r\n-    size_t j, k, found_idx;\r\n+    size_t j, found_idx;\r\n+    uint32_t k;\r\n     int found, combined, valid_scan_key, ret;\r\n \r\n     /* Sanity check inputs */\r\n```",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3462502369",
      "submitted_at": "2025-11-14T02:25:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "reviewed",
      "id": 3465700051,
      "node_id": "PRR_kwDOAP4Jqs7OkmLT",
      "url": null,
      "actor": null,
      "commit_id": "c11d30c25f75776920797b017a568ea0cfc28882",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-14T16:25:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks @theStack for the new PR. I can confirm that this PR is a rebased version of #1698, with the light client functionality removed and comments addressed, except for:\r\n\r\n- https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2414315034\r\n- https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2414294498\r\n- https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3313483669 (only the last one, \"elemement\")\r\n",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3465700051",
      "submitted_at": "2025-11-14T16:25:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "commented",
      "id": 3533591506,
      "node_id": "IC_kwDOAP4Jqs7SnlPS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3533591506",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-14T16:33:07Z",
      "updated_at": "2025-11-14T16:33:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Not providing prevouts_summary (de)serialization functionality yet in the API poses the risk that users try to do it anyway by treating the opaque object as \"serialized\". How to cope with that? Is adding a \"don't do this\" comment in API header sufficient?\r\n\r\nIs there a reason for serializing prevouts_summary without light client functionality? If not, I think the don't do this comment is sufficient. Right now, in contrast to the docs of all other opaque objects, this is missing, however:\r\n\r\n> The exact representation of data inside the opaque data structures is implementation defined and not guaranteed to be portable between different platforms or versions.  ",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3533591506",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20956101523,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAThFLuT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956101523",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "445f2e835fdd81a23784d5b398f1180453a74c55",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/445f2e835fdd81a23784d5b398f1180453a74c55",
      "created_at": "2025-11-15T00:46:39Z"
    },
    {
      "event": "commented",
      "id": 3535206990,
      "node_id": "IC_kwDOAP4Jqs7StvpO",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3535206990",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-15T00:48:14Z",
      "updated_at": "2025-11-15T00:48:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "@w0xlt, @jonasnick: Thanks for the reviews! I've addressed the suggested changes:\r\n* in `_recpient_scan_outputs`: changed the type of `k`  to uint32_t ([comment above](https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3462502369))\r\n* in `_recipient_create_label`: added a scan key validity check (+added a test for that) ([#1698 - comment](https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2414315034))\r\n* unified all mentions of \"Silent Payments\" to [title case](https://en.wikipedia.org/wiki/Title_case) in the header API and example ([#1698 - comment](https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2414294498))\r\n* fixed typo s/elemement/element/ ([#1698 - review](https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3313483669))\r\n* in `_recipient_scan_outputs`: fixed comment in second label candidate ([review above](https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2528111908))\r\n* extended the API header comment for the `_prevouts_summary` opaque data structure, to point out that the data structure is implementation defined (like docs of all other opaque structs) ([comment above](https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3533591506))\r\n\r\n> Nit: Not related to optimization, but the diff below removes some redundant public-key serialization code:\r\n\r\nGiven that this compressed-pubkey-serialization pattern shows up repeatedly also in other modules (ellswift, musig), I think it would make the most sense to add a general helper (e.g. in eckey{,_impl}.h), which could be done in an independent PR. I've opened issue https://github.com/bitcoin-core/secp256k1/issues/1773 to see if there is conceptual support for doing this.\r\n\r\n> > Not providing prevouts_summary (de)serialization functionality yet in the API poses the risk that users try to do it anyway by treating the opaque object as \"serialized\". How to cope with that? Is adding a \"don't do this\" comment in API header sufficient?\r\n> \r\n> Is there a reason for serializing prevouts_summary without light client functionality? If not, I think the don't do this comment is sufficient.\r\n\r\nGood point, I can't think of a good reason for full nodes wanting to serialize prevouts_summary. ",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3535206990",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 20956120856,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAThFQcY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956120856",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-15T00:48:15Z"
    },
    {
      "event": "subscribed",
      "id": 20956120868,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAThFQck",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956120868",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-15T00:48:15Z"
    },
    {
      "event": "mentioned",
      "id": 20956120878,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAThFQcu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956120878",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-15T00:48:15Z"
    },
    {
      "event": "subscribed",
      "id": 20956120885,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAThFQc1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956120885",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-15T00:48:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20956305029,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAThF9aF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956305029",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "9103229d27d85fa8b199705f29bd7dada54ebaa7",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/9103229d27d85fa8b199705f29bd7dada54ebaa7",
      "created_at": "2025-11-15T01:01:15Z"
    },
    {
      "event": "commented",
      "id": 3560474486,
      "node_id": "IC_kwDOAP4Jqs7UOId2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3560474486",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T22:52:16Z",
      "updated_at": "2025-11-20T22:55:40Z",
      "author_association": "NONE",
      "body": "To address the open questions, Ive reviewed the proposed changes by @w0xlt on 8d16914cad57ba07da09d104f0c605ae6284462f.\r\n\r\nI'm going to focus more on the key aspects I extracted from the review and the merits of each change, rather on the big O improvement claims, because I didn't get that far.\r\n\r\nThese are multiple different changes rather than a single one, so to make the review easier I suggest to brake it in multiple commits. I would state on each of them the purpose and the real case scenario where the change would be relevant.\r\n\r\nAlso, I would use clearer names for the variables or at least document their purpose.\r\n\r\nThe changes I've identified so far are the following:\r\n\r\n- Improve label lookup using hash table: I think this is implementation dependent and should be improved by the user rather than by the library itself.\r\nExamples, as part of the documentation, are a usage demonstration, although can point the user the best practices, I prefer clarity rather than performance on them. For example, on the `rust-secp256k1` bindings, I used a [`HashMap` for the example](https://github.com/rust-bitcoin/rust-secp256k1/pull/876/commits/776653d9db064c8a5a422dca2311eaf669d96921#diff-120e5d0e47cef65c1da3e8220332b2fd878324ea96b204955dc7efc39b7d6fe8R84) because it is a familiar standard structure for Rust users. If they would like to gain more performance there, they have other [tools](https://nnethercote.github.io/perf-book/hashing.html) available to replace that structure by themselves.\r\n- On `secp256k1_silentpayments_recipient_sort_cmp`, I understood the change: `(r1->index < r2->index) ? -1 : (r1->index > r2->index) ? 1 : 0` is to make the unstable `secp256k1_hsort` implementation stable. Considering it only affects `secp256k1_silentpayments_sender_create_outputs`, which didn't receive more changes than a variable removal, what are the performance improvements there?\r\n- `SECP256K1_SP_SCAN_BATCH`: I [just learned about it (ge_set_gej_all)](https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3460261306) during this review, but seems that affine to jacobian conversion is needed for the comparison against labels, and is faster to do it in batches. I think the impact of this improvement will only affect the small subset of transaction with large amount of outputs. A good benchmark for this would be coinjoin transactions, although is not supported by BIP 352, a test case is doable.\r\n- Double `head`: I'm not sure of the target of this change, I guess is to skip already found or scanned inputs, but couldn't figure out what is tracking each head.\r\n- Binary tree search for x-only lookups: I think it explain itself, faster lookups on the not labeled case. This may have its merits, but I need to remove the other changes to have a clear answer.\r\n\r\nIn general I agree with @jonasnick that we should define a [clear target to benchmark and improve](https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3460261306). [As I've said before](https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3461362873), the base case should be a wallet with a single label for change.\r\nFor other improvements, I would try to match up plausible real world scenarios before making complex changes in the code base of the PR.\r\nFinally, by looking at `bench_silentpayments_full_tx_scan`, the `use_labels` case is very simple. If we want to test performance improvements on the label lookup, I would start there.\r\n\r\nIn conclusion, from the proposed commit and the discussion around it, the only changes I've found clear enough to consider are:\r\n- [Tracking of found outputs](https://github.com/jonasnick/secp256k1/commit/311b4ebb2bf6612c46cefd80a8812d9c9b5dc6c4): simple enough, small performance improvement for the usual case, better for larger transactions.\r\n",
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3560474486",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21083667735,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATorz0X",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21083667735",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T22:52:18Z"
    },
    {
      "event": "subscribed",
      "id": 21083667746,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATorz0i",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21083667746",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T22:52:18Z"
    },
    {
      "event": "mentioned",
      "id": 21083667760,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATorz0w",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21083667760",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T22:52:18Z"
    },
    {
      "event": "subscribed",
      "id": 21083667781,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATorz1F",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21083667781",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T22:52:18Z"
    },
    {
      "event": "commented",
      "id": 3560646024,
      "node_id": "IC_kwDOAP4Jqs7UOyWI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3560646024",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T23:34:35Z",
      "updated_at": "2025-11-20T23:34:35Z",
      "author_association": "NONE",
      "body": "Thanks @nymius for reviewing the changes, addressing the main points, and proposing a simplification.\r\n\r\nIm currently splitting the optimization commit into smaller pieces to make it easier to review. \r\nIll also take a closer look at your commit and run it against the benchmark files.\r\n\r\nThe only part of the discussion that still feels a bit ambiguous is the base or usual case. \r\nFrom my understanding of https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3341766084, the concern is not about typical usage, but rather about an attacker crafting malicious transactions with many outputs, causing the scanning process to take hours.\r\n\r\nSo the goal of this optimization would be to mitigate that scenario, not the collaborative one.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3560646024",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21084329452,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATouVXs",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21084329452",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T23:34:36Z"
    },
    {
      "event": "subscribed",
      "id": 21084329487,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATouVYP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21084329487",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T23:34:37Z"
    },
    {
      "event": "commented",
      "id": 3561510143,
      "node_id": "IC_kwDOAP4Jqs7USFT_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3561510143",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T05:55:27Z",
      "updated_at": "2025-11-21T05:55:27Z",
      "author_association": "NONE",
      "body": "I ran the `examples/silentpayments_mixed_1.c` file with simplified the version suggested by @nymius  https://github.com/jonasnick/secp256k1/commit/311b4ebb2bf6612c46cefd80a8812d9c9b5dc6c4 . It shows slightly worse performance (see below), but the simpler approach may still be worth it\r\n\r\nWithout the `secp256k1_silentpayments_recipient_sort_cmp` stabilization, I got **82s** for the complex version vs. **114s** for the simpler one. Whether the **30s** difference justifies the additional complexity is up for discussion  I dont have a strong opinion.\r\n\r\nAnswering the questions: `secp256k1_silentpayments_recipient_sort_cmp stabilization` + `heads` speed up the non-adversarial case. The stable sort ensures that the transaction outputs are ordered sequentially by the index $k$.\r\n\r\nThe optimized receiver implementation relies on a heuristic (the `head` pointers) that assumes the next output it is looking for ($k+1$) is located immediately after the previous one ($k$).\r\n\r\n* **With Stable Sort:** The scanner complexity is roughly **O(N)** (Linear).\r\n* **Without Stable Sort:** The scanner complexity degrades to **O(N)** (Quadratic).",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3561510143",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21089045331,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATpAUtT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21089045331",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T05:55:28Z"
    },
    {
      "event": "subscribed",
      "id": 21089045351,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATpAUtn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21089045351",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T05:55:28Z"
    },
    {
      "event": "commented",
      "id": 3563588992,
      "node_id": "IC_kwDOAP4Jqs7UaA2A",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3563588992",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:38Z",
      "updated_at": "2025-11-21T15:46:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "@w0xlt, @nymius: Thanks for investigating this deeper. I've now also had a chance to look at the suggested optimizations and came to similar conclusions as stated in https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3560474486. I particularly agree with the stated points that the changes should not increase complexity significantly and that the most important optimization candidate to consider for mitigating the worst-case scanning attack is \"skip outputs that we have already found\" (as previously stated by @jonasnick, see https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3460261306 and  https://github.com/jonasnick/secp256k1/commit/311b4ebb2bf6612c46cefd80a8812d9c9b5dc6c4). I don't think stabilizing the sorting helps at all, since this is something that happens at the sender side, and we can't rely on the attacker using a specific implementation (even if they did, it's trivial for them to shuffle the outputs after creation).\r\n\r\nFor the proposed target to benchmark, I'm proposing the following modified example that exhibits the worst-case scanning time based on a labels cache with one entry (for change outputs), by creating a tx with 23255 outputs [1] all targeted for Bob: https://github.com/bitcoin-core/secp256k1/commit/1df4287eb8daa34a07888300e0b18ba1c97a3432\r\n\r\nShower-thought from this morning: what if we treat the `tx_outputs` input as _actual_ list that we modify, and remove an entry if it is found? This would have a similar effect as the \"track found outputs\" idea, but without the need of dynamic memory allocation. It's a ~10-lines diff and seems to work fine: https://github.com/theStack/secp256k1/commit/9aba4709b937eb44507494b3bd5e80871193671c\r\nIt reduces the run-time of the proposed example above from ~10 minutes to roughly ~2 seconds on my machine.\r\n\r\nAny thoughts on this? Maybe I'm still missing something.\r\n\r\n[1] that's an upper bound of maximum outputs per block: floor(1000000/43) = 23255",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3563588992",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21100019914,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATpqMDK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100019914",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:39Z"
    },
    {
      "event": "subscribed",
      "id": 21100019955,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATpqMDz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100019955",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:39Z"
    },
    {
      "event": "mentioned",
      "id": 21100019976,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATpqMEI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100019976",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:39Z"
    },
    {
      "event": "subscribed",
      "id": 21100019996,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATpqMEc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100019996",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:39Z"
    },
    {
      "event": "mentioned",
      "id": 21100020018,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATpqMEy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100020018",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:39Z"
    },
    {
      "event": "subscribed",
      "id": 21100020048,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATpqMFQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100020048",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:40Z"
    },
    {
      "event": "commented",
      "id": 3564351976,
      "node_id": "IC_kwDOAP4Jqs7Uc7Ho",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3564351976",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T19:34:35Z",
      "updated_at": "2025-11-21T20:03:46Z",
      "author_association": "NONE",
      "body": "> Shower-thought from this morning: what if we treat the `tx_outputs` input as _actual_ list that we modify, and remove an entry if it is found? This would have a similar effect as the \"track found outputs\" idea, but without the need of dynamic memory allocation. It's a ~10-lines diff and seems to work fine: [theStack@9aba470](https://github.com/theStack/secp256k1/commit/9aba4709b937eb44507494b3bd5e80871193671c) It reduces the run-time of the proposed example above from ~10 minutes to roughly ~2 seconds on my machine.\r\n> \r\n> Any thoughts on this? Maybe I'm still missing something.\r\n\r\n1df4287eb8daa34a07888300e0b18ba1c97a3432 is a good target.\r\nThese are the runtime times I've obtained testing against this target:\r\n| Branch         | Runtime         |\r\n| :----------- | :--------------: | \r\n|theStack@9aba470| ~1.41s |\r\n| theStack@9103229d27d85fa8b199705f29bd7dada54ebaa7 (baseline) | ~9m |\r\n| jonasnick@311b4eb| ~1.49s |\r\n\r\nI had to increase stack size to be able to fit all N_OUTPUT size allocations in the example.\r\n\r\nInitially I preferred the `is_found` allocation rather than the element shifts. But your solution seems to be more performant.",
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3564351976",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3566408583,
      "node_id": "IC_kwDOAP4Jqs7UkxOH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3566408583",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T10:14:22Z",
      "updated_at": "2025-11-22T10:14:22Z",
      "author_association": "NONE",
      "body": "@theStack Yes  if we want to keep only the adversarial-scenario optimizations, we can drop sort stabilization and the extra heads.\r\n\r\nI like your idea of avoiding dynamic memory allocation. Thats a very interesting direction. On my machine, the scan completes in about **0.4s**, which feels like a good balance between simplicity and the optimization needed for the labeled case.\r\n\r\nBelow are the changes I had to make for your example to run on my machine and to record the scan time.\r\n\r\n```diff\r\ndiff --git a/examples/silentpayments.c b/examples/silentpayments.c\r\nindex 5e71e73..d43332f 100644\r\n--- a/examples/silentpayments.c\r\n+++ b/examples/silentpayments.c\r\n@@ -10,6 +10,7 @@\r\n #include <stdio.h>\r\n #include <stdlib.h>\r\n #include <string.h>\r\n+#include <time.h>\r\n \r\n #include <secp256k1_extrakeys.h>\r\n #include <secp256k1_silentpayments.h>\r\n@@ -112,15 +113,21 @@ const unsigned char* label_lookup(\r\n     return NULL;\r\n }\r\n \r\n+static secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\r\n+static const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\r\n+static secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\r\n+static secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\r\n+static secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\r\n+static secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\r\n+static secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\r\n+static const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\r\n+/* 2D array for holding multiple public key pairs. The second index, i.e., [2],\r\n+ * is to represent the spend and scan public keys. */\r\n+static unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\r\n+\r\n int main(void) {\r\n     unsigned char randomize[32];\r\n     unsigned char serialized_xonly[32];\r\n-    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\r\n-    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\r\n-    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\r\n-    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\r\n-    secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\r\n-    secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\r\n     secp256k1_silentpayments_prevouts_summary prevouts_summary;\r\n     secp256k1_pubkey unlabeled_spend_pubkey;\r\n     struct labels_cache bob_labels_cache;\r\n@@ -209,11 +216,6 @@ int main(void) {\r\n     {\r\n         secp256k1_keypair sender_keypairs[N_INPUTS];\r\n         const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\r\n-        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\r\n-        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\r\n-        /* 2D array for holding multiple public key pairs. The second index, i.e., [2],\r\n-         * is to represent the spend and scan public keys. */\r\n-        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\r\n         unsigned char seckey[32];\r\n \r\n         printf(\"Sending...\\n\");\r\n@@ -340,6 +342,9 @@ int main(void) {\r\n              *        `secp256k1_silentpayments_recipient_prevouts_summary_create`\r\n              *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\r\n              */\r\n+            clock_t start, end;\r\n+            double cpu_time_used;\r\n+\r\n             ret = secp256k1_silentpayments_recipient_prevouts_summary_create(ctx,\r\n                 &prevouts_summary,\r\n                 smallest_outpoint,\r\n@@ -356,14 +361,20 @@ int main(void) {\r\n \r\n             /* Scan the transaction */\r\n             n_found_outputs = 0;\r\n+            \r\n+            start = clock();\r\n             ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\r\n                 found_output_ptrs, &n_found_outputs,\r\n-                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, N_OUTPUTS,\r\n+                (const secp256k1_xonly_pubkey **)tx_output_ptrs, N_OUTPUTS,\r\n                 bob_scan_key,\r\n                 &prevouts_summary,\r\n                 &unlabeled_spend_pubkey,\r\n                 label_lookup, &bob_labels_cache /* NULL, NULL for no labels */\r\n             );\r\n+            end = clock();\r\n+            cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;\r\n+            printf(\"Bob's scan took %f seconds\\n\", cpu_time_used);\r\n+            \r\n             if (!ret) {\r\n                 printf(\"This transaction is not valid for Silent Payments, skipping.\\n\");\r\n                 return EXIT_SUCCESS;\r\n@@ -435,7 +446,7 @@ int main(void) {\r\n             n_found_outputs = 0;\r\n             ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\r\n                 found_output_ptrs, &n_found_outputs,\r\n-                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, 1, /* dummy scan with one output (we only care about Bob) */\r\n+                (const secp256k1_xonly_pubkey **)tx_output_ptrs, 1, /* dummy scan with one output (we only care about Bob) */\r\n                 carol_scan_key,\r\n                 &prevouts_summary,\r\n                 &unlabeled_spend_pubkey,\r\n```",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3566408583",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21113780100,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATqereE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21113780100",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T10:14:23Z"
    },
    {
      "event": "subscribed",
      "id": 21113780115,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATqereT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21113780115",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T10:14:23Z"
    },
    {
      "event": "commented",
      "id": 3566870041,
      "node_id": "IC_kwDOAP4Jqs7Umh4Z",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3566870041",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:38Z",
      "updated_at": "2025-11-22T16:39:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "@nymius, @w0xlt: Thanks once again for the quick feedback and for benchmarking! Shortly after my previous comment, I've been notified about yet another approach to tackle the worst-case scanning time attack (kudos to @furszy for bringing up the idea!), that I think is even more elegant: we can use the pointers in the `tx_outputs` list directly to track outputs by setting them to `NULL` if one has been found, and accordingly only treat them if they are non-NULL. With this, it's an only four lines of code change: https://github.com/theStack/secp256k1/commit/2087f9209df35764745dd744051e3d125d3c6b43. It kind of combines the previous two approaches of https://github.com/jonasnick/secp256k1/commit/311b4ebb2bf6612c46cefd80a8812d9c9b5dc6c4 and https://github.com/theStack/secp256k1/commit/9aba470 (-> mark spent outputs, but not in a newly allocated array, but by modifying the `tx_outputs` input list, in order to avoid dynamic memory allocation), with very similar run-time results.\r\n\r\nThe only tiny drawback about these non-malloc approaches might be that something that is conceptually an \"in\" parameter is modified, which might be a bit unsound in a strict API design sense. On the other hand, it shouldn't matter for the user (I doubt that these lists passed in would ever be reused for anything else after by the callers), and we already do the same in the sending API for the recipients, so it's probably fine.\r\n\r\n> @theStack Yes  if we want to keep only the adversarial-scenario optimizations, we can drop sort stabilization and the extra heads.\r\n\r\nThe way I see it currently, code paths for non-adversarial scenarios with increasing k values would be hit so rarely in practice, that I'm sceptical that it's worth it put much effort into those optimizations. When scanning, the vast majority of transactions won't have any matches in the first place. Out of those few that _do have a match_, the vast majority will very likely again not contain any repeated recipient (IMHO it doesn't make that much sense to do that, unless the recipient explicitly asks \"I want to receive my payment split up in multiple UTXOs, but still in a single tx\"?), so in the bigger picture those optimizations wouldn't matter all that much, and I'd assume that the dominant factor should be by far all the (unavoidable) ECDH computations per transaction. But that's still more of a guess and it's still good to already have optimization ideas at hand if we need them in the future.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3566870041",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21115996548,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATqnImE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996548",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:39Z"
    },
    {
      "event": "subscribed",
      "id": 21115996556,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATqnImM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996556",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "mentioned",
      "id": 21115996562,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATqnImS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996562",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "subscribed",
      "id": 21115996571,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATqnImb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996571",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "mentioned",
      "id": 21115996577,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATqnImh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996577",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "subscribed",
      "id": 21115996581,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATqnIml",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996581",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "mentioned",
      "id": 21115996585,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATqnImp",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996585",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "subscribed",
      "id": 21115996592,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATqnImw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996592",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "commented",
      "id": 3567528551,
      "node_id": "IC_kwDOAP4Jqs7UpCpn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3567528551",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-23T06:06:05Z",
      "updated_at": "2025-11-23T06:06:05Z",
      "author_association": "NONE",
      "body": "@theStack Thanks for continuing to refine the optimization. The deletion approach performs slightly better (0.40 s vs. 0.45 s), likely because deleting items shrinks the array and cuts the number of loop iterations by about 50% compared to nullifying them.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3567528551",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21119855419,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATq12s7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21119855419",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-23T06:06:06Z"
    },
    {
      "event": "subscribed",
      "id": 21119855423,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATq12s_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21119855423",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-23T06:06:06Z"
    },
    {
      "event": "referenced",
      "id": 21151923870,
      "node_id": "REFE_lADOAP4Jqs7VEWwNzwAAAATswL6e",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21151923870",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "1c8233acf208a6f935fc11161feda6c0775945e6",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/1c8233acf208a6f935fc11161feda6c0775945e6",
      "created_at": "2025-11-25T00:31:12Z"
    },
    {
      "event": "referenced",
      "id": 21170249357,
      "node_id": "REFE_lADOAP4Jqs7VEWwNzwAAAATt2F6N",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21170249357",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "c16252ddccdeaefdc6c4ec4425ddda91ee813320",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/c16252ddccdeaefdc6c4ec4425ddda91ee813320",
      "created_at": "2025-11-25T17:28:10Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21172132445,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAATt9Rpd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21172132445",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "650b2fb6256a8df06e4193003deb4879f52bf72c",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/650b2fb6256a8df06e4193003deb4879f52bf72c",
      "created_at": "2025-11-25T19:07:56Z"
    },
    {
      "event": "commented",
      "id": 3577161237,
      "node_id": "IC_kwDOAP4Jqs7VNyYV",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3577161237",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-25T19:08:27Z",
      "updated_at": "2025-12-01T23:42:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "To summarize, the following table shows the proposed mitigations for the worst-case scanning attack so far, with benchmark results from my machine. The [previous baseline commit](https://github.com/bitcoin-core/secp256k1/commit/1df4287eb8daa34a07888300e0b18ba1c97a3432) with the worst-case example has been updated to include [@w0xlt's changes](https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3566408583), in order to work without stack size limit changes.\r\n(EDIT: **These benchmark results are based on a baseline that doesn't represent the worst-case and are thus not representative, as [noticed by w0xlt below](https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3592403663).**)\r\n| Branch                                                | Approach                                                 | Runtime |\r\n|-------------------------------------------------------|----------------------------------------------------------|------------------------------------------------|\r\n| https://github.com/theStack/secp256k1/commit/c16252ddccdeaefdc6c4ec4425ddda91ee813320 (Branch [baseline](https://github.com/theStack/secp256k1/tree/pr1765_worstcase_scan_baseline))                    | modified example to exercise worst-case scanning, no fix                                                 | 641.391838s                                    |\r\n| https://github.com/theStack/secp256k1/commit/ec2797715ac51ebe9d57e396d1cb46d4fd474eab (Branch [fix1_...](https://github.com/theStack/secp256k1/tree/pr1765_worstcase_scan_fix1_mark-found-outputs-calloc))  | mark found outputs in `calloc`ed array                   | 0.543969s                                      |\r\n| https://github.com/theStack/secp256k1/commit/135ca0a194f871f5be9fa78d47c4aad8e13a06e0 (Branch [fix2_...](https://github.com/theStack/secp256k1/tree/pr1765_worstcase_scan_fix2_remove-found-outputs))       | remove matched outputs by shifting remaining entries                                   | 0.514952s                                      |\r\n| https://github.com/theStack/secp256k1/commit/8360150954facf9887ebdc687dada781ddcfec9a (Branch [fix3_...](https://github.com/theStack/secp256k1/tree/pr1765_worstcase_scan_fix3_mark-found-outputs-NULLify))| mark found outputs by `NULL` in `tx_outputs` input array | 0.544740s                                      |\r\n\r\nThe run-times of the fixes vary slightly (the removal approach \"fix2\" being the fastest, confirming https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3567528551 above), but are all in the same ballpark. I don't think exact performance results matter much here, as the goal of the mitigation should be to IMHO roughly cut the run-time down from \"minutes\" to \"seconds\" (and remember, this is already for the absolute worst-case, one giant non-standard transaction filling out a whole block, and it can only slow down _one_ specific SP recipient). Thus, I decided to pick the the simplest approach that avoids dynamic memory allocation, i.e. fix number 3 using `NULL` as marker in `tx_outputs`.\r\n\r\nWith that tackled, I believe that all of the open questions and TODOs are addressed now (updated the PR description accordingly). The latest force-push also includes a rebase on master (to include the CI fix #1771).",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3577161237",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "referenced",
      "id": 21224718533,
      "node_id": "REFE_lADOAP4Jqs7VEWwNzwAAAATxF4DF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21224718533",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "e7f7083b530a55c83ce9089a7244d2d9d67ac8b2",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/e7f7083b530a55c83ce9089a7244d2d9d67ac8b2",
      "created_at": "2025-11-27T16:27:18Z"
    },
    {
      "event": "commented",
      "id": 3586704922,
      "node_id": "IC_kwDOAP4Jqs7VyMYa",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3586704922",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-27T16:30:54Z",
      "updated_at": "2025-11-27T16:30:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "I assume you want to rebase on master now that #1774 has been merged. ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3586704922",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21232877891,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAATxlAFD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21232877891",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "created_at": "2025-11-27T23:45:39Z"
    },
    {
      "event": "commented",
      "id": 3587553645,
      "node_id": "IC_kwDOAP4Jqs7V1blt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3587553645",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-28T00:12:55Z",
      "updated_at": "2025-11-28T00:12:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I assume you want to rebase on master now that #1774 has been merged.\r\n\r\nYes, done. Using the new `secp256k1_eckey_pubkey_serialize33` function, the [sending](https://github.com/bitcoin-core/secp256k1/pull/1765/commits/ffffd7ff98368b29759cd3d9933896fb9fa69b1f) and [receiving](https://github.com/bitcoin-core/secp256k1/pull/1765/commits/8caf19c3acdf06ed547e5980fb339990df470bed) commit diffs got a bit smaller (as outlined in https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3462461331), -13 LOC in total.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3587553645",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3591015668,
      "node_id": "IC_kwDOAP4Jqs7WCoz0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3591015668",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-29T05:39:00Z",
      "updated_at": "2025-11-29T05:39:00Z",
      "author_association": "NONE",
      "body": "Thanks for the summary, I've checked the results. I agree with `fix3_*` branch as the final solution, is elegant and trade-offs are clear.",
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3591015668",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3592403663,
      "node_id": "IC_kwDOAP4Jqs7WH7rP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3592403663",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-30T09:47:14Z",
      "updated_at": "2025-11-30T09:47:14Z",
      "author_association": "NONE",
      "body": "Hi @theStack . That's not actually the worst case. The worst case is when the attacker shuffles the outputs randomly (or in any adversarial order). I modified your benchmark to randomly shuffle outputs, and scanning takes several minutes to hours with the current optimization proposal.\r\n\r\nhttps://github.com/w0xlt/secp256k1/commit/435cb96c2dc3c9d4a0fa967fb84432d8dd77783d\r\n\r\nThe issue is that the scanning function receives a label lookup callback, which makes it harder to build a sorted index upfront. Instead, for each output tweak index k, it linearly scans all transaction outputs  resulting in O(n) complexity. An attacker creating ~23,000 unordered outputs can make scanning take hours.\r\n\r\nIf we slightly change the API to replace the label lookup callback with a label entry set, we can sort once and search fast:\r\n1. Build a sorted index of outputs by serialized x-only pubkey  O(n log n) upfront\r\n2. Binary search for each candidate  O(log n) per lookup\r\n\r\nThat way, scanning 23,255 adversarially-ordered outputs drops from hours to ~0.3s. The optimization is purely receiver-side, requires no protocol changes, and works regardless of output ordering. This reduces architectural flexibility, though.\r\n\r\nBefore: for each k, scan all n outputs   O(k  n)  O(n)\r\nAfter:  sort outputs, binary search      O(n log n + k log n)\r\n\r\nThe following commit implements this proposal:\r\nhttps://github.com/w0xlt/secp256k1/commit/2305d7361ad4a2ead9e335ea76ea4fc047e275cf\r\n\r\nYou can verify by running `./build/bin/silentpayments_example` (ordered) and `./build/bin/silentpayments_shuffled_example` (shuffled).",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3592403663",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21255618065,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATy7v4R",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21255618065",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-30T09:47:15Z"
    },
    {
      "event": "subscribed",
      "id": 21255618072,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATy7v4Y",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21255618072",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-30T09:47:15Z"
    },
    {
      "event": "commented",
      "id": 3594230411,
      "node_id": "IC_kwDOAP4Jqs7WO5qL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3594230411",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T02:12:07Z",
      "updated_at": "2025-12-01T02:12:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Hi @theStack . That's not actually the worst case. The worst case is when the attacker shuffles the outputs randomly (or in any adversarial order). \r\n\r\n@w0xlt: Good catch, I indeed missed involving the output order for the worst-case scenario, so https://github.com/theStack/secp256k1/commit/c16252ddccdeaefdc6c4ec4425ddda91ee813320 is not a useful target (in hindsight, the benchmark results look too good to be true, and my previous words of \"we can't rely on the attacker using a specific implementation\" strike back very hard). Thanks for the updated benchmark and the new worst-case fix proposal!\r\n\r\n> I modified your benchmark to randomly shuffle outputs, and scanning takes several minutes to hours with the current optimization proposal.\r\n\r\nAre you sure it could take up \"to hours\"? That would be significantly worse than the previous baseline commit (~10 minutes on my machine), which seems implausible to me. In the unoptimized scanning implementation, the run-time should be very much independent on the order of outputs, as the total number of inner loop iterations is constant ($1+2+3...+N = (N*(N+1))/2 = 270409140$ for our worst-case scenario of $N = 23255$), and it'd be very surprising if any of the three proposed optimizations perform _worse_ than the baseline for shuffled outputs.\r\n\r\nI only did two runs so far with your shuffle-patch added, and got runtimes of ~10 minutes (unoptimized) and ~5 minutes (NULL-ify patch, \"fix3\"). Will do some more thorough benchmarks tomorrow, including your proposed solution.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3594230411",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21263573644,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATzaGKM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21263573644",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T02:12:09Z"
    },
    {
      "event": "subscribed",
      "id": 21263573661,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATzaGKd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21263573661",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T02:12:09Z"
    },
    {
      "event": "mentioned",
      "id": 21263573675,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATzaGKr",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21263573675",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T02:12:09Z"
    },
    {
      "event": "subscribed",
      "id": 21263573682,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATzaGKy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21263573682",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T02:12:09Z"
    },
    {
      "event": "commented",
      "id": 3594425270,
      "node_id": "IC_kwDOAP4Jqs7WPpO2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3594425270",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T03:57:25Z",
      "updated_at": "2025-12-01T03:57:25Z",
      "author_association": "NONE",
      "body": "@theStack Thanks for looking into this.\r\nSorry if I wasnt clear earlier. The shuffled benchmark does perform better in the optimized version than in the baseline, but it loses the sub-second scan times.\r\nThe new proposed approach (assuming it works as expected) should keep those sub-second times even on the shuffled benchmark.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3594425270",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21264784903,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATzet4H",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21264784903",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T03:57:26Z"
    },
    {
      "event": "subscribed",
      "id": 21264784931,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATzet4j",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21264784931",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T03:57:26Z"
    },
    {
      "event": "commented",
      "id": 3598367471,
      "node_id": "IC_kwDOAP4Jqs7Werrv",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3598367471",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T18:55:36Z",
      "updated_at": "2025-12-02T00:54:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "@w0xlt: I've looked at your proposed scanning implementation https://github.com/w0xlt/secp256k1/commit/2305d7361ad4a2ead9e335ea76ea4fc047e275cf and can confirm that it fixes the worst-case scanning attack, as the run-time of the modified example with shuffled outputs is reduced to <1s. What makes this different approach potentially interesting is that it could also to speed up the common case (i.e. no matches), as the number of point additions needed for labels scanning seems to be significantly smaller for the small-scale user (where N_LABELS < 2 * N_OUTPUTS for the average transaction; if N_LABELS=1 and we assume the average transaction to scan for has N_OUTPUTS=2, your approach is 4x faster w.r.t. needed point additions). To verify that I understood it correctly and make the idea digestible to other interested reviewers, I've tried to summarize the current PR's scanning approach (as proposed in BIP-352) vs. your approach on the following gist, written in a somewhat hand-wavy way, I hope the pseudo-code is understandable: https://gist.github.com/theStack/25c77747838610931e8bbeb9d76faf78. Please let me know if I got that right, I _think_ the approach leads to the same result, but I'm still trying to wrap my head around it.\r\n// EDIT: I've been told by @setavenger that this approach is also used by [Frigate Electrum Server](https://github.com/sparrowwallet/frigate) and the [BlindBit wallet](https://github.com/setavenger/blindbit-desktop).\r\n\r\nOn the other hand, I'm still uncertain on whether adding the additional code complexity and the involvement of dynamic memory allocation at all in a secp256k1 module is worth all this, considering that we are talking about an attack that costs an adversary money (at least the fees for the whole block space) and can only slow down one specific SP recipient. It seems a very unusual kind of attack. Changing the scanning API at this point seems also questionable, as I think it went already through several iterations and refinements over the years, and I think the \"pass labels directly\" approach is slower for users with a higher number of labels involved. Also, the mental load for reviewers is significantly higher if the approach doesn't follow the algorithm as specified in BIP-352, as they have to convince themselves that the result is equivalent.\r\n\r\nI'm hence debating on whether one solution could be to keep the PR simply as-is and accept the fact that an adversary can slow down a single entity for a few minutes (for non-standard transactions), to a few seconds (for standard transactions, i.e. tx size <= 100kvB). I don't have a good final answer to this question myself, but want to discuss is at least and come to a decision that both maintainers and users are on board with before taking any further action.\r\n\r\nMy (in retrospect somewhat naive) hope was that there could be a simple few-lines fix for reducing the worst-case scanning attack down to seconds without the need of dynamic memory allocation, but such an easy fix doesn't seem to be in sight.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3598367471",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21285055146,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT0sCqq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21285055146",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T18:55:37Z"
    },
    {
      "event": "subscribed",
      "id": 21285055200,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT0sCrg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21285055200",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T18:55:37Z"
    },
    {
      "event": "mentioned",
      "id": 21291762483,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT1FoMz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21291762483",
      "actor": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T00:54:55Z"
    },
    {
      "event": "subscribed",
      "id": 21291762492,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT1FoM8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21291762492",
      "actor": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T00:54:55Z"
    },
    {
      "event": "commented",
      "id": 3600182512,
      "node_id": "IC_kwDOAP4Jqs7Wlmzw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3600182512",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T04:51:53Z",
      "updated_at": "2025-12-02T04:51:53Z",
      "author_association": "NONE",
      "body": "Hi @theStack thanks a lot for taking the time to review the proposal and write up the comparison.\r\n\r\nMy view is that we should aim for the most efficient and resilient solution, even if the attack scenario is somewhat unusual. The spec can be updated as needed to reflect improvements. Independently of adversarial cases, reducing scanning time from several minutes to under a second is a major win for user experience.\r\n\r\nRegarding complexity: although this approach adds some moving parts, the underlying idea (e.g., using binary search) is conceptually straightforward, so I dont think it should pose a significant burden by itself.\r\n\r\nAs for the dynamic memory concern, the allocation doesnt necessarily have to happen inside the secp256k1 module. We could let the caller provide the required workspace. For example, could we leverage `secp256k1_scratch_space` here?",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3600182512",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21295040889,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT1SIl5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21295040889",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T04:51:54Z"
    },
    {
      "event": "subscribed",
      "id": 21295040919,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT1SImX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21295040919",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T04:51:54Z"
    },
    {
      "event": "commented",
      "id": 3603093854,
      "node_id": "IC_kwDOAP4Jqs7Wwtle",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3603093854",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T17:03:54Z",
      "updated_at": "2025-12-02T17:03:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "@w0xlt: After tinkering a bit with your proposed implementation https://github.com/w0xlt/secp256k1/commit/2305d7361ad4a2ead9e335ea76ea4fc047e275cf, I found that it could be significantly simplified, and it turned out we don't even need dynamic memory allocation:\r\n* instead of building an explicit index, we can simply sort the user-supplied `tx_outputs` array of x-only pubkeys in place and perform binary search directly on that (using the existing `secp256k1_pubkey_xonly_pubkey_cmp`)\r\n* the preparation of the label set group elements array is not needed as well; `_pubkey_load` is a very cheap operation, so it doesn't hurt to call it repeatedly in each k loop iteration (remember that the common case is not having a match, i.e. k doesn't exceed 0 for most scanned transactions)\r\n\r\nDoing this in https://github.com/theStack/secp256k1/commit/1a40e14d31089960d4113b49eeffd287b81cd2a1 still keeps the worst-case scanning benchmark time down at ~450ms on my machine.\r\nAdmittedly, there is a tiny bit of run-time overhead introduced with the simplification (repeated x-only pubkey serialization for the common case), but I don't think that matters much, considering that the involved elliptic curve operations are likely orders of magnitude more expensive than that. With these new insights, I can retract my doubts about code complexity and dynamic memory allocation of your proposed approach, and it's good to have two potential scanning implementations. :+1: \r\n\r\nIt should be pointed out that the \"label set\" approach doesn't come for free though: one major drawback is that for users with a larger label set, the typical scanning scenario (assuming most txs don't have more than just a few outputs) can be slower at some point, as the number of point additions is higher than with the \"BIP\" approach. So if we follow your approach, it's better for small-case users and to eliminate the worst-case scanning attack, but users with a lot of labels are likely not happy with it and would very much prefer the \"BIP\" scanning approach. Not really sure how to deal with that and what to prioritize. (Provide two scanning implementations and let the user pick? :grimacing: )\r\n\r\nI'll anyways try to come up with another \"modified example\" benchmark to better verify the claims about typical scanning scenarios, depending on the number of labels involved and transaction output count. We have spent a good time on the worst-scanning scenario now, but it would be wrong to solely optimize for that and get the typical scanning scenario out of sight.\r\n\r\n> Independently of adversarial cases, reducing scanning time from several minutes to under a second is a major win for user experience.\r\n\r\nI don't agree with that statement, as I can't think of a legit _non_-adversarial case that would lead to scanning times of several minutes, in particular as this would at the minimum involve creating a large non-standard transaction. When considering user experience, by far the most relevant case I'd consider is the \"no match\" scenario (one k loop iteration), as it is the most frequent one, followed by the \"single match\" (two k loop iterations) scenario. Everything above that should be already quite rare in practice.\r\n\r\n> As for the dynamic memory concern, the allocation doesnt necessarily have to happen inside the secp256k1 module. We could let the caller provide the required workspace. For example, could we leverage secp256k1_scratch_space here?\r\n\r\nGood question. Right now, the scratch space API is not even exposed to the user. Btw I don't think dynamic memory allocation is a strict no-go in general, it just seems that there are still some open questions around that area, and waiting until they are all tackled would probably delay the PR for an unforeseeable time. It seems that as of now we can easily avoid dynamic memory allocation anyways though, in both of the proposed implementations.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3603093854",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21311825129,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT2SKTp",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21311825129",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T17:03:56Z"
    },
    {
      "event": "subscribed",
      "id": 21311825171,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT2SKUT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21311825171",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T17:03:56Z"
    },
    {
      "event": "commented",
      "id": 3604154693,
      "node_id": "IC_kwDOAP4Jqs7W0wlF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3604154693",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T22:04:41Z",
      "updated_at": "2025-12-02T22:04:41Z",
      "author_association": "NONE",
      "body": "> Not really sure how to deal with that and what to prioritize. (Provide two scanning implementations and let the user pick?  )\r\n\r\nSome (very) rough ideas on the trade-off\r\n\r\nIf we can define a general rule that determines when its better to use the label-set scan versus the BIP-based scan, we could do something like:\r\n\r\n```c\r\n/* Choose algorithm based on this transaction's characteristics */\r\nif (n_labels > 2 * n_tx_outputs) {\r\n    /* BIP approach: iterate over outputs, add, and look up in label callback */\r\n    use_bip_scan();\r\n} else {\r\n    /* Label-set approach: iterate over labels, add, and search in output index */\r\n    use_labelset_scan();\r\n}\r\n```\r\n\r\nThe heuristic above is just a rough estimate. The BIP version performs roughly ~2N point additions, where *N* is the number of outputs, while the label-set version performs about ~L additions, where *L* is the number of configured labels.\r\n\r\nBut to build a reliable decision rule, wed need more benchmark data across a range of (N, L) combinations.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3604154693",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3608407831,
      "node_id": "IC_kwDOAP4Jqs7XE-8X",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3608407831",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-03T19:11:07Z",
      "updated_at": "2025-12-03T19:11:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "Here is a first attempt at creating a scanning benchmark for the common case scenario (i.e. no matches and hence only one k iteration), comparing the \"BIP\" and \"Label-set\" approaches over a combination of L (number of labels to scan for) and N (number of tx outputs): https://github.com/theStack/secp256k1/commit/fef63fd40f2fad9e26eaf7145d9a38eaceb1e8ef. Running this modified example outputs the following on my arm64 machine:\r\n\r\n```\r\n$ ./build/bin/silentpayments_example\r\nSilent Payments (BIP-352) scanning benchmarks\r\n[common case scenario, i.e. only one k iteration without match]\r\n\r\nLegend: L... number of labels, N... number of transaction outputs\r\n\r\n===== BIP approach (calculate label candidates for each output, look them up in labels cache) =====\r\nL= 1: [N=2:  69 us] [N=5:  82 us] [N=10:  89 us] [N=20: 121 us] [N=50: 197 us] [N=100: 343 us] [N=200: 632 us]\r\nL= 2: [N=2:  61 us] [N=5:  80 us] [N=10:  78 us] [N=20: 101 us] [N=50: 177 us] [N=100: 314 us] [N=200: 566 us]\r\nL= 3: [N=2:  54 us] [N=5:  58 us] [N=10:  76 us] [N=20:  95 us] [N=50: 166 us] [N=100: 288 us] [N=200: 535 us]\r\nL= 5: [N=2:  51 us] [N=5:  55 us] [N=10:  67 us] [N=20: 160 us] [N=50: 159 us] [N=100: 271 us] [N=200: 496 us]\r\nL=10: [N=2:  49 us] [N=5:  55 us] [N=10:  66 us] [N=20:  89 us] [N=50: 158 us] [N=100: 276 us] [N=200: 494 us]\r\nL=20: [N=2:  54 us] [N=5:  55 us] [N=10:  68 us] [N=20:  90 us] [N=50: 159 us] [N=100: 271 us] [N=200: 505 us]\r\nL=50: [N=2:  49 us] [N=5:  55 us] [N=10:  71 us] [N=20:  88 us] [N=50: 160 us] [N=100: 274 us] [N=200: 504 us]\r\n\r\n===== Label-set approach (calculate output candidate for each label, look it up in outputs) =====\r\nL= 1: [N=2:  51 us] [N=5:  47 us] [N=10:  48 us] [N=20:  51 us] [N=50:  59 us] [N=100:  77 us] [N=200: 116 us]\r\nL= 2: [N=2:  49 us] [N=5:  57 us] [N=10:  50 us] [N=20:  53 us] [N=50:  65 us] [N=100:  81 us] [N=200: 120 us]\r\nL= 3: [N=2:  49 us] [N=5:  51 us] [N=10:  50 us] [N=20:  56 us] [N=50:  63 us] [N=100:  82 us] [N=200: 118 us]\r\nL= 5: [N=2:  58 us] [N=5:  52 us] [N=10:  55 us] [N=20:  56 us] [N=50:  68 us] [N=100:  81 us] [N=200: 119 us]\r\nL=10: [N=2:  63 us] [N=5:  59 us] [N=10:  61 us] [N=20:  62 us] [N=50:  71 us] [N=100:  87 us] [N=200: 126 us]\r\nL=20: [N=2:  70 us] [N=5:  71 us] [N=10:  74 us] [N=20:  90 us] [N=50:  83 us] [N=100: 101 us] [N=200: 139 us]\r\nL=50: [N=2: 104 us] [N=5: 107 us] [N=10: 111 us] [N=20: 113 us] [N=50: 122 us] [N=100: 141 us] [N=200: 192 us]\r\n```\r\nThese results should be taken with a large grain of salt, as the numbers fluctuate a lot (visible for the BIP approach, where all lines should have about the same results, as the performance is in theory independent of L; also, for the first two L the results are surprisingly worse, maybe some unintended caching effects for later runs?) but one can at least see the general previously suspected trend that the BIP approach gets worse with increasing N, while the label-set approach gets worse with increasing L. As a very rough first statement, I'd say assuming that users don't use more than a handful (let's say up to 10) labels and transactions with more outputs get more common in the future, using the label-set approach seems superior, and the only reason to keep the BIP approach is to target users that want to scan for a large number of (let's say dozens) of labels.\r\n\r\nComments or ideas on how to best reason about this would be much appreciated (also a rough review of the modified benchmark example, it could also be that there are bugs). Maybe someone has an idea how to connect this with some actual historic on-chain stats? The list of L and N values to benchmark for can be adapted by changing the two arrays `n_labels_bench` and `n_outputs_bench` at the top of the example file.\r\n\r\n> If we can define a general rule that determines when its better to use the label-set scan versus the BIP-based scan, we could do something like:\r\n\r\nMakes sense yeah, thought about something similar. What makes this a bit inconvenient (aside from additional review and maintenance burden, obviously) is that users would have to pass both the labels set and implement and pass in a call-back functions, which seems to result in a bloated API. Maybe it's better to focus on one approach and ship another scan function for \"giant label set\" power users later? I could be wrong, but I don't think using more than three or four labels would be a very common use-case.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3608407831",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3610848914,
      "node_id": "IC_kwDOAP4Jqs7XOS6S",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3610848914",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T08:27:18Z",
      "updated_at": "2025-12-04T08:27:18Z",
      "author_association": "NONE",
      "body": "@theStack  Thanks very much for this benchmark. It is very insightful.\r\n\r\nFrom my understanding, your benchmark confirms that the label-set approach performs better overall and scales more smoothly with the transaction size `N` (number of outputs). For small `N` they are comparable, but as `N` grows the label-set approach becomes significantly faster than the BIP approach.\r\n\r\nI also evaluated Montgomery batch inversion via `secp256k1_ge_set_all_gej_var` in the label-set scanning path on top of your commit. This seems to mainly help when there are many labels (large `L`). For `L = 50` the label-set approach becomes noticeably faster still, so it dominates the BIP-style scanning for almost all `(L, N)` combinations in this benchmark. All runs are using the same common case scenario as in your example (one `k` iteration, no match).\r\n\r\nhttps://github.com/w0xlt/secp256k1/commit/1e8d196e456de957e497275205e3e77df2b4f74b\r\n\r\nBelow is the benchmark commit as measured on my machine (no batch inversion):\r\n```\r\n===== BIP approach (calculate label candidates for each output, look them up in labels cache) =====\r\nL= 1: [N=2: 351 us] [N=5: 200 us] [N=10: 231 us] [N=20: 261 us] [N=50: 289 us] [N=100: 451 us] [N=200: 745 us]\r\nL= 2: [N=2:  81 us] [N=5: 109 us] [N=10:  82 us] [N=20: 153 us] [N=50: 218 us] [N=100: 379 us] [N=200: 631 us]\r\nL= 3: [N=2:  55 us] [N=5:  59 us] [N=10:  75 us] [N=20:  99 us] [N=50: 185 us] [N=100: 299 us] [N=200: 586 us]\r\nL= 5: [N=2:  52 us] [N=5:  58 us] [N=10:  70 us] [N=20:  90 us] [N=50: 171 us] [N=100: 302 us] [N=200: 514 us]\r\nL=10: [N=2:  48 us] [N=5:  53 us] [N=10:  62 us] [N=20:  86 us] [N=50: 153 us] [N=100: 269 us] [N=200: 489 us]\r\nL=20: [N=2:  44 us] [N=5:  52 us] [N=10:  64 us] [N=20:  86 us] [N=50: 147 us] [N=100: 267 us] [N=200: 481 us]\r\nL=50: [N=2:  44 us] [N=5:  47 us] [N=10:  61 us] [N=20:  91 us] [N=50: 153 us] [N=100: 257 us] [N=200: 469 us]\r\n\r\n===== Label-set approach (calculate output candidate for each label, look it up in outputs) =====\r\nL= 1: [N=2:  39 us] [N=5:  38 us] [N=10:  37 us] [N=20:  38 us] [N=50:  41 us] [N=100:  48 us] [N=200:  64 us]\r\nL= 2: [N=2:  37 us] [N=5:  36 us] [N=10:  36 us] [N=20:  37 us] [N=50:  41 us] [N=100:  46 us] [N=200:  65 us]\r\nL= 3: [N=2:  40 us] [N=5:  36 us] [N=10:  37 us] [N=20:  39 us] [N=50:  43 us] [N=100:  49 us] [N=200:  75 us]\r\nL= 5: [N=2:  39 us] [N=5:  39 us] [N=10:  41 us] [N=20:  42 us] [N=50:  47 us] [N=100:  51 us] [N=200:  84 us]\r\nL=10: [N=2:  47 us] [N=5:  47 us] [N=10:  45 us] [N=20:  46 us] [N=50:  49 us] [N=100:  55 us] [N=200:  71 us]\r\nL=20: [N=2:  58 us] [N=5:  56 us] [N=10:  58 us] [N=20:  55 us] [N=50:  59 us] [N=100:  66 us] [N=200:  84 us]\r\nL=50: [N=2:  88 us] [N=5:  85 us] [N=10:  93 us] [N=20:  88 us] [N=50:  94 us] [N=100: 100 us] [N=200: 120 us]\r\n```\r\n\r\nThe numbers after applying batch inversion:\r\n```\r\n===== Label-set approach (calculate output candidate for each label, look it up in outputs) =====\r\nL= 1: [N=2:  38 us] [N=5:  37 us] [N=10:  37 us] [N=20:  37 us] [N=50:  41 us] [N=100:  48 us] [N=200:  61 us]\r\nL= 2: [N=2:  35 us] [N=5:  38 us] [N=10:  37 us] [N=20:  44 us] [N=50:  41 us] [N=100:  47 us] [N=200:  62 us]\r\nL= 3: [N=2:  35 us] [N=5:  38 us] [N=10:  39 us] [N=20:  38 us] [N=50:  46 us] [N=100:  46 us] [N=200:  66 us]\r\nL= 5: [N=2:  49 us] [N=5:  36 us] [N=10:  36 us] [N=20:  40 us] [N=50:  42 us] [N=100:  49 us] [N=200:  63 us]\r\nL=10: [N=2:  37 us] [N=5:  37 us] [N=10:  37 us] [N=20:  37 us] [N=50:  41 us] [N=100:  49 us] [N=200:  65 us]\r\nL=20: [N=2:  46 us] [N=5:  47 us] [N=10:  42 us] [N=20:  42 us] [N=50:  48 us] [N=100:  56 us] [N=200:  73 us]\r\nL=50: [N=2:  54 us] [N=5:  46 us] [N=10:  46 us] [N=20:  50 us] [N=50:  52 us] [N=100:  60 us] [N=200:  82 us]\r\n```\r\n\r\nThe only code change here is using batch inversion in the label-set path.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3610848914",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21352573348,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT4tmmk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21352573348",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T08:27:19Z"
    },
    {
      "event": "subscribed",
      "id": 21352573383,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT4tmnH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21352573383",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T08:27:20Z"
    },
    {
      "event": "commented",
      "id": 3614019199,
      "node_id": "IC_kwDOAP4Jqs7XaY5_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3614019199",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T19:33:59Z",
      "updated_at": "2025-12-04T19:33:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Here is a first attempt at creating a scanning benchmark for the common case scenario (i.e. no matches and hence only one k iteration), comparing the \"BIP\" and \"Label-set\" approaches over a combination of L (number of labels to scan for) and N (number of tx outputs): https://github.com/theStack/secp256k1/commit/fef63fd40f2fad9e26eaf7145d9a38eaceb1e8ef\r\n\r\nThis is now available as an _actual_ benchmark using the framework (i.e. implemented in the module's `bench_impl.h`), leading to more stable results, especially for the lower-N cases (N<=10), which I'd consider to hit most frequently: https://github.com/theStack/secp256k1/commit/8eced6432bf8a6fd4dc968f846ca8373043d092b, see https://gist.github.com/theStack/25c77747838610931e8bbeb9d76faf78?permalink_comment_id=5892266#gistcomment-5892266 for the results on my machine. Both approaches are now also benchmarked for no-labels scanning (i.e. L=0) and for the BIP approach, only L=1 is tested, as any higher values don't have an influence on the run-time, if we assume that the label cache lookup cost is negligible.\r\n\r\n\r\n@w0xlt:\r\n> From my understanding, your benchmark confirms that the label-set approach performs better overall and scales more smoothly with the transaction size N (number of outputs). For small N they are comparable, but as N grows the label-set approach becomes significantly faster than the BIP approach.\r\n\r\nI agree. It seems to me that, unless there is a really strong reasons to support use-cases with dozens of labels, we should consider switching from the BIP to the Label-set scanning approach. I'm not sure though if larger N values appear frequent enough in blocks nowadays to have a significant influence over the overall scanning time (I'd roughly guess that the vast majority of SP eligible txs wouldn't exceed 10 outputs, though that should be verified), but that could change in the future.\r\n\r\n> I also evaluated Montgomery batch inversion via secp256k1_ge_set_all_gej_var in the label-set scanning path on top of your commit. This seems to mainly help when there are many labels (large L). For L = 50 the label-set approach becomes noticeably faster still, so it dominates the BIP-style scanning for almost all (L, N) combinations in this benchmark. All runs are using the same common case scenario as in your example (one k iteration, no match).\r\n\r\nThat's great, didn't review this code in detail yet but it seems to be simple enough to be considered on top, if we go with the label set scanning approach; the benchmarks also look very promising, will integrate them and run on my machine as well tomorrow.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3614019199",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21368434137,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT5qG3Z",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21368434137",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T19:34:01Z"
    },
    {
      "event": "subscribed",
      "id": 21368434174,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT5qG3-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21368434174",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T19:34:01Z"
    },
    {
      "event": "reviewed",
      "id": 3542178806,
      "node_id": "PRR_kwDOAP4Jqs7TIVv2",
      "url": null,
      "actor": null,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-05T19:33:42Z",
      "author_association": "MEMBER",
      "body": "A bit late but joining this party full-time now. I just finished the sending part. Will keep reviewing. Cool stuff.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3542178806",
      "submitted_at": "2025-12-05T19:33:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "reviewed",
      "id": 3548663278,
      "node_id": "PRR_kwDOAP4Jqs7ThE3u",
      "url": null,
      "actor": null,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-07T01:49:55Z",
      "author_association": "MEMBER",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3548663278",
      "submitted_at": "2025-12-07T01:49:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "reviewed",
      "id": 3553138859,
      "node_id": "PRR_kwDOAP4Jqs7TyJir",
      "url": null,
      "actor": null,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-08T20:28:32Z",
      "author_association": "MEMBER",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3553138859",
      "submitted_at": "2025-12-08T20:28:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "referenced",
      "id": 21472685587,
      "node_id": "REFE_lADOAP4Jqs7VEWwNzwAAAAT_3y4T",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21472685587",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "be5e4f02fd2c66bfacaaaa767183bbe3c89da169",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/be5e4f02fd2c66bfacaaaa767183bbe3c89da169",
      "created_at": "2025-12-10T08:27:59Z"
    },
    {
      "event": "commented",
      "id": 3640574740,
      "node_id": "IC_kwDOAP4Jqs7Y_sMU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3640574740",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-11T07:15:44Z",
      "updated_at": "2025-12-11T07:15:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thinking a bit more about the \"LabelSet\" scanning approach and particularly on how to avoid the repeated x-only pubkey serialization in the compare and binary search finding functions (as pointed out in https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3603093854), I've come to realize that the tx outputs could simply be provided as already serialized x-only pubkeys (raw 32-bytes, directly extracted from a taproot output's `scriptPubKey`), as we don't do any elliptic curve operations with them (in contrast to the \"BIP\" approach). That interface change gets rids of repeated internal serialization and, maybe even more important for overall performance, avoids the need of preparatory `secp256k1_xonly_pubkey_parse` calls from the user for each tx output, costing a field element square root calculation each (in order to recover the y coordinate, via $y = \\sqrt(x^3 + 7)$ ). I've updated the benchmark with that method, adding the xonly-pubkey parsing calls prior to scanning for the BIP benchmark, in order to have a fair comparison: https://github.com/theStack/secp256k1/commit/ab201ed32b5b326d7a065ac0bcaab52b09693ecd (this still doesn't include the batch inversion patch from @w0xlt yet).\r\n\r\nWhile it's nice to have a faster implementation for small-scale users, I'm still unsure how to proceed now for this PR. No matter how much we optimize the \"LabelSet\" approach, it will always be at some point worse for use-cases with larger amount of labels. I've e.g. been made aware that for use-cases like \"proof of payments\", having tens of thousands of labels doesn't even seem unlikely. In an ideal world we would probably implement both approaches and choose whatever is faster, either automatically with a single API function (as prototyped in https://gist.github.com/theStack/25c77747838610931e8bbeb9d76faf78?permalink_comment_id=5897811#gistcomment-5897811) or by providing two different API functions, with good documentation that recommends when to use which one, depending on the L and N parameters.\r\n\r\nWe could either:\r\n1) only release the \"BIP\" scanning approach for now (that's the current state of this PR), with the drawback that it doesn't provide the best possible performance for small-scale users (only a handful of labels) yet\r\n2) only release the \"LabelSet\" scanning approach, with the drawback that it's practically unusable for power-users with a large amount of labels, as each additional label would degrade scanning performance\r\n3) release both already (best for the user for maximum performance, but increases complexity)\r\n\r\nI'd advocate for options 1 or 3 (being now aware that having lots of labels could be much more common than I thought, option 2 doesn't seem to be a good idea, as it would make the module practically unusable for a certain user group), with a tendency to option 1 to keep it simple.\r\n\r\nTo take a step back, the original goal of looking deeper into alternative scanning approaches was fixing the \"worst-case scanning attack\", caused by a single 1vMB transaction full of outputs that all go to a single recipient group (i.e. all having the same scan pubkey), leading to a scanning time of several minutes. The \"LabelSet\" scanning approaches fixes this attack for users with small amounts of labels nicely, but for larger amounts of labels the \"BIP\" scanning approach would still be used, which I think suffers from this problem inherently due to nested looping over the transaction outputs.\r\n\r\nCircling back to what I stated earlier:\r\n> I'm hence debating on whether one solution could be to keep the PR simply as-is and accept the fact that an adversary can slow down a single entity for a few minutes (for non-standard transactions), to a few seconds (for standard transactions, i.e. tx size <= 100kvB).",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3640574740",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21496842473,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAUBT8jp",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21496842473",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-11T07:15:46Z"
    },
    {
      "event": "subscribed",
      "id": 21496842494,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAUBT8j-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21496842494",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-11T07:15:46Z"
    },
    {
      "event": "reviewed",
      "id": 3566774354,
      "node_id": "PRR_kwDOAP4Jqs7UmKhS",
      "url": null,
      "actor": null,
      "commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-11T10:32:53Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3566774354",
      "submitted_at": "2025-12-11T10:32:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "commented",
      "id": 3643845356,
      "node_id": "IC_kwDOAP4Jqs7ZMKrs",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3643845356",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-11T21:25:41Z",
      "updated_at": "2025-12-11T21:25:41Z",
      "author_association": "NONE",
      "body": "As I understand it, although the LabelSet approach was originally proposed to avoid worst-case performance issues, an interesting side effect is that it gives the user more control and predictability over scanning costs: runtime depends more on the number of labels (which the wallet controls) and less on the number of P2TR outputs in the block (which the wallet cannot control).\r\n\r\nThe LabelSet approach also scales more smoothly with respect to the number of labels than the BIP approach scales with respect to the number of outputs, as shown in the benchmarks:\r\n\r\n```\r\nBenchmark                               ,    Min(us)    ,    Avg(us)    ,    Max(us)\r\nsp_full_scan_BIP-algo_L=50_N=50         ,   138.0       ,   139.0       ,   139.0\r\nsp_full_scan_LabelSet-algo_L=50_N=50    ,    54.2       ,    54.3       ,    54.6\r\n```\r\n\r\nThe hybrid approach gets the best of both worlds and matches the faster of the two algorithms.\r\n\r\nThat said, I agree that the BIP is the easiest and most thoroughly reviewed solution (and the safest to adopt). \r\nThe LabelSet approach appears to offer the best default performance per the benchmark but introduces new assumptions and requires additional review.\r\nThe hybrid approach is likely the best engineering solution, though it comes at the cost of greater complexity and review effort.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3643845356",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21597290536,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAUHTIAo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21597290536",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "created_at": "2025-12-16T16:37:50Z"
    },
    {
      "event": "commented",
      "id": 3661532671,
      "node_id": "IC_kwDOAP4Jqs7aPo3_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3661532671",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-16T17:02:57Z",
      "updated_at": "2025-12-16T17:02:57Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for all the review comments so far, very helpful!\r\n\r\nForce-pushed with the following changes:\r\n* added non-NULL `ARG_CHECK`s for \"array of pointer\" parameters, including API tests (as done in #1779 for existing functions)\r\n* fixed two \"array of pointer\" initialization bugs that were uncovered with these checks, one in the receiving test vectors code, one in the example (see https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2615901474 for details)\r\n* switched the data type for parameters regarding \"number of recipients\" (`index` and `n_recipients`) from `size_t` to `uint32_t` and removed the now obsolete \"k exceeds UINT32_MAX\" error handling cases accordingly (see also the suggested BIP change: https://github.com/bitcoin/bips/pull/2055)\r\n* introduced a new `secp256k1_silentpayments_label` type, including (de)serialization API functions (as suggested in https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2610534331)\r\n* deterministic sorting of recipients: modified our compare function to use the index as tie-breaker (stabilizes the unstable heap sort result): for the end user, this doesn't matter much, but having a well-defined determinstic order helps reasoning and simplifies our testing code, and removes some potentially confusing \"don't rely on the order\" comments (kudos to @w0xlt who proposed this in a different context a longer time ago for tackling the \"worst-case scanning attack\", see https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3499455867)\r\n* reworked comment in `_create_shared_secret` w.r.t. the point multiplication result not being infinity (referring to both the sender and receiver call-sites), see https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2610056690\r\n* updated the benchmark commit to remove \"silentpayments_output_scan\" from help texts (only relevant for light-clients), adapted the error messages to master (see #1778)\r\n* various smaller fixes in the API docs and the impl. comments about untestable code branches (e.g. s/greater than or equal to the curve order/zero or greater than or equal to the curve order)\r\n\r\nRegarding https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595796731, the `test_recipient_sort` function has not been modified yet (other than removing the now obsolete \"unstable heapsort\" comment, so at least that potentially confusing part is gone), I'm still thinking and discussing with @furszy on how to best generalize this. A first draft on how that could look like, based on the linked suggestion above, is here: https://gist.github.com/theStack/c0fd8fa9a5c474f8baf4c57169758d41",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3661532671",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21597805813,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAUHVFz1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21597805813",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-16T17:02:58Z"
    },
    {
      "event": "subscribed",
      "id": 21597805845,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAUHVF0V",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21597805845",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-16T17:02:58Z"
    },
    {
      "event": "mentioned",
      "id": 21597805869,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAUHVF0t",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21597805869",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-16T17:02:58Z"
    },
    {
      "event": "subscribed",
      "id": 21597805888,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAUHVF1A",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21597805888",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-16T17:02:59Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21599472640,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAUHbcwA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21599472640",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "26e1e88f326bd73f1617481d2cf87b2cd2b19ba6",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/26e1e88f326bd73f1617481d2cf87b2cd2b19ba6",
      "created_at": "2025-12-16T18:30:44Z"
    },
    {
      "event": "commented",
      "id": 3661892706,
      "node_id": "IC_kwDOAP4Jqs7aRAxi",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3661892706",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-16T18:38:23Z",
      "updated_at": "2025-12-16T18:38:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "Force-pushed another time (sorry for the noise!) to rename the label creation and (de)serialization API functions to be more consistent:\r\n* `_silentpayments_recipient_create_label` -> `_silentpayments_recipient_label_create`\r\n* `_silentpayments_label_serialize` -> `_silentpayments_recipient_label_serialize`\r\n* `_silentpayments_label_parse` -> `_silentpayments_recipient_label_parse`\r\n\r\nAlso updated the API summary in the PR description accordingly.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3661892706",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "reviewed",
      "id": 3586639072,
      "node_id": "PRR_kwDOAP4Jqs7Vx8Tg",
      "url": null,
      "actor": null,
      "commit_id": "26e1e88f326bd73f1617481d2cf87b2cd2b19ba6",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-17T09:04:47Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3586639072",
      "submitted_at": "2025-12-17T09:04:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21625656075,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAUI_VML",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21625656075",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "4183d5072c781d887f41d87bcd55c8968aa70177",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/4183d5072c781d887f41d87bcd55c8968aa70177",
      "created_at": "2025-12-17T19:44:29Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21625755620,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAUI_tfk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21625755620",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "created_at": "2025-12-17T19:50:14Z"
    },
    {
      "event": "commented",
      "id": 3666985825,
      "node_id": "IC_kwDOAP4Jqs7akcNh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3666985825",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-17T20:12:41Z",
      "updated_at": "2025-12-17T20:12:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "@real-or-random: Thanks! Addressed your review comments regarding the remaining \"label pubkey\" terminology and the label cache explanation in the API documentation and reworked commenting `_create_shared_secret` w.r.t. non-infinity/non-zero requirements ([[1]](https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2626133290), [[2]](https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2626177122), [[3]](https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2626179300), [[4]](https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2624241943)). Also added test coverage for the newly introduced `_recipient_label_{parse,serialize}` (including NULL parameter API tests), as I noticed this was missing.\r\n\r\nFwiw I've updated the BIP-352 Python implementation (based on secp256k1lab, with names reflecting this module PR to ease review) to include the latest changes. It also contains the \"LabelSet approach\" now, so reviewers can (hopefully) more easily form an opinion about the two scanning approaches, seeing it from a higher-level perspective, without being too distracted by the C noise yet: https://github.com/theStack/secp256k1lab/blob/775f74373b30390932e10ab6f9d31db606339987/src/secp256k1lab/bip352.py#L234\r\n\r\nA branch with an alternative version of this PR, implementing the \"LabelSet approach\" (as opposed to the \"BIP approach\" for scanning, used right now) is coming up, likely within the next 1-2 days. The actual scanning implementation change is not even that large, the tedious part is the API change which requires to change tests, benchmarks and the example code as well.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3666985825",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21626179460,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAUJBU-E",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21626179460",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-17T20:12:42Z"
    },
    {
      "event": "subscribed",
      "id": 21626179478,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAUJBU-W",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21626179478",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-17T20:12:43Z"
    },
    {
      "event": "commented",
      "id": 3677024453,
      "node_id": "IC_kwDOAP4Jqs7bKvDF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3677024453",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-19T23:45:34Z",
      "updated_at": "2025-12-19T23:54:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "> A branch with an alternative version of this PR, implementing the \"LabelSet approach\" (as opposed to the \"BIP approach\" for scanning, used right now) is coming up, likely within the next 1-2 days. The actual scanning implementation change is not even that large, the tedious part is the API change which requires to change tests, benchmarks and the example code as well.\r\n\r\nThis is now ready: https://github.com/theStack/secp256k1/tree/silentpayments_module_fullnode_only-LabelSet-scan\r\n\r\nNote that the \"LabelSet approach\" `_scan_outputs` API differs in the following ways from the \"BIP approach\":\r\n* transaction outputs to scan for are passed in raw 32-byte format, rather than as `secp256k1_xonly_pubkey` instances, as we don't have to treat tx outputs as group elements; this is a small but nice advantage I think, as the user has to do less preparatory work, including potential error handling for crytographically invalid taproot outputs, and it's also faster (i.e. no `secp256k1_xonly_pubkey_parse` calls, involving a field element square root calculation)\r\n* the label cache callback type and the corresponding parameters are gone, and instead an array of pointers to `secp256k1_silentpayments_label_entry` instances is passed, each consisting of a  (label, label_tweak) pair; directly passing labels information seems to make things easier for the user as well I think, having to maintain a separate data structure and providing a callback function is just more error-prone and complex\r\n\r\nDifferences in the implementation, in comparison to the \"BIP approach\":\r\n* `tx_outputs` are lexicographically sorted in place before the scanning process starts, to prepare for a fast lookup using binary search\r\n* rather than iterating over all transaction outputs for each new k value and do `tx output -> label candidate -> label cache` calculations/lookups, do it in the other direction: for each new k value, iterate over the list of passed labels repeatedly, where each label is added to the unlabeled output candidate, and do `label -> output candidate -> tx outputs` calculations/lookups instead\r\n* lookups in the transaction outputs, as already mentioned, are done via binary search, using the function `secp256k1_silentpayments_tx_output_find`\r\n\r\nI think in some sense the LabelSet approach is even more straight-forward and easier to understand, as it more resembles the steps on the sender side, and there is no need to handle the missing y-parity information in x-only public keys (by trying both). Thanks go once again to @w0xlt who brought up the initial idea and implementation in this PR and even developed it further by using batch inversion (see https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3610848914 and https://github.com/w0xlt/secp256k1/commit/1e8d196e456de957e497275205e3e77df2b4f74b). I decided to not include this optimization yet to keep the branch in a simple reviewer-friendly state for now, but think it's an attractive option to consider.\r\n\r\nComments about the two approaches in general and ideas on how to concretely move on with this PR would be much appreciated. I see merit in both approaches, they are just addressing different use-cases, depending on how many labels are planned to be used. The drawback in the \"BIP approach\" is that it suffers (I think inherently) from the worst-case scanning attack, independently on how many labels are used. If that is a no-go, I think the \"LabelSet approach\" is a realistic option, with the drawback that it doesn't scale well for large-amount-of-labels use-cases. Maybe that's fine for the first release of the module, if that's well-documented.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3677024453",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21680684921,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAUMRP95",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21680684921",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-19T23:45:35Z"
    },
    {
      "event": "subscribed",
      "id": 21680684934,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAUMRP-G",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21680684934",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-19T23:45:35Z"
    },
    {
      "event": "reviewed",
      "id": 3602023522,
      "node_id": "PRR_kwDOAP4Jqs7WsoRi",
      "url": null,
      "actor": null,
      "commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-21T22:57:12Z",
      "author_association": "MEMBER",
      "body": "went through 2c073807c3172ec1b6325c78cd78ece458955b6d only and left a few comments. Will keep moving.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3602023522",
      "submitted_at": "2025-12-21T22:51:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "commented",
      "id": 3684588782,
      "node_id": "IC_kwDOAP4Jqs7bnlzu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3684588782",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-23T00:03:30Z",
      "updated_at": "2025-12-23T00:04:34Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Comments about the two approaches in general and ideas on how to concretely move on with this PR would be much appreciated. I see merit in both approaches, they are just addressing different use-cases, depending on how many labels are planned to be used. The drawback in the \"BIP approach\" is that it suffers (I think inherently) from the worst-case scanning attack, independently on how many labels are used. If that is a no-go, I think the \"LabelSet approach\" is a realistic option, with the drawback that it doesn't scale well for large-amount-of-labels use-cases. Maybe that's fine for the first release of the module, if that's well-documented.\r\n\r\n(Ignorance warning: I have mostly been reading along here but I have not read all the context from the previous PRs and I have not reviewed all the code)\r\n\r\nI guess you are hinting at the same thought I had in your last sentence: I think one approach that would be most defensive (as in should be completely safe for users) would be to only go with LabelSet and also set a max value for the number of labels that can be used. That max number would be somewhat arbitrary but we could set a target time on a target hardware and arrive at some benchmark that we feel comfortable with allowing. This of course wouldn't prevent users from using more labels but in order to do so they would need to call scanning multiple times which should make sure they know what they are getting into in terms of performance. They would likely read the docs and then complain here that this restriction should be removed because they have a use-case. Then we could consider further actions based on this feedback.\r\n\r\nThis still seems doable from a implementation POV and lifting the limit in a future version shouldn't cause any compatibility problems. Doing anything resembling that to mitigate the worst case for the BIP approach seems much worse UX wise and much harder to explain.\r\n\r\nAlso, I guess if we stay with the API from LabelSet internally the BIP approach could still be used if the number of labels is high and the number of outputs is manageable. But there might be some thresholds that users run into that are much harder to explain in the docs. And I honestly have no clue if the label_context/label_lookup UX is something that users desire, lacking the historical context from the previous PRs.\r\n\r\nFWIW, my concerns with the worst case attack are somewhat mild but we should remember that this might be used in some of the most adversarial contexts imaginable: The users could a taker of donations with powerful political adversaries or an exchange with fierce competition for example. That's why I would have a hard time feeling comfortable with letting users just adapt it at this point.",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3684588782",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3694839685,
      "node_id": "IC_kwDOAP4Jqs7cOseF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3694839685",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-28T15:46:39Z",
      "updated_at": "2025-12-28T15:59:26Z",
      "author_association": "NONE",
      "body": "> ===== BIP approach (calculate label candidates for each output, look them up in labels cache) =====\r\n> L= 1: [N=2: 351 us] [N=5: 200 us] [N=10: 231 us] [N=20: 261 us] [N=50: 289 us] [N=100: 451 us] [N=200: 745 us]\r\n> L= 2: [N=2:  81 us] [N=5: 109 us] [N=10:  82 us] [N=20: 153 us] [N=50: 218 us] [N=100: 379 us] [N=200: 631 us]\r\n> L= 3: [N=2:  55 us] [N=5:  59 us] [N=10:  75 us] [N=20:  99 us] [N=50: 185 us] [N=100: 299 us] [N=200: 586 us]\r\n> L= 5: [N=2:  52 us] [N=5:  58 us] [N=10:  70 us] [N=20:  90 us] [N=50: 171 us] [N=100: 302 us] [N=200: 514 us]\r\n> L=10: [N=2:  48 us] [N=5:  53 us] [N=10:  62 us] [N=20:  86 us] [N=50: 153 us] [N=100: 269 us] [N=200: 489 us]\r\n> L=20: [N=2:  44 us] [N=5:  52 us] [N=10:  64 us] [N=20:  86 us] [N=50: 147 us] [N=100: 267 us] [N=200: 481 us]\r\n> L=50: [N=2:  44 us] [N=5:  47 us] [N=10:  61 us] [N=20:  91 us] [N=50: 153 us] [N=100: 257 us] [N=200: 469 us]\r\n> \r\n> ===== Label-set approach (calculate output candidate for each label, look it up in outputs) =====\r\n> L= 1: [N=2:  39 us] [N=5:  38 us] [N=10:  37 us] [N=20:  38 us] [N=50:  41 us] [N=100:  48 us] [N=200:  64 us]\r\n> L= 2: [N=2:  37 us] [N=5:  36 us] [N=10:  36 us] [N=20:  37 us] [N=50:  41 us] [N=100:  46 us] [N=200:  65 us]\r\n> L= 3: [N=2:  40 us] [N=5:  36 us] [N=10:  37 us] [N=20:  39 us] [N=50:  43 us] [N=100:  49 us] [N=200:  75 us]\r\n> L= 5: [N=2:  39 us] [N=5:  39 us] [N=10:  41 us] [N=20:  42 us] [N=50:  47 us] [N=100:  51 us] [N=200:  84 us]\r\n> L=10: [N=2:  47 us] [N=5:  47 us] [N=10:  45 us] [N=20:  46 us] [N=50:  49 us] [N=100:  55 us] [N=200:  71 us]\r\n> L=20: [N=2:  58 us] [N=5:  56 us] [N=10:  58 us] [N=20:  55 us] [N=50:  59 us] [N=100:  66 us] [N=200:  84 us]\r\n> L=50: [N=2:  88 us] [N=5:  85 us] [N=10:  93 us] [N=20:  88 us] [N=50:  94 us] [N=100: 100 us] [N=200: 120 us]\r\n\r\nThese benchmark results from https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3610848914 are interesting. I expect the BIP scanning approach benchmark to report increasing scanning times as `N` increases, independent of `L`, because we expect constant lookup times for labels, but this benchmark reports the scanning time using the BIP approach for `L=1; N=2` to be several times higher than `L=50; N=2`. The scanning times shouldn't vary too much as we vary `L` (unless we drop it to `0`).\r\n\r\nIt is also surprising to see such a large difference between the BIP approach and LabelSet scanning times for `L=1; N=2`. \r\n\r\nI ran [theStack@8eced64](https://github.com/theStack/secp256k1/commit/8eced6432bf8a6fd4dc968f846ca8373043d092b) on my machine and obtained the following results, which are more in line with my expectations:\r\n```\r\nBenchmark                               ,    Min(us)    ,    Avg(us)    ,    Max(us)    \r\n\r\nsp_full_scan_BIP-algo_L=0_N=2           ,    48.4       ,    48.7       ,    49.3    \r\nsp_full_scan_BIP-algo_L=0_N=5           ,    48.5       ,    48.6       ,    48.9    \r\nsp_full_scan_BIP-algo_L=0_N=10          ,    48.6       ,    48.7       ,    48.8    \r\nsp_full_scan_BIP-algo_L=0_N=20          ,    48.9       ,    49.0       ,    49.2    \r\nsp_full_scan_BIP-algo_L=0_N=50          ,    49.6       ,    49.7       ,    49.8    \r\nsp_full_scan_BIP-algo_L=0_N=100         ,    49.9       ,    50.8       ,    51.1    \r\nsp_full_scan_BIP-algo_L=0_N=200         ,    51.0       ,    51.4       ,    52.4    \r\n-----\r\nsp_full_scan_BIP-algo_L=1_N=2           ,    52.4       ,    53.0       ,    53.8    \r\nsp_full_scan_BIP-algo_L=1_N=5           ,    58.0       ,    58.2       ,    58.5    \r\nsp_full_scan_BIP-algo_L=1_N=10          ,    64.9       ,    66.8       ,    68.1    \r\nsp_full_scan_BIP-algo_L=1_N=20          ,    82.9       ,    83.6       ,    84.6    \r\nsp_full_scan_BIP-algo_L=1_N=50          ,   143.0       ,   144.0       ,   146.0    \r\nsp_full_scan_BIP-algo_L=1_N=100         ,   234.0       ,   239.0       ,   241.0    \r\nsp_full_scan_BIP-algo_L=1_N=200         ,   412.0       ,   414.0       ,   417.0    \r\n-----\r\n\r\nsp_full_scan_LabelSet-algo_L=0_N=2      ,    48.8       ,    48.9       ,    49.3    \r\nsp_full_scan_LabelSet-algo_L=0_N=5      ,    49.0       ,    49.1       ,    49.3    \r\nsp_full_scan_LabelSet-algo_L=0_N=10     ,    48.2       ,    49.6       ,    50.3    \r\nsp_full_scan_LabelSet-algo_L=0_N=20     ,    49.3       ,    49.4       ,    49.6    \r\nsp_full_scan_LabelSet-algo_L=0_N=50     ,    56.5       ,    58.1       ,    59.5    \r\nsp_full_scan_LabelSet-algo_L=0_N=100    ,    71.8       ,    74.1       ,    75.7    \r\nsp_full_scan_LabelSet-algo_L=0_N=200    ,   112.0       ,   112.0       ,   112.0    \r\n-----\r\nsp_full_scan_LabelSet-algo_L=1_N=2      ,    49.6       ,    49.7       ,    49.9    \r\nsp_full_scan_LabelSet-algo_L=1_N=5      ,    50.0       ,    50.1       ,    50.5    \r\nsp_full_scan_LabelSet-algo_L=1_N=10     ,    50.8       ,    50.9       ,    51.0    \r\nsp_full_scan_LabelSet-algo_L=1_N=20     ,    52.9       ,    53.0       ,    53.1    \r\nsp_full_scan_LabelSet-algo_L=1_N=50     ,    60.6       ,    60.7       ,    60.9    \r\nsp_full_scan_LabelSet-algo_L=1_N=100    ,    73.0       ,    75.5       ,    76.4    \r\nsp_full_scan_LabelSet-algo_L=1_N=200    ,   109.0       ,   112.0       ,   114.0    \r\n-----\r\nsp_full_scan_LabelSet-algo_L=2_N=2      ,    48.8       ,    50.1       ,    50.7    \r\nsp_full_scan_LabelSet-algo_L=2_N=5      ,    51.0       ,    51.1       ,    51.2    \r\nsp_full_scan_LabelSet-algo_L=2_N=10     ,    49.5       ,    51.3       ,    52.5    \r\nsp_full_scan_LabelSet-algo_L=2_N=20     ,    53.4       ,    53.8       ,    54.0    \r\nsp_full_scan_LabelSet-algo_L=2_N=50     ,    59.7       ,    60.9       ,    61.9    \r\nsp_full_scan_LabelSet-algo_L=2_N=100    ,    73.6       ,    75.4       ,    77.8    \r\nsp_full_scan_LabelSet-algo_L=2_N=200    ,   109.0       ,   109.0       ,   109.0    \r\n-----\r\nsp_full_scan_LabelSet-algo_L=3_N=2      ,    49.4       ,    50.0       ,    51.6    \r\nsp_full_scan_LabelSet-algo_L=3_N=5      ,    49.7       ,    49.9       ,    50.4    \r\nsp_full_scan_LabelSet-algo_L=3_N=10     ,    50.4       ,    50.6       ,    50.8    \r\nsp_full_scan_LabelSet-algo_L=3_N=20     ,    52.3       ,    52.5       ,    52.8    \r\nsp_full_scan_LabelSet-algo_L=3_N=50     ,    59.9       ,    60.1       ,    60.3    \r\nsp_full_scan_LabelSet-algo_L=3_N=100    ,    76.3       ,    78.8       ,    79.6    \r\nsp_full_scan_LabelSet-algo_L=3_N=200    ,   113.0       ,   115.0       ,   116.0    \r\n-----\r\nsp_full_scan_LabelSet-algo_L=5_N=2      ,    53.9       ,    54.0       ,    54.1    \r\nsp_full_scan_LabelSet-algo_L=5_N=5      ,    54.3       ,    54.4       ,    54.6    \r\nsp_full_scan_LabelSet-algo_L=5_N=10     ,    55.2       ,    55.3       ,    55.4    \r\nsp_full_scan_LabelSet-algo_L=5_N=20     ,    57.3       ,    57.5       ,    57.8    \r\nsp_full_scan_LabelSet-algo_L=5_N=50     ,    62.6       ,    64.6       ,    65.6    \r\nsp_full_scan_LabelSet-algo_L=5_N=100    ,    77.5       ,    78.6       ,    79.6    \r\nsp_full_scan_LabelSet-algo_L=5_N=200    ,   112.0       ,   113.0       ,   114.0    \r\n-----\r\nsp_full_scan_LabelSet-algo_L=10_N=2     ,    56.0       ,    57.2       ,    59.0    \r\nsp_full_scan_LabelSet-algo_L=10_N=5     ,    58.1       ,    59.4       ,    60.2    \r\nsp_full_scan_LabelSet-algo_L=10_N=10    ,    60.2       ,    60.7       ,    61.2    \r\nsp_full_scan_LabelSet-algo_L=10_N=20    ,    62.6       ,    63.0       ,    63.9    \r\nsp_full_scan_LabelSet-algo_L=10_N=50    ,    70.7       ,    71.0       ,    71.2    \r\nsp_full_scan_LabelSet-algo_L=10_N=100   ,    86.3       ,    87.4       ,    88.3    \r\nsp_full_scan_LabelSet-algo_L=10_N=200   ,   119.0       ,   123.0       ,   128.0    \r\n-----\r\nsp_full_scan_LabelSet-algo_L=20_N=2     ,    69.0       ,    69.6       ,    70.5    \r\nsp_full_scan_LabelSet-algo_L=20_N=5     ,    71.2       ,    71.2       ,    71.3    \r\nsp_full_scan_LabelSet-algo_L=20_N=10    ,    72.5       ,    72.6       ,    72.7    \r\nsp_full_scan_LabelSet-algo_L=20_N=20    ,    74.9       ,    75.0       ,    75.2    \r\nsp_full_scan_LabelSet-algo_L=20_N=50    ,    83.4       ,    83.5       ,    83.6    \r\nsp_full_scan_LabelSet-algo_L=20_N=100   ,    97.8       ,    99.3       ,   101.0    \r\nsp_full_scan_LabelSet-algo_L=20_N=200   ,   137.0       ,   138.0       ,   139.0    \r\n-----\r\nsp_full_scan_LabelSet-algo_L=50_N=2     ,    97.2       ,    99.5       ,   100.0    \r\nsp_full_scan_LabelSet-algo_L=50_N=5     ,   101.0       ,   102.0       ,   103.0    \r\nsp_full_scan_LabelSet-algo_L=50_N=10    ,   103.0       ,   104.0       ,   105.0    \r\nsp_full_scan_LabelSet-algo_L=50_N=20    ,   107.0       ,   107.0       ,   108.0    \r\nsp_full_scan_LabelSet-algo_L=50_N=50    ,   114.0       ,   116.0       ,   117.0    \r\nsp_full_scan_LabelSet-algo_L=50_N=100   ,   132.0       ,   133.0       ,   134.0    \r\nsp_full_scan_LabelSet-algo_L=50_N=200   ,   165.0       ,   167.0       ,   168.0    \r\n\r\n```\r\n\r\nIIUC, the BIP scanning approach is designed to keep scanning times low as the number of labels increases. If we expect most transactions to have `N << L`, then the BIP scanning approach will be faster overall, especially when there is a significant number of labels. The LabelSet scanning approach takes almost twice as much time as the BIP approach for `L=50;N=2`.\r\n\r\n@w0xlt 's benchmark results with Batch Inversion look promising, but I expect it to be slower than the BIP scanning approach when we scan real blocks, even with a relatively low number of labels.",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3694839685",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21770418280,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAURnjho",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21770418280",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-28T15:46:40Z"
    },
    {
      "event": "subscribed",
      "id": 21770418286,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAURnjhu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21770418286",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-28T15:46:40Z"
    },
    {
      "event": "commented",
      "id": 3695429911,
      "node_id": "IC_kwDOAP4Jqs7cQ8kX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3695429911",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-29T04:57:28Z",
      "updated_at": "2025-12-29T04:57:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "@fjahr: Thanks for weighing in! After much back-and-forth over the last few weeks on the two approaches and their trade-offs, I've reached very similar conclusions and am now convinced that shipping the module with the BIP approach as-is would not be a good idea, and \"LabelSet with limits\" approach as you sketched out is the safest option. It seems that the worst-case scanning attack for large-number-of-labels use-cases could only be fixed at the protocol level anyways (by e.g. limiting the size of SP eligible transactions to 100kvB, or more concretely by bounding the number of taproot outputs), and until that is done the BIP approach should probably not be used at all.\r\n\r\nI've opened a PR following the proposed \"LabelSet scanning with a limit on labels\" path: https://github.com/bitcoin-core/secp256k1/pull/1792 (by now only suggesting a limit by documentation, but that can easily be changed), where the discussion can be continued.\r\n\r\n@Eunovo:\r\n> These benchmark results from https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3610848914 are interesting. I expect the BIP scanning approach benchmark to report increasing scanning times as N increases, independent of L, because we expect constant lookup times for labels, but this benchmark reports the scanning time using the BIP approach for L=1; N=2 to be several times higher than L=50; N=2. The scanning times shouldn't vary too much as we vary L (unless we drop it to 0).\r\n>\r\n> It is also surprising to see such a large difference between the BIP approach and LabelSet scanning times for L=1; N=2.\r\n\r\nI remember also seeing these large differences for low L/N values and believe this was a flaw in the benchmark itself (when it was hand-written in the example binary, rather than using our benchmark framework); for some reason the very first benchmark result line showed significantly longer run-times than later ones, even when the order L or N values was re-arranged. With the \"actual benchmark\" as you ran it, I couldn't reproduce this large gap anymore.\r\n\r\n> IIUC, the BIP scanning approach is designed to keep scanning times low as the number of labels increases. If we expect most transactions to have N << L, then the BIP scanning approach will be faster overall, especially when there is a significant number of labels. The LabelSet scanning approach takes almost twice as much time as the BIP approach for L=50;N=2.\r\n\r\nThat matches my general understanding as well. The theoretical cross-over point should be at $2 * N < L$, as that's the number of EC point additions needed for each approach (2*N BIP approach, L for the LabelSet approach).",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3695429911",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21773641637,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAURz2el",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21773641637",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-29T04:57:29Z"
    },
    {
      "event": "subscribed",
      "id": 21773641649,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAURz2ex",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21773641649",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-29T04:57:29Z"
    },
    {
      "event": "mentioned",
      "id": 21773641662,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAURz2e-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21773641662",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-29T04:57:29Z"
    },
    {
      "event": "subscribed",
      "id": 21773641668,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAURz2fE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21773641668",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-29T04:57:30Z"
    },
    {
      "event": "reviewed",
      "id": 3657637829,
      "node_id": "PRR_kwDOAP4Jqs7aAx_F",
      "url": null,
      "actor": null,
      "commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-13T19:46:04Z",
      "author_association": "NONE",
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3657637829",
      "submitted_at": "2026-01-13T19:46:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "reviewed",
      "id": 3678540890,
      "node_id": "PRR_kwDOAP4Jqs7bQhRa",
      "url": null,
      "actor": null,
      "commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-01-19T15:16:37Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3678540890",
      "submitted_at": "2026-01-19T15:16:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "commented",
      "id": 3770701919,
      "node_id": "IC_kwDOAP4Jqs7gwFhf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3770701919",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-20T02:07:36Z",
      "updated_at": "2026-01-20T02:07:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Tackled the latest review suggestions https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2687881682, https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2705151787, https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2705173147.\r\n\r\nAlso added `TODO` comments for limiting the `k` values both on the sender and receiver side, as this would be a [proposed mitigation against the worst-case scanning issue](https://github.com/bitcoin-core/secp256k1/issues/1799#issuecomment-3769144034) (previously suggested by @RubenSomsen). Since this is a protocol change (backwards-incompatible at least in theory) and needs some more research and a BIP update, I'll leave this PR in draft state until that preparatory work is ready.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3770701919",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 22149968252,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAUoPbF8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22149968252",
      "actor": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-20T02:07:38Z"
    },
    {
      "event": "subscribed",
      "id": 22149968272,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAUoPbGQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22149968272",
      "actor": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-20T02:07:38Z"
    },
    {
      "event": "convert_to_draft",
      "id": 22149968903,
      "node_id": "CTDE_lADOAP4Jqs7VEWwNzwAAAAUoPbQH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22149968903",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-20T02:07:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22149974343,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAUoPclH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22149974343",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "4b53c44f2735da7f6c1f4af23e261ff7a7c3bb01",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/4b53c44f2735da7f6c1f4af23e261ff7a7c3bb01",
      "created_at": "2026-01-20T02:08:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22150490245,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAUoRaiF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22150490245",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "2d4c8ff99559d1db215d0f172e31d83c4371ba37",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/2d4c8ff99559d1db215d0f172e31d83c4371ba37",
      "created_at": "2026-01-20T02:55:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22473784539,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAU7irzb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22473784539",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "created_at": "2026-02-02T17:57:52Z"
    },
    {
      "event": "commented",
      "id": 3837059903,
      "node_id": "IC_kwDOAP4Jqs7ktOM_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3837059903",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-02T18:57:35Z",
      "updated_at": "2026-02-02T18:57:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "The PR has been updated to implement the suggested \"limited-k\" protocol restriction with an example value of K_max=1000: https://github.com/bitcoin-core/secp256k1/pull/1765/changes/66e41d0878f0d9dc4bc946b1170c04735aad85a6 (see discussion https://github.com/bitcoin-core/secp256k1/issues/1799#issuecomment-3773155788 ff.)\r\nIt also includes the common case and worst-case scanning benchmarks with different group sizes (i.e. K_max limits), so reviewers can test out on how different limits would map to worst-scanning scanning times on their machines: https://github.com/bitcoin-core/secp256k1/pull/1765/changes/e3e4162f1aa494df8968aa9f748942b761b7ab54\r\n\r\nI'm keeping the PR as a draft, since the limit used (K_max=1000) is still just an example number and more discussion is needed before a concrete change in BIP-352 is applied.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3837059903",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "reviewed",
      "id": 3748283540,
      "node_id": "PRR_kwDOAP4Jqs7fakSU",
      "url": null,
      "actor": null,
      "commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-02-04T07:06:02Z",
      "author_association": "NONE",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3748283540",
      "submitted_at": "2026-02-04T07:06:02Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "referenced",
      "id": 22520591073,
      "node_id": "REFE_lADOAP4Jqs7VEWwNzwAAAAU-VPLh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22520591073",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "d071aa56d5f75c92a887f78e0e24315e6cc54aa8",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/d071aa56d5f75c92a887f78e0e24315e6cc54aa8",
      "created_at": "2026-02-04T07:44:53Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22564060236,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAVA7DxM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22564060236",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "fed508d99a2d913c97c41f807210b7da1e11f17c",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/fed508d99a2d913c97c41f807210b7da1e11f17c",
      "created_at": "2026-02-05T16:26:28Z"
    },
    {
      "event": "commented",
      "id": 3854991697,
      "node_id": "IC_kwDOAP4Jqs7lxoFR",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3854991697",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-05T17:08:33Z",
      "updated_at": "2026-02-05T17:08:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "Force-pushed after tackling the latest review comments of @w0xlt (thanks!). Note that the PR also still includes two TODOs resulting from the discussion in #1799:\r\n\r\n* `/* TODO: clarify the limitations of labels w.r.t. light clients */` ([link](https://github.com/theStack/secp256k1/blob/fed508d99a2d913c97c41f807210b7da1e11f17c/include/secp256k1_silentpayments.h#L320))\r\n* `/* TODO: potential optimization: the worst-case run-time can be cut in half by randomizing the outputs */` ([link](https://github.com/theStack/secp256k1/blob/fed508d99a2d913c97c41f807210b7da1e11f17c/src/modules/silentpayments/main_impl.h#L631))\r\n\r\nI consider the first one to be significantly more important, since there are serious concerns about a potential lack of wallet interoperability (e.g. full node wallets scanning for lots of labels not being able to be restored on light client wallets) if we don't document this properly.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3854991697",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 22565184388,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVA_WOE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22565184388",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-05T17:08:34Z"
    },
    {
      "event": "subscribed",
      "id": 22565184421,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVA_WOl",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22565184421",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-05T17:08:34Z"
    },
    {
      "event": "reviewed",
      "id": 3759068470,
      "node_id": "PRR_kwDOAP4Jqs7gDtU2",
      "url": null,
      "actor": null,
      "commit_id": "fed508d99a2d913c97c41f807210b7da1e11f17c",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-02-05T19:44:38Z",
      "author_association": "NONE",
      "body": "One subtle API/UX point about `secp256k1_silentpayments_recipient_scan_outputs`: the implementation bounds scanning by `SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT` by capping the `k` loop to `k_max = min(n_tx_outputs, GROUP_LIMIT)`\n\nThe function still returns 1 (success) and only reports `*n_found_outputs` (also capped), so a caller could reasonably assume all outputs were scanned unless they read the note in the header docs. It might be worth returning a distinct status / flag when the bound is hit.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3759068470",
      "submitted_at": "2026-02-05T19:44:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "commented",
      "id": 3856872222,
      "node_id": "IC_kwDOAP4Jqs7l4zMe",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3856872222",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-05T22:56:43Z",
      "updated_at": "2026-02-05T22:56:43Z",
      "author_association": "NONE",
      "body": "I ran `silentpayments_scan_worstcase` benchmarks for the BIP scan.\r\n\r\n| Case | K=10 | K=100 | K=1000 | K=2325 | K=23255 |\r\n|---|---:|---:|---:|---:|---:|\r\n| No optimization (PR as-is) | 0.168s | 1.285s | 12.13s | 29.29s | 287.33s (4.79 min) |\r\n| Only found output removal (0efc140) | 0.169s | 1.234s | 12.14s | 29.22s | 148.55s (2.48 min) |\r\n| All optimizations (0efc140 + 2c24fe8 + 4795a3e) | 0.075s | 0.547s | 5.19s | 11.80s | 60.55s (1.01 min) |\r\n\r\nNotes on the optimizations:\r\n- 0efc140: removes found outputs from the scan list in-place, so later k-iterations scan a shrinking set (~2 at KN).\r\n- 2c24fe8: avoids re-serializing/recomputing the generated x-only key inside each inner-loop comparison (compare 32-byte x-only encodings).\r\n- 4795a3e: batches label-candidate conversion to affine (batch inversion), reducing per-output label overhead.\r\n\r\nBench file used (which allows shuffling outputs)):\r\nhttps://github.com/w0xlt/secp256k1/blob/silentpayments_module_fullnode_only_2/src/modules/silentpayments/bench_impl.h\r\n\r\nTo run the K=23255 row, I temporarily set `SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT` >= 23255 (otherwise the scan caps earlier).\r\n\r\nThe data above indicates the combined optimization effect at K=N is roughly multiplicative: ~2 (removal)  ~2.4 (other work per scanned output)  ~4.8, and we get 287s  60s (~4.75).",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3856872222",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3860192866,
      "node_id": "IC_kwDOAP4Jqs7mFd5i",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3860192866",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-06T12:34:36Z",
      "updated_at": "2026-02-06T19:54:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "For the \"All optimizations\" row, is this with zero labels? Asking because 2c24fe8 introduces a branch for `label_lookup == NULL`\r\n\r\n> * [2c24fe8](https://github.com/bitcoin-core/secp256k1/commit/2c24fe86743e616e8e395b937feae0337ebcd360): avoids re-serializing/recomputing the generated x-only key inside each inner-loop comparison (compare 32-byte x-only encodings).\r\n\r\nHave you tried using `secp256k1_memcmp_var` on the `secp256k1_xonly_pubkey`s directly? (Or, cleaner, add an equality check function for `secp256k1_xonly_pubkey` that is implemented via comparing memory).  \r\n\r\nIn fact, if there are no labels, the fact that the caller passes the tx outputs as `secp256k1_xonly_pubkey` hurts performance. These could be just the serialized xonly keys. ~~(And even if there are labels, we could also batch deserialize the tx outputs.)~~",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3860192866",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3862265628,
      "node_id": "IC_kwDOAP4Jqs7mNX8c",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3862265628",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-06T19:45:55Z",
      "updated_at": "2026-02-06T19:45:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "@w0xlt: Thanks for investigating optimizations, that's very helpful. I tried to pinpoint the speedup in your \"all optimizations\" case and found that the biggest impact comes from batch inversion (~2.5x):\r\n\r\n| Case                                | K=100 | K=1000 | K=2325 |\r\n|-------------------------------------|-------|--------|--------|\r\n| Baseline (PR as-is) https://github.com/theStack/secp256k1/commit/164fe4504dab254b2112ac021c85fa468759658f                | 3.23s | 31.40s | 70.83s |\r\n| Randomize outputs https://github.com/theStack/secp256k1/commit/6b5cf7958f5e4740b5538b400a4ad5c7d3dddc3c [1]                 | 1.68s | 16.21s | 38.73s |\r\n| Randomize outputs + Batch inversion https://github.com/theStack/secp256k1/commit/e8efd94f270f3053b24742d152a74c6961a8bc8d | 0.66s | 6.42s  | 15.33s |\r\n\r\nSo doing both randomizing outputs (2x) and using batch inversion for label candidates (~2.5x) gives us a nice ~5x speedup in total. In comparison, avoiding the repeated serialization of outputs was not noticeable. I think the batch inversion optimization is particularly interesting as it could also improve performance for the \"no match\" common case (to be verified). The price to pay for that is more complex code, e.g. resulting in three nested loops already (k, j, ci), but I think we should consider it.\r\n\r\n[1] It seems that your baseline case is already (very likely unintended?) optimized by doing the shuffling in the benchmarks, which is already ~2x better than the actual worst-case, namely tx outputs listed in the order (k=N-1, k=N-2, ..., k=1, k=0)\r\n\r\n@real-or-random:\r\n> In fact, if there are no labels, the fact that the caller passes the tx outputs as secp256k1_xonly_pubkey hurts performance. These could be just the serialized xonly keys. (And even if there are labels, we could also batch deserialize the tx outputs.)\r\n\r\nHmm good point yeah, though it's unclear if there will be any demand for no-label scanning. As for batch deserializing x-only outputs, is there currently a way to do this (or at all)? It seems that the expensive part is `fe_sqrt` there for calculating the y coordinate.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3862265628",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 22598297285,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVC9qbF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22598297285",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-06T19:45:56Z"
    },
    {
      "event": "subscribed",
      "id": 22598297316,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVC9qbk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22598297316",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-06T19:45:56Z"
    },
    {
      "event": "mentioned",
      "id": 22598297342,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVC9qb-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22598297342",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-06T19:45:56Z"
    },
    {
      "event": "subscribed",
      "id": 22598297358,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVC9qcO",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22598297358",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-06T19:45:56Z"
    },
    {
      "event": "commented",
      "id": 3862292784,
      "node_id": "IC_kwDOAP4Jqs7mNekw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3862292784",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-06T19:53:55Z",
      "updated_at": "2026-02-06T19:53:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "> As for batch deserializing x-only outputs, is there currently a way to do this (or at all)? It seems that the expensive part is `fe_sqrt` there for calculating the y coordinate.\r\n\r\nNevermind, no, there's no reasonable way to batch square roots. This was a brain fart. :)",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3862292784",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3879756717,
      "node_id": "IC_kwDOAP4Jqs7nQGOt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3879756717",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-10T17:45:05Z",
      "updated_at": "2026-02-10T17:45:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I think the batch inversion optimization is particularly interesting as it could also improve performance for the \"no match\" common case (to be verified).\r\n\r\nFollowing up on that, the following table shows benchmark results for the \"no match\" case for various tx output counts (N), with and without batch inversion used (as per `$ ./build/bin/bench silentpayments_scan_nomatch`):\r\n\r\n| Case                                | N=2 | N=5 | N=10 | N=100 | N=1000 | N=2325 | N=23255\r\n|-------------------------------------|-------|--------|--------|--------|--------|--------|--------\r\n| Baseline (PR as-is) https://github.com/theStack/secp256k1/commit/164fe4504dab254b2112ac021c85fa468759658f                | 43.0us | 46.7us | 53.4us | 176.0us | 1418.0us | 3245.0us | 32094.0us\r\n| Batch inversion https://github.com/theStack/secp256k1/commit/e8efd94f270f3053b24742d152a74c6961a8bc8d | 42.3us | 43.7us  | 46.3us | 96.4us | 595.0us | 1334.0us | 13050.0us\r\n| Speedup | **~1.65%** | **~6.86%** | **~15.33%** | **~82.57%** | **~138.31%** | **~143.25%** | **~145.93%**\r\n\r\nConsidering that these performance gains are relevant for all Silent Payments scanners, these numbers strongly indicate that we should include batch inversion. I assume that the vast majority of transactions fall into first three columns (N<=10) these days, so >2x gains would be rather the exception than the rule, but even the consistent single per-cent speedups seem like a win, and worth it the additional implementation complexity. Thoughts on that?\r\n\r\nHere is an alternative branch for batch inversion, that uses only one j loop: https://github.com/theStack/secp256k1/commit/2e22a5c7492fc72f658ca6d3bfedb948084bb193 (in contrast to the solution linked above, where no-label and label scanning have individual j loops).",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3879756717",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3882064264,
      "node_id": "IC_kwDOAP4Jqs7nY5mI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3882064264",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-11T04:34:30Z",
      "updated_at": "2026-02-11T04:34:30Z",
      "author_association": "NONE",
      "body": "I hope you all don't mind - I have one more optimization suggestion.\r\n\r\nEach commit was benchmarked in isolation to show the individual contribution of each change. The setup is the worst-case full-block scanning attack: N = K = 23,255 taproot outputs, all using the same label (m = 0), reversed in order, as defined in the benchmark file. No randomization, because it does not matter in this approach.\r\n\r\n| # | Commit | Description | Time | vs prev | vs baseline |\r\n|---|--------|-------------|-----:|--------:|------------:|\r\n| 1 | 1721f43 | Remove per-group recipient limit (**baseline**) | 283.3 s |  | 1x |\r\n| 2 | 5be27fe | Batch-invert scan label candidates | 117.7 s | 2.4x | 2.4x |\r\n| 3 | fa8adde | Preprocess outputs for order-independent lookup | 116.0 s | 1.01x | 2.4x |\r\n| 4 | f825296 | Reuse preloaded output group elements | 113.8 s | 1.02x | 2.5x |\r\n| 5 | bb83012 | Cache discovered labels as spend-key variants | 0.70 s | **162x** | **405x** |\r\n| 6 | 41e7ae2 | Compute tweak\\*G once per k for all spend variants | 0.24 s | 3.0x | **1,192x** |\r\n\r\nAll optimizations are purely receiver-side reorganizations. They don't change cryptographic semantics or rely on sender cooperation. The number of labels in the wallet also doesn't matter.\r\n\r\nIf this approach is correct, there might be no need to restrict the protocol to k_max.\r\n\r\nThis certainly increases the complexity, but perhaps it's worth it.\r\n\r\nThe repository is:\r\nhttps://github.com/w0xlt/secp256k1/tree/silentpayments_module_fullnode_label_cache",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3882064264",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3885367457,
      "node_id": "IC_kwDOAP4Jqs7nlgCh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3885367457",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-11T15:58:28Z",
      "updated_at": "2026-02-11T15:58:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "@w0xlt: Interesting. Looking at the \"Cache discovered labels as spend-key variants\" commit (https://github.com/bitcoin-core/secp256k1/commit/bb8301221ad2189113e0df4e4d46ff664abca646), it seems to help under the assumption that an attacker uses the same labeled recipient addresses repeatedly in the adversarial tx. If that assumption doesn't hold (e.g. different labeled spend pubkey used for each output; maybe we should define that as the actual worst-case), then it seems to perform strictly worse than the baseline, as the \"derived spend key\" cache only gets filled and looked up, without ever having a hit?\r\n \r\nOn the other hand, an attacker can't derive labeled addresses without knowing the scan secret key, so the assumption that an adversarial transaction is likely to contain many outputs with repeated labeled addresses might be not so far-fetched. :man_shrugging:",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3885367457",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 22708330442,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVJhZ_K",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22708330442",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-11T15:58:29Z"
    },
    {
      "event": "subscribed",
      "id": 22708330481,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVJhZ_x",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22708330481",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-11T15:58:29Z"
    },
    {
      "event": "commented",
      "id": 3887296894,
      "node_id": "IC_kwDOAP4Jqs7ns3F-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3887296894",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-11T21:22:45Z",
      "updated_at": "2026-02-11T21:22:45Z",
      "author_association": "NONE",
      "body": "@theStack thanks for the feedback.\r\n\r\nI added a benchmark toggle to simulate the actual worst-case where each matched output uses a distinct labeled spend key (labels dont repeat, so discovered-label caches get no hits).\r\n\r\nWith K=N=23255 and outputs ordered in descending k (the same worst-case ordering):\r\n\r\n* Pre-optimization scan (PR as-is, single label m=0): ~283 s\r\n* Optimized-scan, single label m=0 (repeated label): ~0.26 s\r\n* Optimized-scan, distinct labels m=k (no cache hits): ~245 s\r\n\r\nSo if this data is correct, the optimization is still a modest (or negligible) win even in the distinct labels adversary model, and its a huge win in the repeated-label case. \r\n\r\nGenerating many distinct labeled addresses is also not something a sender can do from just the receivers public address (labels depend on the receivers scan secret key), unless they first collect many labeled addresses published by the receiver.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3887296894",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 22716919445,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVKCK6V",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22716919445",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-11T21:22:47Z"
    },
    {
      "event": "subscribed",
      "id": 22716919478,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVKCK62",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22716919478",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-11T21:22:47Z"
    },
    {
      "event": "commented",
      "id": 3888202232,
      "node_id": "IC_kwDOAP4Jqs7nwUH4",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3888202232",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-12T01:44:07Z",
      "updated_at": "2026-02-12T01:45:19Z",
      "author_association": "NONE",
      "body": "Added a few commits to this repository to handle the distinct labels worst case  (each of the K matching outputs uses a different label `m=0..K-1`, so the discovered-label cache gets no hits)..\r\nIt reduces that case from ~216.1 s to ~66.9 s (3.2x over the unbounded cache, 4.4x over the unoptimized baseline).\r\n\r\n| # | Commit | Description | Time | vs 1721f43 | vs 1faa518 |\r\n|---|---|---|---:|---:|---:|\r\n|  | 1721f43 | Unoptimized | 295.9 s |  |  |\r\n| 7 | 1faa518 | Unbounded cache + distinct labels | 216.1 s | 1.4x | 1x |\r\n| 8 | dcf1d7f | Cap cached labels at 16 | 128.9 s | 2.3x | 1.7x |\r\n| 9 | a953f9a | Rotate label discovery scan order | 85.6 s | 3.5x | 2.5x |\r\n| 10 | 22217b2 | Scan only unused outputs | 66.9 s | **4.4x** | **3.2x** |\r\n\r\n\r\nAt this point the main trade-off is added complexity + some extra memory/bookkeeping in the receiver scan. \r\n\r\nWe may be able to simplify parts of it (or not). Assuming the approach is sound, it gives us additional mitigation knobs beyond a k_max restriction (e.g., bounded label-variant caching and unused-output tracking), while keeping protocol semantics unchanged.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3888202232",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3892085842,
      "node_id": "IC_kwDOAP4Jqs7n_IRS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3892085842",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-12T16:50:14Z",
      "updated_at": "2026-02-12T16:50:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "@w0xlt: Thanks for providing more optimizations, I'm looking forward to look at them in detail soon.\r\n\r\n> We may be able to simplify parts of it (or not). Assuming the approach is sound, it gives us additional mitigation knobs beyond a k_max restriction (e.g., bounded label-variant caching and unused-output tracking), while keeping protocol semantics unchanged.\r\n\r\nIf those optimizations work as intended and we decide to implement them, this might at some point raise the question if we need to restrict K_max at all. Considering that all of these optimizations increase complexity quite a bit (from what I saw so far), I'd strongly argue that we should still introduce the protocol limit, alone for the reason that there might be other implementations of BIP-352 than libsecp256k1 in the future. If we don't clearly document these optimizations in the BIP (something that I would very much like to avoid, unless it also benefits the \"no match\" common case; the more complex the specification is, the more likely bugs are introduced), we can't expect alternative implementations to pick them up, and thus they would still be vulnerable to the quadratic scaling issue.\r\n\r\nLimiting the k value iterations just seems like the simplest approach with negligible drawbacks. Combining that with the \"batch inversion\" and \"randomizing outputs\" (these two convinced me the most so far in terms of simplicity and efficiency) sounds like a good combination to me to move forward.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3892085842",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 22741471148,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVLf0-s",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22741471148",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-12T16:50:15Z"
    },
    {
      "event": "subscribed",
      "id": 22741471194,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVLf0_a",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22741471194",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-12T16:50:15Z"
    },
    {
      "event": "commented",
      "id": 3895634886,
      "node_id": "IC_kwDOAP4Jqs7oMqvG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3895634886",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-13T08:41:37Z",
      "updated_at": "2026-02-13T09:22:44Z",
      "author_association": "NONE",
      "body": "> I added a benchmark toggle to simulate the actual worst-case where each matched output uses a distinct labeled spend key (labels dont repeat, so discovered-label caches get no hits).\r\n> \r\n> With K=N=23255 and outputs ordered in descending k (the same worst-case ordering):\r\n> \r\n> * Pre-optimization scan (PR as-is, single label m=0): ~283 s\r\n> * Optimized-scan, single label m=0 (repeated label): ~0.26 s\r\n> * Optimized-scan, distinct labels m=k (no cache hits): ~245 s\r\n\r\n~~This is quite unexpected. With `K=N=23255` and distinct labels turned `ON`, the scanning algorithm still takes minutes on my machine.~~\r\nEDIT: I thought the results were presented for distinct labels.\r\n\r\nFrom what I can understand from https://github.com/w0xlt/secp256k1/tree/silentpayments_module_fullnode_label_cache,\r\nThe main speedup comes from the use of a tx-specific labels cache that allows avoiding the worst-case path unless a new label is used.  This should work pretty well as long as the distinct  Labels used in the Tx, is less than the labels cache size i.e If we use 17 Labels and the cache size is 16, then there will always be a cache miss.\r\n\r\nApart from the \"batch inversion\" optimisation, the rest of the commits seem to be implementing \"Removal and Randomisation\" in a different way (I am still unsure about this).",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3895634886",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3898571794,
      "node_id": "IC_kwDOAP4Jqs7oX3wS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3898571794",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-13T18:04:11Z",
      "updated_at": "2026-02-13T18:08:13Z",
      "author_association": "NONE",
      "body": "@Eunovo thanks for reviewing and testing.                                                                                                             \r\n                                                                                                                                                        \r\nThe latest round of optimization commits (fa8adde onward) aren't re-implementing \"Removal and Randomisation\". They introduce a different mechanism: caching discovered labels so future k iterations can check them directly via binary search, instead of re-running the expensive label discovery loop. That's the core.\r\n                                                                                                                                                        \r\nFor the repeated-label worst case (all 23,255 outputs match using the same label, i.e. K=N=23255, m=0), this is where the massive speedup comes from - 0.27s vs ~159s with batch inversion + removal and randomization only.\r\n                                                                                                                                                        \r\nYou're right that with 17 distinct labels and a cache size of 16, we get constant misses. Even so, the full stack of optimizations  brings that case (K=N=23255, m=k) down to ~67s (commit 22217b2), vs ~159s with batch inversion + removal and randomization.\r\nThe \"randomization\" in a953f9a (technically a rotation) was just reintroduced specifically  to handle the distinct-label worst case (m=k) that @theStack raised. \r\n\r\nI don't think we should worry much about the distinct-label case (m=k). An attacker would need to collect thousands of labeled addresses from the same recipient, which is more of a theoretical possibility than a realistic attack. But since it was raised, I proposed a solution.\r\n\r\nThat said, as @theStack noted, if we're happy with a K_max protocol limit, then batch inversion + output randomization is likely sufficient  no need for the label cache complexity. \r\n\r\nThe optimizations proposed here are primarily useful if we want to avoid capping k entirely.\r\n",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3898571794",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 22773551730,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVNaNJy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22773551730",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-13T18:04:12Z"
    },
    {
      "event": "subscribed",
      "id": 22773551787,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVNaNKr",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22773551787",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-13T18:04:12Z"
    },
    {
      "event": "mentioned",
      "id": 22773551840,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVNaNLg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22773551840",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-13T18:04:12Z"
    },
    {
      "event": "subscribed",
      "id": 22773551876,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVNaNME",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22773551876",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-13T18:04:13Z"
    },
    {
      "event": "commented",
      "id": 3907225436,
      "node_id": "IC_kwDOAP4Jqs7o44dc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3907225436",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T09:02:00Z",
      "updated_at": "2026-02-16T09:02:00Z",
      "author_association": "NONE",
      "body": "#### A Quick Note on the Scanning API\r\n\r\nThe full node scanning API might be doing too much. It locks users into a specific scanning strategy instead of giving them primitives to build their own optimisations.\r\n\r\nFor example, when I implemented multi-threaded scanning ([bip352.cpp#L386-L558](https://github.com/Eunovo/bitcoin/blob/87b0c58857b89457da2e2895b5ce5025ad4d5e0f/src/common/bip352.cpp#L386-L558)), I had to add these libsecp functions:\r\n- `secp256k1_silentpayments_recipient_create_tweak`\r\n- `secp256k1_silentpayments_recipient_create_output_pubkey`\r\n- `secp256k1_silentpayments_recipient_create_output_label`\r\n\r\nThis suggests libsecp should expose these building blocks directly rather than bundling everything into one scanning function.\r\n\r\nSimilarly, @w0xlt's optimisation included a lot of complicated logic that doesn't really fit libsecp's usual focus on math and crypto. I think this kind of stuff is better handled by clients using SP primitives from libsecp. This will keep the library focused and give clients flexibility to optimise however they need.",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3907225436",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 22818676407,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVQGV63",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22818676407",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T09:02:01Z"
    },
    {
      "event": "subscribed",
      "id": 22818676448,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVQGV7g",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22818676448",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T09:02:01Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGM2NTAzZWE5NzdmYzRmNDgyMjg5MjE5NzIxY2Y2MDllM2FkNzc2MmY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c6503ea977fc4f482289219721cf609e3ad7762f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c6503ea977fc4f482289219721cf609e3ad7762f",
      "tree": {
        "sha": "fe6964a220b2c7da5f64204244e9b57423f8b87c",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/fe6964a220b2c7da5f64204244e9b57423f8b87c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/322d0a435829f80fbb839abdb469f2a22c84c369",
          "sha": "322d0a435829f80fbb839abdb469f2a22c84c369",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/322d0a435829f80fbb839abdb469f2a22c84c369"
        }
      ],
      "message": "build: add skeleton for new silentpayments (BIP352) module",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-16T14:47:35Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2023-09-27T15:22:14Z"
      },
      "sha": "c6503ea977fc4f482289219721cf609e3ad7762f"
    },
    {
      "event": "commented",
      "id": 3909006629,
      "node_id": "IC_kwDOAP4Jqs7o_rUl",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3909006629",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T15:12:18Z",
      "updated_at": "2026-02-16T15:12:18Z",
      "author_association": "NONE",
      "body": "> The full node scanning API might be doing too much. It locks users into a specific scanning strategy instead of giving them primitives to build their own optimizations.\r\n\r\nI agree. However, my understanding was that the API explicitly aims to reduce degrees of freedom for implementations; a rationale I considered sufficient.\r\n\r\nWhile splitting the API appears straightforward, are there alternatives to avoid these additions at the current review stage?\r\n\r\n- Parallelize by pre-partitioning the `tx_outputs` vector and use a thread-safe cache for tweaks.\r\n- Retain the current API and defer exposing primitives to a subsequent iteration.",
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3909006629",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3909600988,
      "node_id": "IC_kwDOAP4Jqs7pB8bc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3909600988",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:05:49Z",
      "updated_at": "2026-02-16T17:05:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "@Eunovo, @nymius :\r\n> > The full node scanning API might be doing too much. It locks users into a specific scanning strategy instead of giving them primitives to build their own optimizations.\r\n> \r\n> I agree. However, my understanding was that the API explicitly aims to reduce degrees of freedom for implementations; a rationale I considered sufficient.\r\n\r\nYes, the current high-level API design is intentional. Providing an API with lower-level primitives was in fact the initial approach, see the first PR (#1471). At the time, I also thought this was a reasonable idea. However, the discussion highlighted that this approach goes against some of the basic principles of libsecp256k1 (see the comments https://github.com/bitcoin-core/secp256k1/pull/1471#issuecomment-1967953283 ff.). Our goal is to provide high-level APIs that are easy and safe to use, rather than exposing low-level operations and leaving the user to figure out how to combine them - which increases the risk of misuse. So after that, we agreed on providing a high-level API instead, starting with the second take (PR #1519).\r\n\r\nPerformance is of course important, but IIUC the recently presented optimizations all seem to be targeting the worst-case, while not gaining anything for the common case (\"no match\") scenario. Given that we already have some relatively straight-forward ways to mitigate the worst-case now (namely **K_max protocol limit, batch inversion, randomizing outputs**, see https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3862265628), I'd propose to simply take use of (a reasonable subset of) those and keep it as simple as possible otherwise. (Sure, there might be still sophisticated ways to improve that by another order of magnitude and get the worst-case down from e.g. 15 seconds to under a second, but I very much doubt that any users would justify spending additional engineering power on mitigating that further, at the cost of introducing additional complexity. What matters much more in practice is the common case performance, as it dominates the whole scanning process, and for that I'm not convinced that a lower-level API would even help much; users should already be able to parallelize scanning on a per-tx basis).\r\n\r\nSo I double-down on what @w0xlt [stated above](https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3898571794):\r\n> That said, as @theStack noted, if we're happy with a K_max protocol limit, then batch inversion + output randomization is likely sufficient  no need for the label cache complexity.\r\n>\r\n> The optimizations proposed here are primarily useful if we want to avoid capping k entirely.\r\n\r\nTwo of the last remaining blockers are\r\n* agree on a concrete K_max limit, add it to BIP-352\r\n* provide sufficient documentation in the API headers about the risks of wallet interoperability w.r.t. label usage (cc @craigraw)\r\n* implement batch inversion (also helps the common case)\r\n\r\nMy suggestions would be:\r\n\r\n* K_max = 1000 (see [benchmarks](https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3862265628) with the proposed optimizations)\r\n* API docs comment, directly at the label creation function:\r\n```\r\n * WARNING: Creating a large number of labels may significantly degrade\r\n * scanning performance in certain Silent Payments wallet implementations,\r\n * such as light clients. The scanning function provided in this module,\r\n * which is designed for full nodes, performs consistently even with hundreds\r\n * of thousands of labels. Other implementations may not share this property\r\n * or may be unable to use it due to lacking full transaction data.\r\n *\r\n * To maximize wallet interoperability, it is recommended to create only\r\n * the change label (m = 0) and avoid distributing labeled addresses.\r\n```\r\n\r\nFeedback very much welcome. I'm currently working on a branch that adds batch inversion, which I will likely push within the next 1-2 days.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3909600988",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 22831008655,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVQ1YuP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22831008655",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:05:50Z"
    },
    {
      "event": "subscribed",
      "id": 22831008682,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVQ1Yuq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22831008682",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:05:50Z"
    },
    {
      "event": "mentioned",
      "id": 22831008713,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVQ1YvJ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22831008713",
      "actor": {
        "login": "craigraw",
        "id": 862166,
        "node_id": "MDQ6VXNlcjg2MjE2Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/862166?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/craigraw",
        "html_url": "https://github.com/craigraw",
        "followers_url": "https://api.github.com/users/craigraw/followers",
        "following_url": "https://api.github.com/users/craigraw/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/craigraw/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/craigraw/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/craigraw/subscriptions",
        "organizations_url": "https://api.github.com/users/craigraw/orgs",
        "repos_url": "https://api.github.com/users/craigraw/repos",
        "events_url": "https://api.github.com/users/craigraw/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/craigraw/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:05:51Z"
    },
    {
      "event": "subscribed",
      "id": 22831008736,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVQ1Yvg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22831008736",
      "actor": {
        "login": "craigraw",
        "id": 862166,
        "node_id": "MDQ6VXNlcjg2MjE2Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/862166?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/craigraw",
        "html_url": "https://github.com/craigraw",
        "followers_url": "https://api.github.com/users/craigraw/followers",
        "following_url": "https://api.github.com/users/craigraw/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/craigraw/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/craigraw/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/craigraw/subscriptions",
        "organizations_url": "https://api.github.com/users/craigraw/orgs",
        "repos_url": "https://api.github.com/users/craigraw/repos",
        "events_url": "https://api.github.com/users/craigraw/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/craigraw/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:05:51Z"
    },
    {
      "event": "mentioned",
      "id": 22831008770,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVQ1YwC",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22831008770",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:05:51Z"
    },
    {
      "event": "subscribed",
      "id": 22831008799,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVQ1Ywf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22831008799",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:05:51Z"
    },
    {
      "event": "mentioned",
      "id": 22831008832,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVQ1YxA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22831008832",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:05:51Z"
    },
    {
      "event": "subscribed",
      "id": 22831008861,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVQ1Yxd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22831008861",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:05:51Z"
    },
    {
      "event": "mentioned",
      "id": 22831008882,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVQ1Yxy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22831008882",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:05:51Z"
    },
    {
      "event": "subscribed",
      "id": 22831008896,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVQ1YyA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22831008896",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:05:51Z"
    },
    {
      "event": "commented",
      "id": 3909693821,
      "node_id": "IC_kwDOAP4Jqs7pCTF9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3909693821",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T17:25:50Z",
      "updated_at": "2026-02-16T17:25:50Z",
      "author_association": "NONE",
      "body": "> My suggestions would be:\r\n\r\n>K_max = 1000 (see https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3862265628 with the proposed optimizations)\r\nAPI docs comment, directly at the label creation function:\r\n\r\nLooks good to me.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3909693821",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3910051227,
      "node_id": "IC_kwDOAP4Jqs7pDqWb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3910051227",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T18:53:38Z",
      "updated_at": "2026-02-16T18:53:38Z",
      "author_association": "NONE",
      "body": "@theStack thanks for providing all the context. I agree with your conclusion.\r\n\r\n> API docs comment, directly at the label creation function:\r\n\r\nShould it be expressed in the BIP document too?\r\n",
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3910051227",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 22833247970,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAVQ97bi",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22833247970",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T18:53:39Z"
    },
    {
      "event": "subscribed",
      "id": 22833247995,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAVQ97b7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22833247995",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-16T18:53:39Z"
    },
    {
      "event": "commented",
      "id": 3912335055,
      "node_id": "IC_kwDOAP4Jqs7pMX7P",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3912335055",
      "actor": {
        "login": "craigraw",
        "id": 862166,
        "node_id": "MDQ6VXNlcjg2MjE2Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/862166?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/craigraw",
        "html_url": "https://github.com/craigraw",
        "followers_url": "https://api.github.com/users/craigraw/followers",
        "following_url": "https://api.github.com/users/craigraw/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/craigraw/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/craigraw/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/craigraw/subscriptions",
        "organizations_url": "https://api.github.com/users/craigraw/orgs",
        "repos_url": "https://api.github.com/users/craigraw/repos",
        "events_url": "https://api.github.com/users/craigraw/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/craigraw/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-17T05:20:08Z",
      "updated_at": "2026-02-17T05:20:08Z",
      "author_association": "NONE",
      "body": "> API docs comment, directly at the label creation function:\r\n\r\nThe API docs comment LGTM.\r\n\r\n> Should it be expressed in the BIP document too?\r\n\r\nMy view would be yes.",
      "user": {
        "login": "craigraw",
        "id": 862166,
        "node_id": "MDQ6VXNlcjg2MjE2Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/862166?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/craigraw",
        "html_url": "https://github.com/craigraw",
        "followers_url": "https://api.github.com/users/craigraw/followers",
        "following_url": "https://api.github.com/users/craigraw/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/craigraw/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/craigraw/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/craigraw/subscriptions",
        "organizations_url": "https://api.github.com/users/craigraw/orgs",
        "repos_url": "https://api.github.com/users/craigraw/repos",
        "events_url": "https://api.github.com/users/craigraw/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/craigraw/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3912335055",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGMxZTU4MjdkZjY5NmIxMzk0MjgzN2M3NDFkNGMwZjg4NTc0YzVkMzI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c1e5827df696b13942837c741d4c0f88574c5d32",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c1e5827df696b13942837c741d4c0f88574c5d32",
      "tree": {
        "sha": "8b291ca1ca2acbbf454cafb0bbaec8e580fcc352",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/8b291ca1ca2acbbf454cafb0bbaec8e580fcc352"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c6503ea977fc4f482289219721cf609e3ad7762f",
          "sha": "c6503ea977fc4f482289219721cf609e3ad7762f",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c6503ea977fc4f482289219721cf609e3ad7762f"
        }
      ],
      "message": "silentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T16:37:00Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-03-25T16:23:37Z"
      },
      "sha": "c1e5827df696b13942837c741d4c0f88574c5d32"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGJiNjA3Yzg0MDdmOThhZjMzNmJkM2FmY2IxZThlZWM4YjVlM2NiY2M",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/bb607c8407f98af336bd3afcb1e8eec8b5e3cbcc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/bb607c8407f98af336bd3afcb1e8eec8b5e3cbcc",
      "tree": {
        "sha": "b51e6061e36c3161597288d03023d0fbcbbb09a0",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/b51e6061e36c3161597288d03023d0fbcbbb09a0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c1e5827df696b13942837c741d4c0f88574c5d32",
          "sha": "c1e5827df696b13942837c741d4c0f88574c5d32",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c1e5827df696b13942837c741d4c0f88574c5d32"
        }
      ],
      "message": "silentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labeled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labeled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labeled\nsilent payment address.\n\nAdd tests for the label API.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T16:42:43Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-01-22T17:56:05Z"
      },
      "sha": "bb607c8407f98af336bd3afcb1e8eec8b5e3cbcc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDExNDRjNjIzOGJiZWM4YTZiMmUyZDBhNGQyNDk5OGQxOTJiY2U4MGI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1144c6238bbec8a6b2e2d0a4d24998d192bce80b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1144c6238bbec8a6b2e2d0a4d24998d192bce80b",
      "tree": {
        "sha": "12927a2464fa7ac6deea046b910433606ac979de",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/12927a2464fa7ac6deea046b910433606ac979de"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/bb607c8407f98af336bd3afcb1e8eec8b5e3cbcc",
          "sha": "bb607c8407f98af336bd3afcb1e8eec8b5e3cbcc",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/bb607c8407f98af336bd3afcb1e8eec8b5e3cbcc"
        }
      ],
      "message": "silentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled in a future release.\n\nAdd an opaque data type for passing around the prevout public key sum\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply the scan_key * input_hash before doing ECDH.\n\nFinally, add test coverage for the receiving API.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T16:46:34Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-10-02T14:18:13Z"
      },
      "sha": "1144c6238bbec8a6b2e2d0a4d24998d192bce80b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDNiOTlkZjQyMTM2MTUxY2QxNjVmOGYyMmU2ZDRjNWFhMDRhNmM4MGE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3b99df42136151cd165f8f22e6d4c5aa04a6c80a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3b99df42136151cd165f8f22e6d4c5aa04a6c80a",
      "tree": {
        "sha": "b85d60de07978205ae6a1ddab91387b9f1dcfca3",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/b85d60de07978205ae6a1ddab91387b9f1dcfca3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1144c6238bbec8a6b2e2d0a4d24998d192bce80b",
          "sha": "1144c6238bbec8a6b2e2d0a4d24998d192bce80b",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1144c6238bbec8a6b2e2d0a4d24998d192bce80b"
        }
      ],
      "message": "silentpayments: respect per-group recipients protocol limit (K_max=1000)\n\nThis affects both the sending and scanning API functions:\n* Sending fails if any group is exceeding the limit.\n* Scanning doesn't look beyond the limit.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T16:51:49Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-01-29T21:55:13Z"
      },
      "sha": "3b99df42136151cd165f8f22e6d4c5aa04a6c80a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDlmMDQzYzcxNTQzYWViZjRiNzg4ODhjMzU5YzUyYmYxMjg5ZGJhYWI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/9f043c71543aebf4b78888c359c52bf1289dbaab",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/9f043c71543aebf4b78888c359c52bf1289dbaab",
      "tree": {
        "sha": "b04c02808c683dd909e93490e2887d3dd8ef1ee2",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/b04c02808c683dd909e93490e2887d3dd8ef1ee2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3b99df42136151cd165f8f22e6d4c5aa04a6c80a",
          "sha": "3b99df42136151cd165f8f22e6d4c5aa04a6c80a",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3b99df42136151cd165f8f22e6d4c5aa04a6c80a"
        }
      ],
      "message": "silentpayments: add examples/silentpayments.c\n\nDemonstrate sending and scanning on full nodes.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T16:52:01Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-15T17:36:29Z"
      },
      "sha": "9f043c71543aebf4b78888c359c52bf1289dbaab"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGQ4NDliMGU4NDkzN2QwNWU5NGRhMDcyOGE5NzMyOTI5MWU4NTE1NzA",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/d849b0e84937d05e94da0728a97329291e851570",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/d849b0e84937d05e94da0728a97329291e851570",
      "tree": {
        "sha": "4766118167145c400d65f86594a3ab63b3b6353f",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/4766118167145c400d65f86594a3ab63b3b6353f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/9f043c71543aebf4b78888c359c52bf1289dbaab",
          "sha": "9f043c71543aebf4b78888c359c52bf1289dbaab",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/9f043c71543aebf4b78888c359c52bf1289dbaab"
        }
      ],
      "message": "silentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan, both for the common\ncase and worst-case (full-block sized tx) scenarios.\nOnly benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.\n\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T16:52:01Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-25T17:33:35Z"
      },
      "sha": "d849b0e84937d05e94da0728a97329291e851570"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDhiYTUzYWU0ODk2Yzg0NzcxODNlYWZkOGY5YTZkZWE3YzdjMDZjYmQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8ba53ae4896c8477183eafd8f9a6dea7c7c06cbd",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8ba53ae4896c8477183eafd8f9a6dea7c7c06cbd",
      "tree": {
        "sha": "96e9ec9b26545721d997dcc904e589ecbc745101",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/96e9ec9b26545721d997dcc904e589ecbc745101"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/d849b0e84937d05e94da0728a97329291e851570",
          "sha": "d849b0e84937d05e94da0728a97329291e851570",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/d849b0e84937d05e94da0728a97329291e851570"
        }
      ],
      "message": "silentpayments: optimize scanning by using batch inversion\n\nThis improves the worst-case scanning scenario performance by ~2.5x\nand also helps notably in the common case (\"no match\") scenario,\nespecially if the number of outputs is high:\n\nBenchmark results on parent commit (without optimization):\n\nsilentpayments_scan_nomatch_N=2         ,       43.0       ,       43.0       ,       43.0\nsilentpayments_scan_nomatch_N=5         ,       46.8       ,       46.8       ,       46.8\nsilentpayments_scan_nomatch_N=10        ,       53.5       ,       53.5       ,       53.5\nsilentpayments_scan_nomatch_N=100       ,      175.0       ,      177.0       ,      179.0\nsilentpayments_scan_nomatch_N=1000      ,     1425.0       ,     1430.0       ,     1435.0\nsilentpayments_scan_nomatch_N=2325      ,     3255.0       ,     3263.0       ,     3283.0\nsilentpayments_scan_nomatch_N=23255     ,    31986.0       ,    32167.0       ,    32253.0\nsilentpayments_scan_worstcase_K=10      ,   355978.0       ,   356131.0       ,   356397.0\nsilentpayments_scan_worstcase_K=100     ,  3236830.0       ,  3239816.0       ,  3245614.0\nsilentpayments_scan_worstcase_K=1000    , 31425734.0       , 31428156.0       , 31429507.0\n\nBenchmark results on this commit (with optimization):\n\nsilentpayments_scan_nomatch_N=2         ,       42.2       ,       42.2       ,       42.2\nsilentpayments_scan_nomatch_N=5         ,       43.6       ,       43.7       ,       43.7\nsilentpayments_scan_nomatch_N=10        ,       47.1       ,       47.1       ,       47.1\nsilentpayments_scan_nomatch_N=100       ,      100.0       ,      103.0       ,      109.0\nsilentpayments_scan_nomatch_N=1000      ,      651.0       ,      654.0       ,      658.0\nsilentpayments_scan_nomatch_N=2325      ,     1467.0       ,     1469.0       ,     1472.0\nsilentpayments_scan_nomatch_N=23255     ,    14329.0       ,    14340.0       ,    14366.0\nsilentpayments_scan_worstcase_K=10      ,   157345.0       ,   157423.0       ,   157477.0\nsilentpayments_scan_worstcase_K=100     ,  1440178.0       ,  1441172.0       ,  1441910.0\nsilentpayments_scan_worstcase_K=1000    , 13982912.0       , 13989653.0       , 14002783.0",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T17:14:09Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-16T02:30:40Z"
      },
      "sha": "8ba53ae4896c8477183eafd8f9a6dea7c7c06cbd"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDNlN2FmODkyMWU5NjdhZDNkZDhkMjZiNTc3MzhkMjBlMjZjOTAzMTg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3e7af8921e967ad3dd8d26b57738d20e26c90318",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3e7af8921e967ad3dd8d26b57738d20e26c90318",
      "tree": {
        "sha": "5774e51c4501fd9764fe6d5fe3b16d3b8c30e10a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/5774e51c4501fd9764fe6d5fe3b16d3b8c30e10a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8ba53ae4896c8477183eafd8f9a6dea7c7c06cbd",
          "sha": "8ba53ae4896c8477183eafd8f9a6dea7c7c06cbd",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8ba53ae4896c8477183eafd8f9a6dea7c7c06cbd"
        }
      ],
      "message": "tests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h\n\nCo-authored-by: Ron <4712150+macgyver13@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\nCo-authored-by: Tim Ruffing <1071625+real-or-random@users.noreply.github.com>",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T17:14:13Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-02T17:45:43Z"
      },
      "sha": "3e7af8921e967ad3dd8d26b57738d20e26c90318"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDdlNDA4ZDZhMzJkZjg5ZDZkMTE5MDYyOGRkOTg0NWQ4ZTIzZTljNDg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7e408d6a32df89d6d1190628dd9845d8e23e9c48",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7e408d6a32df89d6d1190628dd9845d8e23e9c48",
      "tree": {
        "sha": "f363b4d192b8214eff8c7a593461084a25a64ceb",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/f363b4d192b8214eff8c7a593461084a25a64ceb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3e7af8921e967ad3dd8d26b57738d20e26c90318",
          "sha": "3e7af8921e967ad3dd8d26b57738d20e26c90318",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3e7af8921e967ad3dd8d26b57738d20e26c90318"
        }
      ],
      "message": "tests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T17:14:13Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-11-07T12:18:59Z"
      },
      "sha": "7e408d6a32df89d6d1190628dd9845d8e23e9c48"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGVmMWFkNzA3NjM5NThjY2RjNmRmMWFkNmQ3NjU5ODU0MWE0YmRhODE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/ef1ad70763958ccdc6df1ad6d76598541a4bda81",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/ef1ad70763958ccdc6df1ad6d76598541a4bda81",
      "tree": {
        "sha": "54fd2f833f1dc4a5f68d29f7b0b033c20ea748f5",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/54fd2f833f1dc4a5f68d29f7b0b033c20ea748f5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/7e408d6a32df89d6d1190628dd9845d8e23e9c48",
          "sha": "7e408d6a32df89d6d1190628dd9845d8e23e9c48",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/7e408d6a32df89d6d1190628dd9845d8e23e9c48"
        }
      ],
      "message": "tests: add sha256 tag test\n\nTest midstate tags used in silent payments.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T17:14:13Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T08:46:46Z"
      },
      "sha": "ef1ad70763958ccdc6df1ad6d76598541a4bda81"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDNmNzFlMzkyNDNkYjI3ZWEyYjdkNTBlMGRlMzhhYTBiOTM0ZGRmNGQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3f71e39243db27ea2b7d50e0de38aa0b934ddf4d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3f71e39243db27ea2b7d50e0de38aa0b934ddf4d",
      "tree": {
        "sha": "85e0a7078ac2906b16f3f42ce9d85fd93347084a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/85e0a7078ac2906b16f3f42ce9d85fd93347084a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/ef1ad70763958ccdc6df1ad6d76598541a4bda81",
          "sha": "ef1ad70763958ccdc6df1ad6d76598541a4bda81",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/ef1ad70763958ccdc6df1ad6d76598541a4bda81"
        }
      ],
      "message": "ci: enable silentpayments module",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T17:14:13Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-02-22T23:25:41Z"
      },
      "sha": "3f71e39243db27ea2b7d50e0de38aa0b934ddf4d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDI1OTgwZTgyNjUxYjhiYjMzMTYxMTJhZGE4ZGRmYjk1OTJiNjljYWY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/25980e82651b8bb3316112ada8ddfb9592b69caf",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/25980e82651b8bb3316112ada8ddfb9592b69caf",
      "tree": {
        "sha": "125e0c33fec2d66923b5e9ef3e3c73abf62ff7c0",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/125e0c33fec2d66923b5e9ef3e3c73abf62ff7c0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3f71e39243db27ea2b7d50e0de38aa0b934ddf4d",
          "sha": "3f71e39243db27ea2b7d50e0de38aa0b934ddf4d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3f71e39243db27ea2b7d50e0de38aa0b934ddf4d"
        }
      ],
      "message": "docs: update README",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2026-02-18T17:14:13Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-12T12:57:54Z"
      },
      "sha": "25980e82651b8bb3316112ada8ddfb9592b69caf"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22892694822,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAVUgs0m",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/22892694822",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/25980e82651b8bb3316112ada8ddfb9592b69caf",
      "created_at": "2026-02-18T18:23:01Z"
    },
    {
      "event": "commented",
      "id": 3922513145,
      "node_id": "IC_kwDOAP4Jqs7pzMz5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3922513145",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-18T18:40:49Z",
      "updated_at": "2026-02-18T18:40:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the feedback!\r\n\r\nForce-pushed with the following changes:\r\n- Added an API docs `WARNING` about label creation and wallet interoperability, [as suggested above](https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3909600988)\r\n- Included a separate commit that implements batch inversion (using `secp256k1_ge_set_all_gej_var`) for label scanning (see the [before/after `bench silentpayments` benchmark results in the commit message](https://github.com/bitcoin-core/secp256k1/pull/1765/changes/8ba53ae4896c8477183eafd8f9a6dea7c7c06cbd))\r\n- Renamed various variables in the scanning function for more clarity (`output_ge` -> `unlabeled_output_ge`, `output_xonly` -> `unlabeled_output_xonly`, `spend_pubkey` -> `unlabeled_spend_pubkey`, `output_tweak_scalar` -> `t_k_scalar`)\r\n\r\nThe next steps would be to update the BIP for introducing the K_max value and to include a warning about wallet interoperability there as well (I agree that it's a good idea to do that).",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3922513145",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2528111908",
      "pull_request_review_id": 3465700051,
      "id": 2528111908,
      "node_id": "PRRC_kwDOAP4Jqs6Wr-0k",
      "diff_hunk": "@@ -0,0 +1,685 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    ret &= !secp256k1_scalar_is_zero(input_hash_scalar);\n+    return ret & !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group elemement because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t j, k, found_idx;\n+    int found, combined, valid_scan_key, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    valid_scan_key = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &valid_scan_key, sizeof(valid_scan_key));\n+    if (!valid_scan_key) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+    /* Clear the scan_key_scalar since we no longer need it and leaking this value would break indistinguishability of the transaction. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+\n+    found_idx = 0;\n+    for (k = 0; k < n_tx_outputs; k++) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (j = 0; j < n_tx_outputs; j++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[j]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = j;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[j]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej_var(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded.\n+                 *\n+                 * Note: serialize will also fail if label_ge is the point at infinity, but we know\n+                 * this cannot happen since we only hit this branch if tx_output != output_xonly.\n+                 * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\n+                 * point at infinity.\n+                 */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = j;\n+                    break;\n+                }\n+\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 *     label2 = -tx_output - generated_output\n+                 */\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej_var(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded.\n+                 *\n+                 * Note: serialize will also fail if label_ge is the point at infinity, but we know\n+                 * this cannot happen since we only hit this branch if tx_output != output_xonly.\n+                 * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 625,
      "commit_id": "c11d30c25f75776920797b017a568ea0cfc28882",
      "original_commit_id": "c11d30c25f75776920797b017a568ea0cfc28882",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Should be `- tx_output_gej`?",
      "created_at": "2025-11-14T16:21:51Z",
      "updated_at": "2025-11-14T16:25:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2528111908",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2528111908"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 625,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2590644412",
      "pull_request_review_id": 3542178806,
      "id": 2590644412,
      "node_id": "PRRC_kwDOAP4Jqs6aahi8",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 237,
      "original_position": 216,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin-core/secp256k1/commit/ffffd7ff98368b29759cd3d9933896fb9fa69b1f:\r\n\r\nwhat if `plain_seckeys[i]` is null? (same for `taproot_seckeys[I]` below).",
      "created_at": "2025-12-04T21:31:07Z",
      "updated_at": "2025-12-05T19:33:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2590644412",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2590644412"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 237,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593243357",
      "pull_request_review_id": 3542178806,
      "id": 2593243357,
      "node_id": "PRRC_kwDOAP4Jqs6akcDd",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In ffffd7ff98368b29759cd3d9933896fb9fa69b1f:\r\n\r\nAs `k` depends on `n_recipients`, wouldn't be simpler to ensure that `n_recipients < UINT32_MAX` early on the function? \r\n```C\r\nARG_CHECK(n_recipients > 0 && n_recipients < UINT32_MAX);\r\n```",
      "created_at": "2025-12-05T16:23:53Z",
      "updated_at": "2025-12-05T19:33:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2593243357",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593243357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593365138",
      "pull_request_review_id": 3542178806,
      "id": 2593365138,
      "node_id": "PRRC_kwDOAP4Jqs6ak5yS",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "q: Instead of having this weird `index` field in the public API, wouldn't be simpler to include the generated output directly inside `secp256k1_silentpayments_recipient`?\r\nE.g.\r\n```c\r\nstruct secp256k1_silentpayments_recipient {\r\n    /* Inputs */\r\n    secp256k1_pubkey in_scan_pubkey;\r\n    secp256k1_pubkey in_spend_pubkey;\r\n    /* Output */\r\n    secp256k1_xonly_pubkey out_generated_output;\r\n}\r\n```",
      "created_at": "2025-12-05T17:04:18Z",
      "updated_at": "2025-12-05T19:33:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2593365138",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593365138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 49,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": 52,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593673524",
      "pull_request_review_id": 3542178806,
      "id": 2593673524,
      "node_id": "PRRC_kwDOAP4Jqs6amFE0",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 288,
      "original_position": 266,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin-core/secp256k1/commit/ffffd7ff98368b29759cd3d9933896fb9fa69b1f:\r\n\r\nThis is not realistically possible but.. should also check that the input hash scalar is not the inverse of the aggr sk (aka the result is not 1).",
      "created_at": "2025-12-05T19:00:36Z",
      "updated_at": "2025-12-05T21:59:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2593673524",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593673524"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 284,
      "original_start_line": 266,
      "start_side": "RIGHT",
      "line": 288,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593733673",
      "pull_request_review_id": 3542178806,
      "id": 2593733673,
      "node_id": "PRRC_kwDOAP4Jqs6amTwp",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 165,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin-core/secp256k1/commit/ffffd7ff98368b29759cd3d9933896fb9fa69b1f:\r\n\r\nExtra semicolon here.",
      "created_at": "2025-12-05T19:22:19Z",
      "updated_at": "2025-12-05T19:33:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2593733673",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593733673"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594361262",
      "pull_request_review_id": 3546882246,
      "id": 2594361262,
      "node_id": "PRRC_kwDOAP4Jqs6aos-u",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 237,
      "original_position": 216,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2590644412,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Good catch, will add an `ARG_CHECK` to check for non-NULL, here and in other API functions (scanning) where similar checks for \"array of pointers\" elements are missing. I've also opened https://github.com/bitcoin-core/secp256k1/pull/1779 to do the same for API functions in master for consistency.",
      "created_at": "2025-12-06T01:47:43Z",
      "updated_at": "2025-12-06T01:48:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2594361262",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594361262"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 237,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594444863",
      "pull_request_review_id": 3547039916,
      "id": 2594444863,
      "node_id": "PRRC_kwDOAP4Jqs6apBY_",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think this change would be slightly simpler for the implementation, but possibly quite confusing for the user. Note that the passed in `_silentpayments_recipient` array gets sorted in place (to group by scan pubkey), so we need some way to map the generated outputs back to the original recipients. Doing this by just keeping the original order (that's what the `index` field is needed for) seems the most obvious (expected?) way. Admittedly with your proposed change an user would have the necessary information to do the mapping themselves, but it seems odd to e.g. pass in two recipients (r1, r2), get the result back in a different order (r2, r1) and then having to find out again at what position each recipient has moved, in order to get the corresponding generated output each.",
      "created_at": "2025-12-06T02:34:28Z",
      "updated_at": "2025-12-06T02:34:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2594444863",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594444863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 49,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": 52,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594454594",
      "pull_request_review_id": 3547054404,
      "id": 2594454594,
      "node_id": "PRRC_kwDOAP4Jqs6apDxC",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593243357,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Bounding the number of recipients seems reasonable to me (even though by protocol they could exceed the 32-bit range in theory, if they are not going all to the same scan pubkey, and we would at some point allow ~185 GB sized transactions :p). I wonder if we could even just set the type of `n_recipients` to uint32_t instead of size_t, so the limit is already enforced at compile-time? IIRC there were some previous discussions between @josibake and @jonasnick about that topic (in take 3 or 2 of this PR), will look those up next week before changing.",
      "created_at": "2025-12-06T02:52:17Z",
      "updated_at": "2025-12-06T02:52:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2594454594",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594454594"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594483205",
      "pull_request_review_id": 3547105035,
      "id": 2594483205,
      "node_id": "PRRC_kwDOAP4Jqs6apKwF",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 288,
      "original_position": 266,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593673524,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm trying to wrap my head around on what the exact implications would be if that indeed happened. If $a * inputhash = 1$,the shared secret would then be equal to the recipient spend public key $B_{scan}$. That sounds problematic, I suppose it's a loss of privacy as the output tweaks are revealed, but the funds are still safe?\r\n(Wouldn't any other small-ish value also be problematic, as guessing $2* B_{scan}, 3*B_{scan}$ etc. is trivial as well?).",
      "created_at": "2025-12-06T03:39:29Z",
      "updated_at": "2025-12-06T03:39:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2594483205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594483205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 284,
      "original_start_line": 266,
      "start_side": "RIGHT",
      "line": 288,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595102919",
      "pull_request_review_id": 3547827183,
      "id": 2595102919,
      "node_id": "PRRC_kwDOAP4Jqs6ariDH",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Admittedly with your proposed change an user would have the necessary information to do the mapping themselves, but it seems odd to e.g. pass in two recipients (r1, r2), get the result back in a different order (r2, r1) and then having to find out again at what position each recipient has moved, in order to get the corresponding generated output each.\r\n\r\nIf you have all the information, does the initial ordering matter?\r\n\r\n================================================================================\r\n\r\nAlso, I woke up creative.. another idea to remove the `index` field could be to store the initial ordering inside the `generated_outputs` array. We basically have a `n_recipients` size array with elements that are essentially buffers :).\r\nSo.. we could do something like:\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\n--- a/src/modules/silentpayments/main_impl.h\t(revision ffffd7ff98368b29759cd3d9933896fb9fa69b1f)\r\n+++ b/src/modules/silentpayments/main_impl.h\t(date 1765038514517)\r\n@@ -185,13 +185,14 @@\r\n     const unsigned char * const *plain_seckeys,\r\n     size_t n_plain_seckeys\r\n ) {\r\n-    size_t i, k;\r\n+    size_t i, k, j;\r\n     secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\r\n     secp256k1_ge prevouts_pubkey_sum_ge;\r\n     secp256k1_gej prevouts_pubkey_sum_gej;\r\n     unsigned char shared_secret[33];\r\n     secp256k1_pubkey current_scan_pubkey;\r\n     int ret, sum_is_zero;\r\n+    secp256k1_xonly_pubkey *output = NULL;\r\n \r\n     /* Sanity check inputs. */\r\n     VERIFY_CHECK(ctx != NULL);\r\n@@ -211,9 +212,6 @@\r\n     } else {\r\n         ARG_CHECK(n_plain_seckeys == 0);\r\n     }\r\n-    for (i = 0; i < n_recipients; i++) {\r\n-        ARG_CHECK(recipients[i]->index == i);\r\n-    }\r\n \r\n     seckey_sum_scalar = secp256k1_scalar_zero;\r\n     for (i = 0; i < n_plain_seckeys; i++) {\r\n@@ -268,6 +266,13 @@\r\n         return 0;\r\n     }\r\n     secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\r\n+\r\n+    /* Store recipients ordering prior to sorting the array */\r\n+    for (i = 0; i < n_recipients; i++) {\r\n+        /* Use the output struct as a buffer for storing the pointer of the recipient */\r\n+        memcpy(generated_outputs[i]->data, &recipients[i], sizeof(secp256k1_silentpayments_recipient*));\r\n+    }\r\n+\r\n     /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\r\n      * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\r\n      *\r\n@@ -294,7 +299,17 @@\r\n             secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\r\n             k = 0;\r\n         }\r\n-        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\r\n+\r\n+        /* Look-up for the correct output to initialize based on the initial ordering */\r\n+        for (j = 0; j < n_recipients; j++) {\r\n+            secp256k1_silentpayments_recipient *ptr = NULL;\r\n+            memcpy(&ptr, generated_outputs[j]->data, sizeof(secp256k1_silentpayments_recipient*));\r\n+            if (ptr == recipients[i]) {\r\n+                output = generated_outputs[j];\r\n+            }\r\n+        }\r\n+\r\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, output, shared_secret, &recipients[i]->spend_pubkey, k)) {\r\n             secp256k1_scalar_clear(&seckey_sum_scalar);\r\n             secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\r\n             return 0;\r\n\r\n===================================================================\r\ndiff --git a/include/secp256k1_silentpayments.h b/include/secp256k1_silentpayments.h\r\n--- a/include/secp256k1_silentpayments.h\t(revision ffffd7ff98368b29759cd3d9933896fb9fa69b1f)\r\n+++ b/include/secp256k1_silentpayments.h\t(date 1765038119367)\r\n@@ -45,7 +45,6 @@\r\n typedef struct secp256k1_silentpayments_recipient {\r\n     secp256k1_pubkey scan_pubkey;\r\n     secp256k1_pubkey spend_pubkey;\r\n-    size_t index;\r\n } secp256k1_silentpayments_recipient;\r\n \r\n /** Create Silent Payments outputs for recipient(s).\r\n\r\n\r\n===================================================================\r\ndiff --git a/src/modules/silentpayments/tests_impl.h b/src/modules/silentpayments/tests_impl.h\r\n--- a/src/modules/silentpayments/tests_impl.h\t(revision ffffd7ff98368b29759cd3d9933896fb9fa69b1f)\r\n+++ b/src/modules/silentpayments/tests_impl.h\t(date 1765038518151)\r\n@@ -98,7 +98,6 @@\r\n     for (i = 0; i < 3; i++) {\r\n         CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\r\n         CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey,(*sp_addresses[i])[1], 33));\r\n-        recipients[i].index = i;\r\n         recipient_ptrs[i] = &recipients[i];\r\n         generated_output_ptrs[i] = &generated_outputs[i];\r\n     }\r\n@@ -174,7 +173,6 @@\r\n         CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].scan_pubkey, (*sp_addresses[i])[0], 33));\r\n         CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].spend_pubkey,(*sp_addresses[i])[1], 33));\r\n         /* Set the index value incorrectly */\r\n-        r[i].index = 0;\r\n         rp[i] = &r[i];\r\n         op[i] = &o[i];\r\n     }\r\n@@ -183,13 +181,6 @@\r\n     t[0] = &taproot;\r\n     p[0] = ALICE_SECKEY;\r\n \r\n-    /* Fails if the index is set incorrectly */\r\n-    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\r\n-\r\n-    /* Set the index correctly for the next tests */\r\n-    for (i = 0; i < 2; i++) {\r\n-        r[i].index = i;\r\n-    }\r\n     CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\r\n \r\n     /* Check that null arguments are handled */\r\n@@ -257,7 +248,6 @@\r\n         CHECK(secp256k1_ec_pubkey_negate(CTX, &neg_spend_pubkey));\r\n         r[0].spend_pubkey = neg_spend_pubkey;\r\n         for (i = 0; i < 2; i++) {\r\n-            r[i].index = i;\r\n             rp[i] = &r[i];\r\n         }\r\n         CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\r\n```\r\n\r\n----------------------\r\n\r\nThat being said, this improves the public API at the cost of making the internal code a bit more complex. So Im not strong on it  I just had some fun thinking about different ways to remove the ugly `index` field. So no need to take it.",
      "created_at": "2025-12-06T16:36:29Z",
      "updated_at": "2025-12-06T16:42:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595102919",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595102919"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 49,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": 52,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595796731",
      "pull_request_review_id": 3548663278,
      "id": 2595796731,
      "node_id": "PRRC_kwDOAP4Jqs6auLb7",
      "diff_hunk": "@@ -0,0 +1,273 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../unit_test.h\"\n+\n+/** Constants\n+ *\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f,\n+        0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11,\n+        0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed,\n+        0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7,\n+        0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46, 0x0d, 0x68, 0x08, 0x65, 0x64, 0x45, 0xee,\n+    0x4d, 0x4e, 0xc0, 0x8e, 0xba, 0x8a, 0x66, 0xea,\n+    0x66, 0x8e, 0x4e, 0x12, 0x98, 0x9a, 0x0e, 0x60,\n+    0x4b, 0x5c, 0x36, 0x0e, 0x43, 0xf5, 0x5a, 0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7, 0xf3, 0xc6, 0x79, 0x30, 0x4a, 0xef, 0x8c,\n+    0xc0, 0xc7, 0x61, 0xf1, 0x00, 0x99, 0xdd, 0x7b,\n+    0x20, 0x65, 0x20, 0xd7, 0x11, 0x6f, 0xb7, 0x91,\n+    0xee, 0x74, 0x54, 0xa2, 0xfc, 0x22, 0x79, 0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b, 0x81, 0x34, 0x5d, 0x53, 0x89, 0xba, 0xa3,\n+    0xd8, 0x93, 0xe2, 0xfb, 0xe7, 0x08, 0xdd, 0x6d,\n+    0x82, 0xdc, 0xd8, 0x49, 0xab, 0x03, 0xc1, 0xdb,\n+    0x68, 0xbe, 0xc7, 0xe9, 0x2a, 0x45, 0xfa, 0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea, 0xdc, 0x78, 0x16, 0x5f, 0xf1, 0xf8, 0xea,\n+    0x94, 0xad, 0x7c, 0xfd, 0xc5, 0x49, 0x90, 0x73,\n+    0x8a, 0x4c, 0x53, 0xf6, 0xe0, 0x50, 0x7b, 0x42,\n+    0x15, 0x42, 0x01, 0xb8, 0xe5, 0xdf, 0xf3, 0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret == 1);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    /* Note: in this case, the second output for Carol comes before the first.\n+     * This is because heapsort is an unstable sorting algorithm, i.e., the ordering\n+     * of identical elements is not guaranteed to be preserved\n+     */\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &CAROL_OUTPUT_ONE;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 157,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In ffffd7ff98368b29759cd3d9933896fb9fa69b1f:\r\n\r\nThe heapsort comment was a bit misleading to me. It only matters because were hardcoding the expected outputs, but it's not something we actually care about.\r\n\r\nThe goal of the test is to make sure that shuffling the inputted recipients never changes which outputs are produced, and that each expected output appears exactly once.\r\n\r\nSo we dont need to rely on any final ordering assumptions at all; they depend on heapsorts stability, which (per comment) is unstable. Take the following if you like it:\r\n\r\n```C\r\nstatic void shuffle(unsigned char (*sp_addresses[])[2][33], size_t size) {\r\n    size_t i, j;\r\n    for (i = size - 1; i > 0; i--) {\r\n        unsigned char (*tmp)[2][33] = sp_addresses[i];\r\n        j = testrand_bits(8) % (i + 1);\r\n        sp_addresses[i] = sp_addresses[j];\r\n        sp_addresses[j] = tmp;\r\n    }\r\n}\r\n\r\n/* Ensure that shuffling the inputted recipients never changes\r\n * which outputs are produced, and that each expected output\r\n * appears exactly once */\r\nstatic void test_recipient_sort(void) {\r\n    int i, j;\r\n    unsigned char (*sp_addresses[3])[2][33] = { &CAROL_ADDRESS, &CAROL_ADDRESS, &BOB_ADDRESS };\r\n    unsigned char const *seckey_ptrs[1] = { ALICE_SECKEY };\r\n    unsigned char xonly_ser[32];\r\n\r\n    secp256k1_silentpayments_recipient recipients[3];\r\n    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\r\n    secp256k1_xonly_pubkey generated_outputs[3];\r\n    secp256k1_xonly_pubkey *generated_output_ptrs[3];\r\n\r\n    for (i = 0; i < 6; i++) {\r\n        int pos_bob = -1, pos_carol_one = -1, pos_carol_two = -1;\r\n\r\n        /* Randomize array */\r\n        shuffle(sp_addresses, 3);\r\n\r\n        for (j = 0; j < 3; j++) {\r\n            CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[j].scan_pubkey, (*sp_addresses[j])[0], 33));\r\n            CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[j].spend_pubkey,(*sp_addresses[j])[1], 33));\r\n            recipients[j].index = j;\r\n            recipient_ptrs[j] = &recipients[j];\r\n            generated_output_ptrs[j] = &generated_outputs[j];\r\n        }\r\n        CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, generated_output_ptrs,\r\n                                                             recipient_ptrs, 3,\r\n                                                             SMALLEST_OUTPOINT,\r\n                                                             NULL, 0,\r\n                                                             seckey_ptrs, 1) == 1);\r\n\r\n        /* Verify output correctness and they all appear once */\r\n        for (j = 0; j < 3; j++) {\r\n            int* pos = NULL;\r\n            CHECK(secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[j]));\r\n            if (secp256k1_memcmp_var(xonly_ser, BOB_OUTPUT, 32) == 0) {\r\n                pos = &pos_bob;\r\n            } else if (secp256k1_memcmp_var(xonly_ser, CAROL_OUTPUT_ONE, 32) == 0) {\r\n                pos = &pos_carol_one;\r\n            } else if (secp256k1_memcmp_var(xonly_ser, CAROL_OUTPUT_TWO, 32) == 0) {\r\n                pos = &pos_carol_two;\r\n            } else {\r\n                TEST_FAILURE(\"Error: unknown generated output\");\r\n            }\r\n            CHECK(*pos == -1); /* enforce uniqueness */\r\n            *pos = j;\r\n        }\r\n    }\r\n}\r\n```",
      "created_at": "2025-12-07T01:35:49Z",
      "updated_at": "2025-12-07T01:49:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595796731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595796731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 127,
      "original_start_line": 87,
      "start_side": "RIGHT",
      "line": 193,
      "original_line": 157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595909459",
      "pull_request_review_id": 3548792135,
      "id": 2595909459,
      "node_id": "PRRC_kwDOAP4Jqs6aum9T",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> If you have all the information, does the initial ordering matter?\r\n\r\nIn theory it doesn't, in practice I think some users would be at least surprised or annoyed by getting the generated outputs back in an order that is different from the passed in recipients (some might even lose money by confusing the amounts for e.g. the actual recipient and the change output).\r\n\r\n> Also, I woke up creative.. another idea to remove the index field could be to store the initial ordering inside the generated_outputs array. We basically have a n_recipients size array with elements that are essentially buffers :).\r\n\r\nThat's a neat and indeed very creative idea . (Ab)using a pubkey object's underlying memory for temporarily storing a pointer value feels very hacky though, so not sure if we want to introduce these kind of tricks in general. On the other hand, simplifying the API would be indeed a win, so I'm not fully opposed either. Curious what others think about this.",
      "created_at": "2025-12-07T03:58:14Z",
      "updated_at": "2025-12-07T03:58:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595909459",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595909459"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 49,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": 52,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595911929",
      "pull_request_review_id": 3548795863,
      "id": 2595911929,
      "node_id": "PRRC_kwDOAP4Jqs6aunj5",
      "diff_hunk": "@@ -0,0 +1,273 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../unit_test.h\"\n+\n+/** Constants\n+ *\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f,\n+        0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11,\n+        0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed,\n+        0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7,\n+        0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46, 0x0d, 0x68, 0x08, 0x65, 0x64, 0x45, 0xee,\n+    0x4d, 0x4e, 0xc0, 0x8e, 0xba, 0x8a, 0x66, 0xea,\n+    0x66, 0x8e, 0x4e, 0x12, 0x98, 0x9a, 0x0e, 0x60,\n+    0x4b, 0x5c, 0x36, 0x0e, 0x43, 0xf5, 0x5a, 0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7, 0xf3, 0xc6, 0x79, 0x30, 0x4a, 0xef, 0x8c,\n+    0xc0, 0xc7, 0x61, 0xf1, 0x00, 0x99, 0xdd, 0x7b,\n+    0x20, 0x65, 0x20, 0xd7, 0x11, 0x6f, 0xb7, 0x91,\n+    0xee, 0x74, 0x54, 0xa2, 0xfc, 0x22, 0x79, 0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b, 0x81, 0x34, 0x5d, 0x53, 0x89, 0xba, 0xa3,\n+    0xd8, 0x93, 0xe2, 0xfb, 0xe7, 0x08, 0xdd, 0x6d,\n+    0x82, 0xdc, 0xd8, 0x49, 0xab, 0x03, 0xc1, 0xdb,\n+    0x68, 0xbe, 0xc7, 0xe9, 0x2a, 0x45, 0xfa, 0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea, 0xdc, 0x78, 0x16, 0x5f, 0xf1, 0xf8, 0xea,\n+    0x94, 0xad, 0x7c, 0xfd, 0xc5, 0x49, 0x90, 0x73,\n+    0x8a, 0x4c, 0x53, 0xf6, 0xe0, 0x50, 0x7b, 0x42,\n+    0x15, 0x42, 0x01, 0xb8, 0xe5, 0xdf, 0xf3, 0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret == 1);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    /* Note: in this case, the second output for Carol comes before the first.\n+     * This is because heapsort is an unstable sorting algorithm, i.e., the ordering\n+     * of identical elements is not guaranteed to be preserved\n+     */\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &CAROL_OUTPUT_ONE;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 157,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2595796731,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks for taking a closer look there. I agree this could be improved.\r\n\r\n> The goal of the test is to make sure that shuffling the inputted recipients never changes which outputs are produced, and that each expected output appears exactly once.\r\n> \r\n> So we dont need to rely on any final ordering assumptions at all; they depend on heapsorts stability, which (per comment) is unstable.\r\n\r\nNote that order of the generated outputs does indeed matter and should be tested. The sending API as-is guarantees that for a passed in recipient at position i (`recipients[i]`), the generated output at the same position (`generated_outputs[i]`) can be found (and hence be spent later) by that exact recipient. The only thing not guaranteed due to unstable heap sort is the order in which the increasing k values are used for generating those outputs, for recipients that share the same scan public key.\r\n\r\nFor example, let's say we have three recipients, leading to three outputs:\r\nr0 = (scan_pk, spend_pk_A) -> tx_out0\r\nr1 = (scan_pk, spend_pk_B) -> tx_out1\r\nr2 = (scan_pk, spend_pk_C) -> tx_out2\r\n\r\nThese three recipients are all in one group, sharing the same `ecdh_shared_secret` (see BIP-352). The output tweak $t_k$ for creating depends on that shared secret and a counter k that is increased for each spend public key in the group, starting with k=0. Due to heap sort being unstable, the order in which these spend public keys are picked from the group to create outputs is not guaranteed, i.e. it might be that spend_pk_C is used first to create the output with k=0 (-> assigned to tx_out2), then spend_pk_A with k=1 (-> assigned to tx_out0) and lastly spend_pk_B with k=2 (-> assigned to tx_out1). For a recipient the k value that was used for output generation doesn't matter, they will still find them if they include all other tx outputs and follow the scanning protocol correctly. Note that assigning the generated outputs at the intended position (matching the recipient position) is done using the `index` field in the recipient data structure (see also previous related comment https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595909459).\r\n\r\nSo in the quoted test code,\r\n`CAROL_OUTPUT_ONE` means \"output to carol, generated with k=0\" and\r\n`CAROL_OUTPUT_TWO` means \"output to carol, generated with k=1\" accordingly.\r\nIf `sp_addresses[i]` is assigned to `BOB_ADDRESS`, `sp_outputs[i]` must be `BOB_OUTPUT` (this case is unambiguous, the bob's scan pubkey appears only once in the recipient list).\r\nIf `sp_adresses[i]` is assigned to `CAROL_ADDRESS`, `so_outputs[i]` must be either `CAROL_OUTPUT_ONE` or `CAROL_OUTPUT_TWO` (that scan pubkey appears twice in the recipient list, so the order within those is ambiguous).\r\n\r\nI will give this some more thoughts on how to better express this in the test, suggestions of course welcome.",
      "created_at": "2025-12-07T04:03:33Z",
      "updated_at": "2025-12-07T04:05:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595911929",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595911929"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 127,
      "original_start_line": 87,
      "start_side": "RIGHT",
      "line": 193,
      "original_line": 157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2596386385",
      "pull_request_review_id": 3549361073,
      "id": 2596386385,
      "node_id": "PRRC_kwDOAP4Jqs6awbZR",
      "diff_hunk": "@@ -0,0 +1,273 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../unit_test.h\"\n+\n+/** Constants\n+ *\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f,\n+        0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11,\n+        0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed,\n+        0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7,\n+        0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46, 0x0d, 0x68, 0x08, 0x65, 0x64, 0x45, 0xee,\n+    0x4d, 0x4e, 0xc0, 0x8e, 0xba, 0x8a, 0x66, 0xea,\n+    0x66, 0x8e, 0x4e, 0x12, 0x98, 0x9a, 0x0e, 0x60,\n+    0x4b, 0x5c, 0x36, 0x0e, 0x43, 0xf5, 0x5a, 0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7, 0xf3, 0xc6, 0x79, 0x30, 0x4a, 0xef, 0x8c,\n+    0xc0, 0xc7, 0x61, 0xf1, 0x00, 0x99, 0xdd, 0x7b,\n+    0x20, 0x65, 0x20, 0xd7, 0x11, 0x6f, 0xb7, 0x91,\n+    0xee, 0x74, 0x54, 0xa2, 0xfc, 0x22, 0x79, 0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b, 0x81, 0x34, 0x5d, 0x53, 0x89, 0xba, 0xa3,\n+    0xd8, 0x93, 0xe2, 0xfb, 0xe7, 0x08, 0xdd, 0x6d,\n+    0x82, 0xdc, 0xd8, 0x49, 0xab, 0x03, 0xc1, 0xdb,\n+    0x68, 0xbe, 0xc7, 0xe9, 0x2a, 0x45, 0xfa, 0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea, 0xdc, 0x78, 0x16, 0x5f, 0xf1, 0xf8, 0xea,\n+    0x94, 0xad, 0x7c, 0xfd, 0xc5, 0x49, 0x90, 0x73,\n+    0x8a, 0x4c, 0x53, 0xf6, 0xe0, 0x50, 0x7b, 0x42,\n+    0x15, 0x42, 0x01, 0xb8, 0xe5, 0xdf, 0xf3, 0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret == 1);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    /* Note: in this case, the second output for Carol comes before the first.\n+     * This is because heapsort is an unstable sorting algorithm, i.e., the ordering\n+     * of identical elements is not guaranteed to be preserved\n+     */\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &CAROL_OUTPUT_ONE;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 157,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2595796731,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I did this with my brain based on the other comment; the one I'm saying \"If you have all the information, does the initial ordering matter?\" ([https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595102919](https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595102919)). I just read your response there. Thanks.\r\n\r\nWe can easily adapt the generalized test to verify that the initial recipients ordering matches the final outputs order. We just need to cache their initial positions during creation (post-shuffle), then check that Bob stays in the same spot and that the two Carols appear exactly once, working around the heapsort instability. That is simple to do.\r\n\r\nOverall, this latest test covers strictly more cases than the previous one. And with this approach, we can also easily confirm were not biased by the fixed number of outputs we currently have (right now we only verify arrays of length 3). E.g. it would be nice to test against arrays of length two as well. Also, something very important, it would be good to test `k` is increased for a second output from Bob when there are two outputs for Carol (If `k` is only ever increased and not reset or something unexpected happens, we do have a major issue).\r\nI'm not expecting this ^^ to fail, it is just test coverage we should have.",
      "created_at": "2025-12-07T15:30:07Z",
      "updated_at": "2025-12-07T15:30:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2596386385",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2596386385"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 127,
      "original_start_line": 87,
      "start_side": "RIGHT",
      "line": 193,
      "original_line": 157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2599453964",
      "pull_request_review_id": 3553138859,
      "id": 2599453964,
      "node_id": "PRRC_kwDOAP4Jqs6a8IUM",
      "diff_hunk": "@@ -126,6 +126,60 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 25,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "913fdee7e17b0f69a8e70b9876be47c6a887ff32",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm unsure about the label use-case so far but leaving that topic aside (will keep thinking about it),\r\n\r\nI'm wondering if we could use a typedef for the label here instead of relying on the public key structure.\r\nAt least for me, public keys are meant for sending coins to, and we dont want anyone sending coins to the group element `label = hash(scan_key || m) * G`. Clarifying the intent with a simple typedef might save us a few headaches.",
      "created_at": "2025-12-08T17:16:49Z",
      "updated_at": "2025-12-08T20:28:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2599453964",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2599453964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 148,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2603766315",
      "pull_request_review_id": 3558903592,
      "id": 2603766315,
      "node_id": "PRRC_kwDOAP4Jqs6bMlIr",
      "diff_hunk": "@@ -126,6 +126,60 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 25,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "913fdee7e17b0f69a8e70b9876be47c6a887ff32",
      "in_reply_to_id": 2599453964,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The idea of avoiding the pubkey type for labels has some merit, though I think that introducing a typedef alone would not completely solve the problem. In order to (de)serialize labels (needed to e.g. create entries for the labels cache, or load labels from wallet backups), a user has to call the `secp256k1_pubkey_{serialize,parse}` functions, i.e. the \"pubkey\" terminology would still show up and be mixed with `_silentpayments_label` types (which might even be more confusing for users). Should we introduce aliases for these functions as well? Or, maybe having the typedef alone would still be better than not having it (with proper documentation), will give this some more thoughts.",
      "created_at": "2025-12-09T18:11:33Z",
      "updated_at": "2025-12-09T18:11:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2603766315",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2603766315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 148,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2609620541",
      "pull_request_review_id": 3566255305,
      "id": 2609620541,
      "node_id": "PRRC_kwDOAP4Jqs6bi6Y9",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593243357,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Bounding the number of recipients seems reasonable to me (even though by protocol they could exceed the 32-bit range in theory, if they are not going all to the same scan pubkey, and we would at some point allow ~185 GB sized transactions :p).\r\n\r\nSince noone has a machine with infinite memory, any implementation of the protocol will need to have *some* limit. I think this simply shows that the protocol spec could be improved. There should be reasonable limits for all arrays. Sometimes they're implied, e.g., if the size is serialization in a fixed-length integer, but sometimes they're not. Even if they're implied, it will be better to be explicit in the BIP and just state the limit.\r\n\r\nThis is something I learned from working on multiple BIPs that specify schemes with arrays or other containers. When you write the spec, you want it to be implementable on many platforms, so you try not to be too specific when it comes to choices like maximum sizes. But later, when you go ahead and actually implement the thing, you feel it would be great if the spec would just tell you the limit (because this would have prevented this entire discussion). \r\n \r\n> I wonder if we could even just set the type of `n_recipients` to uint32_t instead of size_t, so the limit is already enforced at compile-time? IIRC there were some previous discussions between @josibake and @jonasnick about that topic (in take 3 or 2 of this PR), will look those up next week before changing.\r\n\r\nI can't remember these discussions, but using `uint32_t` is the most natural thing to do. And then we should update the BIP to make that clear in the spec.\r\n",
      "created_at": "2025-12-11T08:18:55Z",
      "updated_at": "2025-12-11T08:18:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2609620541",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2609620541"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2609841176",
      "pull_request_review_id": 3566518130,
      "id": 2609841176,
      "node_id": "PRRC_kwDOAP4Jqs6bjwQY",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> That's a neat and indeed very creative idea . (Ab)using a pubkey object's underlying memory for temporarily storing a pointer value feels very hacky though, so not sure if we want to introduce these kind of tricks in general. On the other hand, simplifying the API would be indeed a win, so I'm not fully opposed either. Curious what others think about this.\r\n\r\nMy thinking is that I'm slightly in favor. This is not as crazy as it may look. The `data` member of the pubkey is even `unsigned char`, so this should be perfectly legal in C. (If people have doubts, we could even convert to `intptr_t` first and then read out the individual chars from an actual integer type.)\r\n\r\nI have thought of getting rid of `index`, including hacky ways, but somehow I didn't see this way. \r\n\r\nedit: But it will be nice to hear other people's opinions. There was a lot of discussion about the thing already. I can imagine that others had found this approach but rejected it for various reasons.",
      "created_at": "2025-12-11T09:29:29Z",
      "updated_at": "2025-12-11T10:34:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2609841176",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2609841176"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 49,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": 52,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610038006",
      "pull_request_review_id": 3566752113,
      "id": 2610038006,
      "node_id": "PRRC_kwDOAP4Jqs6bkgT2",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 288,
      "original_position": 266,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593673524,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "\r\n\r\n\r\n> In [ffffd7f](https://github.com/bitcoin-core/secp256k1/commit/ffffd7ff98368b29759cd3d9933896fb9fa69b1f):\r\n> \r\n> This is not realistically possible but.. should also check that the input hash scalar is not the inverse of the aggr sk (aka the result is not 1).\r\n\r\nHm, what should go wrong? 1 is a valid secret key for ECDH.\r\n\r\n> I'm trying to wrap my head around on what the exact implications would be if that indeed happened. If $a * inputhash = 1$,the shared secret would then be equal to the recipient spend public key $B_{scan}$. That sounds problematic, I suppose it's a loss of privacy as the output tweaks are revealed, but the funds are still safe?\r\n(Wouldn't any other small-ish value also be problematic, as guessing $2* B_{scan}, 3*B_{scan}$ etc. is trivial as well?).\r\n\r\nNo, I think this is a (common) misconception. With this argument, *any* value would be bad. If the secret key was `1784a975e6545c8cdb932dd228de6d6c`, wouldn't this be bad. If the attacker guessed that value, then privacy would be lost? \r\n\r\n<details>\r\n<summary>Some background</summary>\r\n\r\nSmall values will be easier to guess for attackers that start guessing at 0 (or 1). But there's no point in assuming a specific attacker. What matters here to the sender is just that it will be sufficiently unpredictable (because the raw shared secret goes into a hash), i.e., it has sufficient entropy from the attacker's perspective.\r\n\r\nI think what adds to this misconception is that the situation is more complex for \"human-chosen\" random, e.g., passwords. It's bad to use \"hamster\" as a password because it's an actual word, and so humans are more likely to pick it. Real attackers make use of that fact. So even if the space of allowed passwords is huge, letting a person pick one may yield enough entropy (depending on the person). The point here is that the process of generating a password is not clearly specified and depends on the person.  \r\n\r\nBut cryptography is usually simpler. We know the exact process of generating a secret key, and so we know the exact distribution of secret keys. Typically, secret keys are just chosen uniformly at random (and we'll often want this stronger requirement instead of just \"sufficient entropy\", e.g., in a one-time pad). Ruling out values such as 1 only removes entropy (though ruling out one value makes only a negligible difference, of course.) \r\n\r\nA valid reason to rule out specific values would not be that the attacker can guess them but to avoid creating problems in further computations. Sometimes that's the case. For example, we typically rule out 0 as a secret key because we'd like to avoid the special casing in (de)serializing the point at infinity (and other corner cases). Sometimes corner values can make the protocol. But I don't see a problem with a 1 here. (But maybe we're overlooking something, and @furszy sees a valid problem.)\r\n\r\nIn this specific case, we're dealing with a derived value and not with one chosen uniformly at random. But as I said above, it can be argued that it has sufficient entropy: assuming that the individual summed-up keys are independent, if one of the individual summed-up keys is uniformly random, then the sum is. Then we multiply with a hash, so the product is also uniformly random. (So even if 0 or 1 are problematic values, they would occur only with negligible probability.)\r\n\r\nIf you want to be fully formal, you'd need to take into account that the hash value depends on this sum (the sum pubkey goes into the hash and the attacker can even know this pubkey sum). So in theory, you could, for example, have a hash function that always maps to the inverse. This won't happen for SHA256 obviously, and if you assume the ROM, you can make that formal. \r\n\r\nIn fact, even a malicious sender could not force 0 or 1. This is like a Fiat-Shamir construction. The sender will need to pick the pubkey sum (and thus the seckey sum) before getting the hash value, so it's not feasible to pick the seckey sum depending on the hash value. \r\n\r\n</details>\r\n",
      "created_at": "2025-12-11T10:27:08Z",
      "updated_at": "2025-12-11T10:27:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2610038006",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610038006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 284,
      "original_start_line": 266,
      "start_side": "RIGHT",
      "line": 288,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610056690",
      "pull_request_review_id": 3566774354,
      "id": 2610056690,
      "node_id": "PRRC_kwDOAP4Jqs6bkk3y",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 105,
      "original_position": 94,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Now that I wrote this other long comment above, I'm not sure if this argument is confusing here. The shared secret could, in theory, be the point at infinity, no? I mean, it will happen only with negligible probability even for malicious senders, so I don't see how it would be a problem. But the comment here says that we have validated the public key and secret key. This is true. We have validated the sum secret key to be not 0, but this validation happened before we multiply a hash, and the hash could be zero. Okay, it seems that we also check that the hash is not zero in `secp256k1_silentpayments_calculate_input_hash_scalar` Okay, I guess the code is perfectly fine, but the comment could be made more precise. ",
      "created_at": "2025-12-11T10:32:53Z",
      "updated_at": "2025-12-11T10:32:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2610056690",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610056690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 103,
      "original_start_line": 92,
      "start_side": "RIGHT",
      "line": 105,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610534331",
      "pull_request_review_id": 3567377187,
      "id": 2610534331,
      "node_id": "PRRC_kwDOAP4Jqs6bmZe7",
      "diff_hunk": "@@ -126,6 +126,60 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 25,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "913fdee7e17b0f69a8e70b9876be47c6a887ff32",
      "in_reply_to_id": 2599453964,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think that is a great point. My current thinking is that we should make an entirely new type including serialization functions.\n\nThe pubkey type is a bit stretched sometimes. If we could redesign the entire library from scratch, I'd seriously consider having entirely separate pubkey types for all schemes. You can (ab)use an ECDSA pubkey to perform ECDH, but neither ECDH nor ECDSA have been designed to do this. *Usually* these things are okay, but they create plenty of headaches in theory, and maybe a careful API should, at least, ask its users to convert their keys explicitly. The only real separation we currently have is that for Schnorr sigs but this is because they use x-only keys.\n\nBut even if we try to be in line with the existing code base, a label is indeed a bit far from a pubkey, or even a key: there is not even a corresponding secret key (or secret label). Sure, the underlying group element has some discrete logarithm, but what I want to say is that it doesn't have a meaning in the API of the scheme. ",
      "created_at": "2025-12-11T13:11:07Z",
      "updated_at": "2025-12-11T13:11:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2610534331",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610534331"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 148,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2612705197",
      "pull_request_review_id": 3570057092,
      "id": 2612705197,
      "node_id": "PRRC_kwDOAP4Jqs6buret",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593243357,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> > I wonder if we could even just set the type of `n_recipients` to uint32_t instead of size_t, so the limit is already enforced at compile-time? IIRC there were some previous discussions between @josibake and @jonasnick about that topic (in take 3 or 2 of this PR), will look those up next week before changing.\r\n> \r\n> I can't remember these discussions, but using `uint32_t` is the most natural thing to do. And then we should update the BIP to make that clear in the spec.\r\n\r\nFwiw the previous discussion I had in mind started here: https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2381448515 (see enumeration point 3. specifically). Seems that limiting `n_recipients` to unsigned 32 bit values via `ARG_CHECK`ing was proposed (same as https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2593243357 above), but doing it by changing its type wasn't considered yet. I agree that the BIP should state the limit for clarity and to avoid being out-of-spec, will take a look into that.",
      "created_at": "2025-12-12T02:43:58Z",
      "updated_at": "2025-12-12T02:43:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2612705197",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2612705197"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2612739996",
      "pull_request_review_id": 3570093009,
      "id": 2612739996,
      "node_id": "PRRC_kwDOAP4Jqs6buz-c",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Glad that there is support for this idea. One potentially drawback I only notice now is that finding the output pointer is done via a loop over `n_recipients`, which might come with a performance loss for a larger numbers of recipients, as the nested loops run in $O(n^2)$ time. Maybe that can be avoided as well somehow?",
      "created_at": "2025-12-12T02:56:39Z",
      "updated_at": "2025-12-12T02:56:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2612739996",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2612739996"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 49,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": 52,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2613301592",
      "pull_request_review_id": 3570755264,
      "id": 2613301592,
      "node_id": "PRRC_kwDOAP4Jqs6bw9FY",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Oh, indeed. I don't think it can be avoided (but I'm happy to be proven wrong).\r\n\r\nHm, then my current feeling is that we should keep what we have. Avoiding a bit of (harmless!) API inconvenience at the cost of a bit of added internal complexity seems to be a reasonable tradeoff with users in mind. But doing it at the cost of increasing the complexity seems wrong. \r\n\r\nedit: Still curious to hear what the others think. ",
      "created_at": "2025-12-12T08:02:15Z",
      "updated_at": "2025-12-12T08:02:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2613301592",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2613301592"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 49,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": 52,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2615128619",
      "pull_request_review_id": 3573012406,
      "id": 2615128619,
      "node_id": "PRRC_kwDOAP4Jqs6b37Ir",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593243357,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Opened https://github.com/bitcoin/bips/pull/2055.",
      "created_at": "2025-12-12T18:04:09Z",
      "updated_at": "2025-12-12T18:04:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2615128619",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2615128619"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2615901474",
      "pull_request_review_id": 3573971859,
      "id": 2615901474,
      "node_id": "PRRC_kwDOAP4Jqs6b630i",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 237,
      "original_position": 216,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2590644412,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Introducing non-NULL checks for this PR actually paid off a lot, as they revealed two sneaky bugs:\r\n* in the code exercising the recipient test vectors (`run_silentpayments_test_vector_receive`), the `found_outputs` pointer array was set up incorrectly, as the init loop went only over the number of expected finds (`num_found_output_pubkeys`), rather than the full number of tx outputs (`num_to_scan_outputs`)\r\n* in the example, the same `tx_outputs` array of pointers is used twice for scanning (once for Bob, once for Carol); in the first call, tx outputs that have a match are marked with `NULL`, i.e. on the second call, those outputs were skipped for scanning. This went unnoticed as Carol is obviously not expected to find Bob's outputs anyway (so in some sense one could say it's not even that bad), but I would still say it's a bug and we should setup the tx outputs pointer array again before the second call.",
      "created_at": "2025-12-13T00:29:22Z",
      "updated_at": "2025-12-13T00:29:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2615901474",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2615901474"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 237,
      "original_line": 220,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2624217502",
      "pull_request_review_id": 3584305508,
      "id": 2624217502,
      "node_id": "PRRC_kwDOAP4Jqs6camGe",
      "diff_hunk": "@@ -126,6 +126,60 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 25,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "913fdee7e17b0f69a8e70b9876be47c6a887ff32",
      "in_reply_to_id": 2599453964,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> I think that is a great point. My current thinking is that we should make an entirely new type including serialization functions.\r\n\r\nGood idea. I was initially a bit reluctant to add a new type and more API functions, but now I'm quite happy with the `secp256k1_silentpayments_label` type (see latest force-push), and think it's conceptually the right approach to have a clear separation. I've added public API functions for both parsing and serializing labels. In theory, only serializing is really needed right now for users (to create the labels cache), but I thought it's better to add both for consistency. Could still remove the parsing function if reviewers feel it fits better into a future module extension. It doesn't hurt to have it now, but it might become more relevant in practice if the \"LabelSet\" scanning approach is implemented.\r\n\r\n> But even if we try to be in line with the existing code base, a label is indeed a bit far from a pubkey, or even a key: there is not even a corresponding secret key (or secret label). Sure, the underlying group element has some discrete logarithm, but what I want to say is that it doesn't have a meaning in the API of the scheme.\r\n\r\nUnless I'm misinterpreting your comment, I think the discrete logarithm of a label's underlying group element is indeed quite important in the API: the corresponding \"secret label\" is what we call the _label tweak_, returned together with the label in `_silentpayments_recipient_label_create`, and is needed later for spending a received payment to a labeled address. The label cache is a mapping of label to label tweak, so it's also reflected in the scanning API, where a callback function has to be provided doing a lookup in data structure (i.e. returning a label tweak, if a given label is found).",
      "created_at": "2025-12-16T17:53:59Z",
      "updated_at": "2025-12-16T18:40:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2624217502",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2624217502"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 148,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2624241943",
      "pull_request_review_id": 3584344550,
      "id": 2624241943,
      "node_id": "PRRC_kwDOAP4Jqs6casEX",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 105,
      "original_position": 94,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2610056690,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Reworked the comment to call the involved parts of the point multiplication \"public component\" and \"secret component\" (not entirely sure if these are good names, but at least they are consistent with the function's current parameter names), with a proper explanation what they reflect at the sender and receiver call-sites, respectively. Now that I think about it, another option might be to `VERIFY_CHECK` both of the group element and the scalar inputs to be non-infinity/non-zero and have proper comments at each call-site.",
      "created_at": "2025-12-16T18:03:49Z",
      "updated_at": "2025-12-16T18:03:50Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2624241943",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2624241943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 103,
      "original_start_line": 92,
      "start_side": "RIGHT",
      "line": 105,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2624426975",
      "pull_request_review_id": 3584574753,
      "id": 2624426975,
      "node_id": "PRRC_kwDOAP4Jqs6cbZPf",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 288,
      "original_position": 266,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593673524,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "@real-or-random: Thanks for elaborating, that was very helpful for understanding! Thoughts of \"why would 1 be any different from any other value\" crossed my mind before, but I still had doubts. It's clear now where the misconception came from, and I'm convinced that a check is not needed here.",
      "created_at": "2025-12-16T19:08:21Z",
      "updated_at": "2025-12-16T19:08:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2624426975",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2624426975"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 284,
      "original_start_line": 266,
      "start_side": "RIGHT",
      "line": 288,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2625904064",
      "pull_request_review_id": 3586366458,
      "id": 2625904064,
      "node_id": "PRRC_kwDOAP4Jqs6chB3A",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593243357,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> As `k` depends on `n_recipients`, wouldn't be simpler to ensure that `n_recipients < UINT32_MAX` early on the function?\r\n\r\n`k` doesn't depend on `n_recipients`. It is reset to `0` anytime the recipient `scan_pubkey` changes. You can have `2^64-1` recipients that have significantly less `scan_pubkeys`, and this will be fine if `k` does not exceed `UINT32_MAX`.",
      "created_at": "2025-12-17T07:26:53Z",
      "updated_at": "2025-12-17T07:28:43Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2625904064",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2625904064"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626060851",
      "pull_request_review_id": 3586549555,
      "id": 2626060851,
      "node_id": "PRRC_kwDOAP4Jqs6choIz",
      "diff_hunk": "@@ -126,6 +126,60 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 25,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "913fdee7e17b0f69a8e70b9876be47c6a887ff32",
      "in_reply_to_id": 2599453964,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Unless I'm misinterpreting your comment, I think the discrete logarithm of a label's underlying group element is indeed quite important in the API:\r\n\r\nYes, sorry, I was wrong here. It plays a role in the API, but it's not meant to be \"secret\". But I think my main point still holds up: calling label stuff a \"key\" is misleading. There's no authorization or secrecy aspect to it.",
      "created_at": "2025-12-17T08:26:24Z",
      "updated_at": "2025-12-17T08:26:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2626060851",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626060851"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 148,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626107852",
      "pull_request_review_id": 3586606543,
      "id": 2626107852,
      "node_id": "PRRC_kwDOAP4Jqs6chznM",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 105,
      "original_position": 94,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2610056690,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> another option might be to `VERIFY_CHECK` both of the group element and the scalar inputs to be non-infinity/non-zero and have proper comments at each call-site.\r\n\r\nThat sounds very clean, yes.\r\n",
      "created_at": "2025-12-17T08:41:54Z",
      "updated_at": "2025-12-17T08:41:54Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2626107852",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626107852"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 103,
      "original_start_line": 92,
      "start_side": "RIGHT",
      "line": 105,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626133290",
      "pull_request_review_id": 3586639072,
      "id": 2626133290,
      "node_id": "PRRC_kwDOAP4Jqs6ch50q",
      "diff_hunk": "@@ -0,0 +1,377 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payments outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public key\n+ *  must be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    uint32_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payments outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each Silent Payments\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from Silent Payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  When creating more than one generated output, all of the generated outputs\n+ *  MUST be included in the final transaction. Dropping any of the generated\n+ *  outputs from the final transaction may make all or some of the outputs\n+ *  unfindable by the recipient.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 on failure. This is expected only with an adversarially chosen\n+ *           recipient spend key. Specifically, failure occurs when:\n+ *             - Input secret keys sum to 0 or the negation of a spend key\n+ *               (negligible probability if at least one of the input secret\n+ *               keys is uniformly random and independent of all other keys)\n+ *             - A hash output is not a valid scalar (negligible probability\n+ *               per hash evaluation)\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `secp256k1_silentpayments_recipient` object\n+ *                            with index = 0.\n+ *  In:           recipients: pointer to an array of pointers to Silent Payments\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct Silent\n+ *                            Payments addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the size of the recipients array.\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the size of taproot_seckeys array.\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the size of the plain_seckeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out33: pointer to a 33-byte array to store the serialized label\n+ *  In:    label: pointer to the label\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_label_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out33,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payments labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payments address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if spend pubkey and label sum to zero (negligible probability for\n+ *             labels created according to BIP352).\n+ *\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds Silent Payments prevouts summary data.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 101 bytes in size, and can be safely copied/moved.\n+ *  This structure does not contain secret data. It can be created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payments prevouts summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each Silent Payments\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side.\n+ *\n+ *  Returns: 1 if prevouts summary creation was successful.\n+ *           0 if the transaction is not a Silent Payments transaction.\n+ *\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the size of the xonly_pubkeys array.\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the size of the plain_pubkeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache data,\n+ *  `secp256k1_silentpayments_recipient_label_create` and\n+ *  `secp256k1_silentpayments_recipient_label_serialize` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label public key to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payments transaction outputs.\n+ *\n+ *  Given a prevouts_summary object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For creating the labels cache, `secp256k1_silentpayments_recipient_label_create`\n+ *  and `secp256k1_silentpayments_recipient_label_serialize` can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if the transaction is not a Silent Payments transaction,\n+ *             or if the arguments are invalid.\n+ *\n+ *  Args:                   ctx: pointer to a context object\n+ *  Out:          found_outputs: pointer to an array of pointers to found\n+ *                               output objects. The found outputs array MUST\n+ *                               have the same length as the tx_outputs array.\n+ *              n_found_outputs: pointer to an integer indicating the final\n+ *                               size of the found outputs array. This number\n+ *                               represents the number of outputs found while\n+ *                               scanning (0 if none are found).\n+ *  In:              tx_outputs: pointer to the transaction's x-only public key outputs\n+ *                 n_tx_outputs: the size of the tx_outputs array.\n+ *                   scan_key32: pointer to the recipient's 32 byte scan key. The scan\n+ *                               key is valid if it passes secp256k1_ec_seckey_verify\n+ *             prevouts_summary: pointer to the transaction prevouts summary data (see\n+ *                               `secp256k1_silentpayments_recipient_prevouts_summary_create`).\n+ *       unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                 label_lookup: pointer to a callback function for looking up\n+ *                               a label value. This function takes a label\n+ *                               public key as an argument and returns a pointer to",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 353,
      "commit_id": "26e1e88f326bd73f1617481d2cf87b2cd2b19ba6",
      "original_commit_id": "26e1e88f326bd73f1617481d2cf87b2cd2b19ba6",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: still saying \"label public key\" here. \n\neither way, it will be good to emphasize that it takes a *serialized* label",
      "created_at": "2025-12-17T08:49:51Z",
      "updated_at": "2025-12-17T09:04:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2626133290",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626133290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 352,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 353,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626177122",
      "pull_request_review_id": 3586639072,
      "id": 2626177122,
      "node_id": "PRRC_kwDOAP4Jqs6ciEhi",
      "diff_hunk": "@@ -0,0 +1,377 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payments outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public key\n+ *  must be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    uint32_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payments outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each Silent Payments\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from Silent Payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  When creating more than one generated output, all of the generated outputs\n+ *  MUST be included in the final transaction. Dropping any of the generated\n+ *  outputs from the final transaction may make all or some of the outputs\n+ *  unfindable by the recipient.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 on failure. This is expected only with an adversarially chosen\n+ *           recipient spend key. Specifically, failure occurs when:\n+ *             - Input secret keys sum to 0 or the negation of a spend key\n+ *               (negligible probability if at least one of the input secret\n+ *               keys is uniformly random and independent of all other keys)\n+ *             - A hash output is not a valid scalar (negligible probability\n+ *               per hash evaluation)\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `secp256k1_silentpayments_recipient` object\n+ *                            with index = 0.\n+ *  In:           recipients: pointer to an array of pointers to Silent Payments\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct Silent\n+ *                            Payments addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the size of the recipients array.\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the size of taproot_seckeys array.\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the size of the plain_seckeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out33: pointer to a 33-byte array to store the serialized label\n+ *  In:    label: pointer to the label\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_label_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out33,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payments labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payments address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if spend pubkey and label sum to zero (negligible probability for\n+ *             labels created according to BIP352).\n+ *\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds Silent Payments prevouts summary data.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 101 bytes in size, and can be safely copied/moved.\n+ *  This structure does not contain secret data. It can be created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payments prevouts summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each Silent Payments\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side.\n+ *\n+ *  Returns: 1 if prevouts summary creation was successful.\n+ *           0 if the transaction is not a Silent Payments transaction.\n+ *\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the size of the xonly_pubkeys array.\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the size of the plain_pubkeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache data,\n+ *  `secp256k1_silentpayments_recipient_label_create` and\n+ *  `secp256k1_silentpayments_recipient_label_serialize` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label public key to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 293,
      "commit_id": "26e1e88f326bd73f1617481d2cf87b2cd2b19ba6",
      "original_commit_id": "26e1e88f326bd73f1617481d2cf87b2cd2b19ba6",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Perhaps the wording can be improved here (because currently, \"label cache\" is not explained):\n\n(Please reformat the paragraph, I guessed the line lengths...)\n\n```suggestion\n/** Type of callback function for label lookups\n *\n * A function of this type will be used to retrieve the label tweak for a given\n * label during scanning. A typical implementation will perform a lookup in a\n * key-value store called the \"label cache\".\n *\n *  For creating the label cache,\n *  `secp256k1_silentpayments_recipient_label_create` and\n *  `secp256k1_silentpayments_recipient_label_serialize` can be used.\n *\n *  Returns: pointer to the 32-byte label tweak if there is a match.\n *           NULL pointer if there is no match.\n *\n *  In:         label: pointer to the label public key to check (computed during\n *                     scanning)\n *      label_context: pointer to the recipient's label cache.\n */\ntypedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n```",
      "created_at": "2025-12-17T09:03:07Z",
      "updated_at": "2025-12-17T09:04:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2626177122",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626177122"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 277,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626179300",
      "pull_request_review_id": 3586639072,
      "id": 2626179300,
      "node_id": "PRRC_kwDOAP4Jqs6ciFDk",
      "diff_hunk": "@@ -0,0 +1,377 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payments outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public key\n+ *  must be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    uint32_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payments outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each Silent Payments\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from Silent Payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  When creating more than one generated output, all of the generated outputs\n+ *  MUST be included in the final transaction. Dropping any of the generated\n+ *  outputs from the final transaction may make all or some of the outputs\n+ *  unfindable by the recipient.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 on failure. This is expected only with an adversarially chosen\n+ *           recipient spend key. Specifically, failure occurs when:\n+ *             - Input secret keys sum to 0 or the negation of a spend key\n+ *               (negligible probability if at least one of the input secret\n+ *               keys is uniformly random and independent of all other keys)\n+ *             - A hash output is not a valid scalar (negligible probability\n+ *               per hash evaluation)\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `secp256k1_silentpayments_recipient` object\n+ *                            with index = 0.\n+ *  In:           recipients: pointer to an array of pointers to Silent Payments\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct Silent\n+ *                            Payments addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the size of the recipients array.\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the size of taproot_seckeys array.\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the size of the plain_seckeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out33: pointer to a 33-byte array to store the serialized label\n+ *  In:    label: pointer to the label\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_label_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out33,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payments labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payments address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if spend pubkey and label sum to zero (negligible probability for\n+ *             labels created according to BIP352).\n+ *\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds Silent Payments prevouts summary data.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 101 bytes in size, and can be safely copied/moved.\n+ *  This structure does not contain secret data. It can be created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payments prevouts summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each Silent Payments\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side.\n+ *\n+ *  Returns: 1 if prevouts summary creation was successful.\n+ *           0 if the transaction is not a Silent Payments transaction.\n+ *\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the size of the xonly_pubkeys array.\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the size of the plain_pubkeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Callback function for label lookups\n+ *\n+ *  This function is implemented by the recipient to check if a value exists in\n+ *  the recipients label cache during scanning.\n+ *\n+ *  For creating the labels cache data,\n+ *  `secp256k1_silentpayments_recipient_label_create` and\n+ *  `secp256k1_silentpayments_recipient_label_serialize` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the label public key to check (computed during\n+ *                     scanning)\n+ *      label_context: pointer to the recipients label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set with a valid\n+ *                    public key.\n+ *             label: public key representing the label used.\n+ *                    If found_with_label = false, this is set to an invalid\n+ *                    public key.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_pubkey label;\n+} secp256k1_silentpayments_found_output;\n+\n+/** Scan for Silent Payments transaction outputs.\n+ *\n+ *  Given a prevouts_summary object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For creating the labels cache, `secp256k1_silentpayments_recipient_label_create`\n+ *  and `secp256k1_silentpayments_recipient_label_serialize` can be used.",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 330,
      "commit_id": "26e1e88f326bd73f1617481d2cf87b2cd2b19ba6",
      "original_commit_id": "26e1e88f326bd73f1617481d2cf87b2cd2b19ba6",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n *  For creating the label cache, `secp256k1_silentpayments_recipient_label_create`\n *  and `secp256k1_silentpayments_recipient_label_serialize` can be used.\n```\n(as above)",
      "created_at": "2025-12-17T09:03:45Z",
      "updated_at": "2025-12-17T09:04:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2626179300",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626179300"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 329,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626613373",
      "pull_request_review_id": 3587203117,
      "id": 2626613373,
      "node_id": "PRRC_kwDOAP4Jqs6cjvB9",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593243357,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> > As `k` depends on `n_recipients`, wouldn't be simpler to ensure that `n_recipients < UINT32_MAX` early on the function?\r\n> \r\n> `k` doesn't depend on `n_recipients`. It is reset to `0` anytime the recipient `scan_pubkey` changes. You can have `2^64-1` recipients that have significantly less `scan_pubkeys`, and this will be fine if `k` does not exceed `UINT32_MAX`.\r\n\r\nRight, I think the intended statement here was \"the upper bound of `k` depends on `n_recipients`\" (or \"`k` is bounded by / can't exceed `n_recipients`\").\r\n\r\nExplicitly limiting `n_recipients` is not strictly needed, but I'd still say it makes a lot of sense. If we imagine a hypothetical scenario where someone has $\\geq 2^{32}$ recipients (ignoring for a moment now that this is orders of magnitudes higher than what current consensus rules allow and thus will very likely never happen), it's potentially confusing to the user that this can either succeed or fail, depending on how large the individual `scan_pubkey` groups are. An API doc comment like \"sending to more than $2^{32}-1$ recipients that share the same scan public key is not allowed\" and only verifying this at run-time is just more complex than \"sending to more than $2^{32}-1$ recipients is not allowed\", and having that already avoided at compile-time due to the data type.\r\n\r\nThat said, if the proposed BIP change https://github.com/bitcoin/bips/pull/2055 doesn't make it in, I think reintroducing the `k < UINT32_MAX` run-time checks before incrementing k isn't the end of the world either (though it's introducing a branch that we likely can't test, which we usually try to avoid).",
      "created_at": "2025-12-17T11:03:13Z",
      "updated_at": "2025-12-17T11:03:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2626613373",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2626613373"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2638141579",
      "pull_request_review_id": 3602023522,
      "id": 2638141579,
      "node_id": "PRRC_kwDOAP4Jqs6dPtiL",
      "diff_hunk": "@@ -126,6 +126,96 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 143,
      "original_position": 12,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "2c073807c3172ec1b6325c78cd78ece458955b6d",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In 2c073807c3172ec1b6325c78cd78ece458955b6d:\r\n\r\nWhy 68 bytes when compressed group elements are 33 bytes? Could be 41 bytes if you want extra space for a 4 bytes magic number and 4 extra bytes for any future upgrade (connected to https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2638157829).",
      "created_at": "2025-12-21T22:02:25Z",
      "updated_at": "2025-12-21T22:57:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2638141579",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2638141579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 135,
      "original_start_line": 129,
      "start_side": "RIGHT",
      "line": 143,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2638145462",
      "pull_request_review_id": 3602023522,
      "id": 2638145462,
      "node_id": "PRRC_kwDOAP4Jqs6dPue2",
      "diff_hunk": "@@ -324,4 +324,132 @@ int secp256k1_silentpayments_sender_create_outputs(\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 365,
      "original_position": 31,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "2c073807c3172ec1b6325c78cd78ece458955b6d",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In 2c073807c3172ec1b6325c78cd78ece458955b6d:\r\n\r\nAren't we missing an infinity check here?\r\nWe ensure it during `save` through `secp256k1_ge_to_bytes` but the `load` internal `secp256k1_ge_from_bytes` doesn't seem to be checking it.",
      "created_at": "2025-12-21T22:08:03Z",
      "updated_at": "2025-12-21T22:51:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2638145462",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2638145462"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 361,
      "original_start_line": 350,
      "start_side": "RIGHT",
      "line": 365,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2638157829",
      "pull_request_review_id": 3602023522,
      "id": 2638157829,
      "node_id": "PRRC_kwDOAP4Jqs6dPxgF",
      "diff_hunk": "@@ -126,6 +126,96 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out33: pointer to a 33-byte array to store the serialized label\n+ *  In:    label: pointer to the label\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_label_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out33,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);",
      "path": "include/secp256k1_silentpayments.h",
      "position": 169,
      "original_position": 38,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "2c073807c3172ec1b6325c78cd78ece458955b6d",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In 2c073807c3172ec1b6325c78cd78ece458955b6d:\r\n\r\nq: why not include the label magic number in the output? It seems like a good way to ensure we're parsing a label and not just an arbitrary compressed group element.",
      "created_at": "2025-12-21T22:28:47Z",
      "updated_at": "2025-12-21T22:51:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2638157829",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2638157829"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 158,
      "original_start_line": 152,
      "start_side": "RIGHT",
      "line": 169,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2638162747",
      "pull_request_review_id": 3602023522,
      "id": 2638162747,
      "node_id": "PRRC_kwDOAP4Jqs6dPys7",
      "diff_hunk": "@@ -324,4 +324,132 @@ int secp256k1_silentpayments_sender_create_outputs(\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 414,
      "original_position": 80,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "2c073807c3172ec1b6325c78cd78ece458955b6d",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In 2c073807c3172ec1b6325c78cd78ece458955b6d:\r\n\r\nShould be able to remove this line, the `_ec_pubkey_create_helper()` call you do below performs the same sk validity check.",
      "created_at": "2025-12-21T22:39:40Z",
      "updated_at": "2025-12-21T22:51:05Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2638162747",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2638162747"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 413,
      "original_start_line": 402,
      "start_side": "RIGHT",
      "line": 414,
      "original_line": 403,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2641779778",
      "pull_request_review_id": 3606363542,
      "id": 2641779778,
      "node_id": "PRRC_kwDOAP4Jqs6ddlxC",
      "diff_hunk": "@@ -324,4 +324,132 @@ int secp256k1_silentpayments_sender_create_outputs(\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 414,
      "original_position": 80,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "2c073807c3172ec1b6325c78cd78ece458955b6d",
      "in_reply_to_id": 2638162747,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Note that the `_ec_pubkey_create_helper()` call below performs a generator point multiplication on a different scalar, namely `hash(b_scan || m)`, so its success doesn't tell us anything on whether the scan key is valid or not. ",
      "created_at": "2025-12-23T03:00:14Z",
      "updated_at": "2025-12-23T03:00:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2641779778",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2641779778"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 413,
      "original_start_line": 402,
      "start_side": "RIGHT",
      "line": 414,
      "original_line": 403,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2641827850",
      "pull_request_review_id": 3606424474,
      "id": 2641827850,
      "node_id": "PRRC_kwDOAP4Jqs6ddxgK",
      "diff_hunk": "@@ -126,6 +126,96 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out33: pointer to a 33-byte array to store the serialized label\n+ *  In:    label: pointer to the label\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_label_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out33,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);",
      "path": "include/secp256k1_silentpayments.h",
      "position": 169,
      "original_position": 38,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "2c073807c3172ec1b6325c78cd78ece458955b6d",
      "in_reply_to_id": 2638157829,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Good question. The primary use-case of serializing labels right now is creating the label cache (at least for the \"BIP approach\" of scanning implemented in this PR), and for that I'd say it makes sense to target the most dense serialization for space-efficiency; having all key entries in the cache repeatedly prefixed with the exact same four bytes (increasing its size by >10%) seems wasteful, same for e.g. a large number of labels are saved to disk. (Sure, the users could manually strip those four bytes away and add them again before calling `_label_parse`, but that doesn't seem great either).\r\n\r\nLeaving this open for others to weigh in, maybe it's worth it to do. In any case it seems that label serialization should be specified somewhere, I only notice now that it's apparently not specified in the BIP.",
      "created_at": "2025-12-23T03:40:25Z",
      "updated_at": "2025-12-23T03:40:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2641827850",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2641827850"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 158,
      "original_start_line": 152,
      "start_side": "RIGHT",
      "line": 169,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2641855699",
      "pull_request_review_id": 3606456241,
      "id": 2641855699,
      "node_id": "PRRC_kwDOAP4Jqs6dd4TT",
      "diff_hunk": "@@ -324,4 +324,132 @@ int secp256k1_silentpayments_sender_create_outputs(\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 365,
      "original_position": 31,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "2c073807c3172ec1b6325c78cd78ece458955b6d",
      "in_reply_to_id": 2638145462,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`secp256k1_ge_from_bytes` interprets a 64-byte array as affine coordinates (32 bytes for x,y each), so the notion of infinity doesn't exist here, the called function `secp256k1_ge_from_storage` always sets `r->infinity = 0;`.\r\n\r\nAs I currently understand it, we generally assume that user-facing opaque data types are only created and modified by public API functions, and the only protection against manual tampering are the magic bytes. Once that `ARG_CHECK` is passed in a `_load` function, we just assume that the object must have been created with the corresponding `_save` counterpart.",
      "created_at": "2025-12-23T04:03:21Z",
      "updated_at": "2025-12-23T04:49:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2641855699",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2641855699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 361,
      "original_start_line": 350,
      "start_side": "RIGHT",
      "line": 365,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2641896492",
      "pull_request_review_id": 3606508981,
      "id": 2641896492,
      "node_id": "PRRC_kwDOAP4Jqs6deCQs",
      "diff_hunk": "@@ -126,6 +126,96 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 143,
      "original_position": 12,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "2c073807c3172ec1b6325c78cd78ece458955b6d",
      "in_reply_to_id": 2638141579,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The \"compressed\" notion is only relevant for serialization. IIUC for the opaque data structure types we generally prefer to use representation that closely match internal data types (in this case, `secp256k1_ge`, using `secp256k1_ge_{from,to}_bytes`; note that something like a \"compressed secp256k1_ge\" object doesn't exist), and `_save`/`_load` functions shouldn't involve any expensive operations.\r\n\r\nFor example, in the LabelSet-approach, we pass in the list of labels as `secp256k1_silentpayments_label` instances. If this type was representing a group element where only the x coordinate and the y parity is known (assuming that such a hypothetical \"compressed group element\" internal type would really exist), the full y coordinate would need to be calculated every time. If we do that already at the object creation time (in `_label_create` or `_label_parse`), it only has to be done once.\r\n\r\nRegarding \"4 extra bytes for any future upgrade\", that's of course an option. On the other hand, I can't imagine that a label is ever anything more than a group element. Did you have anything specific already in mind?",
      "created_at": "2025-12-23T04:32:25Z",
      "updated_at": "2025-12-23T04:32:25Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2641896492",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2641896492"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 135,
      "original_start_line": 129,
      "start_side": "RIGHT",
      "line": 143,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2644017330",
      "pull_request_review_id": 3609015898,
      "id": 2644017330,
      "node_id": "PRRC_kwDOAP4Jqs6dmICy",
      "diff_hunk": "@@ -126,6 +126,96 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 143,
      "original_position": 12,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "2c073807c3172ec1b6325c78cd78ece458955b6d",
      "in_reply_to_id": 2638141579,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Regarding \"4 extra bytes for any future upgrade\", that's of course an option. On the other hand, I can't imagine that a label is ever anything more than a group element. Did you have anything specific already in mind?\r\n\r\nNot really; that thought was connected to the previous one: \"As we can decrease the payload size by compressing the point, we can afford to use some extra space for future upgrades\", which is usually a nice-to-have feature in any protocol. But I agree that nothing else really comes to mind atm.\r\n\r\nCan close this convo. Would rather focus on adding a label serialization specification to the BIP, so we can continue the discussion -> https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2641827850.\r\n",
      "created_at": "2025-12-23T18:49:40Z",
      "updated_at": "2025-12-23T18:49:40Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2644017330",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2644017330"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 135,
      "original_start_line": 129,
      "start_side": "RIGHT",
      "line": 143,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2663979109",
      "pull_request_review_id": 3629808600,
      "id": 2663979109,
      "node_id": "PRRC_kwDOAP4Jqs6eyRhl",
      "diff_hunk": "@@ -324,4 +324,132 @@ int secp256k1_silentpayments_sender_create_outputs(\n     return 1;\n }\n \n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 365,
      "original_position": 31,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "2c073807c3172ec1b6325c78cd78ece458955b6d",
      "in_reply_to_id": 2638145462,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> As I currently understand it, we generally assume that user-facing opaque data types are only created and modified by public API functions, and the only protection against manual tampering are the magic bytes. Once that `ARG_CHECK` is passed in a `_load` function, we just assume that the object must have been created with the corresponding `_save` counterpart.\r\n\r\nIndeed, and I don't think we want to make any guarantees about what happens if the caller passes a modified object. And the magic bytes are just a best-effort protection against the user passing an opaque object of the wrong type. ",
      "created_at": "2026-01-06T07:49:06Z",
      "updated_at": "2026-01-06T07:49:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2663979109",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2663979109"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 361,
      "original_start_line": 350,
      "start_side": "RIGHT",
      "line": 365,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2664024832",
      "pull_request_review_id": 3629856752,
      "id": 2664024832,
      "node_id": "PRRC_kwDOAP4Jqs6eycsA",
      "diff_hunk": "@@ -126,6 +126,96 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out33: pointer to a 33-byte array to store the serialized label\n+ *  In:    label: pointer to the label\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_label_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out33,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);",
      "path": "include/secp256k1_silentpayments.h",
      "position": 169,
      "original_position": 38,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "2c073807c3172ec1b6325c78cd78ece458955b6d",
      "in_reply_to_id": 2638157829,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> In any case it seems that label serialization should be specified somewhere, \r\n\r\nIt's not entirely clear in this case, but I agree that this is rather a protocol-level concern: interoperability could indeed matter if you want to use the same label DB with different scanning implementations. And in this case, size indeed matters, so I think we should not add the magic bytes.",
      "created_at": "2026-01-06T08:05:07Z",
      "updated_at": "2026-01-06T08:05:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2664024832",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2664024832"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 158,
      "original_start_line": 152,
      "start_side": "RIGHT",
      "line": 169,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2687881682",
      "pull_request_review_id": 3657637829,
      "id": 2687881682,
      "node_id": "PRRC_kwDOAP4Jqs6gNdHS",
      "diff_hunk": "@@ -0,0 +1,748 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, uint32_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t j, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (j = 0; j < n_recipients; j++) {\n+        if ((j == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[j]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[j]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[j]->index], shared_secret, &recipients[j]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[j]->scan_pubkey;\n+        k++;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    ret &= secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &label_tweak_scalar, &label_ge, label_tweak32);\n+    secp256k1_silentpayments_label_save(label, &label_ge);\n+\n+    secp256k1_scalar_clear(&label_tweak_scalar);\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_silentpayments_label *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_silentpayments_label_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+        for (i = 0; i < n_xonly_pubkeys; i++) {\n+            ARG_CHECK(xonly_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+        for (i = 0; i < n_plain_pubkeys; i++) {\n+            ARG_CHECK(plain_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, uint32_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey **tx_outputs, uint32_t n_tx_outputs,",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 562,
      "commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "original_commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "in_reply_to_id": null,
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "As I commented in the proposed change for [BIP 352](https://github.com/bitcoin/bips/pull/2055/files#r2687839532), the limit on the `n_tx_outputs` is based on the fact that you cannot receive more than `k` different silent payment outputs in a transaction to the same silent payment address[^1], but even in the case this was possible, nothing should prevent you from adding more non silent outputs to the transaction.\r\nTo avoid a constraint that doesn't hold by itself, I would keep the old `size_t` type for `n_tx_outputs`.\r\nThe changes on the recipient fields and the `n_found_outputs` are different, because those fields are bounded by `k`.\r\n\r\n[^1]: Point 3 of https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2381448515",
      "created_at": "2026-01-13T19:46:04Z",
      "updated_at": "2026-01-13T19:57:46Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2687881682",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2687881682"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 562,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2705151787",
      "pull_request_review_id": 3678540890,
      "id": 2705151787,
      "node_id": "PRRC_kwDOAP4Jqs6hPVcr",
      "diff_hunk": "@@ -0,0 +1,748 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, uint32_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t j, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (j = 0; j < n_recipients; j++) {\n+        if ((j == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[j]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[j]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[j]->index], shared_secret, &recipients[j]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[j]->scan_pubkey;\n+        k++;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    ret &= secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &label_tweak_scalar, &label_ge, label_tweak32);\n+    secp256k1_silentpayments_label_save(label, &label_ge);\n+\n+    secp256k1_scalar_clear(&label_tweak_scalar);\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_silentpayments_label *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_silentpayments_label_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+        for (i = 0; i < n_xonly_pubkeys; i++) {\n+            ARG_CHECK(xonly_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+        for (i = 0; i < n_plain_pubkeys; i++) {\n+            ARG_CHECK(plain_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, uint32_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey **tx_outputs, uint32_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    uint32_t k, j, found_idx;\n+    int found, combined, valid_scan_key, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    for (j = 0; j < n_tx_outputs; j++) {\n+        ARG_CHECK(found_outputs[j] != NULL);\n+        ARG_CHECK(tx_outputs[j] != NULL);\n+    }\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    valid_scan_key = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &valid_scan_key, sizeof(valid_scan_key));\n+    if (!valid_scan_key) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    /* Creating the shared secret requires that the public and secret components are\n+     * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+     * scan secret key, and prevouts public key sum) have all been verified at this point,\n+     * assuming that the user hasn't tampered the `prevouts_summary` object manually. */\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+    /* Clear the scan_key_scalar since we no longer need it and leaking this value would break indistinguishability of the transaction. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+\n+    found_idx = 0;\n+    for (k = 0; k < n_tx_outputs; k++) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal\n+         * to the curve order, which is statistically improbable. Returning an error here results in an untestable\n+         * branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (j = 0; j < n_tx_outputs; j++) {\n+            if (tx_outputs[j] == NULL) continue; /* skip already-matched outputs */\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[j]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = j;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[j]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 667,
      "commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "original_commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It seems like we can do this negation outside the `j` loop over the transaction outputs. (Comment \"Negate the generated output\" would need to be updated as well)",
      "created_at": "2026-01-19T15:10:25Z",
      "updated_at": "2026-01-19T15:16:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2705151787",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2705151787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 667,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2705173147",
      "pull_request_review_id": 3678540890,
      "id": 2705173147,
      "node_id": "PRRC_kwDOAP4Jqs6hPaqb",
      "diff_hunk": "@@ -0,0 +1,748 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, uint32_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t j, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (j = 0; j < n_recipients; j++) {\n+        if ((j == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[j]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[j]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[j]->index], shared_secret, &recipients[j]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[j]->scan_pubkey;\n+        k++;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    ret &= secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &label_tweak_scalar, &label_ge, label_tweak32);\n+    secp256k1_silentpayments_label_save(label, &label_ge);\n+\n+    secp256k1_scalar_clear(&label_tweak_scalar);\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_silentpayments_label *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_silentpayments_label_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+        for (i = 0; i < n_xonly_pubkeys; i++) {\n+            ARG_CHECK(xonly_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+        for (i = 0; i < n_plain_pubkeys; i++) {\n+            ARG_CHECK(plain_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, uint32_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey **tx_outputs, uint32_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    uint32_t k, j, found_idx;\n+    int found, combined, valid_scan_key, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    for (j = 0; j < n_tx_outputs; j++) {\n+        ARG_CHECK(found_outputs[j] != NULL);\n+        ARG_CHECK(tx_outputs[j] != NULL);\n+    }\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    valid_scan_key = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &valid_scan_key, sizeof(valid_scan_key));\n+    if (!valid_scan_key) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    /* Creating the shared secret requires that the public and secret components are\n+     * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+     * scan secret key, and prevouts public key sum) have all been verified at this point,\n+     * assuming that the user hasn't tampered the `prevouts_summary` object manually. */\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+    /* Clear the scan_key_scalar since we no longer need it and leaking this value would break indistinguishability of the transaction. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+\n+    found_idx = 0;\n+    for (k = 0; k < n_tx_outputs; k++) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal\n+         * to the curve order, which is statistically improbable. Returning an error here results in an untestable\n+         * branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (j = 0; j < n_tx_outputs; j++) {\n+            if (tx_outputs[j] == NULL) continue; /* skip already-matched outputs */\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[j]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = j;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[j]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej_var(&label_ge, &label_gej);\n+                /* Serialize must succeed because the point was just loaded.\n+                 *\n+                 * Note: serialize will also fail if label_ge is the point at infinity, but we know\n+                 * this cannot happen since we only hit this branch if tx_output != output_xonly.\n+                 * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\n+                 * point at infinity.\n+                 */\n+                secp256k1_eckey_pubkey_serialize33(&label_ge, label33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = j;\n+                    break;\n+                }\n+\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 *     label2 = -tx_output - generated_output\n+                 */\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &output_negated_ge, NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 689,
      "commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "original_commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "What @w0xlt's first optimization approaches showed was that we can use `secp256k1_ge_set_all_gej_var` in scanning. In the simplest implementation we can just use it for the two candidate labels in the innermost loop. This would already be an improvement.",
      "created_at": "2026-01-19T15:16:28Z",
      "updated_at": "2026-01-19T15:16:37Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2705173147",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2705173147"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 689,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2706505453",
      "pull_request_review_id": 3680046828,
      "id": 2706505453,
      "node_id": "PRRC_kwDOAP4Jqs6hUf7t",
      "diff_hunk": "@@ -0,0 +1,748 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, uint32_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t j, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (j = 0; j < n_recipients; j++) {\n+        if ((j == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[j]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[j]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[j]->index], shared_secret, &recipients[j]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[j]->scan_pubkey;\n+        k++;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    ret &= secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &label_tweak_scalar, &label_ge, label_tweak32);\n+    secp256k1_silentpayments_label_save(label, &label_ge);\n+\n+    secp256k1_scalar_clear(&label_tweak_scalar);\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_silentpayments_label *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_silentpayments_label_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+        for (i = 0; i < n_xonly_pubkeys; i++) {\n+            ARG_CHECK(xonly_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+        for (i = 0; i < n_plain_pubkeys; i++) {\n+            ARG_CHECK(plain_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, uint32_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey **tx_outputs, uint32_t n_tx_outputs,",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 562,
      "commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "original_commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "in_reply_to_id": 2687881682,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I agree, see my previous answer on the BIPs PR: https://github.com/bitcoin/bips/pull/2055/files#r2692907049 \r\n\r\nSwitched back to `size_t` as type for the `n_tx_outputs` parameter accordingly, for both the sending (`_create_outputs`) and receiving (`_scan_outputs`) AP functions. I think the `uint32_t` type really only makes sense for the `n_found_outputs` parameter.",
      "created_at": "2026-01-20T02:07:15Z",
      "updated_at": "2026-01-20T02:07:16Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2706505453",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2706505453"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 562,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2706505612",
      "pull_request_review_id": 3680046974,
      "id": 2706505612,
      "node_id": "PRRC_kwDOAP4Jqs6hUf-M",
      "diff_hunk": "@@ -0,0 +1,748 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, uint32_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t j, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (j = 0; j < n_recipients; j++) {\n+        if ((j == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[j]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[j]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[j]->index], shared_secret, &recipients[j]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[j]->scan_pubkey;\n+        k++;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    ret &= secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &label_tweak_scalar, &label_ge, label_tweak32);\n+    secp256k1_silentpayments_label_save(label, &label_ge);\n+\n+    secp256k1_scalar_clear(&label_tweak_scalar);\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_silentpayments_label *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_silentpayments_label_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+        for (i = 0; i < n_xonly_pubkeys; i++) {\n+            ARG_CHECK(xonly_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+        for (i = 0; i < n_plain_pubkeys; i++) {\n+            ARG_CHECK(plain_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, uint32_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey **tx_outputs, uint32_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    uint32_t k, j, found_idx;\n+    int found, combined, valid_scan_key, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    for (j = 0; j < n_tx_outputs; j++) {\n+        ARG_CHECK(found_outputs[j] != NULL);\n+        ARG_CHECK(tx_outputs[j] != NULL);\n+    }\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    valid_scan_key = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &valid_scan_key, sizeof(valid_scan_key));\n+    if (!valid_scan_key) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    /* Creating the shared secret requires that the public and secret components are\n+     * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+     * scan secret key, and prevouts public key sum) have all been verified at this point,\n+     * assuming that the user hasn't tampered the `prevouts_summary` object manually. */\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+    /* Clear the scan_key_scalar since we no longer need it and leaking this value would break indistinguishability of the transaction. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+\n+    found_idx = 0;\n+    for (k = 0; k < n_tx_outputs; k++) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal\n+         * to the curve order, which is statistically improbable. Returning an error here results in an untestable\n+         * branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (j = 0; j < n_tx_outputs; j++) {\n+            if (tx_outputs[j] == NULL) continue; /* skip already-matched outputs */\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[j]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = j;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[j]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 667,
      "commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "original_commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "in_reply_to_id": 2705151787,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Indeed, done.",
      "created_at": "2026-01-20T02:07:22Z",
      "updated_at": "2026-01-20T02:07:22Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2706505612",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2706505612"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 667,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2706505715",
      "pull_request_review_id": 3680047070,
      "id": 2706505715,
      "node_id": "PRRC_kwDOAP4Jqs6hUf_z",
      "diff_hunk": "@@ -0,0 +1,748 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, uint32_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    uint32_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t j, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (j = 0; j < n_recipients; j++) {\n+        if ((j == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[j]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[j]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[j]->index], shared_secret, &recipients[j]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[j]->scan_pubkey;\n+        k++;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    ret &= secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &label_tweak_scalar, &label_ge, label_tweak32);\n+    secp256k1_silentpayments_label_save(label, &label_ge);\n+\n+    secp256k1_scalar_clear(&label_tweak_scalar);\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_silentpayments_label *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_silentpayments_label_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+        for (i = 0; i < n_xonly_pubkeys; i++) {\n+            ARG_CHECK(xonly_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+        for (i = 0; i < n_plain_pubkeys; i++) {\n+            ARG_CHECK(plain_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, uint32_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey **tx_outputs, uint32_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    uint32_t k, j, found_idx;\n+    int found, combined, valid_scan_key, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    for (j = 0; j < n_tx_outputs; j++) {\n+        ARG_CHECK(found_outputs[j] != NULL);\n+        ARG_CHECK(tx_outputs[j] != NULL);\n+    }\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    valid_scan_key = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &valid_scan_key, sizeof(valid_scan_key));\n+    if (!valid_scan_key) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    /* Creating the shared secret requires that the public and secret components are\n+     * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+     * scan secret key, and prevouts public key sum) have all been verified at this point,\n+     * assuming that the user hasn't tampered the `prevouts_summary` object manually. */\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+    /* Clear the scan_key_scalar since we no longer need it and leaking this value would break indistinguishability of the transaction. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+\n+    found_idx = 0;\n+    for (k = 0; k < n_tx_outputs; k++) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal\n+         * to the curve order, which is statistically improbable. Returning an error here results in an untestable\n+         * branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (j = 0; j < n_tx_outputs; j++) {\n+            if (tx_outputs[j] == NULL) continue; /* skip already-matched outputs */\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[j]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = j;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[j]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej_var(&label_ge, &label_gej);\n+                /* Serialize must succeed because the point was just loaded.\n+                 *\n+                 * Note: serialize will also fail if label_ge is the point at infinity, but we know\n+                 * this cannot happen since we only hit this branch if tx_output != output_xonly.\n+                 * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\n+                 * point at infinity.\n+                 */\n+                secp256k1_eckey_pubkey_serialize33(&label_ge, label33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = j;\n+                    break;\n+                }\n+\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 *     label2 = -tx_output - generated_output\n+                 */\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &output_negated_ge, NULL);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 689,
      "commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "original_commit_id": "2ee7d879343a5dafc30ae8dc00844ce1614f6931",
      "in_reply_to_id": 2705173147,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Good idea. Done as suggested for the two candidate labels, and used this opportunity to deduplicate the label checking code with a for loop.",
      "created_at": "2026-01-20T02:07:26Z",
      "updated_at": "2026-01-20T02:07:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2706505715",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2706505715"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 689,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2761578265",
      "pull_request_review_id": 3748283540,
      "id": 2761578265,
      "node_id": "PRRC_kwDOAP4Jqs6kmlcZ",
      "diff_hunk": "@@ -0,0 +1,385 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payments outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* Maximum number of Silent Payments recipients per group (i.e.\n+ * recipients sharing the same scan public key) as per BIP-352 */\n+#define SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT 1000\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public key\n+ *  must be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    uint32_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payments outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each Silent Payments\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from Silent Payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  When creating more than one generated output, all of the generated outputs\n+ *  MUST be included in the final transaction. Dropping any of the generated\n+ *  outputs from the final transaction may make all or some of the outputs\n+ *  unfindable by the recipient.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 on failure. This is expected only with an adversarially chosen\n+ *           recipient spend key. Specifically, failure occurs when:\n+ *             - Input secret keys sum to 0 or the negation of a spend key\n+ *               (negligible probability if at least one of the input secret\n+ *               keys is uniformly random and independent of all other keys)\n+ *             - A hash output is not a valid scalar (negligible probability\n+ *               per hash evaluation)\n+ *             - Any group (i.e. recipients sharing the same scan public key) exceeds\n+ *               the protocol limit SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `secp256k1_silentpayments_recipient` object\n+ *                            with index = 0.\n+ *  In:           recipients: pointer to an array of pointers to Silent Payments\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct Silent\n+ *                            Payments addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the size of the recipients array.\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the size of taproot_seckeys array.\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the size of the plain_seckeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always",
      "path": "include/secp256k1_silentpayments.h",
      "position": 160,
      "original_position": 160,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n *  Returns: 1 when the label could be serialized, 0 otherwise.\n```",
      "created_at": "2026-02-04T00:10:10Z",
      "updated_at": "2026-02-04T07:06:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2761578265",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2761578265"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 160,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2762495463",
      "pull_request_review_id": 3748283540,
      "id": 2762495463,
      "node_id": "PRRC_kwDOAP4Jqs6kqFXn",
      "diff_hunk": "@@ -0,0 +1,385 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payments outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* Maximum number of Silent Payments recipients per group (i.e.\n+ * recipients sharing the same scan public key) as per BIP-352 */\n+#define SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT 1000\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public key\n+ *  must be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    uint32_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payments outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each Silent Payments\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from Silent Payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  When creating more than one generated output, all of the generated outputs\n+ *  MUST be included in the final transaction. Dropping any of the generated\n+ *  outputs from the final transaction may make all or some of the outputs\n+ *  unfindable by the recipient.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 on failure. This is expected only with an adversarially chosen\n+ *           recipient spend key. Specifically, failure occurs when:\n+ *             - Input secret keys sum to 0 or the negation of a spend key\n+ *               (negligible probability if at least one of the input secret\n+ *               keys is uniformly random and independent of all other keys)\n+ *             - A hash output is not a valid scalar (negligible probability\n+ *               per hash evaluation)\n+ *             - Any group (i.e. recipients sharing the same scan public key) exceeds\n+ *               the protocol limit SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `secp256k1_silentpayments_recipient` object\n+ *                            with index = 0.\n+ *  In:           recipients: pointer to an array of pointers to Silent Payments\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct Silent\n+ *                            Payments addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the size of the recipients array.\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the size of taproot_seckeys array.\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the size of the plain_seckeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out33: pointer to a 33-byte array to store the serialized label\n+ *  In:    label: pointer to the label\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_label_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out33,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payments labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payments address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if spend pubkey and label sum to zero (negligible probability for\n+ *             labels created according to BIP352).\n+ *\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds Silent Payments prevouts summary data.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 101 bytes in size, and can be safely copied/moved.\n+ *  This structure does not contain secret data. It can be created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payments prevouts summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each Silent Payments\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side.\n+ *\n+ *  Returns: 1 if prevouts summary creation was successful.\n+ *           0 if the transaction is not a Silent Payments transaction.\n+ *\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the size of the xonly_pubkeys array.\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the size of the plain_pubkeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Type of callback function for label lookups\n+ *\n+ *  A function of this type will be used to retrieve the label tweak for a given\n+ *  label during scanning. A typical implementation will perform a lookup in a\n+ *  key-value store called the \"label cache\".\n+ *\n+ *  For creating the label cache data,\n+ *  `secp256k1_silentpayments_recipient_label_create` and\n+ *  `secp256k1_silentpayments_recipient_label_serialize` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the serialized 33-byte label to check\n+ *                     (computed during scanning)\n+ *      label_context: pointer to the recipient's label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set to a valid value.\n+ *             label: the label used. If found_with_label = false, this is set to\n+ *                    an invalid value.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_silentpayments_label label;\n+} secp256k1_silentpayments_found_output;\n+\n+/* TODO: clarify the limitations of labels w.r.t. light clients */\n+\n+/** Scan for Silent Payments transaction outputs.\n+ *\n+ *  Given a prevouts_summary object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For creating the label cache, `secp256k1_silentpayments_recipient_label_create`\n+ *  and `secp256k1_silentpayments_recipient_label_serialize` can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if the transaction is not a Silent Payments transaction,\n+ *             or if the arguments are invalid.\n+ *",
      "path": "include/secp256k1_silentpayments.h",
      "position": 355,
      "original_position": 342,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n *  Note:\n *  Scanning is bounded by SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT and may\n *  miss outputs if a transaction contains more outputs for a single scan public\n *  key group than this limit.\n```",
      "created_at": "2026-02-04T06:56:09Z",
      "updated_at": "2026-02-04T07:06:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2762495463",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2762495463"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 355,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2762506274",
      "pull_request_review_id": 3748283540,
      "id": 2762506274,
      "node_id": "PRRC_kwDOAP4Jqs6kqIAi",
      "diff_hunk": "@@ -0,0 +1,753 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 317,
      "original_position": 316,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This check should happen before generating the output for k, so we don't partially fill the outputs array with an out-of-protocol output on failure.\n```suggestion\n        }\n        if (k >= SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT) {\n          secp256k1_scalar_clear(&seckey_sum_scalar);\n          secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n          return 0;\n       }       \n```",
      "created_at": "2026-02-04T07:00:21Z",
      "updated_at": "2026-02-04T07:06:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2762506274",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2762506274"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 317,
      "original_line": 316,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2762513681",
      "pull_request_review_id": 3748283540,
      "id": 2762513681,
      "node_id": "PRRC_kwDOAP4Jqs6kqJ0R",
      "diff_hunk": "@@ -0,0 +1,753 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+        k++;\n+        /* Once the number of created outputs for the current recipient group exceeds the\n+         * protocol limit, fail, as the recipient isn't guaranteed to find further ouputs. */\n+        if (k > SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT) {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 328,
      "commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "original_commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It can be removed per https://github.com/bitcoin-core/secp256k1/pull/1765/changes#r2762506274\n```suggestion\n```",
      "created_at": "2026-02-04T07:03:00Z",
      "updated_at": "2026-02-04T07:06:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2762513681",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2762513681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 324,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 328,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2762516512",
      "pull_request_review_id": 3748283540,
      "id": 2762516512,
      "node_id": "PRRC_kwDOAP4Jqs6kqKgg",
      "diff_hunk": "@@ -0,0 +1,753 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+        k++;\n+        /* Once the number of created outputs for the current recipient group exceeds the\n+         * protocol limit, fail, as the recipient isn't guaranteed to find further ouputs. */\n+        if (k > SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    ret &= secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &label_tweak_scalar, &label_ge, label_tweak32);\n+    secp256k1_silentpayments_label_save(label, &label_ge);\n+\n+    secp256k1_scalar_clear(&label_tweak_scalar);\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_silentpayments_label *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_silentpayments_label_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+        for (i = 0; i < n_xonly_pubkeys; i++) {\n+            ARG_CHECK(xonly_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+        for (i = 0; i < n_plain_pubkeys; i++) {\n+            ARG_CHECK(plain_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, uint32_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar scan_key_scalar;\n+    secp256k1_ge spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    unsigned char shared_secret[33];\n+    uint32_t k, k_max;\n+    size_t i, found_idx;\n+    int found, combined, valid_scan_key, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    for (i = 0; i < n_tx_outputs; i++) {\n+        ARG_CHECK(found_outputs[i] != NULL);\n+        ARG_CHECK(tx_outputs[i] != NULL);\n+    }\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    valid_scan_key = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &valid_scan_key, sizeof(valid_scan_key));\n+    if (!valid_scan_key) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    /* Creating the shared secret requires that the public and secret components are\n+     * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+     * scan secret key, and prevouts public key sum) have all been verified at this point,\n+     * assuming that the user hasn't tampered the `prevouts_summary` object manually. */\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+    /* Clear the scan_key_scalar since we no longer need it and leaking this value would break indistinguishability of the transaction. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+\n+    found_idx = 0;\n+    /* Don't look further than the per-group recipient limit, in order to avoid quadratic scaling issues. */\n+    k_max = (n_tx_outputs < SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT) ?\n+             n_tx_outputs : SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT;\n+    /* TODO: potential optimization: the worst-case run-time can be cut in half by randomizing the outputs */\n+    for (k = 0; k < k_max; k++) {\n+        secp256k1_scalar output_tweak_scalar;\n+        secp256k1_xonly_pubkey output_xonly;\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        secp256k1_ge output_negated_ge;\n+        const unsigned char *label_tweak = NULL;\n+        secp256k1_ge label_ge;\n+        size_t j;\n+\n+        /* Calculate the output_tweak and convert it to a scalar.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal\n+         * to the curve order, which is statistically improbable. Returning an error here results in an untestable\n+         * branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only with\n+         * negligible probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* Calculate output_negated = -output */\n+        secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (j = 0; j < n_tx_outputs; j++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[j]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = j;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge tx_output_ge;\n+                secp256k1_gej tx_output_gej;\n+                secp256k1_gej label_candidates_gej[2];\n+                secp256k1_ge label_candidates_ge[2];\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[j]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                /* Calculate scan label candidates:\n+                 *     label_candidate1 =  tx_output - generated_output\n+                 *     label_candidate2 = -tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_candidates_gej[0], &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_gej_neg(&tx_output_gej, &tx_output_gej);\n+                secp256k1_gej_add_ge_var(&label_candidates_gej[1], &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_all_gej_var(label_candidates_ge, label_candidates_gej, 2);\n+\n+                /* Check if either of the label candidates is in the label cache */\n+                for (i = 0; i < 2; i++) {\n+                    unsigned char label33[33];\n+                    /* Note: serialize will only fail if label_ge is the point at infinity, but we know\n+                     * this cannot happen since we only hit this branch if tx_output != output_xonly.\n+                     * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\n+                     * point at infinity.\n+                     */\n+                    secp256k1_eckey_pubkey_serialize33(&label_candidates_ge[i], label33);\n+                    label_tweak = label_lookup(label33, label_context);\n+                    if (label_tweak != NULL) {\n+                        found = 1;\n+                        found_idx = j;\n+                        label_ge = label_candidates_ge[i];\n+                        break;\n+                    }\n+                }\n+                if (found) {\n+                    break;\n+                }\n+            }\n+        }\n+        if (found) {\n+            found_outputs[k]->output = *tx_outputs[found_idx];\n+            secp256k1_scalar_get_b32(found_outputs[k]->tweak, &output_tweak_scalar);\n+            /* Clear the output_tweak_scalar since we no longer need it and leaking this value would\n+             * break indistinguishability of the transaction. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            if (label_tweak != NULL) {\n+                found_outputs[k]->found_with_label = 1;\n+                /* This is extremely unlikely to fail in that it can only really fail if label_tweak\n+                 * is the negation of the shared secret tweak. But since both tweak and label_tweak are\n+                 * created by hashing data, practically speaking this would only happen if an attacker\n+                 * tricked us into using a particular label_tweak (deviating from the protocol).\n+                 *\n+                 * Furthermore, although technically a failure for ec_seckey_tweak_add, this is not treated\n+                 * as a failure for Silent Payments because the output is still spendable with just the\n+                 * spend secret key. We set `tweak = 0` for this case.\n+                 */\n+                if (!secp256k1_ec_seckey_tweak_add(ctx, found_outputs[k]->tweak, label_tweak)) {\n+                    memset(found_outputs[k]->tweak, 0, 32);\n+                }\n+                secp256k1_silentpayments_label_save(&found_outputs[k]->label, &label_ge);\n+            } else {\n+                found_outputs[k]->found_with_label = 0;\n+                /* Set the label public key with an invalid public key value. */\n+                memset(&found_outputs[k]->label, 0, sizeof(secp256k1_pubkey));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 737,
      "commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "original_commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n                memset(&found_outputs[k]->label, 0, sizeof(found_outputs[k]->label));\n```",
      "created_at": "2026-02-04T07:04:09Z",
      "updated_at": "2026-02-04T07:06:02Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2762516512",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2762516512"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 737,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2770099289",
      "pull_request_review_id": 3758206612,
      "id": 2770099289,
      "node_id": "PRRC_kwDOAP4Jqs6lHFxZ",
      "diff_hunk": "@@ -0,0 +1,753 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+        k++;\n+        /* Once the number of created outputs for the current recipient group exceeds the\n+         * protocol limit, fail, as the recipient isn't guaranteed to find further ouputs. */\n+        if (k > SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT) {\n+            return 0;\n+        }\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static const unsigned char secp256k1_silentpayments_label_magic[4] = { 0x27, 0x9d, 0x44, 0xba };\n+\n+/* Saves a group element into a label. Requires that the provided group element is not infinity. */\n+static void secp256k1_silentpayments_label_save(secp256k1_silentpayments_label* label, const secp256k1_ge* ge) {\n+    memcpy(&label->data[0], secp256k1_silentpayments_label_magic, 4);\n+    secp256k1_ge_to_bytes(label->data + 4, ge);\n+}\n+\n+/* Loads a group element from a label. Returns 1 unless the label wasn't properly initialized. */\n+static int secp256k1_silentpayments_label_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_silentpayments_label* label) {\n+    ARG_CHECK(secp256k1_memcmp_var(&label->data[0], secp256k1_silentpayments_label_magic, 4) == 0);\n+    secp256k1_ge_from_bytes(ge, label->data + 4);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_parse(const secp256k1_context* ctx, secp256k1_silentpayments_label* label, const unsigned char *in33) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(in33 != NULL);\n+\n+    if (!secp256k1_eckey_pubkey_parse(&ge, in33, 33)) {\n+        return 0;\n+    }\n+\n+    secp256k1_silentpayments_label_save(label, &ge);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_serialize(const secp256k1_context* ctx, unsigned char *out33, const secp256k1_silentpayments_label* label) {\n+    secp256k1_ge ge;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out33 != NULL);\n+    memset(out33, 0, 33);\n+    ARG_CHECK(label != NULL);\n+\n+    if (!secp256k1_silentpayments_label_load(ctx, &ge, label)) {\n+        return 0;\n+    }\n+    secp256k1_eckey_pubkey_serialize33(&ge, out33);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_label_create(const secp256k1_context *ctx, secp256k1_silentpayments_label *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+    secp256k1_ge label_ge;\n+    secp256k1_scalar label_tweak_scalar;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    memset(label, 0, sizeof(*label));\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* ensure that the passed scan key is valid, in order to avoid creating unspendable labels */\n+    ret = secp256k1_ec_seckey_verify(ctx, scan_key32);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    ret &= secp256k1_ec_pubkey_create_helper(&ctx->ecmult_gen_ctx, &label_tweak_scalar, &label_ge, label_tweak32);\n+    secp256k1_silentpayments_label_save(label, &label_ge);\n+\n+    secp256k1_scalar_clear(&label_tweak_scalar);\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+\n+    return ret;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_silentpayments_label *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_silentpayments_label_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+        for (i = 0; i < n_xonly_pubkeys; i++) {\n+            ARG_CHECK(xonly_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+        for (i = 0; i < n_plain_pubkeys; i++) {\n+            ARG_CHECK(plain_pubkeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, uint32_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar scan_key_scalar;\n+    secp256k1_ge spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    unsigned char shared_secret[33];\n+    uint32_t k, k_max;\n+    size_t i, found_idx;\n+    int found, combined, valid_scan_key, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    for (i = 0; i < n_tx_outputs; i++) {\n+        ARG_CHECK(found_outputs[i] != NULL);\n+        ARG_CHECK(tx_outputs[i] != NULL);\n+    }\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    valid_scan_key = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &valid_scan_key, sizeof(valid_scan_key));\n+    if (!valid_scan_key) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    /* Creating the shared secret requires that the public and secret components are\n+     * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+     * scan secret key, and prevouts public key sum) have all been verified at this point,\n+     * assuming that the user hasn't tampered the `prevouts_summary` object manually. */\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+    /* Clear the scan_key_scalar since we no longer need it and leaking this value would break indistinguishability of the transaction. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+\n+    found_idx = 0;\n+    /* Don't look further than the per-group recipient limit, in order to avoid quadratic scaling issues. */\n+    k_max = (n_tx_outputs < SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT) ?\n+             n_tx_outputs : SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT;\n+    /* TODO: potential optimization: the worst-case run-time can be cut in half by randomizing the outputs */\n+    for (k = 0; k < k_max; k++) {\n+        secp256k1_scalar output_tweak_scalar;\n+        secp256k1_xonly_pubkey output_xonly;\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        secp256k1_ge output_negated_ge;\n+        const unsigned char *label_tweak = NULL;\n+        secp256k1_ge label_ge;\n+        size_t j;\n+\n+        /* Calculate the output_tweak and convert it to a scalar.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal\n+         * to the curve order, which is statistically improbable. Returning an error here results in an untestable\n+         * branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only with\n+         * negligible probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* Calculate output_negated = -output */\n+        secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (j = 0; j < n_tx_outputs; j++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[j]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = j;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge tx_output_ge;\n+                secp256k1_gej tx_output_gej;\n+                secp256k1_gej label_candidates_gej[2];\n+                secp256k1_ge label_candidates_ge[2];\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[j]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                /* Calculate scan label candidates:\n+                 *     label_candidate1 =  tx_output - generated_output\n+                 *     label_candidate2 = -tx_output - generated_output\n+                 */\n+                secp256k1_gej_add_ge_var(&label_candidates_gej[0], &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_gej_neg(&tx_output_gej, &tx_output_gej);\n+                secp256k1_gej_add_ge_var(&label_candidates_gej[1], &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_all_gej_var(label_candidates_ge, label_candidates_gej, 2);\n+\n+                /* Check if either of the label candidates is in the label cache */\n+                for (i = 0; i < 2; i++) {\n+                    unsigned char label33[33];\n+                    /* Note: serialize will only fail if label_ge is the point at infinity, but we know\n+                     * this cannot happen since we only hit this branch if tx_output != output_xonly.\n+                     * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\n+                     * point at infinity.\n+                     */\n+                    secp256k1_eckey_pubkey_serialize33(&label_candidates_ge[i], label33);\n+                    label_tweak = label_lookup(label33, label_context);\n+                    if (label_tweak != NULL) {\n+                        found = 1;\n+                        found_idx = j;\n+                        label_ge = label_candidates_ge[i];\n+                        break;\n+                    }\n+                }\n+                if (found) {\n+                    break;\n+                }\n+            }\n+        }\n+        if (found) {\n+            found_outputs[k]->output = *tx_outputs[found_idx];\n+            secp256k1_scalar_get_b32(found_outputs[k]->tweak, &output_tweak_scalar);\n+            /* Clear the output_tweak_scalar since we no longer need it and leaking this value would\n+             * break indistinguishability of the transaction. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            if (label_tweak != NULL) {\n+                found_outputs[k]->found_with_label = 1;\n+                /* This is extremely unlikely to fail in that it can only really fail if label_tweak\n+                 * is the negation of the shared secret tweak. But since both tweak and label_tweak are\n+                 * created by hashing data, practically speaking this would only happen if an attacker\n+                 * tricked us into using a particular label_tweak (deviating from the protocol).\n+                 *\n+                 * Furthermore, although technically a failure for ec_seckey_tweak_add, this is not treated\n+                 * as a failure for Silent Payments because the output is still spendable with just the\n+                 * spend secret key. We set `tweak = 0` for this case.\n+                 */\n+                if (!secp256k1_ec_seckey_tweak_add(ctx, found_outputs[k]->tweak, label_tweak)) {\n+                    memset(found_outputs[k]->tweak, 0, 32);\n+                }\n+                secp256k1_silentpayments_label_save(&found_outputs[k]->label, &label_ge);\n+            } else {\n+                found_outputs[k]->found_with_label = 0;\n+                /* Set the label public key with an invalid public key value. */\n+                memset(&found_outputs[k]->label, 0, sizeof(secp256k1_pubkey));",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 737,
      "commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "original_commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "in_reply_to_id": 2762516512,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ugh, that was a pretty embarrassing (undiscovered) bug. Thanks for spotting, fixed, and also updated the comment line above to not mention \"public key\" anymore.",
      "created_at": "2026-02-05T16:35:49Z",
      "updated_at": "2026-02-05T16:35:49Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2770099289",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2770099289"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 737,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2770103312",
      "pull_request_review_id": 3758210775,
      "id": 2770103312,
      "node_id": "PRRC_kwDOAP4Jqs6lHGwQ",
      "diff_hunk": "@@ -0,0 +1,753 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *  Since heap sort is unstable, we use the recipient's index as tie-breaker to have a well-defined\n+ *  order, i.e. within scan pubkey groups, the spend pubkeys appear in the same order as they were\n+ *  passed in.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    const secp256k1_silentpayments_recipient *r1 = *(const secp256k1_silentpayments_recipient **)pk1;\n+    const secp256k1_silentpayments_recipient *r2 = *(const secp256k1_silentpayments_recipient **)pk2;\n+\n+    int ret = secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx, &r1->scan_pubkey, &r2->scan_pubkey);\n+    if (ret != 0) {\n+        return ret;\n+    } else {\n+        return (r1->index > r2->index) - (r1->index < r2->index);\n+    }\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    VERIFY_CHECK(!secp256k1_ge_is_infinity(public_component));\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(secret_component));\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return (!secp256k1_scalar_is_zero(output_tweak_scalar)) & (!overflow);\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is zero or greater than or equal to\n+     * the curve order, which is statistically improbable. Returning an error here results in an untestable branch in\n+     * the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i;\n+    uint32_t k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+        for (i = 0; i < n_taproot_seckeys; i++) {\n+            ARG_CHECK(taproot_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+        for (i = 0; i < n_plain_seckeys; i++) {\n+            ARG_CHECK(plain_seckeys[i] != NULL);\n+        }\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(generated_outputs[i] != NULL);\n+        ARG_CHECK(recipients[i] != NULL);\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is zero or greater than or equal to the\n+     * curve order, which is statistically improbable. Returning an error here results in an untestable branch in the\n+     * code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            /* Creating the shared secret requires that the public and secret components are\n+             * non-infinity and non-zero, respectively. Note that the involved parts (input hash,\n+             * secret key sum, and scan public key) have all been verified at this point. */\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 317,
      "original_position": 316,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "in_reply_to_id": 2762506274,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Good point, done. Also thanks for adding the clearing of secrets that I missed.",
      "created_at": "2026-02-05T16:36:47Z",
      "updated_at": "2026-02-05T16:36:47Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2770103312",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2770103312"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 317,
      "original_line": 316,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2770104021",
      "pull_request_review_id": 3758211556,
      "id": 2770104021,
      "node_id": "PRRC_kwDOAP4Jqs6lHG7V",
      "diff_hunk": "@@ -0,0 +1,385 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payments outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* Maximum number of Silent Payments recipients per group (i.e.\n+ * recipients sharing the same scan public key) as per BIP-352 */\n+#define SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT 1000\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public key\n+ *  must be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    uint32_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payments outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each Silent Payments\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from Silent Payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  When creating more than one generated output, all of the generated outputs\n+ *  MUST be included in the final transaction. Dropping any of the generated\n+ *  outputs from the final transaction may make all or some of the outputs\n+ *  unfindable by the recipient.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 on failure. This is expected only with an adversarially chosen\n+ *           recipient spend key. Specifically, failure occurs when:\n+ *             - Input secret keys sum to 0 or the negation of a spend key\n+ *               (negligible probability if at least one of the input secret\n+ *               keys is uniformly random and independent of all other keys)\n+ *             - A hash output is not a valid scalar (negligible probability\n+ *               per hash evaluation)\n+ *             - Any group (i.e. recipients sharing the same scan public key) exceeds\n+ *               the protocol limit SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `secp256k1_silentpayments_recipient` object\n+ *                            with index = 0.\n+ *  In:           recipients: pointer to an array of pointers to Silent Payments\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct Silent\n+ *                            Payments addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the size of the recipients array.\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the size of taproot_seckeys array.\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the size of the plain_seckeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   out33: pointer to a 33-byte array to store the serialized label\n+ *  In:    label: pointer to the label\n+ */\n+SECP256K1_API int secp256k1_silentpayments_recipient_label_serialize(\n+    const secp256k1_context *ctx,\n+    unsigned char *out33,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    unsigned char *label_tweak32,\n+    const unsigned char *scan_key32,\n+    uint32_t m\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Create Silent Payments labeled spend public key.\n+ *\n+ *  Given a recipient's spend public key and a label, calculate the\n+ *  corresponding labeled spend public key:\n+ *\n+ *      labeled_spend_pubkey = unlabeled_spend_pubkey + label\n+ *\n+ *  The result is used by the recipient to create a Silent Payments address,\n+ *  consisting of the serialized and concatenated scan public key and\n+ *  (labeled) spend public key.\n+ *\n+ *  Returns: 1 if labeled spend public key creation was successful.\n+ *           0 if spend pubkey and label sum to zero (negligible probability for\n+ *             labels created according to BIP352).\n+ *\n+ *  Args:                    ctx: pointer to a context object\n+ *  Out:    labeled_spend_pubkey: pointer to the resulting labeled spend public key\n+ *  In:   unlabeled_spend_pubkey: pointer to the recipient's unlabeled spend public key\n+ *                         label: pointer to the recipient's label\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *labeled_spend_pubkey,\n+    const secp256k1_pubkey *unlabeled_spend_pubkey,\n+    const secp256k1_silentpayments_label *label\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n+\n+/** Opaque data structure that holds Silent Payments prevouts summary data.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 101 bytes in size, and can be safely copied/moved.\n+ *  This structure does not contain secret data. It can be created with\n+ *  `secp256k1_silentpayments_recipient_prevouts_summary_create`.\n+ */\n+typedef struct secp256k1_silentpayments_prevouts_summary {\n+    unsigned char data[101];\n+} secp256k1_silentpayments_prevouts_summary;\n+\n+/** Compute Silent Payments prevouts summary from prevout public keys and transaction\n+ *  inputs.\n+ *\n+ *  Given a list of n public keys A_1...A_n (one for each Silent Payments\n+ *  eligible input to spend) and a serialized outpoint_smallest36, create a\n+ *  `prevouts_summary` object. This object summarizes the prevout data from the\n+ *  transaction inputs needed for scanning.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment.\n+ *\n+ *  The public keys have to be passed in via two different parameter pairs, one\n+ *  for regular and one for x-only public keys, in order to avoid the need of\n+ *  users converting to a common public key format before calling this function.\n+ *  The resulting data can be used for scanning on the recipient side.\n+ *\n+ *  Returns: 1 if prevouts summary creation was successful.\n+ *           0 if the transaction is not a Silent Payments transaction.\n+ *\n+ *  Args:                 ctx: pointer to a context object\n+ *  Out:     prevouts_summary: pointer to prevouts_summary object containing the\n+ *                             summed public key and input_hash.\n+ *  In:   outpoint_smallest36: serialized smallest outpoint (lexicographically)\n+ *                             from the transaction inputs\n+ *              xonly_pubkeys: pointer to an array of pointers to taproot\n+ *                             x-only public keys (can be NULL if no taproot\n+ *                             inputs are used)\n+ *            n_xonly_pubkeys: the size of the xonly_pubkeys array.\n+ *              plain_pubkeys: pointer to an array of pointers to non-taproot\n+ *                             public keys (can be NULL if no non-taproot\n+ *                             inputs are used)\n+ *            n_plain_pubkeys: the size of the plain_pubkeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Type of callback function for label lookups\n+ *\n+ *  A function of this type will be used to retrieve the label tweak for a given\n+ *  label during scanning. A typical implementation will perform a lookup in a\n+ *  key-value store called the \"label cache\".\n+ *\n+ *  For creating the label cache data,\n+ *  `secp256k1_silentpayments_recipient_label_create` and\n+ *  `secp256k1_silentpayments_recipient_label_serialize` can be used.\n+ *\n+ *  Returns: pointer to the 32-byte label tweak if there is a match.\n+ *           NULL pointer if there is no match.\n+ *\n+ *  In:         label: pointer to the serialized 33-byte label to check\n+ *                     (computed during scanning)\n+ *      label_context: pointer to the recipient's label cache.\n+ */\n+typedef const unsigned char* (*secp256k1_silentpayments_label_lookup)(const unsigned char* label33, const void* label_context);\n+\n+/** Found outputs struct\n+ *\n+ *  Struct for holding a found output along with data needed to spend it later.\n+ *\n+ *            output: the x-only public key for the taproot output\n+ *             tweak: the 32-byte tweak needed to spend the output\n+ *  found_with_label: boolean value to indicate if the output was sent to a\n+ *                    labeled address. If true, label will be set to a valid value.\n+ *             label: the label used. If found_with_label = false, this is set to\n+ *                    an invalid value.\n+ */\n+typedef struct secp256k1_silentpayments_found_output {\n+    secp256k1_xonly_pubkey output;\n+    unsigned char tweak[32];\n+    int found_with_label;\n+    secp256k1_silentpayments_label label;\n+} secp256k1_silentpayments_found_output;\n+\n+/* TODO: clarify the limitations of labels w.r.t. light clients */\n+\n+/** Scan for Silent Payments transaction outputs.\n+ *\n+ *  Given a prevouts_summary object, a recipient's 32 byte scan key and spend public key,\n+ *  and the relevant transaction outputs, scan for outputs belonging to\n+ *  the recipient and return the tweak(s) needed for spending the output(s). An\n+ *  optional label_lookup callback function and label_context can be passed if\n+ *  the recipient uses labels. This allows for checking if a label exists in\n+ *  the recipients label cache and retrieving the label tweak during scanning.\n+ *\n+ *  If used, the `label_lookup` function must return a pointer to a 32-byte label\n+ *  tweak if the label is found, or NULL otherwise. The returned pointer must remain\n+ *  valid until the next call to `label_lookup` or until the function returns,\n+ *  whichever comes first. It is not retained beyond that.\n+ *\n+ *  For creating the label cache, `secp256k1_silentpayments_recipient_label_create`\n+ *  and `secp256k1_silentpayments_recipient_label_serialize` can be used.\n+ *\n+ *  Returns: 1 if output scanning was successful.\n+ *           0 if the transaction is not a Silent Payments transaction,\n+ *             or if the arguments are invalid.\n+ *",
      "path": "include/secp256k1_silentpayments.h",
      "position": 355,
      "original_position": 342,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "in_reply_to_id": 2762495463,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks, added.",
      "created_at": "2026-02-05T16:36:57Z",
      "updated_at": "2026-02-05T16:36:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2770104021",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2770104021"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 355,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2770126141",
      "pull_request_review_id": 3758235199,
      "id": 2770126141,
      "node_id": "PRRC_kwDOAP4Jqs6lHMU9",
      "diff_hunk": "@@ -0,0 +1,385 @@\n+#ifndef SECP256K1_SILENTPAYMENTS_H\n+#define SECP256K1_SILENTPAYMENTS_H\n+\n+#include <stdint.h>\n+#include \"secp256k1.h\"\n+#include \"secp256k1_extrakeys.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module provides an implementation for Silent Payments, as specified in\n+ *  BIP352. This particularly involves the creation of input tweak data by\n+ *  summing up secret or public keys and the derivation of a shared secret using\n+ *  Elliptic Curve Diffie-Hellman. Combined are either:\n+ *    - spender's secret keys and recipient's public key (a * B, sender side)\n+ *    - spender's public keys and recipient's secret key (A * b, recipient side)\n+ *  With this result, the necessary key material for ultimately creating/scanning\n+ *  or spending Silent Payments outputs can be determined.\n+ *\n+ *  Note that this module is _not_ a full implementation of BIP352, as it\n+ *  inherently doesn't deal with higher-level concepts like addresses, output\n+ *  script types or transactions. The intent is to provide a module for\n+ *  abstracting away the elliptic-curve operations required for the protocol. For\n+ *  any wallet software already using libsecp256k1, this API should provide all\n+ *  the functions needed for a Silent Payments implementation without requiring\n+ *  any further elliptic-curve operations from the wallet.\n+ */\n+\n+/* Maximum number of Silent Payments recipients per group (i.e.\n+ * recipients sharing the same scan public key) as per BIP-352 */\n+#define SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT 1000\n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public key\n+ *  must be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    uint32_t index;\n+} secp256k1_silentpayments_recipient;\n+\n+/** Create Silent Payments outputs for recipient(s).\n+ *\n+ *  Given a list of n secret keys a_1...a_n (one for each Silent Payments\n+ *  eligible input to spend), a serialized outpoint, and a list of recipients,\n+ *  create the taproot outputs. Inputs with conditional branches or multiple\n+ *  public keys are excluded from Silent Payments eligible inputs; see BIP352\n+ *  for more information.\n+ *\n+ *  `outpoint_smallest36` refers to the smallest outpoint lexicographically\n+ *  from the transaction inputs (both Silent Payments eligible and non-eligible\n+ *  inputs). This value MUST be the smallest outpoint out of all of the\n+ *  transaction inputs, otherwise the recipient will be unable to find the\n+ *  payment. Determining the smallest outpoint from the list of transaction\n+ *  inputs is the responsibility of the caller. It is strongly recommended\n+ *  that implementations ensure they are doing this correctly by using the\n+ *  test vectors from BIP352.\n+ *\n+ *  When creating more than one generated output, all of the generated outputs\n+ *  MUST be included in the final transaction. Dropping any of the generated\n+ *  outputs from the final transaction may make all or some of the outputs\n+ *  unfindable by the recipient.\n+ *\n+ *  Returns: 1 if creation of outputs was successful.\n+ *           0 on failure. This is expected only with an adversarially chosen\n+ *           recipient spend key. Specifically, failure occurs when:\n+ *             - Input secret keys sum to 0 or the negation of a spend key\n+ *               (negligible probability if at least one of the input secret\n+ *               keys is uniformly random and independent of all other keys)\n+ *             - A hash output is not a valid scalar (negligible probability\n+ *               per hash evaluation)\n+ *             - Any group (i.e. recipients sharing the same scan public key) exceeds\n+ *               the protocol limit SECP256K1_SILENTPAYMENTS_RECIPIENT_GROUP_LIMIT\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static).\n+ *  Out:   generated_outputs: pointer to an array of pointers to xonly public keys,\n+ *                            one per recipient.\n+ *                            The outputs are ordered to match the original\n+ *                            ordering of the recipient objects, i.e.,\n+ *                            `generated_outputs[0]` is the generated output\n+ *                            for the `secp256k1_silentpayments_recipient` object\n+ *                            with index = 0.\n+ *  In:           recipients: pointer to an array of pointers to Silent Payments\n+ *                            recipients, where each recipient is a scan public\n+ *                            key, a spend public key, and an index indicating\n+ *                            its position in the original ordering. The\n+ *                            recipient array will be grouped by scan public key\n+ *                            in place (as specified in BIP0352), but generated\n+ *                            outputs are saved in the `generated_outputs` array\n+ *                            to match the original ordering (using the index\n+ *                            field). This ensures the caller is able to match\n+ *                            the generated outputs to the correct Silent\n+ *                            Payments addresses. The same recipient can be\n+ *                            passed multiple times to create multiple outputs\n+ *                            for the same recipient.\n+ *              n_recipients: the size of the recipients array.\n+ *       outpoint_smallest36: serialized (36-byte) smallest outpoint\n+ *                            (lexicographically) from the transaction inputs\n+ *           taproot_seckeys: pointer to an array of pointers to taproot\n+ *                            keypair inputs (can be NULL if no secret keys\n+ *                            of taproot inputs are used)\n+ *         n_taproot_seckeys: the size of taproot_seckeys array.\n+ *             plain_seckeys: pointer to an array of pointers to 32-byte\n+ *                            secret keys of non-taproot inputs (can be NULL\n+ *                            if no secret keys of non-taproot inputs are\n+ *                            used)\n+ *           n_plain_seckeys: the size of the plain_seckeys array.\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n+\n+/** Opaque data structure that holds a Silent Payments label.\n+ *\n+ *  Guaranteed to be 68 bytes in size. Serialized and parsed with\n+ *  `secp256k1_silentpayments_recipient_label_serialize` and\n+ *  `secp256k1_silentpayments_recipient_label_parse`.\n+ */\n+typedef struct secp256k1_silentpayments_label {\n+    unsigned char data[68];\n+} secp256k1_silentpayments_label;\n+\n+/** Parse a Silent Payments label.\n+ *\n+ *  Returns: 1 when the label could be parsed, 0 otherwise.\n+ *  Args:    ctx: pointer to a context object\n+ *  Out:   label: pointer to a label object\n+ *  In:     in33: pointer to the 33-byte label to be parsed\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_label_parse(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_label *label,\n+    const unsigned char *in33\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Serialize a Silent Payments label\n+ *\n+ *  Returns: 1 always",
      "path": "include/secp256k1_silentpayments.h",
      "position": 160,
      "original_position": 160,
      "commit_id": "25980e82651b8bb3316112ada8ddfb9592b69caf",
      "original_commit_id": "7ce90dd7525fdc72d8ee0ebf470fa8d3fe0bd601",
      "in_reply_to_id": 2761578265,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This is actually intended as-is, because the API description generally assumes that passed in custom (opaque) types are valid (see also other serialization functions, for example [`secp256k1_ec_pubkey_serialize`](https://github.com/bitcoin-core/secp256k1/blob/1d146ac3edd47a6ea10669a18cae62171a8e35c6/include/secp256k1.h#L430), and commits like https://github.com/bitcoin-core/secp256k1/pull/1089/changes/b8f8b99f0fb3a5cd4c6fb1c9c8dfed881839e19e).",
      "created_at": "2026-02-05T16:42:28Z",
      "updated_at": "2026-02-05T16:42:29Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2770126141",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2770126141"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 160,
      "original_line": 160,
      "side": "RIGHT"
    }
  ]
}