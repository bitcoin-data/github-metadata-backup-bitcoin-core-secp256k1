{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765",
    "id": 2966544424,
    "node_id": "PR_kwDOAP4Jqs6w0eAo",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1765.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1765.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
    "number": 1765,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Add \"silentpayments\" module implementing BIP352 (take 4, limited to full-node scanning)",
    "user": {
      "login": "theStack",
      "id": 91535,
      "node_id": "MDQ6VXNlcjkxNTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theStack",
      "html_url": "https://github.com/theStack",
      "followers_url": "https://api.github.com/users/theStack/followers",
      "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
      "organizations_url": "https://api.github.com/users/theStack/orgs",
      "repos_url": "https://api.github.com/users/theStack/repos",
      "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/theStack/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "### Description\r\n\r\nThis PR implements [BIP352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki) with scanning limited to full-nodes. Light-client scanning is planned to be added in a separate PR in the future. The following 5 API functions are currently introduced:\r\n\r\nSender side [[BIP description](https://github.com/bitcoin/bips/blob/c9a6ca6297eb8de850f6b64dafb8e60ee9b64d66/bip-0352.mediawiki?plain=1#L297-L312)]: \r\n* `secp256k1_silentpayments_sender_create_outputs`: given a list of $n$ secret keys $a_1 ... a_n$, a serialized outpoint, and a list of recipients (each consisting of silent payments scan pubkey and spend pubkey), create the corresponding transaction outputs (x-only public keys) for the sending transaction \r\n\r\nReceiver side, label creation [[BIP description](https://github.com/bitcoin/bips/blob/c9a6ca6297eb8de850f6b64dafb8e60ee9b64d66/bip-0352.mediawiki?plain=1#L200)]:\r\n* `secp256k1_recipient_create_label`: given a scan secret key and label integer, calculate the corresponding label_tweak and label public key\r\n* `secp256k1_recipient_create_labeled_spend_pubkey`: given a spend public key and a label public key, create the corresponding labeled spend public key\r\n\r\nReceiver side, scanning [[BIP description](https://github.com/bitcoin/bips/blob/c9a6ca6297eb8de850f6b64dafb8e60ee9b64d66/bip-0352.mediawiki?plain=1#L334)]: \r\n* `secp256k1_recipient_prevouts_summary_create`: given a list of $n$ public keys $A_1 ... A_n$ and a serialized outpoint, create a `prevouts_summary` object needed for scanning\r\n* `secp256k1_recipient_scan_outputs`: given a `prevouts_summary` object, a recipients scan secret key and spend public key, and the relevant transaction outputs (x-only public keys), scan for outputs belonging to the recipients and and return the tweak(s) needed for spending the output(s). Optionally, a label_lookup callback function can be provided to also scan for labels.\r\n\r\nFor a higher-level overview on what these functions exactly do, it's suggested to look at a corresponding [Python implementation](https://github.com/theStack/secp256k1lab/blob/add_bip352_module_review_helper/src/secp256k1lab/bip352.py) that was created based on the secp256k1lab project (it passes the test vectors, so this \"executable pseudo-code\" should be correct).\r\n\r\n### Changes to the previous take\r\n\r\nBased on the latest state of the previous PR #1698 (take 3), the following changes have been made:\r\n* rebased on master (adapting to the new unit test framework added in #1734; thanks to furszy for his [mini-guide](https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3340808550))\r\n* removed functionality that is only relevant for light clients (`_prevout_summary_{parse,serialize}`, `__recipient_create_output_pubkeys`), adapted tests and benchmark accordingly\r\n* adapted examples to have both Bob and Carol do full-node scanning, with a TODO to switch the latter to light-client scanning once available in the future\r\n* addressed various review comments, if still relevant (https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2433803533, https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2433808769, https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2433811927, https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2433817223)\r\n\r\nThe scope reduction isn't immediately visible in commit count (only one commit was _only_ introducing light-client relevant functionality and could be completely removed), but the review burden compared #1698 is still significantly lower in terms of LOC, especially in the receiving commit.\r\n\r\n### Open questions / TODOs\r\n* ~~Recent proposals of reducing the worst-case scanning time (see posts by w0xlt and jonasnick, https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3448610022 ff.) are not taken into account yet.~~ :arrow_right: solved by marking already-found outputs, see https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3577161237 :heavy_check_mark: \r\n* ~~Not providing `prevouts_summary` (de)serialization functionality yet in the API poses the risk that users try to do it anyway by treating the opaque object as \"serialized\". How to cope with that? Is adding a \"don't do this\" comment in API header sufficient?~~ :arrow_right: solved by mentioning a \"don't do this\" comment in the API header (same phrasing as in other modules), see https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3533591506 :heavy_check_mark: ",
    "labels": [
      {
        "id": 4975353639,
        "node_id": "LA_kwDOAP4Jqs8AAAABKI3fJw",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels/feature",
        "name": "feature",
        "description": "",
        "color": "731E95",
        "default": false
      }
    ],
    "created_at": "2025-10-31T12:06:04Z",
    "updated_at": "2025-12-16T16:37:50Z",
    "mergeable": true,
    "mergeable_state": "unstable",
    "merged": false,
    "merge_commit_sha": "d149a80f4a74937310b30d20e6448f95e0fc1e42",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "theStack:silentpayments_module_fullnode_only",
      "ref": "silentpayments_module_fullnode_only",
      "sha": "96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 452762907,
        "node_id": "R_kgDOGvydGw",
        "name": "secp256k1",
        "full_name": "theStack/secp256k1",
        "owner": {
          "login": "theStack",
          "id": 91535,
          "node_id": "MDQ6VXNlcjkxNTM1",
          "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/theStack",
          "html_url": "https://github.com/theStack",
          "followers_url": "https://api.github.com/users/theStack/followers",
          "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
          "organizations_url": "https://api.github.com/users/theStack/orgs",
          "repos_url": "https://api.github.com/users/theStack/repos",
          "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/theStack/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/theStack/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/theStack/secp256k1",
        "archive_url": "https://api.github.com/repos/theStack/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/theStack/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/theStack/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/theStack/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/theStack/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/theStack/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/theStack/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/theStack/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/theStack/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/theStack/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/theStack/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/theStack/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/theStack/secp256k1/events",
        "forks_url": "https://api.github.com/repos/theStack/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/theStack/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/theStack/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/theStack/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/theStack/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/theStack/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/theStack/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/theStack/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/theStack/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/theStack/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/theStack/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/theStack/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/theStack/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/theStack/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/theStack/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/theStack/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:theStack/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/theStack/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/theStack/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/theStack/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/theStack/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/theStack/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/theStack/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/theStack/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/theStack/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/theStack/secp256k1/hooks",
        "svn_url": "https://github.com/theStack/secp256k1",
        "language": "C",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 13102,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-12-16T16:37:48Z",
        "created_at": "2022-01-27T16:42:12Z",
        "updated_at": "2025-09-14T19:27:22Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "8d445730ec79a9fa722eea59b6b697c3b9b1d501",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 1106,
        "stargazers_count": 2359,
        "watchers_count": 2359,
        "size": 14022,
        "default_branch": "master",
        "open_issues_count": 162,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-12-15T19:44:03Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2025-12-15T19:44:07Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 8088,
    "deletions": 35,
    "changed_files": 23,
    "commits": 11,
    "review_comments": 27,
    "comments": 28
  },
  "events": [
    {
      "event": "labeled",
      "id": 20764376070,
      "node_id": "LE_lADOAP4Jqs7VEWwNzwAAAATVpzwG",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20764376070",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-06T16:09:29Z",
      "label": {
        "name": "feature",
        "color": "731E95"
      }
    },
    {
      "event": "commented",
      "id": 3499455867,
      "node_id": "IC_kwDOAP4Jqs7QlXV7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3499455867",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-06T21:27:50Z",
      "updated_at": "2025-11-06T21:27:50Z",
      "author_association": "NONE",
      "body": "Added the optimized version on top of this PR:\r\nhttps://github.com/w0xlt/secp256k1/commit/8d16914cad57ba07da09d104f0c605ae6284462f\r\n\r\nFor more context:\r\nhttps://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3462891318",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3499455867",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3500144381,
      "node_id": "IC_kwDOAP4Jqs7Qn_b9",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3500144381",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-07T01:58:22Z",
      "updated_at": "2025-11-07T01:58:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "Small supplementary update: I've created a corresponding Python implementation of the provided API functions based on secp256k1lab (https://github.com/theStack/secp256k1lab/blob/add_bip352_module_review_helper/src/secp256k1lab/bip352.py) (also linked in the PR description). The hope is that this makes reviewing this PR a bit easier by having a less noisy, \"executable pseudo-code\"-like description on what happens under the hood. The code passes the BIP352 test vectors and hence should be correct.\r\n\r\n> Added the optimized version on top of this PR: [w0xlt@8d16914](https://github.com/w0xlt/secp256k1/commit/8d16914cad57ba07da09d104f0c605ae6284462f)\r\n> \r\n> For more context: [#1698 (comment)](https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3462891318)\r\n\r\nThanks for rebasing on top of this PR, much appreciated! I will take a closer look within the next days.\r\n",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3500144381",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "subscribed",
      "id": 20780027146,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATWlg0K",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20780027146",
      "actor": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-07T07:32:48Z"
    },
    {
      "event": "reviewed",
      "id": 3462461331,
      "node_id": "PRR_kwDOAP4Jqs7OYPeT",
      "url": null,
      "actor": null,
      "commit_id": "c11d30c25f75776920797b017a568ea0cfc28882",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-14T02:04:05Z",
      "author_association": "NONE",
      "body": "Nit: Not related to optimization, but the diff below removes some redundant public-key serialization code:\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\nindex 106da20..922433d 100644\r\n--- a/src/modules/silentpayments/main_impl.h\r\n+++ b/src/modules/silentpayments/main_impl.h\r\n@@ -21,6 +21,19 @@\r\n /** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\r\n static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\r\n \r\n+/* Serialize a ge to compressed 33 bytes. Keeps eckey_pubkey_serialize usage uniform\r\n+ * (expects non-const ge*), and centralizes the VERIFY_CHECK. */\r\n+static SECP256K1_INLINE void secp256k1_sp_ge_serialize33(const secp256k1_ge* in, unsigned char out33[33]) {\r\n+    size_t len = 33;\r\n+    secp256k1_ge tmp = *in;\r\n+    int ok = secp256k1_eckey_pubkey_serialize(&tmp, out33, &len, 1);\r\n+#ifdef VERIFY\r\n+    VERIFY_CHECK(ok && len == 33);\r\n+#else\r\n+    (void)ok;\r\n+#endif\r\n+}\r\n+\r\n /** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\r\n  *  ensure the correct values of k are used when creating multiple outputs for a recipient.\r\n  *\r\n@@ -68,13 +81,11 @@ static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar\r\n     secp256k1_sha256 hash;\r\n     unsigned char pubkey_sum_ser[33];\r\n     unsigned char input_hash[32];\r\n-    size_t len;\r\n     int ret, overflow;\r\n \r\n     secp256k1_silentpayments_sha256_init_inputs(&hash);\r\n     secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\r\n-    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\r\n-    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\r\n+    secp256k1_sp_ge_serialize33(pubkey_sum, pubkey_sum_ser);\r\n     secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\r\n     secp256k1_sha256_finalize(&hash, input_hash);\r\n     /* Convert input_hash to a scalar.\r\n@@ -85,15 +96,13 @@ static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar\r\n      * an error to ensure strict compliance with BIP0352.\r\n      */\r\n     secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\r\n-    ret &= !secp256k1_scalar_is_zero(input_hash_scalar);\r\n+    ret = !secp256k1_scalar_is_zero(input_hash_scalar);\r\n     return ret & !overflow;\r\n }\r\n \r\n static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\r\n     secp256k1_gej ss_j;\r\n     secp256k1_ge ss;\r\n-    size_t len;\r\n-    int ret;\r\n \r\n     secp256k1_ecmult_const(&ss_j, public_component, secret_component);\r\n     secp256k1_ge_set_gej(&ss, &ss_j);\r\n@@ -103,12 +112,7 @@ static void secp256k1_silentpayments_create_shared_secret(const secp256k1_contex\r\n      * impossible at this point considering we have already validated the public key and\r\n      * the secret key.\r\n      */\r\n-    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\r\n-#ifdef VERIFY\r\n-    VERIFY_CHECK(ret && len == 33);\r\n-#else\r\n-    (void)ret;\r\n-#endif\r\n+    secp256k1_sp_ge_serialize33(&ss, shared_secret33);\r\n \r\n     /* Leaking these values would break indistinguishability of the transaction, so clear them. */\r\n     secp256k1_ge_clear(&ss);\r\n@@ -585,7 +589,6 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n                 secp256k1_ge output_negated_ge, tx_output_ge;\r\n                 secp256k1_gej tx_output_gej, label_gej;\r\n                 unsigned char label33[33];\r\n-                size_t len;\r\n \r\n                 secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[j]);\r\n                 secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\r\n@@ -595,7 +598,6 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n                 secp256k1_ge_neg(&output_negated_ge, &output_ge);\r\n                 secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\r\n                 secp256k1_ge_set_gej_var(&label_ge, &label_gej);\r\n-                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\r\n                 /* Serialize must succeed because the point was just loaded.\r\n                  *\r\n                  * Note: serialize will also fail if label_ge is the point at infinity, but we know\r\n@@ -603,7 +605,7 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n                  * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\r\n                  * point at infinity.\r\n                  */\r\n-                VERIFY_CHECK(ret && len == 33);\r\n+                secp256k1_sp_ge_serialize33(&label_ge, label33);\r\n                 label_tweak = label_lookup(label33, label_context);\r\n                 if (label_tweak != NULL) {\r\n                     found = 1;\r\n@@ -617,7 +619,6 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n                 secp256k1_gej_neg(&label_gej, &tx_output_gej);\r\n                 secp256k1_gej_add_ge_var(&label_gej, &label_gej, &output_negated_ge, NULL);\r\n                 secp256k1_ge_set_gej_var(&label_ge, &label_gej);\r\n-                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\r\n                 /* Serialize must succeed because the point was just loaded.\r\n                  *\r\n                  * Note: serialize will also fail if label_ge is the point at infinity, but we know\r\n@@ -625,7 +626,7 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n                  * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\r\n                  * point at infinity.\r\n                  */\r\n-                VERIFY_CHECK(ret && len == 33);\r\n+                secp256k1_sp_ge_serialize33(&label_ge, label33);\r\n                 label_tweak = label_lookup(label33, label_context);\r\n                 if (label_tweak != NULL) {\r\n                     found = 1;\r\n``` ",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3462461331",
      "submitted_at": "2025-11-14T02:04:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "reviewed",
      "id": 3462502369,
      "node_id": "PRR_kwDOAP4Jqs7OYZfh",
      "url": null,
      "actor": null,
      "commit_id": "c11d30c25f75776920797b017a568ea0cfc28882",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-14T02:25:07Z",
      "author_association": "NONE",
      "body": "nit: The following diff removes the implicit cast and clarifies that k is 4 bytes\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\nindex 922433d..d94aed6 100644\r\n--- a/src/modules/silentpayments/main_impl.h\r\n+++ b/src/modules/silentpayments/main_impl.h\r\n@@ -512,7 +512,8 @@ int secp256k1_silentpayments_recipient_scan_outputs(\r\n     secp256k1_xonly_pubkey output_xonly;\r\n     unsigned char shared_secret[33];\r\n     const unsigned char *label_tweak = NULL;\r\n-    size_t j, k, found_idx;\r\n+    size_t j, found_idx;\r\n+    uint32_t k;\r\n     int found, combined, valid_scan_key, ret;\r\n \r\n     /* Sanity check inputs */\r\n```",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3462502369",
      "submitted_at": "2025-11-14T02:25:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "reviewed",
      "id": 3465700051,
      "node_id": "PRR_kwDOAP4Jqs7OkmLT",
      "url": null,
      "actor": null,
      "commit_id": "c11d30c25f75776920797b017a568ea0cfc28882",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-14T16:25:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks @theStack for the new PR. I can confirm that this PR is a rebased version of #1698, with the light client functionality removed and comments addressed, except for:\r\n\r\n- https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2414315034\r\n- https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2414294498\r\n- https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3313483669 (only the last one, \"elemement\")\r\n",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3465700051",
      "submitted_at": "2025-11-14T16:25:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "commented",
      "id": 3533591506,
      "node_id": "IC_kwDOAP4Jqs7SnlPS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3533591506",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-14T16:33:07Z",
      "updated_at": "2025-11-14T16:33:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Not providing prevouts_summary (de)serialization functionality yet in the API poses the risk that users try to do it anyway by treating the opaque object as \"serialized\". How to cope with that? Is adding a \"don't do this\" comment in API header sufficient?\r\n\r\nIs there a reason for serializing prevouts_summary without light client functionality? If not, I think the don't do this comment is sufficient. Right now, in contrast to the docs of all other opaque objects, this is missing, however:\r\n\r\n> The exact representation of data inside the opaque data structures is implementation defined and not guaranteed to be portable between different platforms or versions.  ",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3533591506",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20956101523,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAThFLuT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956101523",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "445f2e835fdd81a23784d5b398f1180453a74c55",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/445f2e835fdd81a23784d5b398f1180453a74c55",
      "created_at": "2025-11-15T00:46:39Z"
    },
    {
      "event": "commented",
      "id": 3535206990,
      "node_id": "IC_kwDOAP4Jqs7StvpO",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3535206990",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-15T00:48:14Z",
      "updated_at": "2025-11-15T00:48:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "@w0xlt, @jonasnick: Thanks for the reviews! I've addressed the suggested changes:\r\n* in `_recpient_scan_outputs`: changed the type of `k`  to uint32_t ([comment above](https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3462502369))\r\n* in `_recipient_create_label`: added a scan key validity check (+added a test for that) ([#1698 - comment](https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2414315034))\r\n* unified all mentions of \"Silent Payments\" to [title case](https://en.wikipedia.org/wiki/Title_case) in the header API and example ([#1698 - comment](https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2414294498))\r\n* fixed typo s/elemement/element/ ([#1698 - review](https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3313483669))\r\n* in `_recipient_scan_outputs`: fixed comment in second label candidate ([review above](https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2528111908))\r\n* extended the API header comment for the `_prevouts_summary` opaque data structure, to point out that the data structure is implementation defined (like docs of all other opaque structs) ([comment above](https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3533591506))\r\n\r\n> Nit: Not related to optimization, but the diff below removes some redundant public-key serialization code:\r\n\r\nGiven that this compressed-pubkey-serialization pattern shows up repeatedly also in other modules (ellswift, musig), I think it would make the most sense to add a general helper (e.g. in eckey{,_impl}.h), which could be done in an independent PR. I've opened issue https://github.com/bitcoin-core/secp256k1/issues/1773 to see if there is conceptual support for doing this.\r\n\r\n> > Not providing prevouts_summary (de)serialization functionality yet in the API poses the risk that users try to do it anyway by treating the opaque object as \"serialized\". How to cope with that? Is adding a \"don't do this\" comment in API header sufficient?\r\n> \r\n> Is there a reason for serializing prevouts_summary without light client functionality? If not, I think the don't do this comment is sufficient.\r\n\r\nGood point, I can't think of a good reason for full nodes wanting to serialize prevouts_summary. ",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3535206990",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 20956120856,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAThFQcY",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956120856",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-15T00:48:15Z"
    },
    {
      "event": "subscribed",
      "id": 20956120868,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAThFQck",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956120868",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-15T00:48:15Z"
    },
    {
      "event": "mentioned",
      "id": 20956120878,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAThFQcu",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956120878",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-15T00:48:15Z"
    },
    {
      "event": "subscribed",
      "id": 20956120885,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAThFQc1",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956120885",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-15T00:48:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20956305029,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAThF9aF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/20956305029",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "9103229d27d85fa8b199705f29bd7dada54ebaa7",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/9103229d27d85fa8b199705f29bd7dada54ebaa7",
      "created_at": "2025-11-15T01:01:15Z"
    },
    {
      "event": "commented",
      "id": 3560474486,
      "node_id": "IC_kwDOAP4Jqs7UOId2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3560474486",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T22:52:16Z",
      "updated_at": "2025-11-20T22:55:40Z",
      "author_association": "NONE",
      "body": "To address the open questions, Ive reviewed the proposed changes by @w0xlt on 8d16914cad57ba07da09d104f0c605ae6284462f.\r\n\r\nI'm going to focus more on the key aspects I extracted from the review and the merits of each change, rather on the big O improvement claims, because I didn't get that far.\r\n\r\nThese are multiple different changes rather than a single one, so to make the review easier I suggest to brake it in multiple commits. I would state on each of them the purpose and the real case scenario where the change would be relevant.\r\n\r\nAlso, I would use clearer names for the variables or at least document their purpose.\r\n\r\nThe changes I've identified so far are the following:\r\n\r\n- Improve label lookup using hash table: I think this is implementation dependent and should be improved by the user rather than by the library itself.\r\nExamples, as part of the documentation, are a usage demonstration, although can point the user the best practices, I prefer clarity rather than performance on them. For example, on the `rust-secp256k1` bindings, I used a [`HashMap` for the example](https://github.com/rust-bitcoin/rust-secp256k1/pull/876/commits/776653d9db064c8a5a422dca2311eaf669d96921#diff-120e5d0e47cef65c1da3e8220332b2fd878324ea96b204955dc7efc39b7d6fe8R84) because it is a familiar standard structure for Rust users. If they would like to gain more performance there, they have other [tools](https://nnethercote.github.io/perf-book/hashing.html) available to replace that structure by themselves.\r\n- On `secp256k1_silentpayments_recipient_sort_cmp`, I understood the change: `(r1->index < r2->index) ? -1 : (r1->index > r2->index) ? 1 : 0` is to make the unstable `secp256k1_hsort` implementation stable. Considering it only affects `secp256k1_silentpayments_sender_create_outputs`, which didn't receive more changes than a variable removal, what are the performance improvements there?\r\n- `SECP256K1_SP_SCAN_BATCH`: I [just learned about it (ge_set_gej_all)](https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3460261306) during this review, but seems that affine to jacobian conversion is needed for the comparison against labels, and is faster to do it in batches. I think the impact of this improvement will only affect the small subset of transaction with large amount of outputs. A good benchmark for this would be coinjoin transactions, although is not supported by BIP 352, a test case is doable.\r\n- Double `head`: I'm not sure of the target of this change, I guess is to skip already found or scanned inputs, but couldn't figure out what is tracking each head.\r\n- Binary tree search for x-only lookups: I think it explain itself, faster lookups on the not labeled case. This may have its merits, but I need to remove the other changes to have a clear answer.\r\n\r\nIn general I agree with @jonasnick that we should define a [clear target to benchmark and improve](https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3460261306). [As I've said before](https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3461362873), the base case should be a wallet with a single label for change.\r\nFor other improvements, I would try to match up plausible real world scenarios before making complex changes in the code base of the PR.\r\nFinally, by looking at `bench_silentpayments_full_tx_scan`, the `use_labels` case is very simple. If we want to test performance improvements on the label lookup, I would start there.\r\n\r\nIn conclusion, from the proposed commit and the discussion around it, the only changes I've found clear enough to consider are:\r\n- [Tracking of found outputs](https://github.com/jonasnick/secp256k1/commit/311b4ebb2bf6612c46cefd80a8812d9c9b5dc6c4): simple enough, small performance improvement for the usual case, better for larger transactions.\r\n",
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3560474486",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21083667735,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATorz0X",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21083667735",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T22:52:18Z"
    },
    {
      "event": "subscribed",
      "id": 21083667746,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATorz0i",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21083667746",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T22:52:18Z"
    },
    {
      "event": "mentioned",
      "id": 21083667760,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATorz0w",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21083667760",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T22:52:18Z"
    },
    {
      "event": "subscribed",
      "id": 21083667781,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATorz1F",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21083667781",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T22:52:18Z"
    },
    {
      "event": "commented",
      "id": 3560646024,
      "node_id": "IC_kwDOAP4Jqs7UOyWI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3560646024",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T23:34:35Z",
      "updated_at": "2025-11-20T23:34:35Z",
      "author_association": "NONE",
      "body": "Thanks @nymius for reviewing the changes, addressing the main points, and proposing a simplification.\r\n\r\nIm currently splitting the optimization commit into smaller pieces to make it easier to review. \r\nIll also take a closer look at your commit and run it against the benchmark files.\r\n\r\nThe only part of the discussion that still feels a bit ambiguous is the base or usual case. \r\nFrom my understanding of https://github.com/bitcoin-core/secp256k1/pull/1698#pullrequestreview-3341766084, the concern is not about typical usage, but rather about an attacker crafting malicious transactions with many outputs, causing the scanning process to take hours.\r\n\r\nSo the goal of this optimization would be to mitigate that scenario, not the collaborative one.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3560646024",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21084329452,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATouVXs",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21084329452",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T23:34:36Z"
    },
    {
      "event": "subscribed",
      "id": 21084329487,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATouVYP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21084329487",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-20T23:34:37Z"
    },
    {
      "event": "commented",
      "id": 3561510143,
      "node_id": "IC_kwDOAP4Jqs7USFT_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3561510143",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T05:55:27Z",
      "updated_at": "2025-11-21T05:55:27Z",
      "author_association": "NONE",
      "body": "I ran the `examples/silentpayments_mixed_1.c` file with simplified the version suggested by @nymius  https://github.com/jonasnick/secp256k1/commit/311b4ebb2bf6612c46cefd80a8812d9c9b5dc6c4 . It shows slightly worse performance (see below), but the simpler approach may still be worth it\r\n\r\nWithout the `secp256k1_silentpayments_recipient_sort_cmp` stabilization, I got **82s** for the complex version vs. **114s** for the simpler one. Whether the **30s** difference justifies the additional complexity is up for discussion  I dont have a strong opinion.\r\n\r\nAnswering the questions: `secp256k1_silentpayments_recipient_sort_cmp stabilization` + `heads` speed up the non-adversarial case. The stable sort ensures that the transaction outputs are ordered sequentially by the index $k$.\r\n\r\nThe optimized receiver implementation relies on a heuristic (the `head` pointers) that assumes the next output it is looking for ($k+1$) is located immediately after the previous one ($k$).\r\n\r\n* **With Stable Sort:** The scanner complexity is roughly **O(N)** (Linear).\r\n* **Without Stable Sort:** The scanner complexity degrades to **O(N)** (Quadratic).",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3561510143",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21089045331,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATpAUtT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21089045331",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T05:55:28Z"
    },
    {
      "event": "subscribed",
      "id": 21089045351,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATpAUtn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21089045351",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T05:55:28Z"
    },
    {
      "event": "commented",
      "id": 3563588992,
      "node_id": "IC_kwDOAP4Jqs7UaA2A",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3563588992",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:38Z",
      "updated_at": "2025-11-21T15:46:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "@w0xlt, @nymius: Thanks for investigating this deeper. I've now also had a chance to look at the suggested optimizations and came to similar conclusions as stated in https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3560474486. I particularly agree with the stated points that the changes should not increase complexity significantly and that the most important optimization candidate to consider for mitigating the worst-case scanning attack is \"skip outputs that we have already found\" (as previously stated by @jonasnick, see https://github.com/bitcoin-core/secp256k1/pull/1698#issuecomment-3460261306 and  https://github.com/jonasnick/secp256k1/commit/311b4ebb2bf6612c46cefd80a8812d9c9b5dc6c4). I don't think stabilizing the sorting helps at all, since this is something that happens at the sender side, and we can't rely on the attacker using a specific implementation (even if they did, it's trivial for them to shuffle the outputs after creation).\r\n\r\nFor the proposed target to benchmark, I'm proposing the following modified example that exhibits the worst-case scanning time based on a labels cache with one entry (for change outputs), by creating a tx with 23255 outputs [1] all targeted for Bob: https://github.com/bitcoin-core/secp256k1/commit/1df4287eb8daa34a07888300e0b18ba1c97a3432\r\n\r\nShower-thought from this morning: what if we treat the `tx_outputs` input as _actual_ list that we modify, and remove an entry if it is found? This would have a similar effect as the \"track found outputs\" idea, but without the need of dynamic memory allocation. It's a ~10-lines diff and seems to work fine: https://github.com/theStack/secp256k1/commit/9aba4709b937eb44507494b3bd5e80871193671c\r\nIt reduces the run-time of the proposed example above from ~10 minutes to roughly ~2 seconds on my machine.\r\n\r\nAny thoughts on this? Maybe I'm still missing something.\r\n\r\n[1] that's an upper bound of maximum outputs per block: floor(1000000/43) = 23255",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3563588992",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21100019914,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATpqMDK",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100019914",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:39Z"
    },
    {
      "event": "subscribed",
      "id": 21100019955,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATpqMDz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100019955",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:39Z"
    },
    {
      "event": "mentioned",
      "id": 21100019976,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATpqMEI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100019976",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:39Z"
    },
    {
      "event": "subscribed",
      "id": 21100019996,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATpqMEc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100019996",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:39Z"
    },
    {
      "event": "mentioned",
      "id": 21100020018,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATpqMEy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100020018",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:39Z"
    },
    {
      "event": "subscribed",
      "id": 21100020048,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATpqMFQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21100020048",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T15:46:40Z"
    },
    {
      "event": "commented",
      "id": 3564351976,
      "node_id": "IC_kwDOAP4Jqs7Uc7Ho",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3564351976",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-21T19:34:35Z",
      "updated_at": "2025-11-21T20:03:46Z",
      "author_association": "NONE",
      "body": "> Shower-thought from this morning: what if we treat the `tx_outputs` input as _actual_ list that we modify, and remove an entry if it is found? This would have a similar effect as the \"track found outputs\" idea, but without the need of dynamic memory allocation. It's a ~10-lines diff and seems to work fine: [theStack@9aba470](https://github.com/theStack/secp256k1/commit/9aba4709b937eb44507494b3bd5e80871193671c) It reduces the run-time of the proposed example above from ~10 minutes to roughly ~2 seconds on my machine.\r\n> \r\n> Any thoughts on this? Maybe I'm still missing something.\r\n\r\n1df4287eb8daa34a07888300e0b18ba1c97a3432 is a good target.\r\nThese are the runtime times I've obtained testing against this target:\r\n| Branch         | Runtime         |\r\n| :----------- | :--------------: | \r\n|theStack@9aba470| ~1.41s |\r\n| theStack@9103229d27d85fa8b199705f29bd7dada54ebaa7 (baseline) | ~9m |\r\n| jonasnick@311b4eb| ~1.49s |\r\n\r\nI had to increase stack size to be able to fit all N_OUTPUT size allocations in the example.\r\n\r\nInitially I preferred the `is_found` allocation rather than the element shifts. But your solution seems to be more performant.",
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3564351976",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3566408583,
      "node_id": "IC_kwDOAP4Jqs7UkxOH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3566408583",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T10:14:22Z",
      "updated_at": "2025-11-22T10:14:22Z",
      "author_association": "NONE",
      "body": "@theStack Yes  if we want to keep only the adversarial-scenario optimizations, we can drop sort stabilization and the extra heads.\r\n\r\nI like your idea of avoiding dynamic memory allocation. Thats a very interesting direction. On my machine, the scan completes in about **0.4s**, which feels like a good balance between simplicity and the optimization needed for the labeled case.\r\n\r\nBelow are the changes I had to make for your example to run on my machine and to record the scan time.\r\n\r\n```diff\r\ndiff --git a/examples/silentpayments.c b/examples/silentpayments.c\r\nindex 5e71e73..d43332f 100644\r\n--- a/examples/silentpayments.c\r\n+++ b/examples/silentpayments.c\r\n@@ -10,6 +10,7 @@\r\n #include <stdio.h>\r\n #include <stdlib.h>\r\n #include <string.h>\r\n+#include <time.h>\r\n \r\n #include <secp256k1_extrakeys.h>\r\n #include <secp256k1_silentpayments.h>\r\n@@ -112,15 +113,21 @@ const unsigned char* label_lookup(\r\n     return NULL;\r\n }\r\n \r\n+static secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\r\n+static const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\r\n+static secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\r\n+static secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\r\n+static secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\r\n+static secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\r\n+static secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\r\n+static const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\r\n+/* 2D array for holding multiple public key pairs. The second index, i.e., [2],\r\n+ * is to represent the spend and scan public keys. */\r\n+static unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\r\n+\r\n int main(void) {\r\n     unsigned char randomize[32];\r\n     unsigned char serialized_xonly[32];\r\n-    secp256k1_xonly_pubkey tx_inputs[N_INPUTS];\r\n-    const secp256k1_xonly_pubkey *tx_input_ptrs[N_INPUTS];\r\n-    secp256k1_xonly_pubkey tx_outputs[N_OUTPUTS];\r\n-    secp256k1_xonly_pubkey *tx_output_ptrs[N_OUTPUTS];\r\n-    secp256k1_silentpayments_found_output found_outputs[N_OUTPUTS];\r\n-    secp256k1_silentpayments_found_output *found_output_ptrs[N_OUTPUTS];\r\n     secp256k1_silentpayments_prevouts_summary prevouts_summary;\r\n     secp256k1_pubkey unlabeled_spend_pubkey;\r\n     struct labels_cache bob_labels_cache;\r\n@@ -209,11 +216,6 @@ int main(void) {\r\n     {\r\n         secp256k1_keypair sender_keypairs[N_INPUTS];\r\n         const secp256k1_keypair *sender_keypair_ptrs[N_INPUTS];\r\n-        secp256k1_silentpayments_recipient recipients[N_OUTPUTS];\r\n-        const secp256k1_silentpayments_recipient *recipient_ptrs[N_OUTPUTS];\r\n-        /* 2D array for holding multiple public key pairs. The second index, i.e., [2],\r\n-         * is to represent the spend and scan public keys. */\r\n-        unsigned char (*sp_addresses[N_OUTPUTS])[2][33];\r\n         unsigned char seckey[32];\r\n \r\n         printf(\"Sending...\\n\");\r\n@@ -340,6 +342,9 @@ int main(void) {\r\n              *        `secp256k1_silentpayments_recipient_prevouts_summary_create`\r\n              *     2. Call `secp256k1_silentpayments_recipient_scan_outputs`\r\n              */\r\n+            clock_t start, end;\r\n+            double cpu_time_used;\r\n+\r\n             ret = secp256k1_silentpayments_recipient_prevouts_summary_create(ctx,\r\n                 &prevouts_summary,\r\n                 smallest_outpoint,\r\n@@ -356,14 +361,20 @@ int main(void) {\r\n \r\n             /* Scan the transaction */\r\n             n_found_outputs = 0;\r\n+            \r\n+            start = clock();\r\n             ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\r\n                 found_output_ptrs, &n_found_outputs,\r\n-                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, N_OUTPUTS,\r\n+                (const secp256k1_xonly_pubkey **)tx_output_ptrs, N_OUTPUTS,\r\n                 bob_scan_key,\r\n                 &prevouts_summary,\r\n                 &unlabeled_spend_pubkey,\r\n                 label_lookup, &bob_labels_cache /* NULL, NULL for no labels */\r\n             );\r\n+            end = clock();\r\n+            cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;\r\n+            printf(\"Bob's scan took %f seconds\\n\", cpu_time_used);\r\n+            \r\n             if (!ret) {\r\n                 printf(\"This transaction is not valid for Silent Payments, skipping.\\n\");\r\n                 return EXIT_SUCCESS;\r\n@@ -435,7 +446,7 @@ int main(void) {\r\n             n_found_outputs = 0;\r\n             ret = secp256k1_silentpayments_recipient_scan_outputs(ctx,\r\n                 found_output_ptrs, &n_found_outputs,\r\n-                (const secp256k1_xonly_pubkey * const *)tx_output_ptrs, 1, /* dummy scan with one output (we only care about Bob) */\r\n+                (const secp256k1_xonly_pubkey **)tx_output_ptrs, 1, /* dummy scan with one output (we only care about Bob) */\r\n                 carol_scan_key,\r\n                 &prevouts_summary,\r\n                 &unlabeled_spend_pubkey,\r\n```",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3566408583",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21113780100,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATqereE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21113780100",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T10:14:23Z"
    },
    {
      "event": "subscribed",
      "id": 21113780115,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATqereT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21113780115",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T10:14:23Z"
    },
    {
      "event": "commented",
      "id": 3566870041,
      "node_id": "IC_kwDOAP4Jqs7Umh4Z",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3566870041",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:38Z",
      "updated_at": "2025-11-22T16:39:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "@nymius, @w0xlt: Thanks once again for the quick feedback and for benchmarking! Shortly after my previous comment, I've been notified about yet another approach to tackle the worst-case scanning time attack (kudos to @furszy for bringing up the idea!), that I think is even more elegant: we can use the pointers in the `tx_outputs` list directly to track outputs by setting them to `NULL` if one has been found, and accordingly only treat them if they are non-NULL. With this, it's an only four lines of code change: https://github.com/theStack/secp256k1/commit/2087f9209df35764745dd744051e3d125d3c6b43. It kind of combines the previous two approaches of https://github.com/jonasnick/secp256k1/commit/311b4ebb2bf6612c46cefd80a8812d9c9b5dc6c4 and https://github.com/theStack/secp256k1/commit/9aba470 (-> mark spent outputs, but not in a newly allocated array, but by modifying the `tx_outputs` input list, in order to avoid dynamic memory allocation), with very similar run-time results.\r\n\r\nThe only tiny drawback about these non-malloc approaches might be that something that is conceptually an \"in\" parameter is modified, which might be a bit unsound in a strict API design sense. On the other hand, it shouldn't matter for the user (I doubt that these lists passed in would ever be reused for anything else after by the callers), and we already do the same in the sending API for the recipients, so it's probably fine.\r\n\r\n> @theStack Yes  if we want to keep only the adversarial-scenario optimizations, we can drop sort stabilization and the extra heads.\r\n\r\nThe way I see it currently, code paths for non-adversarial scenarios with increasing k values would be hit so rarely in practice, that I'm sceptical that it's worth it put much effort into those optimizations. When scanning, the vast majority of transactions won't have any matches in the first place. Out of those few that _do have a match_, the vast majority will very likely again not contain any repeated recipient (IMHO it doesn't make that much sense to do that, unless the recipient explicitly asks \"I want to receive my payment split up in multiple UTXOs, but still in a single tx\"?), so in the bigger picture those optimizations wouldn't matter all that much, and I'd assume that the dominant factor should be by far all the (unavoidable) ECDH computations per transaction. But that's still more of a guess and it's still good to already have optimization ideas at hand if we need them in the future.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3566870041",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21115996548,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATqnImE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996548",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:39Z"
    },
    {
      "event": "subscribed",
      "id": 21115996556,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATqnImM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996556",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "mentioned",
      "id": 21115996562,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATqnImS",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996562",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "subscribed",
      "id": 21115996571,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATqnImb",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996571",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "mentioned",
      "id": 21115996577,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATqnImh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996577",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "subscribed",
      "id": 21115996581,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATqnIml",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996581",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "mentioned",
      "id": 21115996585,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATqnImp",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996585",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "subscribed",
      "id": 21115996592,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATqnImw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21115996592",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-22T16:39:40Z"
    },
    {
      "event": "commented",
      "id": 3567528551,
      "node_id": "IC_kwDOAP4Jqs7UpCpn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3567528551",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-23T06:06:05Z",
      "updated_at": "2025-11-23T06:06:05Z",
      "author_association": "NONE",
      "body": "@theStack Thanks for continuing to refine the optimization. The deletion approach performs slightly better (0.40 s vs. 0.45 s), likely because deleting items shrinks the array and cuts the number of loop iterations by about 50% compared to nullifying them.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3567528551",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21119855419,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATq12s7",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21119855419",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-23T06:06:06Z"
    },
    {
      "event": "subscribed",
      "id": 21119855423,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATq12s_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21119855423",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-23T06:06:06Z"
    },
    {
      "event": "referenced",
      "id": 21151923870,
      "node_id": "REFE_lADOAP4Jqs7VEWwNzwAAAATswL6e",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21151923870",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "1c8233acf208a6f935fc11161feda6c0775945e6",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/1c8233acf208a6f935fc11161feda6c0775945e6",
      "created_at": "2025-11-25T00:31:12Z"
    },
    {
      "event": "referenced",
      "id": 21170249357,
      "node_id": "REFE_lADOAP4Jqs7VEWwNzwAAAATt2F6N",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21170249357",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "c16252ddccdeaefdc6c4ec4425ddda91ee813320",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/c16252ddccdeaefdc6c4ec4425ddda91ee813320",
      "created_at": "2025-11-25T17:28:10Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21172132445,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAATt9Rpd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21172132445",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "650b2fb6256a8df06e4193003deb4879f52bf72c",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/650b2fb6256a8df06e4193003deb4879f52bf72c",
      "created_at": "2025-11-25T19:07:56Z"
    },
    {
      "event": "commented",
      "id": 3577161237,
      "node_id": "IC_kwDOAP4Jqs7VNyYV",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3577161237",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-25T19:08:27Z",
      "updated_at": "2025-12-01T23:42:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "To summarize, the following table shows the proposed mitigations for the worst-case scanning attack so far, with benchmark results from my machine. The [previous baseline commit](https://github.com/bitcoin-core/secp256k1/commit/1df4287eb8daa34a07888300e0b18ba1c97a3432) with the worst-case example has been updated to include [@w0xlt's changes](https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3566408583), in order to work without stack size limit changes.\r\n(EDIT: **These benchmark results are based on a baseline that doesn't represent the worst-case and are thus not representative, as [noticed by w0xlt below](https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3592403663).**)\r\n| Branch                                                | Approach                                                 | Runtime |\r\n|-------------------------------------------------------|----------------------------------------------------------|------------------------------------------------|\r\n| https://github.com/theStack/secp256k1/commit/c16252ddccdeaefdc6c4ec4425ddda91ee813320 (Branch [baseline](https://github.com/theStack/secp256k1/tree/pr1765_worstcase_scan_baseline))                    | modified example to exercise worst-case scanning, no fix                                                 | 641.391838s                                    |\r\n| https://github.com/theStack/secp256k1/commit/ec2797715ac51ebe9d57e396d1cb46d4fd474eab (Branch [fix1_...](https://github.com/theStack/secp256k1/tree/pr1765_worstcase_scan_fix1_mark-found-outputs-calloc))  | mark found outputs in `calloc`ed array                   | 0.543969s                                      |\r\n| https://github.com/theStack/secp256k1/commit/135ca0a194f871f5be9fa78d47c4aad8e13a06e0 (Branch [fix2_...](https://github.com/theStack/secp256k1/tree/pr1765_worstcase_scan_fix2_remove-found-outputs))       | remove matched outputs by shifting remaining entries                                   | 0.514952s                                      |\r\n| https://github.com/theStack/secp256k1/commit/8360150954facf9887ebdc687dada781ddcfec9a (Branch [fix3_...](https://github.com/theStack/secp256k1/tree/pr1765_worstcase_scan_fix3_mark-found-outputs-NULLify))| mark found outputs by `NULL` in `tx_outputs` input array | 0.544740s                                      |\r\n\r\nThe run-times of the fixes vary slightly (the removal approach \"fix2\" being the fastest, confirming https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3567528551 above), but are all in the same ballpark. I don't think exact performance results matter much here, as the goal of the mitigation should be to IMHO roughly cut the run-time down from \"minutes\" to \"seconds\" (and remember, this is already for the absolute worst-case, one giant non-standard transaction filling out a whole block, and it can only slow down _one_ specific SP recipient). Thus, I decided to pick the the simplest approach that avoids dynamic memory allocation, i.e. fix number 3 using `NULL` as marker in `tx_outputs`.\r\n\r\nWith that tackled, I believe that all of the open questions and TODOs are addressed now (updated the PR description accordingly). The latest force-push also includes a rebase on master (to include the CI fix #1771).",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3577161237",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "referenced",
      "id": 21224718533,
      "node_id": "REFE_lADOAP4Jqs7VEWwNzwAAAATxF4DF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21224718533",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "e7f7083b530a55c83ce9089a7244d2d9d67ac8b2",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/e7f7083b530a55c83ce9089a7244d2d9d67ac8b2",
      "created_at": "2025-11-27T16:27:18Z"
    },
    {
      "event": "commented",
      "id": 3586704922,
      "node_id": "IC_kwDOAP4Jqs7VyMYa",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3586704922",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-27T16:30:54Z",
      "updated_at": "2025-11-27T16:30:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "I assume you want to rebase on master now that #1774 has been merged. ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3586704922",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21232877891,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAATxlAFD",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21232877891",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "created_at": "2025-11-27T23:45:39Z"
    },
    {
      "event": "commented",
      "id": 3587553645,
      "node_id": "IC_kwDOAP4Jqs7V1blt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3587553645",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-28T00:12:55Z",
      "updated_at": "2025-11-28T00:12:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I assume you want to rebase on master now that #1774 has been merged.\r\n\r\nYes, done. Using the new `secp256k1_eckey_pubkey_serialize33` function, the [sending](https://github.com/bitcoin-core/secp256k1/pull/1765/commits/ffffd7ff98368b29759cd3d9933896fb9fa69b1f) and [receiving](https://github.com/bitcoin-core/secp256k1/pull/1765/commits/8caf19c3acdf06ed547e5980fb339990df470bed) commit diffs got a bit smaller (as outlined in https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3462461331), -13 LOC in total.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3587553645",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3591015668,
      "node_id": "IC_kwDOAP4Jqs7WCoz0",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3591015668",
      "actor": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-29T05:39:00Z",
      "updated_at": "2025-11-29T05:39:00Z",
      "author_association": "NONE",
      "body": "Thanks for the summary, I've checked the results. I agree with `fix3_*` branch as the final solution, is elegant and trade-offs are clear.",
      "user": {
        "login": "nymius",
        "id": 155548262,
        "node_id": "U_kgDOCUV6Zg",
        "avatar_url": "https://avatars.githubusercontent.com/u/155548262?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/nymius",
        "html_url": "https://github.com/nymius",
        "followers_url": "https://api.github.com/users/nymius/followers",
        "following_url": "https://api.github.com/users/nymius/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/nymius/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/nymius/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/nymius/subscriptions",
        "organizations_url": "https://api.github.com/users/nymius/orgs",
        "repos_url": "https://api.github.com/users/nymius/repos",
        "events_url": "https://api.github.com/users/nymius/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/nymius/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3591015668",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3592403663,
      "node_id": "IC_kwDOAP4Jqs7WH7rP",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3592403663",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-30T09:47:14Z",
      "updated_at": "2025-11-30T09:47:14Z",
      "author_association": "NONE",
      "body": "Hi @theStack . That's not actually the worst case. The worst case is when the attacker shuffles the outputs randomly (or in any adversarial order). I modified your benchmark to randomly shuffle outputs, and scanning takes several minutes to hours with the current optimization proposal.\r\n\r\nhttps://github.com/w0xlt/secp256k1/commit/435cb96c2dc3c9d4a0fa967fb84432d8dd77783d\r\n\r\nThe issue is that the scanning function receives a label lookup callback, which makes it harder to build a sorted index upfront. Instead, for each output tweak index k, it linearly scans all transaction outputs  resulting in O(n) complexity. An attacker creating ~23,000 unordered outputs can make scanning take hours.\r\n\r\nIf we slightly change the API to replace the label lookup callback with a label entry set, we can sort once and search fast:\r\n1. Build a sorted index of outputs by serialized x-only pubkey  O(n log n) upfront\r\n2. Binary search for each candidate  O(log n) per lookup\r\n\r\nThat way, scanning 23,255 adversarially-ordered outputs drops from hours to ~0.3s. The optimization is purely receiver-side, requires no protocol changes, and works regardless of output ordering. This reduces architectural flexibility, though.\r\n\r\nBefore: for each k, scan all n outputs   O(k  n)  O(n)\r\nAfter:  sort outputs, binary search      O(n log n + k log n)\r\n\r\nThe following commit implements this proposal:\r\nhttps://github.com/w0xlt/secp256k1/commit/2305d7361ad4a2ead9e335ea76ea4fc047e275cf\r\n\r\nYou can verify by running `./build/bin/silentpayments_example` (ordered) and `./build/bin/silentpayments_shuffled_example` (shuffled).",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3592403663",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21255618065,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATy7v4R",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21255618065",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-30T09:47:15Z"
    },
    {
      "event": "subscribed",
      "id": 21255618072,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATy7v4Y",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21255618072",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-30T09:47:15Z"
    },
    {
      "event": "commented",
      "id": 3594230411,
      "node_id": "IC_kwDOAP4Jqs7WO5qL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3594230411",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T02:12:07Z",
      "updated_at": "2025-12-01T02:12:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Hi @theStack . That's not actually the worst case. The worst case is when the attacker shuffles the outputs randomly (or in any adversarial order). \r\n\r\n@w0xlt: Good catch, I indeed missed involving the output order for the worst-case scenario, so https://github.com/theStack/secp256k1/commit/c16252ddccdeaefdc6c4ec4425ddda91ee813320 is not a useful target (in hindsight, the benchmark results look too good to be true, and my previous words of \"we can't rely on the attacker using a specific implementation\" strike back very hard). Thanks for the updated benchmark and the new worst-case fix proposal!\r\n\r\n> I modified your benchmark to randomly shuffle outputs, and scanning takes several minutes to hours with the current optimization proposal.\r\n\r\nAre you sure it could take up \"to hours\"? That would be significantly worse than the previous baseline commit (~10 minutes on my machine), which seems implausible to me. In the unoptimized scanning implementation, the run-time should be very much independent on the order of outputs, as the total number of inner loop iterations is constant ($1+2+3...+N = (N*(N+1))/2 = 270409140$ for our worst-case scenario of $N = 23255$), and it'd be very surprising if any of the three proposed optimizations perform _worse_ than the baseline for shuffled outputs.\r\n\r\nI only did two runs so far with your shuffle-patch added, and got runtimes of ~10 minutes (unoptimized) and ~5 minutes (NULL-ify patch, \"fix3\"). Will do some more thorough benchmarks tomorrow, including your proposed solution.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3594230411",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21263573644,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATzaGKM",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21263573644",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T02:12:09Z"
    },
    {
      "event": "subscribed",
      "id": 21263573661,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATzaGKd",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21263573661",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T02:12:09Z"
    },
    {
      "event": "mentioned",
      "id": 21263573675,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATzaGKr",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21263573675",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T02:12:09Z"
    },
    {
      "event": "subscribed",
      "id": 21263573682,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATzaGKy",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21263573682",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T02:12:09Z"
    },
    {
      "event": "commented",
      "id": 3594425270,
      "node_id": "IC_kwDOAP4Jqs7WPpO2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3594425270",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T03:57:25Z",
      "updated_at": "2025-12-01T03:57:25Z",
      "author_association": "NONE",
      "body": "@theStack Thanks for looking into this.\r\nSorry if I wasnt clear earlier. The shuffled benchmark does perform better in the optimized version than in the baseline, but it loses the sub-second scan times.\r\nThe new proposed approach (assuming it works as expected) should keep those sub-second times even on the shuffled benchmark.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3594425270",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21264784903,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAATzet4H",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21264784903",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T03:57:26Z"
    },
    {
      "event": "subscribed",
      "id": 21264784931,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAATzet4j",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21264784931",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T03:57:26Z"
    },
    {
      "event": "commented",
      "id": 3598367471,
      "node_id": "IC_kwDOAP4Jqs7Werrv",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3598367471",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T18:55:36Z",
      "updated_at": "2025-12-02T00:54:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "@w0xlt: I've looked at your proposed scanning implementation https://github.com/w0xlt/secp256k1/commit/2305d7361ad4a2ead9e335ea76ea4fc047e275cf and can confirm that it fixes the worst-case scanning attack, as the run-time of the modified example with shuffled outputs is reduced to <1s. What makes this different approach potentially interesting is that it could also to speed up the common case (i.e. no matches), as the number of point additions needed for labels scanning seems to be significantly smaller for the small-scale user (where N_LABELS < 2 * N_OUTPUTS for the average transaction; if N_LABELS=1 and we assume the average transaction to scan for has N_OUTPUTS=2, your approach is 4x faster w.r.t. needed point additions). To verify that I understood it correctly and make the idea digestible to other interested reviewers, I've tried to summarize the current PR's scanning approach (as proposed in BIP-352) vs. your approach on the following gist, written in a somewhat hand-wavy way, I hope the pseudo-code is understandable: https://gist.github.com/theStack/25c77747838610931e8bbeb9d76faf78. Please let me know if I got that right, I _think_ the approach leads to the same result, but I'm still trying to wrap my head around it.\r\n// EDIT: I've been told by @setavenger that this approach is also used by [Frigate Electrum Server](https://github.com/sparrowwallet/frigate) and the [BlindBit wallet](https://github.com/setavenger/blindbit-desktop).\r\n\r\nOn the other hand, I'm still uncertain on whether adding the additional code complexity and the involvement of dynamic memory allocation at all in a secp256k1 module is worth all this, considering that we are talking about an attack that costs an adversary money (at least the fees for the whole block space) and can only slow down one specific SP recipient. It seems a very unusual kind of attack. Changing the scanning API at this point seems also questionable, as I think it went already through several iterations and refinements over the years, and I think the \"pass labels directly\" approach is slower for users with a higher number of labels involved. Also, the mental load for reviewers is significantly higher if the approach doesn't follow the algorithm as specified in BIP-352, as they have to convince themselves that the result is equivalent.\r\n\r\nI'm hence debating on whether one solution could be to keep the PR simply as-is and accept the fact that an adversary can slow down a single entity for a few minutes (for non-standard transactions), to a few seconds (for standard transactions, i.e. tx size <= 100kvB). I don't have a good final answer to this question myself, but want to discuss is at least and come to a decision that both maintainers and users are on board with before taking any further action.\r\n\r\nMy (in retrospect somewhat naive) hope was that there could be a simple few-lines fix for reducing the worst-case scanning attack down to seconds without the need of dynamic memory allocation, but such an easy fix doesn't seem to be in sight.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3598367471",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21285055146,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT0sCqq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21285055146",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T18:55:37Z"
    },
    {
      "event": "subscribed",
      "id": 21285055200,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT0sCrg",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21285055200",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-01T18:55:37Z"
    },
    {
      "event": "mentioned",
      "id": 21291762483,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT1FoMz",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21291762483",
      "actor": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T00:54:55Z"
    },
    {
      "event": "subscribed",
      "id": 21291762492,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT1FoM8",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21291762492",
      "actor": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T00:54:55Z"
    },
    {
      "event": "commented",
      "id": 3600182512,
      "node_id": "IC_kwDOAP4Jqs7Wlmzw",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3600182512",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T04:51:53Z",
      "updated_at": "2025-12-02T04:51:53Z",
      "author_association": "NONE",
      "body": "Hi @theStack thanks a lot for taking the time to review the proposal and write up the comparison.\r\n\r\nMy view is that we should aim for the most efficient and resilient solution, even if the attack scenario is somewhat unusual. The spec can be updated as needed to reflect improvements. Independently of adversarial cases, reducing scanning time from several minutes to under a second is a major win for user experience.\r\n\r\nRegarding complexity: although this approach adds some moving parts, the underlying idea (e.g., using binary search) is conceptually straightforward, so I dont think it should pose a significant burden by itself.\r\n\r\nAs for the dynamic memory concern, the allocation doesnt necessarily have to happen inside the secp256k1 module. We could let the caller provide the required workspace. For example, could we leverage `secp256k1_scratch_space` here?",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3600182512",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21295040889,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT1SIl5",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21295040889",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T04:51:54Z"
    },
    {
      "event": "subscribed",
      "id": 21295040919,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT1SImX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21295040919",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T04:51:54Z"
    },
    {
      "event": "commented",
      "id": 3603093854,
      "node_id": "IC_kwDOAP4Jqs7Wwtle",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3603093854",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T17:03:54Z",
      "updated_at": "2025-12-02T17:03:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "@w0xlt: After tinkering a bit with your proposed implementation https://github.com/w0xlt/secp256k1/commit/2305d7361ad4a2ead9e335ea76ea4fc047e275cf, I found that it could be significantly simplified, and it turned out we don't even need dynamic memory allocation:\r\n* instead of building an explicit index, we can simply sort the user-supplied `tx_outputs` array of x-only pubkeys in place and perform binary search directly on that (using the existing `secp256k1_pubkey_xonly_pubkey_cmp`)\r\n* the preparation of the label set group elements array is not needed as well; `_pubkey_load` is a very cheap operation, so it doesn't hurt to call it repeatedly in each k loop iteration (remember that the common case is not having a match, i.e. k doesn't exceed 0 for most scanned transactions)\r\n\r\nDoing this in https://github.com/theStack/secp256k1/commit/1a40e14d31089960d4113b49eeffd287b81cd2a1 still keeps the worst-case scanning benchmark time down at ~450ms on my machine.\r\nAdmittedly, there is a tiny bit of run-time overhead introduced with the simplification (repeated x-only pubkey serialization for the common case), but I don't think that matters much, considering that the involved elliptic curve operations are likely orders of magnitude more expensive than that. With these new insights, I can retract my doubts about code complexity and dynamic memory allocation of your proposed approach, and it's good to have two potential scanning implementations. :+1: \r\n\r\nIt should be pointed out that the \"label set\" approach doesn't come for free though: one major drawback is that for users with a larger label set, the typical scanning scenario (assuming most txs don't have more than just a few outputs) can be slower at some point, as the number of point additions is higher than with the \"BIP\" approach. So if we follow your approach, it's better for small-case users and to eliminate the worst-case scanning attack, but users with a lot of labels are likely not happy with it and would very much prefer the \"BIP\" scanning approach. Not really sure how to deal with that and what to prioritize. (Provide two scanning implementations and let the user pick? :grimacing: )\r\n\r\nI'll anyways try to come up with another \"modified example\" benchmark to better verify the claims about typical scanning scenarios, depending on the number of labels involved and transaction output count. We have spent a good time on the worst-scanning scenario now, but it would be wrong to solely optimize for that and get the typical scanning scenario out of sight.\r\n\r\n> Independently of adversarial cases, reducing scanning time from several minutes to under a second is a major win for user experience.\r\n\r\nI don't agree with that statement, as I can't think of a legit _non_-adversarial case that would lead to scanning times of several minutes, in particular as this would at the minimum involve creating a large non-standard transaction. When considering user experience, by far the most relevant case I'd consider is the \"no match\" scenario (one k loop iteration), as it is the most frequent one, followed by the \"single match\" (two k loop iterations) scenario. Everything above that should be already quite rare in practice.\r\n\r\n> As for the dynamic memory concern, the allocation doesnt necessarily have to happen inside the secp256k1 module. We could let the caller provide the required workspace. For example, could we leverage secp256k1_scratch_space here?\r\n\r\nGood question. Right now, the scratch space API is not even exposed to the user. Btw I don't think dynamic memory allocation is a strict no-go in general, it just seems that there are still some open questions around that area, and waiting until they are all tackled would probably delay the PR for an unforeseeable time. It seems that as of now we can easily avoid dynamic memory allocation anyways though, in both of the proposed implementations.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3603093854",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21311825129,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT2SKTp",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21311825129",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T17:03:56Z"
    },
    {
      "event": "subscribed",
      "id": 21311825171,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT2SKUT",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21311825171",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T17:03:56Z"
    },
    {
      "event": "commented",
      "id": 3604154693,
      "node_id": "IC_kwDOAP4Jqs7W0wlF",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3604154693",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T22:04:41Z",
      "updated_at": "2025-12-02T22:04:41Z",
      "author_association": "NONE",
      "body": "> Not really sure how to deal with that and what to prioritize. (Provide two scanning implementations and let the user pick?  )\r\n\r\nSome (very) rough ideas on the trade-off\r\n\r\nIf we can define a general rule that determines when its better to use the label-set scan versus the BIP-based scan, we could do something like:\r\n\r\n```c\r\n/* Choose algorithm based on this transaction's characteristics */\r\nif (n_labels > 2 * n_tx_outputs) {\r\n    /* BIP approach: iterate over outputs, add, and look up in label callback */\r\n    use_bip_scan();\r\n} else {\r\n    /* Label-set approach: iterate over labels, add, and search in output index */\r\n    use_labelset_scan();\r\n}\r\n```\r\n\r\nThe heuristic above is just a rough estimate. The BIP version performs roughly ~2N point additions, where *N* is the number of outputs, while the label-set version performs about ~L additions, where *L* is the number of configured labels.\r\n\r\nBut to build a reliable decision rule, wed need more benchmark data across a range of (N, L) combinations.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3604154693",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3608407831,
      "node_id": "IC_kwDOAP4Jqs7XE-8X",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3608407831",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-03T19:11:07Z",
      "updated_at": "2025-12-03T19:11:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "Here is a first attempt at creating a scanning benchmark for the common case scenario (i.e. no matches and hence only one k iteration), comparing the \"BIP\" and \"Label-set\" approaches over a combination of L (number of labels to scan for) and N (number of tx outputs): https://github.com/theStack/secp256k1/commit/fef63fd40f2fad9e26eaf7145d9a38eaceb1e8ef. Running this modified example outputs the following on my arm64 machine:\r\n\r\n```\r\n$ ./build/bin/silentpayments_example\r\nSilent Payments (BIP-352) scanning benchmarks\r\n[common case scenario, i.e. only one k iteration without match]\r\n\r\nLegend: L... number of labels, N... number of transaction outputs\r\n\r\n===== BIP approach (calculate label candidates for each output, look them up in labels cache) =====\r\nL= 1: [N=2:  69 us] [N=5:  82 us] [N=10:  89 us] [N=20: 121 us] [N=50: 197 us] [N=100: 343 us] [N=200: 632 us]\r\nL= 2: [N=2:  61 us] [N=5:  80 us] [N=10:  78 us] [N=20: 101 us] [N=50: 177 us] [N=100: 314 us] [N=200: 566 us]\r\nL= 3: [N=2:  54 us] [N=5:  58 us] [N=10:  76 us] [N=20:  95 us] [N=50: 166 us] [N=100: 288 us] [N=200: 535 us]\r\nL= 5: [N=2:  51 us] [N=5:  55 us] [N=10:  67 us] [N=20: 160 us] [N=50: 159 us] [N=100: 271 us] [N=200: 496 us]\r\nL=10: [N=2:  49 us] [N=5:  55 us] [N=10:  66 us] [N=20:  89 us] [N=50: 158 us] [N=100: 276 us] [N=200: 494 us]\r\nL=20: [N=2:  54 us] [N=5:  55 us] [N=10:  68 us] [N=20:  90 us] [N=50: 159 us] [N=100: 271 us] [N=200: 505 us]\r\nL=50: [N=2:  49 us] [N=5:  55 us] [N=10:  71 us] [N=20:  88 us] [N=50: 160 us] [N=100: 274 us] [N=200: 504 us]\r\n\r\n===== Label-set approach (calculate output candidate for each label, look it up in outputs) =====\r\nL= 1: [N=2:  51 us] [N=5:  47 us] [N=10:  48 us] [N=20:  51 us] [N=50:  59 us] [N=100:  77 us] [N=200: 116 us]\r\nL= 2: [N=2:  49 us] [N=5:  57 us] [N=10:  50 us] [N=20:  53 us] [N=50:  65 us] [N=100:  81 us] [N=200: 120 us]\r\nL= 3: [N=2:  49 us] [N=5:  51 us] [N=10:  50 us] [N=20:  56 us] [N=50:  63 us] [N=100:  82 us] [N=200: 118 us]\r\nL= 5: [N=2:  58 us] [N=5:  52 us] [N=10:  55 us] [N=20:  56 us] [N=50:  68 us] [N=100:  81 us] [N=200: 119 us]\r\nL=10: [N=2:  63 us] [N=5:  59 us] [N=10:  61 us] [N=20:  62 us] [N=50:  71 us] [N=100:  87 us] [N=200: 126 us]\r\nL=20: [N=2:  70 us] [N=5:  71 us] [N=10:  74 us] [N=20:  90 us] [N=50:  83 us] [N=100: 101 us] [N=200: 139 us]\r\nL=50: [N=2: 104 us] [N=5: 107 us] [N=10: 111 us] [N=20: 113 us] [N=50: 122 us] [N=100: 141 us] [N=200: 192 us]\r\n```\r\nThese results should be taken with a large grain of salt, as the numbers fluctuate a lot (visible for the BIP approach, where all lines should have about the same results, as the performance is in theory independent of L; also, for the first two L the results are surprisingly worse, maybe some unintended caching effects for later runs?) but one can at least see the general previously suspected trend that the BIP approach gets worse with increasing N, while the label-set approach gets worse with increasing L. As a very rough first statement, I'd say assuming that users don't use more than a handful (let's say up to 10) labels and transactions with more outputs get more common in the future, using the label-set approach seems superior, and the only reason to keep the BIP approach is to target users that want to scan for a large number of (let's say dozens) of labels.\r\n\r\nComments or ideas on how to best reason about this would be much appreciated (also a rough review of the modified benchmark example, it could also be that there are bugs). Maybe someone has an idea how to connect this with some actual historic on-chain stats? The list of L and N values to benchmark for can be adapted by changing the two arrays `n_labels_bench` and `n_outputs_bench` at the top of the example file.\r\n\r\n> If we can define a general rule that determines when its better to use the label-set scan versus the BIP-based scan, we could do something like:\r\n\r\nMakes sense yeah, thought about something similar. What makes this a bit inconvenient (aside from additional review and maintenance burden, obviously) is that users would have to pass both the labels set and implement and pass in a call-back functions, which seems to result in a bloated API. Maybe it's better to focus on one approach and ship another scan function for \"giant label set\" power users later? I could be wrong, but I don't think using more than three or four labels would be a very common use-case.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3608407831",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "commented",
      "id": 3610848914,
      "node_id": "IC_kwDOAP4Jqs7XOS6S",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3610848914",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T08:27:18Z",
      "updated_at": "2025-12-04T08:27:18Z",
      "author_association": "NONE",
      "body": "@theStack  Thanks very much for this benchmark. It is very insightful.\r\n\r\nFrom my understanding, your benchmark confirms that the label-set approach performs better overall and scales more smoothly with the transaction size `N` (number of outputs). For small `N` they are comparable, but as `N` grows the label-set approach becomes significantly faster than the BIP approach.\r\n\r\nI also evaluated Montgomery batch inversion via `secp256k1_ge_set_all_gej_var` in the label-set scanning path on top of your commit. This seems to mainly help when there are many labels (large `L`). For `L = 50` the label-set approach becomes noticeably faster still, so it dominates the BIP-style scanning for almost all `(L, N)` combinations in this benchmark. All runs are using the same common case scenario as in your example (one `k` iteration, no match).\r\n\r\nhttps://github.com/w0xlt/secp256k1/commit/1e8d196e456de957e497275205e3e77df2b4f74b\r\n\r\nBelow is the benchmark commit as measured on my machine (no batch inversion):\r\n```\r\n===== BIP approach (calculate label candidates for each output, look them up in labels cache) =====\r\nL= 1: [N=2: 351 us] [N=5: 200 us] [N=10: 231 us] [N=20: 261 us] [N=50: 289 us] [N=100: 451 us] [N=200: 745 us]\r\nL= 2: [N=2:  81 us] [N=5: 109 us] [N=10:  82 us] [N=20: 153 us] [N=50: 218 us] [N=100: 379 us] [N=200: 631 us]\r\nL= 3: [N=2:  55 us] [N=5:  59 us] [N=10:  75 us] [N=20:  99 us] [N=50: 185 us] [N=100: 299 us] [N=200: 586 us]\r\nL= 5: [N=2:  52 us] [N=5:  58 us] [N=10:  70 us] [N=20:  90 us] [N=50: 171 us] [N=100: 302 us] [N=200: 514 us]\r\nL=10: [N=2:  48 us] [N=5:  53 us] [N=10:  62 us] [N=20:  86 us] [N=50: 153 us] [N=100: 269 us] [N=200: 489 us]\r\nL=20: [N=2:  44 us] [N=5:  52 us] [N=10:  64 us] [N=20:  86 us] [N=50: 147 us] [N=100: 267 us] [N=200: 481 us]\r\nL=50: [N=2:  44 us] [N=5:  47 us] [N=10:  61 us] [N=20:  91 us] [N=50: 153 us] [N=100: 257 us] [N=200: 469 us]\r\n\r\n===== Label-set approach (calculate output candidate for each label, look it up in outputs) =====\r\nL= 1: [N=2:  39 us] [N=5:  38 us] [N=10:  37 us] [N=20:  38 us] [N=50:  41 us] [N=100:  48 us] [N=200:  64 us]\r\nL= 2: [N=2:  37 us] [N=5:  36 us] [N=10:  36 us] [N=20:  37 us] [N=50:  41 us] [N=100:  46 us] [N=200:  65 us]\r\nL= 3: [N=2:  40 us] [N=5:  36 us] [N=10:  37 us] [N=20:  39 us] [N=50:  43 us] [N=100:  49 us] [N=200:  75 us]\r\nL= 5: [N=2:  39 us] [N=5:  39 us] [N=10:  41 us] [N=20:  42 us] [N=50:  47 us] [N=100:  51 us] [N=200:  84 us]\r\nL=10: [N=2:  47 us] [N=5:  47 us] [N=10:  45 us] [N=20:  46 us] [N=50:  49 us] [N=100:  55 us] [N=200:  71 us]\r\nL=20: [N=2:  58 us] [N=5:  56 us] [N=10:  58 us] [N=20:  55 us] [N=50:  59 us] [N=100:  66 us] [N=200:  84 us]\r\nL=50: [N=2:  88 us] [N=5:  85 us] [N=10:  93 us] [N=20:  88 us] [N=50:  94 us] [N=100: 100 us] [N=200: 120 us]\r\n```\r\n\r\nThe numbers after applying batch inversion:\r\n```\r\n===== Label-set approach (calculate output candidate for each label, look it up in outputs) =====\r\nL= 1: [N=2:  38 us] [N=5:  37 us] [N=10:  37 us] [N=20:  37 us] [N=50:  41 us] [N=100:  48 us] [N=200:  61 us]\r\nL= 2: [N=2:  35 us] [N=5:  38 us] [N=10:  37 us] [N=20:  44 us] [N=50:  41 us] [N=100:  47 us] [N=200:  62 us]\r\nL= 3: [N=2:  35 us] [N=5:  38 us] [N=10:  39 us] [N=20:  38 us] [N=50:  46 us] [N=100:  46 us] [N=200:  66 us]\r\nL= 5: [N=2:  49 us] [N=5:  36 us] [N=10:  36 us] [N=20:  40 us] [N=50:  42 us] [N=100:  49 us] [N=200:  63 us]\r\nL=10: [N=2:  37 us] [N=5:  37 us] [N=10:  37 us] [N=20:  37 us] [N=50:  41 us] [N=100:  49 us] [N=200:  65 us]\r\nL=20: [N=2:  46 us] [N=5:  47 us] [N=10:  42 us] [N=20:  42 us] [N=50:  48 us] [N=100:  56 us] [N=200:  73 us]\r\nL=50: [N=2:  54 us] [N=5:  46 us] [N=10:  46 us] [N=20:  50 us] [N=50:  52 us] [N=100:  60 us] [N=200:  82 us]\r\n```\r\n\r\nThe only code change here is using batch inversion in the label-set path.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3610848914",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21352573348,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT4tmmk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21352573348",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T08:27:19Z"
    },
    {
      "event": "subscribed",
      "id": 21352573383,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT4tmnH",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21352573383",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T08:27:20Z"
    },
    {
      "event": "commented",
      "id": 3614019199,
      "node_id": "IC_kwDOAP4Jqs7XaY5_",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3614019199",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T19:33:59Z",
      "updated_at": "2025-12-04T19:33:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Here is a first attempt at creating a scanning benchmark for the common case scenario (i.e. no matches and hence only one k iteration), comparing the \"BIP\" and \"Label-set\" approaches over a combination of L (number of labels to scan for) and N (number of tx outputs): https://github.com/theStack/secp256k1/commit/fef63fd40f2fad9e26eaf7145d9a38eaceb1e8ef\r\n\r\nThis is now available as an _actual_ benchmark using the framework (i.e. implemented in the module's `bench_impl.h`), leading to more stable results, especially for the lower-N cases (N<=10), which I'd consider to hit most frequently: https://github.com/theStack/secp256k1/commit/8eced6432bf8a6fd4dc968f846ca8373043d092b, see https://gist.github.com/theStack/25c77747838610931e8bbeb9d76faf78?permalink_comment_id=5892266#gistcomment-5892266 for the results on my machine. Both approaches are now also benchmarked for no-labels scanning (i.e. L=0) and for the BIP approach, only L=1 is tested, as any higher values don't have an influence on the run-time, if we assume that the label cache lookup cost is negligible.\r\n\r\n\r\n@w0xlt:\r\n> From my understanding, your benchmark confirms that the label-set approach performs better overall and scales more smoothly with the transaction size N (number of outputs). For small N they are comparable, but as N grows the label-set approach becomes significantly faster than the BIP approach.\r\n\r\nI agree. It seems to me that, unless there is a really strong reasons to support use-cases with dozens of labels, we should consider switching from the BIP to the Label-set scanning approach. I'm not sure though if larger N values appear frequent enough in blocks nowadays to have a significant influence over the overall scanning time (I'd roughly guess that the vast majority of SP eligible txs wouldn't exceed 10 outputs, though that should be verified), but that could change in the future.\r\n\r\n> I also evaluated Montgomery batch inversion via secp256k1_ge_set_all_gej_var in the label-set scanning path on top of your commit. This seems to mainly help when there are many labels (large L). For L = 50 the label-set approach becomes noticeably faster still, so it dominates the BIP-style scanning for almost all (L, N) combinations in this benchmark. All runs are using the same common case scenario as in your example (one k iteration, no match).\r\n\r\nThat's great, didn't review this code in detail yet but it seems to be simple enough to be considered on top, if we go with the label set scanning approach; the benchmarks also look very promising, will integrate them and run on my machine as well tomorrow.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3614019199",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21368434137,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAT5qG3Z",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21368434137",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T19:34:01Z"
    },
    {
      "event": "subscribed",
      "id": 21368434174,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAT5qG3-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21368434174",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-04T19:34:01Z"
    },
    {
      "event": "reviewed",
      "id": 3542178806,
      "node_id": "PRR_kwDOAP4Jqs7TIVv2",
      "url": null,
      "actor": null,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-05T19:33:42Z",
      "author_association": "MEMBER",
      "body": "A bit late but joining this party full-time now. I just finished the sending part. Will keep reviewing. Cool stuff.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3542178806",
      "submitted_at": "2025-12-05T19:33:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "reviewed",
      "id": 3548663278,
      "node_id": "PRR_kwDOAP4Jqs7ThE3u",
      "url": null,
      "actor": null,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-07T01:49:55Z",
      "author_association": "MEMBER",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3548663278",
      "submitted_at": "2025-12-07T01:49:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "reviewed",
      "id": 3553138859,
      "node_id": "PRR_kwDOAP4Jqs7TyJir",
      "url": null,
      "actor": null,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-08T20:28:32Z",
      "author_association": "MEMBER",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3553138859",
      "submitted_at": "2025-12-08T20:28:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "referenced",
      "id": 21472685587,
      "node_id": "REFE_lADOAP4Jqs7VEWwNzwAAAAT_3y4T",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21472685587",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "be5e4f02fd2c66bfacaaaa767183bbe3c89da169",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/be5e4f02fd2c66bfacaaaa767183bbe3c89da169",
      "created_at": "2025-12-10T08:27:59Z"
    },
    {
      "event": "commented",
      "id": 3640574740,
      "node_id": "IC_kwDOAP4Jqs7Y_sMU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3640574740",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-11T07:15:44Z",
      "updated_at": "2025-12-11T07:15:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thinking a bit more about the \"LabelSet\" scanning approach and particularly on how to avoid the repeated x-only pubkey serialization in the compare and binary search finding functions (as pointed out in https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3603093854), I've come to realize that the tx outputs could simply be provided as already serialized x-only pubkeys (raw 32-bytes, directly extracted from a taproot output's `scriptPubKey`), as we don't do any elliptic curve operations with them (in contrast to the \"BIP\" approach). That interface change gets rids of repeated internal serialization and, maybe even more important for overall performance, avoids the need of preparatory `secp256k1_xonly_pubkey_parse` calls from the user for each tx output, costing a field element square root calculation each (in order to recover the y coordinate, via $y = \\sqrt(x^3 + 7)$ ). I've updated the benchmark with that method, adding the xonly-pubkey parsing calls prior to scanning for the BIP benchmark, in order to have a fair comparison: https://github.com/theStack/secp256k1/commit/ab201ed32b5b326d7a065ac0bcaab52b09693ecd (this still doesn't include the batch inversion patch from @w0xlt yet).\r\n\r\nWhile it's nice to have a faster implementation for small-scale users, I'm still unsure how to proceed now for this PR. No matter how much we optimize the \"LabelSet\" approach, it will always be at some point worse for use-cases with larger amount of labels. I've e.g. been made aware that for use-cases like \"proof of payments\", having tens of thousands of labels doesn't even seem unlikely. In an ideal world we would probably implement both approaches and choose whatever is faster, either automatically with a single API function (as prototyped in https://gist.github.com/theStack/25c77747838610931e8bbeb9d76faf78?permalink_comment_id=5897811#gistcomment-5897811) or by providing two different API functions, with good documentation that recommends when to use which one, depending on the L and N parameters.\r\n\r\nWe could either:\r\n1) only release the \"BIP\" scanning approach for now (that's the current state of this PR), with the drawback that it doesn't provide the best possible performance for small-scale users (only a handful of labels) yet\r\n2) only release the \"LabelSet\" scanning approach, with the drawback that it's practically unusable for power-users with a large amount of labels, as each additional label would degrade scanning performance\r\n3) release both already (best for the user for maximum performance, but increases complexity)\r\n\r\nI'd advocate for options 1 or 3 (being now aware that having lots of labels could be much more common than I thought, option 2 doesn't seem to be a good idea, as it would make the module practically unusable for a certain user group), with a tendency to option 1 to keep it simple.\r\n\r\nTo take a step back, the original goal of looking deeper into alternative scanning approaches was fixing the \"worst-case scanning attack\", caused by a single 1vMB transaction full of outputs that all go to a single recipient group (i.e. all having the same scan pubkey), leading to a scanning time of several minutes. The \"LabelSet\" scanning approaches fixes this attack for users with small amounts of labels nicely, but for larger amounts of labels the \"BIP\" scanning approach would still be used, which I think suffers from this problem inherently due to nested looping over the transaction outputs.\r\n\r\nCircling back to what I stated earlier:\r\n> I'm hence debating on whether one solution could be to keep the PR simply as-is and accept the fact that an adversary can slow down a single entity for a few minutes (for non-standard transactions), to a few seconds (for standard transactions, i.e. tx size <= 100kvB).",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3640574740",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "mentioned",
      "id": 21496842473,
      "node_id": "MEE_lADOAP4Jqs7VEWwNzwAAAAUBT8jp",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21496842473",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-11T07:15:46Z"
    },
    {
      "event": "subscribed",
      "id": 21496842494,
      "node_id": "SE_lADOAP4Jqs7VEWwNzwAAAAUBT8j-",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21496842494",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-11T07:15:46Z"
    },
    {
      "event": "reviewed",
      "id": 3566774354,
      "node_id": "PRR_kwDOAP4Jqs7UmKhS",
      "url": null,
      "actor": null,
      "commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-11T10:32:53Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#pullrequestreview-3566774354",
      "submitted_at": "2025-12-11T10:32:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
    },
    {
      "event": "commented",
      "id": 3643845356,
      "node_id": "IC_kwDOAP4Jqs7ZMKrs",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/3643845356",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-11T21:25:41Z",
      "updated_at": "2025-12-11T21:25:41Z",
      "author_association": "NONE",
      "body": "As I understand it, although the LabelSet approach was originally proposed to avoid worst-case performance issues, an interesting side effect is that it gives the user more control and predictability over scanning costs: runtime depends more on the number of labels (which the wallet controls) and less on the number of P2TR outputs in the block (which the wallet cannot control).\r\n\r\nThe LabelSet approach also scales more smoothly with respect to the number of labels than the BIP approach scales with respect to the number of outputs, as shown in the benchmarks:\r\n\r\n```\r\nBenchmark                               ,    Min(us)    ,    Avg(us)    ,    Max(us)\r\nsp_full_scan_BIP-algo_L=50_N=50         ,   138.0       ,   139.0       ,   139.0\r\nsp_full_scan_LabelSet-algo_L=50_N=50    ,    54.2       ,    54.3       ,    54.6\r\n```\r\n\r\nThe hybrid approach gets the best of both worlds and matches the faster of the two algorithms.\r\n\r\nThat said, I agree that the BIP is the easiest and most thoroughly reviewed solution (and the safest to adopt). \r\nThe LabelSet approach appears to offer the best default performance per the benchmark but introduces new assumptions and requires additional review.\r\nThe hybrid approach is likely the best engineering solution, though it comes at the cost of greater complexity and review effort.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#issuecomment-3643845356",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1765"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGI3ZmFkZTY5ZTY1NTkwYjFhNDNmYmJjNzhkNGJmYmM0MTZkNDRhOGQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b7fade69e65590b1a43fbbc78d4bfbc416d44a8d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b7fade69e65590b1a43fbbc78d4bfbc416d44a8d",
      "tree": {
        "sha": "e2695c6cec76fa4e336e5ba2db7d6fec2475a17a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e2695c6cec76fa4e336e5ba2db7d6fec2475a17a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8d445730ec79a9fa722eea59b6b697c3b9b1d501",
          "sha": "8d445730ec79a9fa722eea59b6b697c3b9b1d501",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8d445730ec79a9fa722eea59b6b697c3b9b1d501"
        }
      ],
      "message": "build: add skeleton for new silentpayments (BIP352) module",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-15T21:50:55Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2023-09-27T15:22:14Z"
      },
      "sha": "b7fade69e65590b1a43fbbc78d4bfbc416d44a8d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGRiZmJkNDBmYjMwNTRjODcyZmJiYjY5ZGRhZWFlMjlhZGYyMDdhMTQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/dbfbd40fb3054c872fbbb69ddaeae29adf207a14",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/dbfbd40fb3054c872fbbb69ddaeae29adf207a14",
      "tree": {
        "sha": "1e4f19aab403a13aa28f339ba96f5c083a483046",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/1e4f19aab403a13aa28f339ba96f5c083a483046"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/b7fade69e65590b1a43fbbc78d4bfbc416d44a8d",
          "sha": "b7fade69e65590b1a43fbbc78d4bfbc416d44a8d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/b7fade69e65590b1a43fbbc78d4bfbc416d44a8d"
        }
      ],
      "message": "silentpayments: sending\n\nAdd a routine for the entire sending flow which takes a set of private keys,\nthe smallest outpoint, and list of recipients and returns a list of\nx-only public keys by performing the following steps:\n\n1. Sum up the private keys\n2. Calculate the input_hash\n3. For each recipient group:\n    3a. Calculate a shared secret\n    3b. Create the requested number of outputs\n\nThis function assumes a single sender context in that it requires the\nsender to have access to all of the private keys. In the future, this\nAPI may be expanded to allow for a multiple senders or for a single\nsender who does not have access to all private keys at any given time,\nbut for now these modes are considered out of scope / unsafe.\n\nInternal to the library, add:\n\n1. A function for creating shared secrets (i.e., a*B or b*A)\n2. A function for generating the \"SharedSecret\" tagged hash\n3. A function for creating a single output public key",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-16T15:02:38Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-03-25T16:23:37Z"
      },
      "sha": "dbfbd40fb3054c872fbbb69ddaeae29adf207a14"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGVmYzk1YzZmNWY4MDBhNGMyMDFkNDllN2UwNjgzNWRkN2NlMzlmYzQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/efc95c6f5f800a4c201d49e7e06835dd7ce39fc4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/efc95c6f5f800a4c201d49e7e06835dd7ce39fc4",
      "tree": {
        "sha": "9efacf7cdcd4bb5d673b7e690c7c1a5f8a20f2f2",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/9efacf7cdcd4bb5d673b7e690c7c1a5f8a20f2f2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/dbfbd40fb3054c872fbbb69ddaeae29adf207a14",
          "sha": "dbfbd40fb3054c872fbbb69ddaeae29adf207a14",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/dbfbd40fb3054c872fbbb69ddaeae29adf207a14"
        }
      ],
      "message": "silentpayments: recipient label support\n\nAdd function for creating a label tweak. This requires a tagged hash\nfunction for labels. This function is used by the receiver for creating\nlabels to be used for a) creating labeled addresses and b) to populate\na labels cache when scanning.\n\nAdd function for creating a labeled spend pubkey. This involves taking\na label tweak, turning it into a public key and adding it to the spend\npublic key. This function is used by the receiver to create a labeled\nsilent payment address.\n\nAdd tests for the label API.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-16T15:02:41Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-01-22T17:56:05Z"
      },
      "sha": "efc95c6f5f800a4c201d49e7e06835dd7ce39fc4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGEyYTUzZGMxNDI0Y2RhNGY5MWNlOTEwNTQxZDgzMmM1ZjFjOTNjOGQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a2a53dc1424cda4f91ce910541d832c5f1c93c8d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a2a53dc1424cda4f91ce910541d832c5f1c93c8d",
      "tree": {
        "sha": "6d167cc866794d090c8a0d62bcd8d25ae71b4903",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/6d167cc866794d090c8a0d62bcd8d25ae71b4903"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/efc95c6f5f800a4c201d49e7e06835dd7ce39fc4",
          "sha": "efc95c6f5f800a4c201d49e7e06835dd7ce39fc4",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/efc95c6f5f800a4c201d49e7e06835dd7ce39fc4"
        }
      ],
      "message": "silentpayments: receiving\n\nAdd routine for scanning a transaction and returning the necessary\nspending data for any found outputs. This function works with labels via\na lookup callback and requires access to the transaction outputs.\nRequiring access to the transaction outputs is not suitable for light\nclients, but light client support is enabled in the next commit.\n\nAdd an opaque data type for passing around the prevout public key sum\nand the input hash tweak (input_hash). This data is passed to the scanner\nbefore the ECDH step as two separate elements so that the scanner can\nmultiply the scan_key * input_hash before doing ECDH.\n\nFinally, add test coverage for the receiving API.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-16T15:06:50Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-10-02T14:18:13Z"
      },
      "sha": "a2a53dc1424cda4f91ce910541d832c5f1c93c8d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDFkZWJjZDY4YzdhNzZiMGY5OGNkZjc1NDA3YTAxYzhlYTJhOTc1NGI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1debcd68c7a76b0f98cdf75407a01c8ea2a9754b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1debcd68c7a76b0f98cdf75407a01c8ea2a9754b",
      "tree": {
        "sha": "91863375dcee40581bbcad9a691e46623c7a072a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/91863375dcee40581bbcad9a691e46623c7a072a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a2a53dc1424cda4f91ce910541d832c5f1c93c8d",
          "sha": "a2a53dc1424cda4f91ce910541d832c5f1c93c8d",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a2a53dc1424cda4f91ce910541d832c5f1c93c8d"
        }
      ],
      "message": "silentpayments: add examples/silentpayments.c\n\nDemonstrate sending and scanning on full nodes.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-16T15:06:53Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-15T17:36:29Z"
      },
      "sha": "1debcd68c7a76b0f98cdf75407a01c8ea2a9754b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDBkNmVlZmU3ZmQzZGQ2OTM5OTliYmE0NjBkY2RkY2IzMjk2MzRiY2E",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0d6eefe7fd3dd693999bba460dcddcb329634bca",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0d6eefe7fd3dd693999bba460dcddcb329634bca",
      "tree": {
        "sha": "7272a63912fe3ab5ed46890ababbeca45c6b71e1",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/7272a63912fe3ab5ed46890ababbeca45c6b71e1"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/1debcd68c7a76b0f98cdf75407a01c8ea2a9754b",
          "sha": "1debcd68c7a76b0f98cdf75407a01c8ea2a9754b",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/1debcd68c7a76b0f98cdf75407a01c8ea2a9754b"
        }
      ],
      "message": "silentpayments: add benchmarks for scanning\n\nAdd a benchmark for a full transaction scan.\nOnly benchmarks for scanning are added as this is the most\nperformance critical portion of the protocol.\n\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-16T15:19:24Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-04-25T17:33:35Z"
      },
      "sha": "0d6eefe7fd3dd693999bba460dcddcb329634bca"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGM2NWQ2NTYzZWVmMWZhZTY2NDc4YjUxOTQ5Njc5ZGY1MmRlNjg1Yzc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c65d6563eef1fae66478b51949679df52de685c7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c65d6563eef1fae66478b51949679df52de685c7",
      "tree": {
        "sha": "82c684aedc89da28e23918033f7768297efed6f3",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/82c684aedc89da28e23918033f7768297efed6f3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/0d6eefe7fd3dd693999bba460dcddcb329634bca",
          "sha": "0d6eefe7fd3dd693999bba460dcddcb329634bca",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/0d6eefe7fd3dd693999bba460dcddcb329634bca"
        }
      ],
      "message": "tests: add BIP-352 test vectors\n\nAdd the BIP-352 test vectors. The vectors are generated with a Python script\nthat converts the .json file from the BIP to C code:\n\n$ ./tools/tests_silentpayments_generate.py test_vectors.json > ./src/modules/silentpayments/vectors.h\n\nCo-authored-by: Ron <4712150+macgyver13@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>\nCo-authored-by: Tim Ruffing <1071625+real-or-random@users.noreply.github.com>",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-16T15:19:28Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-02T17:45:43Z"
      },
      "sha": "c65d6563eef1fae66478b51949679df52de685c7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDY4ODYyZjlhZGNlMzNiNmMyMWE4ZmYyMWVlMmMxNzgwNzkxNzNlMDc",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/68862f9adce33b6c21a8ff21ee2c178079173e07",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/68862f9adce33b6c21a8ff21ee2c178079173e07",
      "tree": {
        "sha": "ca3b923bb54051373afd468101cfbd7bf5584387",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ca3b923bb54051373afd468101cfbd7bf5584387"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/c65d6563eef1fae66478b51949679df52de685c7",
          "sha": "c65d6563eef1fae66478b51949679df52de685c7",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/c65d6563eef1fae66478b51949679df52de685c7"
        }
      ],
      "message": "tests: add constant time tests\n\nCo-authored-by: Jonas Nick <2582071+jonasnick@users.noreply.github.com>\nCo-authored-by: Sebastian Falbesoner <91535+thestack@users.noreply.github.com>",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-16T15:19:28Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-11-07T12:18:59Z"
      },
      "sha": "68862f9adce33b6c21a8ff21ee2c178079173e07"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGY5MTc1OTZjNjllYjQ5ZTA0NzQ5ODI0YzNmZjgxZDk0MjQ4NjYyZWI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f917596c69eb49e04749824c3ff81d94248662eb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f917596c69eb49e04749824c3ff81d94248662eb",
      "tree": {
        "sha": "af02a8aeb1880ecbcd2d89b250fb43d6dbf117f1",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/af02a8aeb1880ecbcd2d89b250fb43d6dbf117f1"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/68862f9adce33b6c21a8ff21ee2c178079173e07",
          "sha": "68862f9adce33b6c21a8ff21ee2c178079173e07",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/68862f9adce33b6c21a8ff21ee2c178079173e07"
        }
      ],
      "message": "tests: add sha256 tag test\n\nTest midstate tags used in silent payments.",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-16T15:19:28Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2025-08-15T08:46:46Z"
      },
      "sha": "f917596c69eb49e04749824c3ff81d94248662eb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDQ2MWJiODQ5NzM5OTU3MjJlMTM4ZjY5MjlmNzJhZWJhMTJhZjZhMTI",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/461bb84973995722e138f6929f72aeba12af6a12",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/461bb84973995722e138f6929f72aeba12af6a12",
      "tree": {
        "sha": "2c656fd0e1c9add386f579305b3bb4dde0258fbc",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/2c656fd0e1c9add386f579305b3bb4dde0258fbc"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f917596c69eb49e04749824c3ff81d94248662eb",
          "sha": "f917596c69eb49e04749824c3ff81d94248662eb",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f917596c69eb49e04749824c3ff81d94248662eb"
        }
      ],
      "message": "ci: enable silentpayments module",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-16T15:19:28Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2024-02-22T23:25:41Z"
      },
      "sha": "461bb84973995722e138f6929f72aeba12af6a12"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDk2YjdkOTA0YjRjZGRiNTdkZDZmMWY0OTE3ZDA2YzVlZWIzYjBkMzk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "tree": {
        "sha": "a9ef546600a64c2d317eed1fb09c91e2e297d75f",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/a9ef546600a64c2d317eed1fb09c91e2e297d75f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/461bb84973995722e138f6929f72aeba12af6a12",
          "sha": "461bb84973995722e138f6929f72aeba12af6a12",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/461bb84973995722e138f6929f72aeba12af6a12"
        }
      ],
      "message": "docs: update README",
      "committer": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2025-12-16T15:19:28Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2024-07-12T12:57:54Z"
      },
      "sha": "96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21597290536,
      "node_id": "HRFPE_lADOAP4Jqs7VEWwNzwAAAAUHTIAo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/21597290536",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "commit_url": "https://api.github.com/repos/theStack/secp256k1/commits/96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "created_at": "2025-12-16T16:37:50Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2528111908",
      "pull_request_review_id": 3465700051,
      "id": 2528111908,
      "node_id": "PRRC_kwDOAP4Jqs6Wr-0k",
      "diff_hunk": "@@ -0,0 +1,685 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n+\n+#include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n+\n+/** magic bytes for ensuring prevouts_summary objects were initialized correctly. */\n+static const unsigned char secp256k1_silentpayments_prevouts_summary_magic[4] = { 0xa7, 0x1c, 0xd3, 0x5e };\n+\n+/** Sort an array of silent payment recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    size_t len;\n+    int ret, overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    ret = secp256k1_eckey_pubkey_serialize(pubkey_sum, pubkey_sum_ser, &len, 1);\n+    VERIFY_CHECK(ret && len == sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    ret &= !secp256k1_scalar_is_zero(input_hash_scalar);\n+    return ret & !overflow;\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+    size_t len;\n+    int ret;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group elemement because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    ret = secp256k1_eckey_pubkey_serialize(&ss, shared_secret33, &len, 1);\n+#ifdef VERIFY\n+    VERIFY_CHECK(ret && len == 33);\n+#else\n+    (void)ret;\n+#endif\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }\n+        current_scan_pubkey = recipients[i]->scan_pubkey;\n+    }\n+    secp256k1_scalar_clear(&seckey_sum_scalar);\n+    secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+    return 1;\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Label\". */\n+static void secp256k1_silentpayments_sha256_init_label(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x26b95d63ul;\n+    hash->s[1] = 0x8bf1b740ul;\n+    hash->s[2] = 0x10a5986ful;\n+    hash->s[3] = 0x06a387a5ul;\n+    hash->s[4] = 0x2d1c1c30ul;\n+    hash->s[5] = 0xd035951aul;\n+    hash->s[6] = 0x2d7f0f96ul;\n+    hash->s[7] = 0x29e3e0dbul;\n+\n+    hash->bytes = 64;\n+}\n+\n+int secp256k1_silentpayments_recipient_create_label(const secp256k1_context *ctx, secp256k1_pubkey *label, unsigned char *label_tweak32, const unsigned char *scan_key32, uint32_t m) {\n+    secp256k1_sha256 hash;\n+    unsigned char m_serialized[4];\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(label != NULL);\n+    ARG_CHECK(label_tweak32 != NULL);\n+    ARG_CHECK(scan_key32 != NULL);\n+\n+    /* Compute hash(ser_256(b_scan) || ser_32(m))  [sha256 with tag \"BIP0352/Label\"] */\n+    secp256k1_silentpayments_sha256_init_label(&hash);\n+    secp256k1_sha256_write(&hash, scan_key32, 32);\n+    secp256k1_write_be32(m_serialized, m);\n+    secp256k1_sha256_write(&hash, m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_finalize(&hash, label_tweak32);\n+\n+    secp256k1_memclear_explicit(m_serialized, sizeof(m_serialized));\n+    secp256k1_sha256_clear(&hash);\n+    return secp256k1_ec_pubkey_create(ctx, label, label_tweak32);\n+}\n+\n+int secp256k1_silentpayments_recipient_create_labeled_spend_pubkey(const secp256k1_context *ctx, secp256k1_pubkey *labeled_spend_pubkey, const secp256k1_pubkey *unlabeled_spend_pubkey, const secp256k1_pubkey *label) {\n+    secp256k1_ge labeled_spend_pubkey_ge, label_addend;\n+    secp256k1_gej result_gej;\n+    secp256k1_ge result_ge;\n+    int ret;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(labeled_spend_pubkey != NULL);\n+    ARG_CHECK(unlabeled_spend_pubkey != NULL);\n+    ARG_CHECK(label != NULL);\n+\n+    /* Calculate labeled_spend_pubkey = spend_pubkey + label.\n+     * If either the label or spend public key is an invalid public key,\n+     * return early\n+     */\n+    ret = secp256k1_pubkey_load(ctx, &labeled_spend_pubkey_ge, unlabeled_spend_pubkey);\n+    ret &= secp256k1_pubkey_load(ctx, &label_addend, label);\n+    if (!ret) {\n+        return 0;\n+    }\n+    secp256k1_gej_set_ge(&result_gej, &labeled_spend_pubkey_ge);\n+    secp256k1_gej_add_ge_var(&result_gej, &result_gej, &label_addend, NULL);\n+    if (secp256k1_gej_is_infinity(&result_gej)) {\n+        return 0;\n+    }\n+\n+    secp256k1_ge_set_gej_var(&result_ge, &result_gej);\n+    secp256k1_pubkey_save(labeled_spend_pubkey, &result_ge);\n+\n+    return 1;\n+}\n+\n+/** An explanation of the prevouts_summary object and its usage:\n+ *\n+ *  The prevouts_summary object contains:\n+ *\n+ *  [magic: 4 bytes][boolean: 1 byte][prevouts_pubkey_sum: 64 bytes][input_hash: 32 bytes]\n+ *\n+ *  The magic bytes are checked by functions using the prevouts_summary object to\n+ *  check that the prevouts_summary object was initialized correctly.\n+ *\n+ *  The boolean (combined) indicates whether or not the summed prevout public keys and the\n+ *  input_hash scalar have already been combined or are both included. The reason\n+ *  for keeping input_hash and the summed prevout public keys separate is so that an elliptic\n+ *  curve multiplication can be avoided when creating the shared secret, i.e.,\n+ *  (recipient_scan_key * input_hash) * prevouts_pubkey_sum.\n+ *\n+ *  But when storing the prevouts_summary object (not supported yet), either to send to\n+ *  light clients or for wallet rescans, we can save 32-bytes by combining the input_hash\n+ *  and prevouts_pubkey_sum and saving the resulting point serialized as a compressed\n+ *  public key, i.e., input_hash * prevouts_pubkey_sum.\n+ *\n+ *  For each function:\n+ *\n+ *  - `_recipient_prevouts_summary_create` always creates a prevouts_summary object with combined = false\n+ */\n+\n+int secp256k1_silentpayments_recipient_prevouts_summary_create(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_xonly_pubkey * const *xonly_pubkeys,\n+    size_t n_xonly_pubkeys,\n+    const secp256k1_pubkey * const *plain_pubkeys,\n+    size_t n_plain_pubkeys\n+) {\n+    size_t i;\n+    secp256k1_ge prevouts_pubkey_sum_ge, addend;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    secp256k1_scalar input_hash_scalar;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_pubkeys != NULL) || (xonly_pubkeys != NULL));\n+    if (xonly_pubkeys != NULL) {\n+        ARG_CHECK(n_xonly_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_xonly_pubkeys == 0);\n+    }\n+    if (plain_pubkeys != NULL) {\n+        ARG_CHECK(n_plain_pubkeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_pubkeys == 0);\n+    }\n+\n+    /* Compute prevouts_pubkey_sum = A_1 + A_2 + ... + A_n.\n+     *\n+     * Since an attacker can maliciously craft transactions where the public keys sum to zero, fail early here\n+     * to avoid making the caller do extra work, e.g., when building an index or scanning a malicious transaction.\n+     *\n+     * This will also fail if any of the provided prevout public keys are malformed.\n+     */\n+    secp256k1_gej_set_infinity(&prevouts_pubkey_sum_gej);\n+    for (i = 0; i < n_plain_pubkeys; i++) {\n+        if (!secp256k1_pubkey_load(ctx, &addend, plain_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    for (i = 0; i < n_xonly_pubkeys; i++) {\n+        if (!secp256k1_xonly_pubkey_load(ctx, &addend, xonly_pubkeys[i])) {\n+            return 0;\n+        }\n+        secp256k1_gej_add_ge_var(&prevouts_pubkey_sum_gej, &prevouts_pubkey_sum_gej, &addend, NULL);\n+    }\n+    if (secp256k1_gej_is_infinity(&prevouts_pubkey_sum_gej)) {\n+        return 0;\n+    }\n+    secp256k1_ge_set_gej_var(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* Calculate the input_hash and convert it to a scalar.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        return 0;\n+    }\n+    memcpy(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4);\n+    prevouts_summary->data[4] = 0;\n+    secp256k1_ge_to_bytes(&prevouts_summary->data[5], &prevouts_pubkey_sum_ge);\n+    secp256k1_scalar_get_b32(&prevouts_summary->data[5 + 64], &input_hash_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_recipient_scan_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_silentpayments_found_output **found_outputs, size_t *n_found_outputs,\n+    const secp256k1_xonly_pubkey * const *tx_outputs, size_t n_tx_outputs,\n+    const unsigned char *scan_key32,\n+    const secp256k1_silentpayments_prevouts_summary *prevouts_summary,\n+    const secp256k1_pubkey *spend_pubkey,\n+    const secp256k1_silentpayments_label_lookup label_lookup,\n+    const void *label_context\n+) {\n+    secp256k1_scalar output_tweak_scalar, scan_key_scalar;\n+    secp256k1_ge label_ge, spend_pubkey_ge, prevouts_pubkey_sum_ge;\n+    secp256k1_xonly_pubkey output_xonly;\n+    unsigned char shared_secret[33];\n+    const unsigned char *label_tweak = NULL;\n+    size_t j, k, found_idx;\n+    int found, combined, valid_scan_key, ret;\n+\n+    /* Sanity check inputs */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(found_outputs != NULL);\n+    ARG_CHECK(n_found_outputs != NULL);\n+    ARG_CHECK(tx_outputs != NULL);\n+    ARG_CHECK(n_tx_outputs > 0);\n+    ARG_CHECK(scan_key32 != NULL);\n+    ARG_CHECK(prevouts_summary != NULL);\n+    ARG_CHECK(secp256k1_memcmp_var(&prevouts_summary->data[0], secp256k1_silentpayments_prevouts_summary_magic, 4) == 0);\n+    ARG_CHECK(spend_pubkey != NULL);\n+    /* Passing a context without a lookup function is non-sensical */\n+    if (label_context != NULL) {\n+        ARG_CHECK(label_lookup != NULL);\n+    }\n+    valid_scan_key = secp256k1_scalar_set_b32_seckey(&scan_key_scalar, scan_key32);\n+    secp256k1_declassify(ctx, &valid_scan_key, sizeof(valid_scan_key));\n+    if (!valid_scan_key) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_ge_from_bytes(&prevouts_pubkey_sum_ge, &prevouts_summary->data[5]);\n+    combined = (int)prevouts_summary->data[4];\n+    if (!combined) {\n+        secp256k1_scalar input_hash_scalar;\n+        secp256k1_scalar_set_b32(&input_hash_scalar, &prevouts_summary->data[5 + 64], NULL);\n+        secp256k1_scalar_mul(&scan_key_scalar, &scan_key_scalar, &input_hash_scalar);\n+    }\n+    ret = secp256k1_pubkey_load(ctx, &spend_pubkey_ge, spend_pubkey);\n+    if (!ret) {\n+        secp256k1_scalar_clear(&scan_key_scalar);\n+        return 0;\n+    }\n+    secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &prevouts_pubkey_sum_ge, &scan_key_scalar);\n+    /* Clear the scan_key_scalar since we no longer need it and leaking this value would break indistinguishability of the transaction. */\n+    secp256k1_scalar_clear(&scan_key_scalar);\n+\n+    found_idx = 0;\n+    for (k = 0; k < n_tx_outputs; k++) {\n+        secp256k1_ge output_ge = spend_pubkey_ge;\n+        /* Calculate the output_tweak and convert it to a scalar.\n+         *\n+         * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+         * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+         */\n+        if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret, k)) {\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+\n+        /* Calculate output = spend_pubkey + output_tweak * G.\n+         * This can fail if output_tweak * G is the negation of spend_pubkey, but this happens only\n+         * with negligible probability for honestly created spend_pubkey as output_tweak is the output of a hash function. */\n+        if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+            /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+            secp256k1_scalar_clear(&output_tweak_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        found = 0;\n+        secp256k1_xonly_pubkey_save(&output_xonly, &output_ge);\n+        for (j = 0; j < n_tx_outputs; j++) {\n+            if (secp256k1_xonly_pubkey_cmp(ctx, &output_xonly, tx_outputs[j]) == 0) {\n+                label_tweak = NULL;\n+                found = 1;\n+                found_idx = j;\n+                break;\n+            }\n+\n+            /* If not found, proceed to check for labels (if a label lookup function is provided). */\n+            if (label_lookup != NULL) {\n+                secp256k1_ge output_negated_ge, tx_output_ge;\n+                secp256k1_gej tx_output_gej, label_gej;\n+                unsigned char label33[33];\n+                size_t len;\n+\n+                secp256k1_xonly_pubkey_load(ctx, &tx_output_ge, tx_outputs[j]);\n+                secp256k1_gej_set_ge(&tx_output_gej, &tx_output_ge);\n+                /* Negate the generated output and calculate first scan label candidate:\n+                 *     label1 = tx_output - generated_output\n+                 */\n+                secp256k1_ge_neg(&output_negated_ge, &output_ge);\n+                secp256k1_gej_add_ge_var(&label_gej, &tx_output_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej_var(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded.\n+                 *\n+                 * Note: serialize will also fail if label_ge is the point at infinity, but we know\n+                 * this cannot happen since we only hit this branch if tx_output != output_xonly.\n+                 * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the\n+                 * point at infinity.\n+                 */\n+                VERIFY_CHECK(ret && len == 33);\n+                label_tweak = label_lookup(label33, label_context);\n+                if (label_tweak != NULL) {\n+                    found = 1;\n+                    found_idx = j;\n+                    break;\n+                }\n+\n+                /* If not found, negate the tx_output and calculate second scan label candidate:\n+                 *     label2 = -tx_output - generated_output\n+                 */\n+                secp256k1_gej_neg(&label_gej, &tx_output_gej);\n+                secp256k1_gej_add_ge_var(&label_gej, &label_gej, &output_negated_ge, NULL);\n+                secp256k1_ge_set_gej_var(&label_ge, &label_gej);\n+                ret = secp256k1_eckey_pubkey_serialize(&label_ge, label33, &len, 1);\n+                /* Serialize must succeed because the point was just loaded.\n+                 *\n+                 * Note: serialize will also fail if label_ge is the point at infinity, but we know\n+                 * this cannot happen since we only hit this branch if tx_output != output_xonly.\n+                 * Thus, we know that label_ge = tx_output_gej + output_negated_ge cannot be the",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 625,
      "commit_id": "c11d30c25f75776920797b017a568ea0cfc28882",
      "original_commit_id": "c11d30c25f75776920797b017a568ea0cfc28882",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Should be `- tx_output_gej`?",
      "created_at": "2025-11-14T16:21:51Z",
      "updated_at": "2025-11-14T16:25:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2528111908",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2528111908"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 625,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2590644412",
      "pull_request_review_id": 3542178806,
      "id": 2590644412,
      "node_id": "PRRC_kwDOAP4Jqs6aahi8",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 239,
      "original_position": 216,
      "commit_id": "96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin-core/secp256k1/commit/ffffd7ff98368b29759cd3d9933896fb9fa69b1f:\r\n\r\nwhat if `plain_seckeys[i]` is null? (same for `taproot_seckeys[I]` below).",
      "created_at": "2025-12-04T21:31:07Z",
      "updated_at": "2025-12-05T19:33:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2590644412",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2590644412"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 239,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593243357",
      "pull_request_review_id": 3542178806,
      "id": 2593243357,
      "node_id": "PRRC_kwDOAP4Jqs6akcDd",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In ffffd7ff98368b29759cd3d9933896fb9fa69b1f:\r\n\r\nAs `k` depends on `n_recipients`, wouldn't be simpler to ensure that `n_recipients < UINT32_MAX` early on the function? \r\n```C\r\nARG_CHECK(n_recipients > 0 && n_recipients < UINT32_MAX);\r\n```",
      "created_at": "2025-12-05T16:23:53Z",
      "updated_at": "2025-12-05T19:33:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2593243357",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593243357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593365138",
      "pull_request_review_id": 3542178806,
      "id": 2593365138,
      "node_id": "PRRC_kwDOAP4Jqs6ak5yS",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "q: Instead of having this weird `index` field in the public API, wouldn't be simpler to include the generated output directly inside `secp256k1_silentpayments_recipient`?\r\nE.g.\r\n```c\r\nstruct secp256k1_silentpayments_recipient {\r\n    /* Inputs */\r\n    secp256k1_pubkey in_scan_pubkey;\r\n    secp256k1_pubkey in_spend_pubkey;\r\n    /* Output */\r\n    secp256k1_xonly_pubkey out_generated_output;\r\n}\r\n```",
      "created_at": "2025-12-05T17:04:18Z",
      "updated_at": "2025-12-05T19:33:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2593365138",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593365138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593673524",
      "pull_request_review_id": 3542178806,
      "id": 2593673524,
      "node_id": "PRRC_kwDOAP4Jqs6amFE0",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 290,
      "original_position": 266,
      "commit_id": "96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin-core/secp256k1/commit/ffffd7ff98368b29759cd3d9933896fb9fa69b1f:\r\n\r\nThis is not realistically possible but.. should also check that the input hash scalar is not the inverse of the aggr sk (aka the result is not 1).",
      "created_at": "2025-12-05T19:00:36Z",
      "updated_at": "2025-12-05T21:59:33Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2593673524",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593673524"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 286,
      "original_start_line": 266,
      "start_side": "RIGHT",
      "line": 290,
      "original_line": 290,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593733673",
      "pull_request_review_id": 3542178806,
      "id": 2593733673,
      "node_id": "PRRC_kwDOAP4Jqs6amTwp",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 165,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin-core/secp256k1/commit/ffffd7ff98368b29759cd3d9933896fb9fa69b1f:\r\n\r\nExtra semicolon here.",
      "created_at": "2025-12-05T19:22:19Z",
      "updated_at": "2025-12-05T19:33:42Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2593733673",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2593733673"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594361262",
      "pull_request_review_id": 3546882246,
      "id": 2594361262,
      "node_id": "PRRC_kwDOAP4Jqs6aos-u",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 239,
      "original_position": 216,
      "commit_id": "96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2590644412,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Good catch, will add an `ARG_CHECK` to check for non-NULL, here and in other API functions (scanning) where similar checks for \"array of pointers\" elements are missing. I've also opened https://github.com/bitcoin-core/secp256k1/pull/1779 to do the same for API functions in master for consistency.",
      "created_at": "2025-12-06T01:47:43Z",
      "updated_at": "2025-12-06T01:48:31Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2594361262",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594361262"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 239,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594444863",
      "pull_request_review_id": 3547039916,
      "id": 2594444863,
      "node_id": "PRRC_kwDOAP4Jqs6apBY_",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think this change would be slightly simpler for the implementation, but possibly quite confusing for the user. Note that the passed in `_silentpayments_recipient` array gets sorted in place (to group by scan pubkey), so we need some way to map the generated outputs back to the original recipients. Doing this by just keeping the original order (that's what the `index` field is needed for) seems the most obvious (expected?) way. Admittedly with your proposed change an user would have the necessary information to do the mapping themselves, but it seems odd to e.g. pass in two recipients (r1, r2), get the result back in a different order (r2, r1) and then having to find out again at what position each recipient has moved, in order to get the corresponding generated output each.",
      "created_at": "2025-12-06T02:34:28Z",
      "updated_at": "2025-12-06T02:34:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2594444863",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594444863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594454594",
      "pull_request_review_id": 3547054404,
      "id": 2594454594,
      "node_id": "PRRC_kwDOAP4Jqs6apDxC",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593243357,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Bounding the number of recipients seems reasonable to me (even though by protocol they could exceed the 32-bit range in theory, if they are not going all to the same scan pubkey, and we would at some point allow ~185 GB sized transactions :p). I wonder if we could even just set the type of `n_recipients` to uint32_t instead of size_t, so the limit is already enforced at compile-time? IIRC there were some previous discussions between @josibake and @jonasnick about that topic (in take 3 or 2 of this PR), will look those up next week before changing.",
      "created_at": "2025-12-06T02:52:17Z",
      "updated_at": "2025-12-06T02:52:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2594454594",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594454594"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594483205",
      "pull_request_review_id": 3547105035,
      "id": 2594483205,
      "node_id": "PRRC_kwDOAP4Jqs6apKwF",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 290,
      "original_position": 266,
      "commit_id": "96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593673524,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm trying to wrap my head around on what the exact implications would be if that indeed happened. If $a * inputhash = 1$,the shared secret would then be equal to the recipient spend public key $B_{scan}$. That sounds problematic, I suppose it's a loss of privacy as the output tweaks are revealed, but the funds are still safe?\r\n(Wouldn't any other small-ish value also be problematic, as guessing $2* B_{scan}, 3*B_{scan}$ etc. is trivial as well?).",
      "created_at": "2025-12-06T03:39:29Z",
      "updated_at": "2025-12-06T03:39:30Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2594483205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2594483205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 286,
      "original_start_line": 266,
      "start_side": "RIGHT",
      "line": 290,
      "original_line": 290,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595102919",
      "pull_request_review_id": 3547827183,
      "id": 2595102919,
      "node_id": "PRRC_kwDOAP4Jqs6ariDH",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Admittedly with your proposed change an user would have the necessary information to do the mapping themselves, but it seems odd to e.g. pass in two recipients (r1, r2), get the result back in a different order (r2, r1) and then having to find out again at what position each recipient has moved, in order to get the corresponding generated output each.\r\n\r\nIf you have all the information, does the initial ordering matter?\r\n\r\n================================================================================\r\n\r\nAlso, I woke up creative.. another idea to remove the `index` field could be to store the initial ordering inside the `generated_outputs` array. We basically have a `n_recipients` size array with elements that are essentially buffers :).\r\nSo.. we could do something like:\r\n\r\n```diff\r\ndiff --git a/src/modules/silentpayments/main_impl.h b/src/modules/silentpayments/main_impl.h\r\n--- a/src/modules/silentpayments/main_impl.h\t(revision ffffd7ff98368b29759cd3d9933896fb9fa69b1f)\r\n+++ b/src/modules/silentpayments/main_impl.h\t(date 1765038514517)\r\n@@ -185,13 +185,14 @@\r\n     const unsigned char * const *plain_seckeys,\r\n     size_t n_plain_seckeys\r\n ) {\r\n-    size_t i, k;\r\n+    size_t i, k, j;\r\n     secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\r\n     secp256k1_ge prevouts_pubkey_sum_ge;\r\n     secp256k1_gej prevouts_pubkey_sum_gej;\r\n     unsigned char shared_secret[33];\r\n     secp256k1_pubkey current_scan_pubkey;\r\n     int ret, sum_is_zero;\r\n+    secp256k1_xonly_pubkey *output = NULL;\r\n \r\n     /* Sanity check inputs. */\r\n     VERIFY_CHECK(ctx != NULL);\r\n@@ -211,9 +212,6 @@\r\n     } else {\r\n         ARG_CHECK(n_plain_seckeys == 0);\r\n     }\r\n-    for (i = 0; i < n_recipients; i++) {\r\n-        ARG_CHECK(recipients[i]->index == i);\r\n-    }\r\n \r\n     seckey_sum_scalar = secp256k1_scalar_zero;\r\n     for (i = 0; i < n_plain_seckeys; i++) {\r\n@@ -268,6 +266,13 @@\r\n         return 0;\r\n     }\r\n     secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\r\n+\r\n+    /* Store recipients ordering prior to sorting the array */\r\n+    for (i = 0; i < n_recipients; i++) {\r\n+        /* Use the output struct as a buffer for storing the pointer of the recipient */\r\n+        memcpy(generated_outputs[i]->data, &recipients[i], sizeof(secp256k1_silentpayments_recipient*));\r\n+    }\r\n+\r\n     /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\r\n      * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\r\n      *\r\n@@ -294,7 +299,17 @@\r\n             secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\r\n             k = 0;\r\n         }\r\n-        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\r\n+\r\n+        /* Look-up for the correct output to initialize based on the initial ordering */\r\n+        for (j = 0; j < n_recipients; j++) {\r\n+            secp256k1_silentpayments_recipient *ptr = NULL;\r\n+            memcpy(&ptr, generated_outputs[j]->data, sizeof(secp256k1_silentpayments_recipient*));\r\n+            if (ptr == recipients[i]) {\r\n+                output = generated_outputs[j];\r\n+            }\r\n+        }\r\n+\r\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, output, shared_secret, &recipients[i]->spend_pubkey, k)) {\r\n             secp256k1_scalar_clear(&seckey_sum_scalar);\r\n             secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\r\n             return 0;\r\n\r\n===================================================================\r\ndiff --git a/include/secp256k1_silentpayments.h b/include/secp256k1_silentpayments.h\r\n--- a/include/secp256k1_silentpayments.h\t(revision ffffd7ff98368b29759cd3d9933896fb9fa69b1f)\r\n+++ b/include/secp256k1_silentpayments.h\t(date 1765038119367)\r\n@@ -45,7 +45,6 @@\r\n typedef struct secp256k1_silentpayments_recipient {\r\n     secp256k1_pubkey scan_pubkey;\r\n     secp256k1_pubkey spend_pubkey;\r\n-    size_t index;\r\n } secp256k1_silentpayments_recipient;\r\n \r\n /** Create Silent Payments outputs for recipient(s).\r\n\r\n\r\n===================================================================\r\ndiff --git a/src/modules/silentpayments/tests_impl.h b/src/modules/silentpayments/tests_impl.h\r\n--- a/src/modules/silentpayments/tests_impl.h\t(revision ffffd7ff98368b29759cd3d9933896fb9fa69b1f)\r\n+++ b/src/modules/silentpayments/tests_impl.h\t(date 1765038518151)\r\n@@ -98,7 +98,6 @@\r\n     for (i = 0; i < 3; i++) {\r\n         CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\r\n         CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey,(*sp_addresses[i])[1], 33));\r\n-        recipients[i].index = i;\r\n         recipient_ptrs[i] = &recipients[i];\r\n         generated_output_ptrs[i] = &generated_outputs[i];\r\n     }\r\n@@ -174,7 +173,6 @@\r\n         CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].scan_pubkey, (*sp_addresses[i])[0], 33));\r\n         CHECK(secp256k1_ec_pubkey_parse(CTX, &r[i].spend_pubkey,(*sp_addresses[i])[1], 33));\r\n         /* Set the index value incorrectly */\r\n-        r[i].index = 0;\r\n         rp[i] = &r[i];\r\n         op[i] = &o[i];\r\n     }\r\n@@ -183,13 +181,6 @@\r\n     t[0] = &taproot;\r\n     p[0] = ALICE_SECKEY;\r\n \r\n-    /* Fails if the index is set incorrectly */\r\n-    CHECK_ILLEGAL(CTX, secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\r\n-\r\n-    /* Set the index correctly for the next tests */\r\n-    for (i = 0; i < 2; i++) {\r\n-        r[i].index = i;\r\n-    }\r\n     CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1));\r\n \r\n     /* Check that null arguments are handled */\r\n@@ -257,7 +248,6 @@\r\n         CHECK(secp256k1_ec_pubkey_negate(CTX, &neg_spend_pubkey));\r\n         r[0].spend_pubkey = neg_spend_pubkey;\r\n         for (i = 0; i < 2; i++) {\r\n-            r[i].index = i;\r\n             rp[i] = &r[i];\r\n         }\r\n         CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, op, rp, 2, SMALLEST_OUTPOINT, NULL, 0, p, 1) == 0);\r\n```\r\n\r\n----------------------\r\n\r\nThat being said, this improves the public API at the cost of making the internal code a bit more complex. So Im not strong on it  I just had some fun thinking about different ways to remove the ugly `index` field. So no need to take it.",
      "created_at": "2025-12-06T16:36:29Z",
      "updated_at": "2025-12-06T16:42:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595102919",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595102919"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595796731",
      "pull_request_review_id": 3548663278,
      "id": 2595796731,
      "node_id": "PRRC_kwDOAP4Jqs6auLb7",
      "diff_hunk": "@@ -0,0 +1,273 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../unit_test.h\"\n+\n+/** Constants\n+ *\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f,\n+        0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11,\n+        0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed,\n+        0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7,\n+        0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46, 0x0d, 0x68, 0x08, 0x65, 0x64, 0x45, 0xee,\n+    0x4d, 0x4e, 0xc0, 0x8e, 0xba, 0x8a, 0x66, 0xea,\n+    0x66, 0x8e, 0x4e, 0x12, 0x98, 0x9a, 0x0e, 0x60,\n+    0x4b, 0x5c, 0x36, 0x0e, 0x43, 0xf5, 0x5a, 0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7, 0xf3, 0xc6, 0x79, 0x30, 0x4a, 0xef, 0x8c,\n+    0xc0, 0xc7, 0x61, 0xf1, 0x00, 0x99, 0xdd, 0x7b,\n+    0x20, 0x65, 0x20, 0xd7, 0x11, 0x6f, 0xb7, 0x91,\n+    0xee, 0x74, 0x54, 0xa2, 0xfc, 0x22, 0x79, 0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b, 0x81, 0x34, 0x5d, 0x53, 0x89, 0xba, 0xa3,\n+    0xd8, 0x93, 0xe2, 0xfb, 0xe7, 0x08, 0xdd, 0x6d,\n+    0x82, 0xdc, 0xd8, 0x49, 0xab, 0x03, 0xc1, 0xdb,\n+    0x68, 0xbe, 0xc7, 0xe9, 0x2a, 0x45, 0xfa, 0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea, 0xdc, 0x78, 0x16, 0x5f, 0xf1, 0xf8, 0xea,\n+    0x94, 0xad, 0x7c, 0xfd, 0xc5, 0x49, 0x90, 0x73,\n+    0x8a, 0x4c, 0x53, 0xf6, 0xe0, 0x50, 0x7b, 0x42,\n+    0x15, 0x42, 0x01, 0xb8, 0xe5, 0xdf, 0xf3, 0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret == 1);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    /* Note: in this case, the second output for Carol comes before the first.\n+     * This is because heapsort is an unstable sorting algorithm, i.e., the ordering\n+     * of identical elements is not guaranteed to be preserved\n+     */\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &CAROL_OUTPUT_ONE;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 157,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In ffffd7ff98368b29759cd3d9933896fb9fa69b1f:\r\n\r\nThe heapsort comment was a bit misleading to me. It only matters because were hardcoding the expected outputs, but it's not something we actually care about.\r\n\r\nThe goal of the test is to make sure that shuffling the inputted recipients never changes which outputs are produced, and that each expected output appears exactly once.\r\n\r\nSo we dont need to rely on any final ordering assumptions at all; they depend on heapsorts stability, which (per comment) is unstable. Take the following if you like it:\r\n\r\n```C\r\nstatic void shuffle(unsigned char (*sp_addresses[])[2][33], size_t size) {\r\n    size_t i, j;\r\n    for (i = size - 1; i > 0; i--) {\r\n        unsigned char (*tmp)[2][33] = sp_addresses[i];\r\n        j = testrand_bits(8) % (i + 1);\r\n        sp_addresses[i] = sp_addresses[j];\r\n        sp_addresses[j] = tmp;\r\n    }\r\n}\r\n\r\n/* Ensure that shuffling the inputted recipients never changes\r\n * which outputs are produced, and that each expected output\r\n * appears exactly once */\r\nstatic void test_recipient_sort(void) {\r\n    int i, j;\r\n    unsigned char (*sp_addresses[3])[2][33] = { &CAROL_ADDRESS, &CAROL_ADDRESS, &BOB_ADDRESS };\r\n    unsigned char const *seckey_ptrs[1] = { ALICE_SECKEY };\r\n    unsigned char xonly_ser[32];\r\n\r\n    secp256k1_silentpayments_recipient recipients[3];\r\n    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\r\n    secp256k1_xonly_pubkey generated_outputs[3];\r\n    secp256k1_xonly_pubkey *generated_output_ptrs[3];\r\n\r\n    for (i = 0; i < 6; i++) {\r\n        int pos_bob = -1, pos_carol_one = -1, pos_carol_two = -1;\r\n\r\n        /* Randomize array */\r\n        shuffle(sp_addresses, 3);\r\n\r\n        for (j = 0; j < 3; j++) {\r\n            CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[j].scan_pubkey, (*sp_addresses[j])[0], 33));\r\n            CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[j].spend_pubkey,(*sp_addresses[j])[1], 33));\r\n            recipients[j].index = j;\r\n            recipient_ptrs[j] = &recipients[j];\r\n            generated_output_ptrs[j] = &generated_outputs[j];\r\n        }\r\n        CHECK(secp256k1_silentpayments_sender_create_outputs(CTX, generated_output_ptrs,\r\n                                                             recipient_ptrs, 3,\r\n                                                             SMALLEST_OUTPOINT,\r\n                                                             NULL, 0,\r\n                                                             seckey_ptrs, 1) == 1);\r\n\r\n        /* Verify output correctness and they all appear once */\r\n        for (j = 0; j < 3; j++) {\r\n            int* pos = NULL;\r\n            CHECK(secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[j]));\r\n            if (secp256k1_memcmp_var(xonly_ser, BOB_OUTPUT, 32) == 0) {\r\n                pos = &pos_bob;\r\n            } else if (secp256k1_memcmp_var(xonly_ser, CAROL_OUTPUT_ONE, 32) == 0) {\r\n                pos = &pos_carol_one;\r\n            } else if (secp256k1_memcmp_var(xonly_ser, CAROL_OUTPUT_TWO, 32) == 0) {\r\n                pos = &pos_carol_two;\r\n            } else {\r\n                TEST_FAILURE(\"Error: unknown generated output\");\r\n            }\r\n            CHECK(*pos == -1); /* enforce uniqueness */\r\n            *pos = j;\r\n        }\r\n    }\r\n}\r\n```",
      "created_at": "2025-12-07T01:35:49Z",
      "updated_at": "2025-12-07T01:49:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595796731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595796731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 127,
      "original_start_line": 87,
      "start_side": "RIGHT",
      "line": 193,
      "original_line": 193,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595909459",
      "pull_request_review_id": 3548792135,
      "id": 2595909459,
      "node_id": "PRRC_kwDOAP4Jqs6aum9T",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> If you have all the information, does the initial ordering matter?\r\n\r\nIn theory it doesn't, in practice I think some users would be at least surprised or annoyed by getting the generated outputs back in an order that is different from the passed in recipients (some might even lose money by confusing the amounts for e.g. the actual recipient and the change output).\r\n\r\n> Also, I woke up creative.. another idea to remove the index field could be to store the initial ordering inside the generated_outputs array. We basically have a n_recipients size array with elements that are essentially buffers :).\r\n\r\nThat's a neat and indeed very creative idea . (Ab)using a pubkey object's underlying memory for temporarily storing a pointer value feels very hacky though, so not sure if we want to introduce these kind of tricks in general. On the other hand, simplifying the API would be indeed a win, so I'm not fully opposed either. Curious what others think about this.",
      "created_at": "2025-12-07T03:58:14Z",
      "updated_at": "2025-12-07T03:58:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595909459",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595909459"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595911929",
      "pull_request_review_id": 3548795863,
      "id": 2595911929,
      "node_id": "PRRC_kwDOAP4Jqs6aunj5",
      "diff_hunk": "@@ -0,0 +1,273 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../unit_test.h\"\n+\n+/** Constants\n+ *\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f,\n+        0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11,\n+        0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed,\n+        0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7,\n+        0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46, 0x0d, 0x68, 0x08, 0x65, 0x64, 0x45, 0xee,\n+    0x4d, 0x4e, 0xc0, 0x8e, 0xba, 0x8a, 0x66, 0xea,\n+    0x66, 0x8e, 0x4e, 0x12, 0x98, 0x9a, 0x0e, 0x60,\n+    0x4b, 0x5c, 0x36, 0x0e, 0x43, 0xf5, 0x5a, 0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7, 0xf3, 0xc6, 0x79, 0x30, 0x4a, 0xef, 0x8c,\n+    0xc0, 0xc7, 0x61, 0xf1, 0x00, 0x99, 0xdd, 0x7b,\n+    0x20, 0x65, 0x20, 0xd7, 0x11, 0x6f, 0xb7, 0x91,\n+    0xee, 0x74, 0x54, 0xa2, 0xfc, 0x22, 0x79, 0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b, 0x81, 0x34, 0x5d, 0x53, 0x89, 0xba, 0xa3,\n+    0xd8, 0x93, 0xe2, 0xfb, 0xe7, 0x08, 0xdd, 0x6d,\n+    0x82, 0xdc, 0xd8, 0x49, 0xab, 0x03, 0xc1, 0xdb,\n+    0x68, 0xbe, 0xc7, 0xe9, 0x2a, 0x45, 0xfa, 0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea, 0xdc, 0x78, 0x16, 0x5f, 0xf1, 0xf8, 0xea,\n+    0x94, 0xad, 0x7c, 0xfd, 0xc5, 0x49, 0x90, 0x73,\n+    0x8a, 0x4c, 0x53, 0xf6, 0xe0, 0x50, 0x7b, 0x42,\n+    0x15, 0x42, 0x01, 0xb8, 0xe5, 0xdf, 0xf3, 0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret == 1);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    /* Note: in this case, the second output for Carol comes before the first.\n+     * This is because heapsort is an unstable sorting algorithm, i.e., the ordering\n+     * of identical elements is not guaranteed to be preserved\n+     */\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &CAROL_OUTPUT_ONE;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 157,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2595796731,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks for taking a closer look there. I agree this could be improved.\r\n\r\n> The goal of the test is to make sure that shuffling the inputted recipients never changes which outputs are produced, and that each expected output appears exactly once.\r\n> \r\n> So we dont need to rely on any final ordering assumptions at all; they depend on heapsorts stability, which (per comment) is unstable.\r\n\r\nNote that order of the generated outputs does indeed matter and should be tested. The sending API as-is guarantees that for a passed in recipient at position i (`recipients[i]`), the generated output at the same position (`generated_outputs[i]`) can be found (and hence be spent later) by that exact recipient. The only thing not guaranteed due to unstable heap sort is the order in which the increasing k values are used for generating those outputs, for recipients that share the same scan public key.\r\n\r\nFor example, let's say we have three recipients, leading to three outputs:\r\nr0 = (scan_pk, spend_pk_A) -> tx_out0\r\nr1 = (scan_pk, spend_pk_B) -> tx_out1\r\nr2 = (scan_pk, spend_pk_C) -> tx_out2\r\n\r\nThese three recipients are all in one group, sharing the same `ecdh_shared_secret` (see BIP-352). The output tweak $t_k$ for creating depends on that shared secret and a counter k that is increased for each spend public key in the group, starting with k=0. Due to heap sort being unstable, the order in which these spend public keys are picked from the group to create outputs is not guaranteed, i.e. it might be that spend_pk_C is used first to create the output with k=0 (-> assigned to tx_out2), then spend_pk_A with k=1 (-> assigned to tx_out0) and lastly spend_pk_B with k=2 (-> assigned to tx_out1). For a recipient the k value that was used for output generation doesn't matter, they will still find them if they include all other tx outputs and follow the scanning protocol correctly. Note that assigning the generated outputs at the intended position (matching the recipient position) is done using the `index` field in the recipient data structure (see also previous related comment https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595909459).\r\n\r\nSo in the quoted test code,\r\n`CAROL_OUTPUT_ONE` means \"output to carol, generated with k=0\" and\r\n`CAROL_OUTPUT_TWO` means \"output to carol, generated with k=1\" accordingly.\r\nIf `sp_addresses[i]` is assigned to `BOB_ADDRESS`, `sp_outputs[i]` must be `BOB_OUTPUT` (this case is unambiguous, the bob's scan pubkey appears only once in the recipient list).\r\nIf `sp_adresses[i]` is assigned to `CAROL_ADDRESS`, `so_outputs[i]` must be either `CAROL_OUTPUT_ONE` or `CAROL_OUTPUT_TWO` (that scan pubkey appears twice in the recipient list, so the order within those is ambiguous).\r\n\r\nI will give this some more thoughts on how to better express this in the test, suggestions of course welcome.",
      "created_at": "2025-12-07T04:03:33Z",
      "updated_at": "2025-12-07T04:05:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595911929",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2595911929"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 127,
      "original_start_line": 87,
      "start_side": "RIGHT",
      "line": 193,
      "original_line": 193,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2596386385",
      "pull_request_review_id": 3549361073,
      "id": 2596386385,
      "node_id": "PRRC_kwDOAP4Jqs6awbZR",
      "diff_hunk": "@@ -0,0 +1,273 @@\n+/***********************************************************************\n+ * Distributed under the MIT software license, see the accompanying    *\n+ * file COPYING or https://www.opensource.org/licenses/mit-license.php.*\n+ ***********************************************************************/\n+\n+#ifndef SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+#define SECP256K1_MODULE_SILENTPAYMENTS_TESTS_H\n+\n+#include \"../../../include/secp256k1_silentpayments.h\"\n+#include \"../../unit_test.h\"\n+\n+/** Constants\n+ *\n+ *   Malformed Seckey: a seckey that is all zeros\n+ *          Addresses: scan and spend public keys for Bob and Carol\n+ *            Outputs: generated outputs from Alice's secret key and Bob/Carol's\n+ *                     scan public keys\n+ *  Smallest Outpoint: smallest outpoint lexicographically from the transaction\n+ *             Seckey: secret key for Alice\n+ *\n+ *  The values themselves are not important.\n+ */\n+static unsigned char MALFORMED_SECKEY[32] = { 0x00 };\n+static unsigned char BOB_ADDRESS[2][33] = {\n+    {\n+        0x02, 0x15, 0x40, 0xae, 0xa8, 0x97, 0x54, 0x7a,\n+        0xd4, 0x39, 0xb4, 0xe0, 0xf6, 0x09, 0xe5, 0xf0,\n+        0xfa, 0x63, 0xde, 0x89, 0xab, 0x11, 0xed, 0xe3,\n+        0x1e, 0x8c, 0xde, 0x4b, 0xe2, 0x19, 0x42, 0x5f,\n+        0x23\n+    },\n+    {\n+        0x02, 0x3e, 0xff, 0xf8, 0x18, 0x51, 0x65, 0xea,\n+        0x63, 0xa9, 0x92, 0xb3, 0x9f, 0x31, 0xd8, 0xfd,\n+        0x8e, 0x0e, 0x64, 0xae, 0xf9, 0xd3, 0x88, 0x07,\n+        0x34, 0x97, 0x37, 0x14, 0xa5, 0x3d, 0x83, 0x11,\n+        0x8d\n+    }\n+};\n+static unsigned char CAROL_ADDRESS[2][33] = {\n+    {\n+        0x03, 0xbb, 0xc6, 0x3f, 0x12, 0x74, 0x5d, 0x3b,\n+        0x9e, 0x9d, 0x24, 0xc6, 0xcd, 0x7a, 0x1e, 0xfe,\n+        0xba, 0xd0, 0xa7, 0xf4, 0x69, 0x23, 0x2f, 0xbe,\n+        0xcf, 0x31, 0xfb, 0xa7, 0xb4, 0xf7, 0xdd, 0xed,\n+        0xa8\n+    },\n+    {\n+        0x03, 0x81, 0xeb, 0x9a, 0x9a, 0x9e, 0xc7, 0x39,\n+        0xd5, 0x27, 0xc1, 0x63, 0x1b, 0x31, 0xb4, 0x21,\n+        0x56, 0x6f, 0x5c, 0x2a, 0x47, 0xb4, 0xab, 0x5b,\n+        0x1f, 0x6a, 0x68, 0x6d, 0xfb, 0x68, 0xea, 0xb7,\n+        0x16\n+    }\n+};\n+static unsigned char BOB_OUTPUT[32] = {\n+    0x46, 0x0d, 0x68, 0x08, 0x65, 0x64, 0x45, 0xee,\n+    0x4d, 0x4e, 0xc0, 0x8e, 0xba, 0x8a, 0x66, 0xea,\n+    0x66, 0x8e, 0x4e, 0x12, 0x98, 0x9a, 0x0e, 0x60,\n+    0x4b, 0x5c, 0x36, 0x0e, 0x43, 0xf5, 0x5a, 0xfa\n+};\n+static unsigned char CAROL_OUTPUT_ONE[32] = {\n+    0xb7, 0xf3, 0xc6, 0x79, 0x30, 0x4a, 0xef, 0x8c,\n+    0xc0, 0xc7, 0x61, 0xf1, 0x00, 0x99, 0xdd, 0x7b,\n+    0x20, 0x65, 0x20, 0xd7, 0x11, 0x6f, 0xb7, 0x91,\n+    0xee, 0x74, 0x54, 0xa2, 0xfc, 0x22, 0x79, 0xf4\n+};\n+static unsigned char CAROL_OUTPUT_TWO[32] = {\n+    0x4b, 0x81, 0x34, 0x5d, 0x53, 0x89, 0xba, 0xa3,\n+    0xd8, 0x93, 0xe2, 0xfb, 0xe7, 0x08, 0xdd, 0x6d,\n+    0x82, 0xdc, 0xd8, 0x49, 0xab, 0x03, 0xc1, 0xdb,\n+    0x68, 0xbe, 0xc7, 0xe9, 0x2a, 0x45, 0xfa, 0xc5\n+};\n+static unsigned char SMALLEST_OUTPOINT[36] = {\n+    0x16, 0x9e, 0x1e, 0x83, 0xe9, 0x30, 0x85, 0x33, 0x91,\n+    0xbc, 0x6f, 0x35, 0xf6, 0x05, 0xc6, 0x75, 0x4c, 0xfe,\n+    0xad, 0x57, 0xcf, 0x83, 0x87, 0x63, 0x9d, 0x3b, 0x40,\n+    0x96, 0xc5, 0x4f, 0x18, 0xf4, 0x00, 0x00, 0x00, 0x00\n+};\n+static unsigned char ALICE_SECKEY[32] = {\n+    0xea, 0xdc, 0x78, 0x16, 0x5f, 0xf1, 0xf8, 0xea,\n+    0x94, 0xad, 0x7c, 0xfd, 0xc5, 0x49, 0x90, 0x73,\n+    0x8a, 0x4c, 0x53, 0xf6, 0xe0, 0x50, 0x7b, 0x42,\n+    0x15, 0x42, 0x01, 0xb8, 0xe5, 0xdf, 0xf3, 0xb1\n+};\n+\n+static void test_recipient_sort_helper(unsigned char (*sp_addresses[3])[2][33], unsigned char (*sp_outputs[3])[32]) {\n+    unsigned char const *seckey_ptrs[1];\n+    secp256k1_silentpayments_recipient recipients[3];\n+    const secp256k1_silentpayments_recipient *recipient_ptrs[3];\n+    secp256k1_xonly_pubkey generated_outputs[3];\n+    secp256k1_xonly_pubkey *generated_output_ptrs[3];\n+    unsigned char xonly_ser[32];\n+    size_t i;\n+    int ret;\n+\n+    seckey_ptrs[0] = ALICE_SECKEY;\n+    for (i = 0; i < 3; i++) {\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].scan_pubkey, (*sp_addresses[i])[0], 33));\n+        CHECK(secp256k1_ec_pubkey_parse(CTX, &recipients[i].spend_pubkey,(*sp_addresses[i])[1], 33));\n+        recipients[i].index = i;\n+        recipient_ptrs[i] = &recipients[i];\n+        generated_output_ptrs[i] = &generated_outputs[i];\n+    }\n+    ret = secp256k1_silentpayments_sender_create_outputs(CTX,\n+        generated_output_ptrs,\n+        recipient_ptrs, 3,\n+        SMALLEST_OUTPOINT,\n+        NULL, 0,\n+        seckey_ptrs, 1\n+    );\n+    CHECK(ret == 1);\n+    for (i = 0; i < 3; i++) {\n+        secp256k1_xonly_pubkey_serialize(CTX, xonly_ser, &generated_outputs[i]);\n+        CHECK(secp256k1_memcmp_var(xonly_ser, (*sp_outputs[i]), 32) == 0);\n+    }\n+}\n+\n+static void test_recipient_sort(void) {\n+    unsigned char (*sp_addresses[3])[2][33];\n+    unsigned char (*sp_outputs[3])[32];\n+\n+    /* With a fixed set of addresses and a fixed set of inputs,\n+     * test that we always get the same outputs, regardless of the ordering\n+     * of the recipients\n+     */\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &BOB_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &BOB_OUTPUT;\n+    sp_outputs[2] = &CAROL_OUTPUT_TWO;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &CAROL_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &BOB_ADDRESS;\n+\n+    sp_outputs[0] = &CAROL_OUTPUT_ONE;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &BOB_OUTPUT;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+\n+    sp_addresses[0] = &BOB_ADDRESS;\n+    sp_addresses[1] = &CAROL_ADDRESS;\n+    sp_addresses[2] = &CAROL_ADDRESS;\n+\n+    /* Note: in this case, the second output for Carol comes before the first.\n+     * This is because heapsort is an unstable sorting algorithm, i.e., the ordering\n+     * of identical elements is not guaranteed to be preserved\n+     */\n+    sp_outputs[0] = &BOB_OUTPUT;\n+    sp_outputs[1] = &CAROL_OUTPUT_TWO;\n+    sp_outputs[2] = &CAROL_OUTPUT_ONE;\n+    test_recipient_sort_helper(sp_addresses, sp_outputs);\n+}",
      "path": "src/modules/silentpayments/tests_impl.h",
      "position": 1,
      "original_position": 157,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2595796731,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I did this with my brain based on the other comment; the one I'm saying \"If you have all the information, does the initial ordering matter?\" ([https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595102919](https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2595102919)). I just read your response there. Thanks.\r\n\r\nWe can easily adapt the generalized test to verify that the initial recipients ordering matches the final outputs order. We just need to cache their initial positions during creation (post-shuffle), then check that Bob stays in the same spot and that the two Carols appear exactly once, working around the heapsort instability. That is simple to do.\r\n\r\nOverall, this latest test covers strictly more cases than the previous one. And with this approach, we can also easily confirm were not biased by the fixed number of outputs we currently have (right now we only verify arrays of length 3). E.g. it would be nice to test against arrays of length two as well. Also, something very important, it would be good to test `k` is increased for a second output from Bob when there are two outputs for Carol (If `k` is only ever increased and not reset or something unexpected happens, we do have a major issue).\r\nI'm not expecting this ^^ to fail, it is just test coverage we should have.",
      "created_at": "2025-12-07T15:30:07Z",
      "updated_at": "2025-12-07T15:30:07Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2596386385",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2596386385"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 127,
      "original_start_line": 87,
      "start_side": "RIGHT",
      "line": 193,
      "original_line": 193,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2599453964",
      "pull_request_review_id": 3553138859,
      "id": 2599453964,
      "node_id": "PRRC_kwDOAP4Jqs6a8IUM",
      "diff_hunk": "@@ -126,6 +126,60 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 25,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "913fdee7e17b0f69a8e70b9876be47c6a887ff32",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm unsure about the label use-case so far but leaving that topic aside (will keep thinking about it),\r\n\r\nI'm wondering if we could use a typedef for the label here instead of relying on the public key structure.\r\nAt least for me, public keys are meant for sending coins to, and we dont want anyone sending coins to the group element `label = hash(scan_key || m) * G`. Clarifying the intent with a simple typedef might save us a few headaches.",
      "created_at": "2025-12-08T17:16:49Z",
      "updated_at": "2025-12-08T20:28:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2599453964",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2599453964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 148,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2603766315",
      "pull_request_review_id": 3558903592,
      "id": 2603766315,
      "node_id": "PRRC_kwDOAP4Jqs6bMlIr",
      "diff_hunk": "@@ -126,6 +126,60 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 25,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "913fdee7e17b0f69a8e70b9876be47c6a887ff32",
      "in_reply_to_id": 2599453964,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The idea of avoiding the pubkey type for labels has some merit, though I think that introducing a typedef alone would not completely solve the problem. In order to (de)serialize labels (needed to e.g. create entries for the labels cache, or load labels from wallet backups), a user has to call the `secp256k1_pubkey_{serialize,parse}` functions, i.e. the \"pubkey\" terminology would still show up and be mixed with `_silentpayments_label` types (which might even be more confusing for users). Should we introduce aliases for these functions as well? Or, maybe having the typedef alone would still be better than not having it (with proper documentation), will give this some more thoughts.",
      "created_at": "2025-12-09T18:11:33Z",
      "updated_at": "2025-12-09T18:11:34Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2603766315",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2603766315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 148,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2609620541",
      "pull_request_review_id": 3566255305,
      "id": 2609620541,
      "node_id": "PRRC_kwDOAP4Jqs6bi6Y9",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593243357,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Bounding the number of recipients seems reasonable to me (even though by protocol they could exceed the 32-bit range in theory, if they are not going all to the same scan pubkey, and we would at some point allow ~185 GB sized transactions :p).\r\n\r\nSince noone has a machine with infinite memory, any implementation of the protocol will need to have *some* limit. I think this simply shows that the protocol spec could be improved. There should be reasonable limits for all arrays. Sometimes they're implied, e.g., if the size is serialization in a fixed-length integer, but sometimes they're not. Even if they're implied, it will be better to be explicit in the BIP and just state the limit.\r\n\r\nThis is something I learned from working on multiple BIPs that specify schemes with arrays or other containers. When you write the spec, you want it to be implementable on many platforms, so you try not to be too specific when it comes to choices like maximum sizes. But later, when you go ahead and actually implement the thing, you feel it would be great if the spec would just tell you the limit (because this would have prevented this entire discussion). \r\n \r\n> I wonder if we could even just set the type of `n_recipients` to uint32_t instead of size_t, so the limit is already enforced at compile-time? IIRC there were some previous discussions between @josibake and @jonasnick about that topic (in take 3 or 2 of this PR), will look those up next week before changing.\r\n\r\nI can't remember these discussions, but using `uint32_t` is the most natural thing to do. And then we should update the BIP to make that clear in the spec.\r\n",
      "created_at": "2025-12-11T08:18:55Z",
      "updated_at": "2025-12-11T08:18:55Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2609620541",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2609620541"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2609841176",
      "pull_request_review_id": 3566518130,
      "id": 2609841176,
      "node_id": "PRRC_kwDOAP4Jqs6bjwQY",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> That's a neat and indeed very creative idea . (Ab)using a pubkey object's underlying memory for temporarily storing a pointer value feels very hacky though, so not sure if we want to introduce these kind of tricks in general. On the other hand, simplifying the API would be indeed a win, so I'm not fully opposed either. Curious what others think about this.\r\n\r\nMy thinking is that I'm slightly in favor. This is not as crazy as it may look. The `data` member of the pubkey is even `unsigned char`, so this should be perfectly legal in C. (If people have doubts, we could even convert to `intptr_t` first and then read out the individual chars from an actual integer type.)\r\n\r\nI have thought of getting rid of `index`, including hacky ways, but somehow I didn't see this way. \r\n\r\nedit: But it will be nice to hear other people's opinions. There was a lot of discussion about the thing already. I can imagine that others had found this approach but rejected it for various reasons.",
      "created_at": "2025-12-11T09:29:29Z",
      "updated_at": "2025-12-11T10:34:18Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2609841176",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2609841176"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610038006",
      "pull_request_review_id": 3566752113,
      "id": 2610038006,
      "node_id": "PRRC_kwDOAP4Jqs6bkgT2",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 290,
      "original_position": 266,
      "commit_id": "96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593673524,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "\r\n\r\n\r\n> In [ffffd7f](https://github.com/bitcoin-core/secp256k1/commit/ffffd7ff98368b29759cd3d9933896fb9fa69b1f):\r\n> \r\n> This is not realistically possible but.. should also check that the input hash scalar is not the inverse of the aggr sk (aka the result is not 1).\r\n\r\nHm, what should go wrong? 1 is a valid secret key for ECDH.\r\n\r\n> I'm trying to wrap my head around on what the exact implications would be if that indeed happened. If $a * inputhash = 1$,the shared secret would then be equal to the recipient spend public key $B_{scan}$. That sounds problematic, I suppose it's a loss of privacy as the output tweaks are revealed, but the funds are still safe?\r\n(Wouldn't any other small-ish value also be problematic, as guessing $2* B_{scan}, 3*B_{scan}$ etc. is trivial as well?).\r\n\r\nNo, I think this is a (common) misconception. With this argument, *any* value would be bad. If the secret key was `1784a975e6545c8cdb932dd228de6d6c`, wouldn't this be bad. If the attacker guessed that value, then privacy would be lost? \r\n\r\n<details>\r\n<summary>Some background</summary>\r\n\r\nSmall values will be easier to guess for attackers that start guessing at 0 (or 1). But there's no point in assuming a specific attacker. What matters here to the sender is just that it will be sufficiently unpredictable (because the raw shared secret goes into a hash), i.e., it has sufficient entropy from the attacker's perspective.\r\n\r\nI think what adds to this misconception is that the situation is more complex for \"human-chosen\" random, e.g., passwords. It's bad to use \"hamster\" as a password because it's an actual word, and so humans are more likely to pick it. Real attackers make use of that fact. So even if the space of allowed passwords is huge, letting a person pick one may yield enough entropy (depending on the person). The point here is that the process of generating a password is not clearly specified and depends on the person.  \r\n\r\nBut cryptography is usually simpler. We know the exact process of generating a secret key, and so we know the exact distribution of secret keys. Typically, secret keys are just chosen uniformly at random (and we'll often want this stronger requirement instead of just \"sufficient entropy\", e.g., in a one-time pad). Ruling out values such as 1 only removes entropy (though ruling out one value makes only a negligible difference, of course.) \r\n\r\nA valid reason to rule out specific values would not be that the attacker can guess them but to avoid creating problems in further computations. Sometimes that's the case. For example, we typically rule out 0 as a secret key because we'd like to avoid the special casing in (de)serializing the point at infinity (and other corner cases). Sometimes corner values can make the protocol. But I don't see a problem with a 1 here. (But maybe we're overlooking something, and @furszy sees a valid problem.)\r\n\r\nIn this specific case, we're dealing with a derived value and not with one chosen uniformly at random. But as I said above, it can be argued that it has sufficient entropy: assuming that the individual summed-up keys are independent, if one of the individual summed-up keys is uniformly random, then the sum is. Then we multiply with a hash, so the product is also uniformly random. (So even if 0 or 1 are problematic values, they would occur only with negligible probability.)\r\n\r\nIf you want to be fully formal, you'd need to take into account that the hash value depends on this sum (the sum pubkey goes into the hash and the attacker can even know this pubkey sum). So in theory, you could, for example, have a hash function that always maps to the inverse. This won't happen for SHA256 obviously, and if you assume the ROM, you can make that formal. \r\n\r\nIn fact, even a malicious sender could not force 0 or 1. This is like a Fiat-Shamir construction. The sender will need to pick the pubkey sum (and thus the seckey sum) before getting the hash value, so it's not feasible to pick the seckey sum depending on the hash value. \r\n\r\n</details>\r\n",
      "created_at": "2025-12-11T10:27:08Z",
      "updated_at": "2025-12-11T10:27:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2610038006",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610038006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 286,
      "original_start_line": 266,
      "start_side": "RIGHT",
      "line": 290,
      "original_line": 290,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610056690",
      "pull_request_review_id": 3566774354,
      "id": 2610056690,
      "node_id": "PRRC_kwDOAP4Jqs6bkk3y",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 108,
      "original_position": 94,
      "commit_id": "96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Now that I wrote this other long comment above, I'm not sure if this argument is confusing here. The shared secret could, in theory, be the point at infinity, no? I mean, it will happen only with negligible probability even for malicious senders, so I don't see how it would be a problem. But the comment here says that we have validated the public key and secret key. This is true. We have validated the sum secret key to be not 0, but this validation happened before we multiply a hash, and the hash could be zero. Okay, it seems that we also check that the hash is not zero in `secp256k1_silentpayments_calculate_input_hash_scalar` Okay, I guess the code is perfectly fine, but the comment could be made more precise. ",
      "created_at": "2025-12-11T10:32:53Z",
      "updated_at": "2025-12-11T10:32:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2610056690",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610056690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": 100,
      "original_start_line": 92,
      "start_side": "RIGHT",
      "line": 108,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610534331",
      "pull_request_review_id": 3567377187,
      "id": 2610534331,
      "node_id": "PRRC_kwDOAP4Jqs6bmZe7",
      "diff_hunk": "@@ -126,6 +126,60 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_sender_c\n     size_t n_plain_seckeys\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(5);\n \n+/** Create Silent Payments label tweak and label.\n+ *\n+ *  Given a recipient's 32 byte scan key and a label integer m, calculate the\n+ *  corresponding label tweak and label:\n+ *\n+ *      label_tweak = hash(scan_key || m)\n+ *            label = label_tweak * G\n+ *\n+ *  Returns: 1 if label tweak and label creation was successful.\n+ *           0 if hash output label_tweak32 is not valid scalar (negligible\n+ *             probability per hash evaluation).\n+ *\n+ *  Args:                ctx: pointer to a context object\n+ *                            (not secp256k1_context_static)\n+ *  Out:               label: pointer to the resulting label public key\n+ *             label_tweak32: pointer to the 32 byte label tweak\n+ *  In:           scan_key32: pointer to the recipient's 32 byte scan key\n+ *                         m: integer for the m-th label (0 is used for change outputs)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_silentpayments_recipient_create_label(\n+    const secp256k1_context *ctx,\n+    secp256k1_pubkey *label,",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 25,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "913fdee7e17b0f69a8e70b9876be47c6a887ff32",
      "in_reply_to_id": 2599453964,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think that is a great point. My current thinking is that we should make an entirely new type including serialization functions.\n\nThe pubkey type is a bit stretched sometimes. If we could redesign the entire library from scratch, I'd seriously consider having entirely separate pubkey types for all schemes. You can (ab)use an ECDSA pubkey to perform ECDH, but neither ECDH nor ECDSA have been designed to do this. *Usually* these things are okay, but they create plenty of headaches in theory, and maybe a careful API should, at least, ask its users to convert their keys explicitly. The only real separation we currently have is that for Schnorr sigs but this is because they use x-only keys.\n\nBut even if we try to be in line with the existing code base, a label is indeed a bit far from a pubkey, or even a key: there is not even a corresponding secret key (or secret label). Sure, the underlying group element has some discrete logarithm, but what I want to say is that it doesn't have a meaning in the API of the scheme. ",
      "created_at": "2025-12-11T13:11:07Z",
      "updated_at": "2025-12-11T13:11:26Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2610534331",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2610534331"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 148,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2612705197",
      "pull_request_review_id": 3570057092,
      "id": 2612705197,
      "node_id": "PRRC_kwDOAP4Jqs6buret",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593243357,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> > I wonder if we could even just set the type of `n_recipients` to uint32_t instead of size_t, so the limit is already enforced at compile-time? IIRC there were some previous discussions between @josibake and @jonasnick about that topic (in take 3 or 2 of this PR), will look those up next week before changing.\r\n> \r\n> I can't remember these discussions, but using `uint32_t` is the most natural thing to do. And then we should update the BIP to make that clear in the spec.\r\n\r\nFwiw the previous discussion I had in mind started here: https://github.com/bitcoin-core/secp256k1/pull/1698#discussion_r2381448515 (see enumeration point 3. specifically). Seems that limiting `n_recipients` to unsigned 32 bit values via `ARG_CHECK`ing was proposed (same as https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2593243357 above), but doing it by changing its type wasn't considered yet. I agree that the BIP should state the limit for clarity and to avoid being out-of-spec, will take a look into that.",
      "created_at": "2025-12-12T02:43:58Z",
      "updated_at": "2025-12-12T02:43:59Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2612705197",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2612705197"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2612739996",
      "pull_request_review_id": 3570093009,
      "id": 2612739996,
      "node_id": "PRRC_kwDOAP4Jqs6buz-c",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Glad that there is support for this idea. One potentially drawback I only notice now is that finding the output pointer is done via a loop over `n_recipients`, which might come with a performance loss for a larger numbers of recipients, as the nested loops run in $O(n^2)$ time. Maybe that can be avoided as well somehow?",
      "created_at": "2025-12-12T02:56:39Z",
      "updated_at": "2025-12-12T02:56:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2612739996",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2612739996"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2613301592",
      "pull_request_review_id": 3570755264,
      "id": 2613301592,
      "node_id": "PRRC_kwDOAP4Jqs6bw9FY",
      "diff_hunk": "@@ -25,6 +26,106 @@ extern \"C\" {\n  *  any further elliptic-curve operations from the wallet.\n  */\n \n+\n+/** The data from a single recipient address\n+ *\n+ *  This struct serves as an input argument to `silentpayments_sender_create_outputs`.\n+ *\n+ *  `index` must be set to the position (starting with 0) of this recipient in the\n+ *  `recipients` array passed to `silentpayments_sender_create_outputs`. It is\n+ *  used to map the returned generated outputs back to the original recipient.\n+ *\n+ *  Note:\n+ *  The spend public key named `spend_pubkey` may have been optionally tweaked with\n+ *  a label by the recipient. Whether `spend_pubkey` has actually been tagged with\n+ *  a label is irrelevant for the sender. As a documentation convention in this API,\n+ *  `unlabeled_spend_pubkey` is used to indicate when the unlabeled spend public must\n+ *  be used.\n+ */\n+typedef struct secp256k1_silentpayments_recipient {\n+    secp256k1_pubkey scan_pubkey;\n+    secp256k1_pubkey spend_pubkey;\n+    size_t index;",
      "path": "include/secp256k1_silentpayments.h",
      "position": 1,
      "original_position": 31,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593365138,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Oh, indeed. I don't think it can be avoided (but I'm happy to be proven wrong).\r\n\r\nHm, then my current feeling is that we should keep what we have. Avoiding a bit of (harmless!) API inconvenience at the cost of a bit of added internal complexity seems to be a reasonable tradeoff with users in mind. But doing it at the cost of increasing the complexity seems wrong. \r\n\r\nedit: Still curious to hear what the others think. ",
      "created_at": "2025-12-12T08:02:15Z",
      "updated_at": "2025-12-12T08:02:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2613301592",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2613301592"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 48,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2615128619",
      "pull_request_review_id": 3573012406,
      "id": 2615128619,
      "node_id": "PRRC_kwDOAP4Jqs6b37Ir",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* Secret keys used for taproot outputs have to be negated if they result in an odd point. This is to ensure\n+     * the sender and recipient can arrive at the same shared secret when using x-only public keys. */\n+    for (i = 0; i < n_taproot_seckeys; i++) {\n+        secp256k1_ge addend_point;\n+        ret = secp256k1_keypair_load(ctx, &addend, &addend_point, taproot_seckeys[i]);\n+        secp256k1_declassify(ctx, &ret, sizeof(ret));\n+        if (!ret) {\n+            secp256k1_scalar_clear(&addend);\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            return 0;\n+        }\n+        if (secp256k1_fe_is_odd(&addend_point.y)) {\n+            secp256k1_scalar_negate(&addend, &addend);\n+        }\n+        secp256k1_scalar_add(&seckey_sum_scalar, &seckey_sum_scalar, &addend);\n+    }\n+    /* If there are any failures in loading/summing up the secret keys, fail early. */\n+    sum_is_zero = secp256k1_scalar_is_zero(&seckey_sum_scalar);\n+    secp256k1_declassify(ctx, &sum_is_zero, sizeof(sum_is_zero));\n+    secp256k1_scalar_clear(&addend);\n+    if (sum_is_zero) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &prevouts_pubkey_sum_gej, &seckey_sum_scalar);\n+    secp256k1_ge_set_gej(&prevouts_pubkey_sum_ge, &prevouts_pubkey_sum_gej);\n+    /* We declassify the pubkey sum because serializing a group element (done in the\n+     * `_calculate_input_hash_scalar` call following) is not a constant-time operation.\n+     */\n+    secp256k1_declassify(ctx, &prevouts_pubkey_sum_ge, sizeof(prevouts_pubkey_sum_ge));\n+\n+    /* Calculate the input_hash and convert it to a scalar so that it can be multiplied with the summed up private keys, i.e., a_sum = a_sum * input_hash.\n+     * By multiplying the scalars together first, we can save an elliptic curve multiplication.\n+     *\n+     * Note: _input_hash_scalar can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_calculate_input_hash_scalar(&input_hash_scalar, outpoint_smallest36, &prevouts_pubkey_sum_ge)) {\n+        secp256k1_scalar_clear(&seckey_sum_scalar);\n+        return 0;\n+    }\n+    secp256k1_scalar_mul(&seckey_sum_scalar, &seckey_sum_scalar, &input_hash_scalar);\n+    /* _recipient_sort sorts the array of recipients in place by their scan public keys (lexicographically).\n+     * This ensures that all recipients with the same scan public key are grouped together, as specified in BIP0352.\n+     *\n+     * More specifically, this ensures `k` is incremented from 0 to the number of requested outputs for each recipient group,\n+     * where a recipient group is all addresses with the same scan public key.\n+     */\n+    secp256k1_silentpayments_recipient_sort(ctx, recipients, n_recipients);\n+    current_scan_pubkey = recipients[0]->scan_pubkey;\n+    k = 0;  /* This is a dead store but clang will emit a false positive warning if we omit it. */\n+    for (i = 0; i < n_recipients; i++) {\n+        if ((i == 0) || (secp256k1_ec_pubkey_cmp(ctx, &current_scan_pubkey, &recipients[i]->scan_pubkey) != 0)) {\n+            /* If we are on a different scan pubkey, its time to recreate the shared secret and reset k to 0.\n+             * It's very unlikely the scan public key is invalid by this point, since this means the caller would\n+             * have created the _silentpayments_recipient object incorrectly, but just to be sure we still check that\n+             * the public key is valid.\n+             */\n+            secp256k1_ge pk;\n+            if (!secp256k1_pubkey_load(ctx, &pk, &recipients[i]->scan_pubkey)) {\n+                secp256k1_scalar_clear(&seckey_sum_scalar);\n+                /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+                secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+                return 0;\n+            }\n+            secp256k1_silentpayments_create_shared_secret(ctx, shared_secret, &pk, &seckey_sum_scalar);\n+            k = 0;\n+        }\n+        if (!secp256k1_silentpayments_create_output_pubkey(ctx, generated_outputs[recipients[i]->index], shared_secret, &recipients[i]->spend_pubkey, k)) {\n+            secp256k1_scalar_clear(&seckey_sum_scalar);\n+            secp256k1_memclear_explicit(&shared_secret, sizeof(shared_secret));\n+            return 0;\n+        }\n+        /* BIP0352 specifies that k is serialized as a 4 byte (32 bit) value, so we check to make\n+         * sure we are not exceeding the max value for a uint32 before incrementing k.\n+         * In practice, this should never happen as it would be impossible to create a transaction\n+         * with this many outputs.\n+         */\n+        if (k < UINT32_MAX) {\n+            k++;\n+        } else {\n+            return 0;\n+        }",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 1,
      "original_position": 307,
      "commit_id": "f96f41f24f8a43384e57a04d1cb73798c579b59a",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2593243357,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Opened https://github.com/bitcoin/bips/pull/2055.",
      "created_at": "2025-12-12T18:04:09Z",
      "updated_at": "2025-12-12T18:04:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2615128619",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2615128619"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": 302,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 311,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2615901474",
      "pull_request_review_id": 3573971859,
      "id": 2615901474,
      "node_id": "PRRC_kwDOAP4Jqs6b630i",
      "diff_hunk": "@@ -7,10 +7,313 @@\n #define SECP256K1_MODULE_SILENTPAYMENTS_MAIN_H\n \n #include \"../../../include/secp256k1.h\"\n+#include \"../../../include/secp256k1_extrakeys.h\"\n #include \"../../../include/secp256k1_silentpayments.h\"\n \n-/* TODO: implement functions for sender side. */\n+#include \"../../eckey.h\"\n+#include \"../../ecmult.h\"\n+#include \"../../ecmult_const.h\"\n+#include \"../../ecmult_gen.h\"\n+#include \"../../group.h\"\n+#include \"../../hash.h\"\n+#include \"../../hsort.h\"\n \n-/* TODO: implement functions for receiver side. */\n+/** Sort an array of Silent Payments recipients. This is used to group recipients by scan pubkey to\n+ *  ensure the correct values of k are used when creating multiple outputs for a recipient.\n+ *\n+ *  Note: secp256k1_silentpayments_recipient_sort uses heap sort, which is unstable.\n+ *  Developers cannot and should not rely on deterministic sorting of _recipient objects.\n+ */\n+static int secp256k1_silentpayments_recipient_sort_cmp(const void* pk1, const void* pk2, void *ctx) {\n+    return secp256k1_ec_pubkey_cmp((secp256k1_context *)ctx,\n+        &(*(const secp256k1_silentpayments_recipient **)pk1)->scan_pubkey,\n+        &(*(const secp256k1_silentpayments_recipient **)pk2)->scan_pubkey\n+    );\n+}\n+\n+static void secp256k1_silentpayments_recipient_sort(const secp256k1_context* ctx, const secp256k1_silentpayments_recipient **recipients, size_t n_recipients) {\n+    /* Suppress wrong warning (fixed in MSVC 19.33) */\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(push)\n+    #pragma warning(disable: 4090)\n+    #endif\n+\n+    secp256k1_hsort(recipients, n_recipients, sizeof(*recipients), secp256k1_silentpayments_recipient_sort_cmp, (void *)ctx);\n+\n+    #if defined(_MSC_VER) && (_MSC_VER < 1933)\n+    #pragma warning(pop)\n+    #endif\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/Inputs\". */\n+static void secp256k1_silentpayments_sha256_init_inputs(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0xd4143ffcul;\n+    hash->s[1] = 0x012ea4b5ul;\n+    hash->s[2] = 0x36e21c8ful;\n+    hash->s[3] = 0xf7ec7b54ul;\n+    hash->s[4] = 0x4dd4e2acul;\n+    hash->s[5] = 0x9bcaa0a4ul;\n+    hash->s[6] = 0xe244899bul;\n+    hash->s[7] = 0xcd06903eul;\n+\n+    hash->bytes = 64;\n+}\n+\n+/** Callers must ensure that pubkey_sum is not the point at infinity before calling this function. */\n+static int secp256k1_silentpayments_calculate_input_hash_scalar(secp256k1_scalar *input_hash_scalar, const unsigned char *outpoint_smallest36, secp256k1_ge *pubkey_sum) {\n+    secp256k1_sha256 hash;\n+    unsigned char pubkey_sum_ser[33];\n+    unsigned char input_hash[32];\n+    int overflow;\n+\n+    secp256k1_silentpayments_sha256_init_inputs(&hash);\n+    secp256k1_sha256_write(&hash, outpoint_smallest36, 36);\n+    secp256k1_eckey_pubkey_serialize33(pubkey_sum, pubkey_sum_ser);\n+    secp256k1_sha256_write(&hash, pubkey_sum_ser, sizeof(pubkey_sum_ser));\n+    secp256k1_sha256_finalize(&hash, input_hash);\n+    /* Convert input_hash to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero or greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(input_hash_scalar, input_hash, &overflow);\n+    return (!secp256k1_scalar_is_zero(input_hash_scalar)) & (!overflow);\n+}\n+\n+static void secp256k1_silentpayments_create_shared_secret(const secp256k1_context *ctx, unsigned char *shared_secret33, const secp256k1_ge *public_component, const secp256k1_scalar *secret_component) {\n+    secp256k1_gej ss_j;\n+    secp256k1_ge ss;\n+\n+    secp256k1_ecmult_const(&ss_j, public_component, secret_component);\n+    secp256k1_ge_set_gej(&ss, &ss_j);\n+    /* We declassify the shared secret group element because serializing a group element is a non-constant time operation. */\n+    secp256k1_declassify(ctx, &ss, sizeof(ss));\n+    /* This can only fail if the shared secret is the point at infinity, which should be\n+     * impossible at this point considering we have already validated the public key and\n+     * the secret key.\n+     */\n+    secp256k1_eckey_pubkey_serialize33(&ss, shared_secret33);\n+\n+    /* Leaking these values would break indistinguishability of the transaction, so clear them. */\n+    secp256k1_ge_clear(&ss);\n+    secp256k1_gej_clear(&ss_j);\n+}\n+\n+/** Set hash state to the BIP340 tagged hash midstate for \"BIP0352/SharedSecret\". */\n+static void secp256k1_silentpayments_sha256_init_sharedsecret(secp256k1_sha256* hash) {\n+    secp256k1_sha256_initialize(hash);\n+    hash->s[0] = 0x88831537ul;\n+    hash->s[1] = 0x5127079bul;\n+    hash->s[2] = 0x69c2137bul;\n+    hash->s[3] = 0xab0303e6ul;\n+    hash->s[4] = 0x98fa21faul;\n+    hash->s[5] = 0x4a888523ul;\n+    hash->s[6] = 0xbd99daabul;\n+    hash->s[7] = 0xf25e5e0aul;\n+\n+    hash->bytes = 64;\n+}\n+\n+static int secp256k1_silentpayments_create_output_tweak(secp256k1_scalar *output_tweak_scalar, const unsigned char *shared_secret33, uint32_t k) {\n+    secp256k1_sha256 hash;\n+    unsigned char hash_ser[32];\n+    unsigned char k_serialized[4];\n+    int ret, overflow;\n+\n+    /* Compute hash(shared_secret || ser_32(k))  [sha256 with tag \"BIP0352/SharedSecret\"] */\n+    secp256k1_silentpayments_sha256_init_sharedsecret(&hash);\n+    secp256k1_sha256_write(&hash, shared_secret33, 33);\n+    secp256k1_write_be32(k_serialized, k);\n+    secp256k1_sha256_write(&hash, k_serialized, sizeof(k_serialized));\n+    secp256k1_sha256_finalize(&hash, hash_ser);\n+    /* Convert output_tweak to a scalar.\n+     *\n+     * This can only fail if the output of the hash function is zero greater than or equal to the curve order, which\n+     * happens with negligible probability. Normally, we would use VERIFY_CHECK as opposed to returning an error\n+     * since returning an error here would result in an untestable branch in the code. But in this case, we return\n+     * an error to ensure strict compliance with BIP0352.\n+     */\n+    secp256k1_scalar_set_b32(output_tweak_scalar, hash_ser, &overflow);\n+    ret = !secp256k1_scalar_is_zero(output_tweak_scalar);\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_memclear_explicit(hash_ser, sizeof(hash_ser));\n+    secp256k1_sha256_clear(&hash);\n+    return ret & !overflow;\n+}\n+\n+static int secp256k1_silentpayments_create_output_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *output_xonly, const unsigned char *shared_secret33, const secp256k1_pubkey *spend_pubkey, uint32_t k) {\n+    secp256k1_ge output_ge;\n+    secp256k1_scalar output_tweak_scalar;\n+    /* Calculate the output_tweak and convert it to a scalar.\n+     *\n+     * Note: _create_output_tweak can only fail if the output of the hash function is greater than or equal to the curve order, which is statistically improbable.\n+     * Returning an error here results in an untestable branch in the code, but we do this anyways to ensure strict compliance with BIP0352.\n+     */\n+    if (!secp256k1_silentpayments_create_output_tweak(&output_tweak_scalar, shared_secret33, k)) {\n+        return 0;\n+    }\n+    if (!secp256k1_pubkey_load(ctx, &output_ge, spend_pubkey)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    }\n+    /* `tweak_add` only fails if output_tweak_scalar*G = -spend_pubkey. Considering output_tweak is the output of a hash function,\n+     * this will happen only with negligible probability for honestly created spend_pubkey, but we handle this\n+     * error anyway to protect against this function being called with a malicious inputs, i.e., spend_pubkey = -(_create_output_tweak(shared_secret33, k))*G\n+     */\n+    if (!secp256k1_eckey_pubkey_tweak_add(&output_ge, &output_tweak_scalar)) {\n+        secp256k1_scalar_clear(&output_tweak_scalar);\n+        return 0;\n+    };\n+    secp256k1_xonly_pubkey_save(output_xonly, &output_ge);\n+\n+    /* Leaking this value would break indistinguishability of the transaction, so clear it. */\n+    secp256k1_scalar_clear(&output_tweak_scalar);\n+    return 1;\n+}\n+\n+int secp256k1_silentpayments_sender_create_outputs(\n+    const secp256k1_context *ctx,\n+    secp256k1_xonly_pubkey **generated_outputs,\n+    const secp256k1_silentpayments_recipient **recipients,\n+    size_t n_recipients,\n+    const unsigned char *outpoint_smallest36,\n+    const secp256k1_keypair * const *taproot_seckeys,\n+    size_t n_taproot_seckeys,\n+    const unsigned char * const *plain_seckeys,\n+    size_t n_plain_seckeys\n+) {\n+    size_t i, k;\n+    secp256k1_scalar seckey_sum_scalar, addend, input_hash_scalar;\n+    secp256k1_ge prevouts_pubkey_sum_ge;\n+    secp256k1_gej prevouts_pubkey_sum_gej;\n+    unsigned char shared_secret[33];\n+    secp256k1_pubkey current_scan_pubkey;\n+    int ret, sum_is_zero;\n+\n+    /* Sanity check inputs. */\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(generated_outputs != NULL);\n+    ARG_CHECK(recipients != NULL);\n+    ARG_CHECK(n_recipients > 0);\n+    ARG_CHECK(outpoint_smallest36 != NULL);\n+    ARG_CHECK((plain_seckeys != NULL) || (taproot_seckeys != NULL));\n+    if (taproot_seckeys != NULL) {\n+        ARG_CHECK(n_taproot_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_taproot_seckeys == 0);\n+    }\n+    if (plain_seckeys != NULL) {\n+        ARG_CHECK(n_plain_seckeys > 0);\n+    } else {\n+        ARG_CHECK(n_plain_seckeys == 0);\n+    }\n+    for (i = 0; i < n_recipients; i++) {\n+        ARG_CHECK(recipients[i]->index == i);\n+    }\n+\n+    seckey_sum_scalar = secp256k1_scalar_zero;\n+    for (i = 0; i < n_plain_seckeys; i++) {\n+        ret = secp256k1_scalar_set_b32_seckey(&addend, plain_seckeys[i]);",
      "path": "src/modules/silentpayments/main_impl.h",
      "position": 239,
      "original_position": 216,
      "commit_id": "96b7d904b4cddb57dd6f1f4917d06c5eeb3b0d39",
      "original_commit_id": "ffffd7ff98368b29759cd3d9933896fb9fa69b1f",
      "in_reply_to_id": 2590644412,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Introducing non-NULL checks for this PR actually paid off a lot, as they revealed two sneaky bugs:\r\n* in the code exercising the recipient test vectors (`run_silentpayments_test_vector_receive`), the `found_outputs` pointer array was set up incorrectly, as the init loop went only over the number of expected finds (`num_found_output_pubkeys`), rather than the full number of tx outputs (`num_to_scan_outputs`)\r\n* in the example, the same `tx_outputs` array of pointers is used twice for scanning (once for Bob, once for Carol); in the first call, tx outputs that have a match are marked with `NULL`, i.e. on the second call, those outputs were skipped for scanning. This went unnoticed as Carol is obviously not expected to find Bob's outputs anyway (so in some sense one could say it's not even that bad), but I would still say it's a bug and we should setup the tx outputs pointer array again before the second call.",
      "created_at": "2025-12-13T00:29:22Z",
      "updated_at": "2025-12-13T00:29:23Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1765#discussion_r2615901474",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/2615901474"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1765"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 239,
      "original_line": 239,
      "side": "RIGHT"
    }
  ]
}