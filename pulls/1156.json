{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156",
    "id": 1125001640,
    "node_id": "PR_kwDOAP4Jqs5DDimo",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/1156.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/1156.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1156",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1156/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/99bd3355994a436e25d148c68e097cca11f3c63e",
    "number": 1156,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Followups to int128_struct arithmetic",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is a follow-up to #1000:\r\n* Add randomized unit tests for int128 logic.\r\n* Add CI for the `_(u)mulh` code path (on non-ARM64 MSVC).\r\n* Add heuristic logic to enable int128_struct based arithmetic on 64-bit MSVC, or systems with pointers wider than 32 bits.\r\n* Fix signed overflow in ARM64 MSVC code.",
    "labels": [],
    "created_at": "2022-11-16T19:51:10Z",
    "updated_at": "2022-11-18T21:51:21Z",
    "closed_at": "2022-11-18T21:51:21Z",
    "mergeable_state": "unknown",
    "merged_at": "2022-11-18T21:51:21Z",
    "merge_commit_sha": "e40fd277b7a157e68576a457e2968f0adb2bbab1",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "sipa:202211_int128",
      "ref": "202211_int128",
      "sha": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 16648672,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODY3Mg==",
        "name": "secp256k1",
        "full_name": "sipa/secp256k1",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/secp256k1",
        "archive_url": "https://api.github.com/repos/sipa/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/sipa/secp256k1/events",
        "forks_url": "https://api.github.com/repos/sipa/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/sipa/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/sipa/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/sipa/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/sipa/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/sipa/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/sipa/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/sipa/secp256k1/hooks",
        "svn_url": "https://github.com/sipa/secp256k1",
        "language": "C",
        "forks_count": 20,
        "stargazers_count": 43,
        "watchers_count": 43,
        "size": 11487,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-05-31T17:42:23Z",
        "created_at": "2014-02-08T17:33:30Z",
        "updated_at": "2023-05-11T11:08:51Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "6138d73be471ece4717af8e7f419dde0a414568e",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 948,
        "stargazers_count": 1768,
        "watchers_count": 1768,
        "size": 10062,
        "default_branch": "master",
        "open_issues_count": 142,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-12T16:38:48Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2023-06-12T17:38:13Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 391,
    "deletions": 85,
    "changed_files": 6,
    "commits": 5,
    "review_comments": 20,
    "comments": 1
  },
  "events": [
    {
      "event": "reviewed",
      "id": 1183259839,
      "node_id": "PRR_kwDOAP4Jqs5Ghxy_",
      "url": null,
      "actor": null,
      "commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#pullrequestreview-1183259839",
      "submitted_at": "2022-11-16T20:09:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
    },
    {
      "event": "reviewed",
      "id": 1183248694,
      "node_id": "PRR_kwDOAP4Jqs5GhvE2",
      "url": null,
      "actor": null,
      "commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#pullrequestreview-1183248694",
      "submitted_at": "2022-11-16T20:26:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
    },
    {
      "event": "reviewed",
      "id": 1183305101,
      "node_id": "PRR_kwDOAP4Jqs5Gh82N",
      "url": null,
      "actor": null,
      "commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#pullrequestreview-1183305101",
      "submitted_at": "2022-11-16T20:46:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7827843841,
      "node_id": "HRFPE_lADOAP4Jqs5Wjps0zwAAAAHSk2sB",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7827843841",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-16T20:49:08Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKGYyYjdlODg3NjhmODZiMmZkNTA2YmU0YTg5NzBiYTZkMTQyM2QwYTU",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f2b7e88768f86b2fd506be4a8970ba6d1423d0a5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f2b7e88768f86b2fd506be4a8970ba6d1423d0a5",
      "tree": {
        "sha": "d254cd36743f713c430e8218a0487f194a9be724",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/d254cd36743f713c430e8218a0487f194a9be724"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/6138d73be471ece4717af8e7f419dde0a414568e",
          "sha": "6138d73be471ece4717af8e7f419dde0a414568e",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/6138d73be471ece4717af8e7f419dde0a414568e"
        }
      ],
      "message": "Add int128 randomized tests",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-17T14:28:30Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-14T20:42:44Z"
      },
      "sha": "f2b7e88768f86b2fd506be4a8970ba6d1423d0a5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDYzZmYwNjRkMmY3ZTY3YmI4Y2UzNDMxY2E1ZDdmOGYwNTZiYTZiYmQ",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/63ff064d2f7e67bb8ce3431ca5d7f8f056ba6bbd",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/63ff064d2f7e67bb8ce3431ca5d7f8f056ba6bbd",
      "tree": {
        "sha": "130f887065e62a426e6ffdabf8653d301ff8bddd",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/130f887065e62a426e6ffdabf8653d301ff8bddd"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/f2b7e88768f86b2fd506be4a8970ba6d1423d0a5",
          "sha": "f2b7e88768f86b2fd506be4a8970ba6d1423d0a5",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/f2b7e88768f86b2fd506be4a8970ba6d1423d0a5"
        }
      ],
      "message": "int128: Add test override for testing __(u)mulh on MSVC X64\n\nAlso add a corresponding CI job",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-17T14:28:30Z"
      },
      "author": {
        "name": "Tim Ruffing",
        "email": "crypto@timruffing.de",
        "date": "2022-11-14T22:24:12Z"
      },
      "sha": "63ff064d2f7e67bb8ce3431ca5d7f8f056ba6bbd"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDliNWY1ODlkMzBjM2E4NmRmNjg2YWFkY2RlNjNlYWE1NGVlYWZlNzE",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/9b5f589d30c3a86df686aadcde63eaa54eeafe71",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/9b5f589d30c3a86df686aadcde63eaa54eeafe71",
      "tree": {
        "sha": "3cf719ef3e167a70928c9470e419f4ffcb825f7f",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/3cf719ef3e167a70928c9470e419f4ffcb825f7f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/63ff064d2f7e67bb8ce3431ca5d7f8f056ba6bbd",
          "sha": "63ff064d2f7e67bb8ce3431ca5d7f8f056ba6bbd",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/63ff064d2f7e67bb8ce3431ca5d7f8f056ba6bbd"
        }
      ],
      "message": "Heuristically decide whether to use int128_struct",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-17T14:28:30Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-16T19:49:17Z"
      },
      "sha": "9b5f589d30c3a86df686aadcde63eaa54eeafe71"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7834491617,
      "node_id": "HRFPE_lADOAP4Jqs5Wjps0zwAAAAHS-Nrh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7834491617",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-17T14:28:39Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDNhZmNlMGFmN2MwMGViNGM1Y2E2ZDMwM2UzNmE0OGM5MWE4MDA0NTk",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "tree": {
        "sha": "22183ac01405d5072ad8b0d63e4ed2f3adc99ab5",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/22183ac01405d5072ad8b0d63e4ed2f3adc99ab5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/9b5f589d30c3a86df686aadcde63eaa54eeafe71",
          "sha": "9b5f589d30c3a86df686aadcde63eaa54eeafe71",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/9b5f589d30c3a86df686aadcde63eaa54eeafe71"
        }
      ],
      "message": "Avoid signed overflow in MSVC AMR64 secp256k1_mul128",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-17T14:44:10Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-17T14:44:10Z"
      },
      "sha": "3afce0af7c00eb4c5ca6d303e36a48c91a800459"
    },
    {
      "event": "reviewed",
      "id": 1184552555,
      "node_id": "PRR_kwDOAP4Jqs5GmtZr",
      "url": null,
      "actor": null,
      "commit_id": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "utACK 3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#pullrequestreview-1184552555",
      "submitted_at": "2022-11-17T15:35:34Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
    },
    {
      "event": "reviewed",
      "id": 1184566898,
      "node_id": "PRR_kwDOAP4Jqs5Gmw5y",
      "url": null,
      "actor": null,
      "commit_id": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#pullrequestreview-1184566898",
      "submitted_at": "2022-11-17T15:42:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
    },
    {
      "event": "reviewed",
      "id": 1184664740,
      "node_id": "PRR_kwDOAP4Jqs5GnIyk",
      "url": null,
      "actor": null,
      "commit_id": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#pullrequestreview-1184664740",
      "submitted_at": "2022-11-17T16:36:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAP4JqtoAKDk5YmQzMzU1OTk0YTQzNmUyNWQxNDhjNjhlMDk3Y2NhMTFmM2M2M2U",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/99bd3355994a436e25d148c68e097cca11f3c63e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/99bd3355994a436e25d148c68e097cca11f3c63e",
      "tree": {
        "sha": "e6f8fba60934d75826db30f7ce29dd57724d98b3",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e6f8fba60934d75826db30f7ce29dd57724d98b3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/3afce0af7c00eb4c5ca6d303e36a48c91a800459",
          "sha": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/3afce0af7c00eb4c5ca6d303e36a48c91a800459"
        }
      ],
      "message": "Make int128 overflow test use secp256k1_[ui]128_mul",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-17T17:22:29Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-11-17T17:22:29Z"
      },
      "sha": "99bd3355994a436e25d148c68e097cca11f3c63e"
    },
    {
      "event": "commented",
      "id": 1319015784,
      "node_id": "IC_kwDOAP4Jqs5OnpVo",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/1319015784",
      "actor": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-17T18:07:40Z",
      "updated_at": "2022-11-17T18:07:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "utACK 99bd335\r\n",
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#issuecomment-1319015784",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/1156"
    },
    {
      "event": "reviewed",
      "id": 1185262489,
      "node_id": "PRR_kwDOAP4Jqs5GpauZ",
      "url": null,
      "actor": null,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "utACK 99bd3355994a436e25d148c68e097cca11f3c63e",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#pullrequestreview-1185262489",
      "submitted_at": "2022-11-17T23:52:43Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
    },
    {
      "event": "reviewed",
      "id": 1186703856,
      "node_id": "PRR_kwDOAP4Jqs5Gu6nw",
      "url": null,
      "actor": null,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#pullrequestreview-1186703856",
      "submitted_at": "2022-11-18T19:59:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
    },
    {
      "event": "reviewed",
      "id": 1186793954,
      "node_id": "PRR_kwDOAP4Jqs5GvQni",
      "url": null,
      "actor": null,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "utACK 99bd3355994a436e25d148c68e097cca11f3c63e\r\n\r\nEDIT: Maybe https://github.com/bitcoin-core/secp256k1/pull/1158#issuecomment-1319363718 should be merged first?",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#pullrequestreview-1186793954",
      "submitted_at": "2022-11-18T21:04:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
    },
    {
      "event": "reviewed",
      "id": 1186848176,
      "node_id": "PRR_kwDOAP4Jqs5Gvd2w",
      "url": null,
      "actor": null,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK 99bd3355994a436e25d148c68e097cca11f3c63e tested this also on MSVC locally with the override, including all the benchmark binaries\r\n\r\n> EDIT: Maybe [#1158 (comment)](https://github.com/bitcoin-core/secp256k1/pull/1158#issuecomment-1319363718) should be merged first?\r\n\r\nI think we should be greedy and merge it now that it has enough ACKs. The other one will be rather easy to rebase.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#pullrequestreview-1186848176",
      "submitted_at": "2022-11-18T21:46:35Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
    },
    {
      "event": "merged",
      "id": 7847721111,
      "node_id": "ME_lADOAP4Jqs5Wjps0zwAAAAHTwriX",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7847721111",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "e40fd277b7a157e68576a457e2968f0adb2bbab1",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/e40fd277b7a157e68576a457e2968f0adb2bbab1",
      "created_at": "2022-11-18T21:51:21Z"
    },
    {
      "event": "closed",
      "id": 7847721130,
      "node_id": "CE_lADOAP4Jqs5Wjps0zwAAAAHTwriq",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/7847721130",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-18T21:51:21Z"
    },
    {
      "event": "referenced",
      "id": 8021364909,
      "node_id": "REFE_lADOAP4Jqs5Wjps0zwAAAAHeHFCt",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8021364909",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "9d47e7b71b2805430e8c7b43816efd225a6ccd8c",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/9d47e7b71b2805430e8c7b43816efd225a6ccd8c",
      "created_at": "2022-12-13T04:45:18Z"
    },
    {
      "event": "referenced",
      "id": 8041640159,
      "node_id": "REFE_lADOAP4Jqs5Wjps0zwAAAAHfUbDf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8041640159",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "55ffd47cc6b61177a9670ecec359370ffdcab523",
      "commit_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/commits/55ffd47cc6b61177a9670ecec359370ffdcab523",
      "created_at": "2022-12-14T21:22:09Z"
    },
    {
      "event": "referenced",
      "id": 8041673377,
      "node_id": "REFE_lADOAP4Jqs5Wjps0zwAAAAHfUjKh",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8041673377",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "967c65b158ca73da38c4c1d16628bd4b41aa2676",
      "commit_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/commits/967c65b158ca73da38c4c1d16628bd4b41aa2676",
      "created_at": "2022-12-14T21:26:54Z"
    },
    {
      "event": "referenced",
      "id": 8205538231,
      "node_id": "REFE_lADOAP4Jqs5Wjps0zwAAAAHpFpO3",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8205538231",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "78b5ddf28b94200ef730008305f4824cdabfc4fa",
      "commit_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/commits/78b5ddf28b94200ef730008305f4824cdabfc4fa",
      "created_at": "2023-01-11T21:16:52Z"
    },
    {
      "event": "referenced",
      "id": 8205565067,
      "node_id": "REFE_lADOAP4Jqs5Wjps0zwAAAAHpFvyL",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8205565067",
      "actor": {
        "login": "dhruv",
        "id": 856960,
        "node_id": "MDQ6VXNlcjg1Njk2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dhruv",
        "html_url": "https://github.com/dhruv",
        "followers_url": "https://api.github.com/users/dhruv/followers",
        "following_url": "https://api.github.com/users/dhruv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dhruv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dhruv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
        "organizations_url": "https://api.github.com/users/dhruv/orgs",
        "repos_url": "https://api.github.com/users/dhruv/repos",
        "events_url": "https://api.github.com/users/dhruv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dhruv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "215394a1d5167034556210cabc66b524dd7c270d",
      "commit_url": "https://api.github.com/repos/dhruv/bitcoin-core-ci/commits/215394a1d5167034556210cabc66b524dd7c270d",
      "created_at": "2023-01-11T21:21:01Z"
    },
    {
      "event": "referenced",
      "id": 8748930358,
      "node_id": "REFE_lADOAP4Jqs5Wjps0zwAAAAIJehU2",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/8748930358",
      "actor": {
        "login": "div72",
        "id": 60045611,
        "node_id": "MDQ6VXNlcjYwMDQ1NjEx",
        "avatar_url": "https://avatars.githubusercontent.com/u/60045611?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/div72",
        "html_url": "https://github.com/div72",
        "followers_url": "https://api.github.com/users/div72/followers",
        "following_url": "https://api.github.com/users/div72/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/div72/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/div72/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/div72/subscriptions",
        "organizations_url": "https://api.github.com/users/div72/orgs",
        "repos_url": "https://api.github.com/users/div72/repos",
        "events_url": "https://api.github.com/users/div72/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/div72/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "945b09457569a68ff338368a99234bd8473da1bf",
      "commit_url": "https://api.github.com/repos/div72/Gridcoin-Research/commits/945b09457569a68ff338368a99234bd8473da1bf",
      "created_at": "2023-03-14T22:14:03Z"
    },
    {
      "event": "referenced",
      "id": 9068914919,
      "node_id": "REFE_lADOAP4Jqs5Wjps0zwAAAAIcjKjn",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9068914919",
      "actor": {
        "login": "str4d",
        "id": 4993799,
        "node_id": "MDQ6VXNlcjQ5OTM3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4993799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/str4d",
        "html_url": "https://github.com/str4d",
        "followers_url": "https://api.github.com/users/str4d/followers",
        "following_url": "https://api.github.com/users/str4d/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/str4d/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/str4d/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/str4d/subscriptions",
        "organizations_url": "https://api.github.com/users/str4d/orgs",
        "repos_url": "https://api.github.com/users/str4d/repos",
        "events_url": "https://api.github.com/users/str4d/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/str4d/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0df7b459f686a563763f2c5add4a96d47bdbbd06",
      "commit_url": "https://api.github.com/repos/str4d/zcash/commits/0df7b459f686a563763f2c5add4a96d47bdbbd06",
      "created_at": "2023-04-21T15:40:14Z"
    },
    {
      "event": "referenced",
      "id": 9425177823,
      "node_id": "REFE_lADOAP4Jqs5Wjps0zwAAAAIxyMzf",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/9425177823",
      "actor": {
        "login": "vmta",
        "id": 23269741,
        "node_id": "MDQ6VXNlcjIzMjY5NzQx",
        "avatar_url": "https://avatars.githubusercontent.com/u/23269741?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vmta",
        "html_url": "https://github.com/vmta",
        "followers_url": "https://api.github.com/users/vmta/followers",
        "following_url": "https://api.github.com/users/vmta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vmta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vmta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vmta/subscriptions",
        "organizations_url": "https://api.github.com/users/vmta/orgs",
        "repos_url": "https://api.github.com/users/vmta/repos",
        "events_url": "https://api.github.com/users/vmta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vmta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "e1120c94a1fe2208bfe6c939b4f67f6d37ce931c",
      "commit_url": "https://api.github.com/repos/umkoin/umkoin/commits/e1120c94a1fe2208bfe6c939b4f67f6d37ce931c",
      "created_at": "2023-06-04T15:42:08Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024452084",
      "pull_request_review_id": 1183248694,
      "id": 1024452084,
      "node_id": "PRRC_kwDOAP4Jqs49D-X0",
      "diff_hunk": "@@ -230,21 +230,34 @@ static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag)\n     *r = (int)(r_masked | a_masked);\n }\n \n-/* If USE_FORCE_WIDEMUL_{INT128, INT128_STRUCT, INT64} is set, use that wide multiplication implementation.\n- * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n- */\n #if defined(USE_FORCE_WIDEMUL_INT128_STRUCT)\n+/* If USE_FORCE_WIDEMUL_INT128_STRUCT is set, use int128_struct. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_STRUCT 1\n #elif defined(USE_FORCE_WIDEMUL_INT128)\n+/* If USE_FORCE_WIDEMUL_INT128 is set, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n #elif defined(USE_FORCE_WIDEMUL_INT64)\n+/* If USE_FORCE_WIDEMUL_INT64 is set, use int64. */\n # define SECP256K1_WIDEMUL_INT64 1\n #elif defined(UINT128_MAX) || defined(__SIZEOF_INT128__)\n+/* If __int128 exists, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n+#elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_ARM64))\n+/* On 64-bit MSVC targets (x86_64 and arm64), use int128_struct\n+ * (which has special logic to implement using intrinsics on those systems). */\n+# define SECP256K1_WIDEMUL_INT128 1\n+# define SECP256K1_INT128_STRUCT 1\n+#elif UINTPTR_MAX > 0xffffffff\n+/* Systems with 64-bit pointers (and thus registers) very likely benefit from\n+ * using 64-bit based arithmetic (even if we need to fall back to 32x32->64 based\n+ * multiplication logic. */",
      "path": "src/util.h",
      "position": null,
      "original_position": 30,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n/* Systems with 64-bit pointers (and thus registers) very likely benefit from\r\n * using 64-bit based arithmetic (even if we need to fall back to 32x32->64 based\r\n * multiplication logic). */\r\n```",
      "created_at": "2022-11-16T20:00:15Z",
      "updated_at": "2022-11-16T20:26:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1024452084",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024452084"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": 254,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024455806",
      "pull_request_review_id": 1183248694,
      "id": 1024455806,
      "node_id": "PRRC_kwDOAP4Jqs49D_R-",
      "diff_hunk": "@@ -230,21 +230,34 @@ static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag)\n     *r = (int)(r_masked | a_masked);\n }\n \n-/* If USE_FORCE_WIDEMUL_{INT128, INT128_STRUCT, INT64} is set, use that wide multiplication implementation.\n- * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n- */\n #if defined(USE_FORCE_WIDEMUL_INT128_STRUCT)\n+/* If USE_FORCE_WIDEMUL_INT128_STRUCT is set, use int128_struct. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_STRUCT 1\n #elif defined(USE_FORCE_WIDEMUL_INT128)\n+/* If USE_FORCE_WIDEMUL_INT128 is set, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n #elif defined(USE_FORCE_WIDEMUL_INT64)\n+/* If USE_FORCE_WIDEMUL_INT64 is set, use int64. */\n # define SECP256K1_WIDEMUL_INT64 1\n #elif defined(UINT128_MAX) || defined(__SIZEOF_INT128__)\n+/* If __int128 exists, use int128. */",
      "path": "src/util.h",
      "position": null,
      "original_position": 19,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n/* If native 128-bit types exist, use int128. */\r\n```\r\n\r\n(because our logic will also happily use `int128_t`, not only `__int128`.)",
      "created_at": "2022-11-16T20:04:41Z",
      "updated_at": "2022-11-16T20:26:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1024455806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024455806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024459489",
      "pull_request_review_id": 1183259839,
      "id": 1024459489,
      "node_id": "PRRC_kwDOAP4Jqs49EALh",
      "diff_hunk": "@@ -37,6 +41,10 @@ static SECP256K1_INLINE int secp256k1_u128_check_bits(const secp256k1_uint128 *r\n    return (*r >> n == 0);\n }\n \n+static SECP256K1_INLINE void secp256k1_i128_load(secp256k1_int128 *r, int64_t hi, uint64_t lo) {\n+    *r = (((uint128_t)(uint64_t)hi) << 64) + lo;",
      "path": "src/int128_native_impl.h",
      "position": 16,
      "original_position": 16,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "why not `((int128_t)hi << 64) + lo`?",
      "created_at": "2022-11-16T20:09:13Z",
      "updated_at": "2022-11-16T20:09:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1024459489",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024459489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 45,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024467221",
      "pull_request_review_id": 1183270154,
      "id": 1024467221,
      "node_id": "PRRC_kwDOAP4Jqs49ECEV",
      "diff_hunk": "@@ -37,6 +41,10 @@ static SECP256K1_INLINE int secp256k1_u128_check_bits(const secp256k1_uint128 *r\n    return (*r >> n == 0);\n }\n \n+static SECP256K1_INLINE void secp256k1_i128_load(secp256k1_int128 *r, int64_t hi, uint64_t lo) {\n+    *r = (((uint128_t)(uint64_t)hi) << 64) + lo;",
      "path": "src/int128_native_impl.h",
      "position": 16,
      "original_position": 16,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "in_reply_to_id": 1024459489,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`((int128_t)hi << 64) + lo` is UB if hi is negative (left-shift of negative value is undefined).\r\n\r\n`((uint128_t)hi << 64) + lo` would work, but involves sign-extending hi, and then throwing those extension bits away.\r\n\r\n`((uint128_t)(uint64_t)hi << 64) + lo` is equivalent, but avoids the sign-extension, which I thought would be more obviously correct.",
      "created_at": "2022-11-16T20:17:00Z",
      "updated_at": "2022-11-16T20:17:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1024467221",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024467221"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 45,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024476155",
      "pull_request_review_id": 1183283103,
      "id": 1024476155,
      "node_id": "PRRC_kwDOAP4Jqs49EEP7",
      "diff_hunk": "@@ -37,6 +41,10 @@ static SECP256K1_INLINE int secp256k1_u128_check_bits(const secp256k1_uint128 *r\n    return (*r >> n == 0);\n }\n \n+static SECP256K1_INLINE void secp256k1_i128_load(secp256k1_int128 *r, int64_t hi, uint64_t lo) {\n+    *r = (((uint128_t)(uint64_t)hi) << 64) + lo;",
      "path": "src/int128_native_impl.h",
      "position": 16,
      "original_position": 16,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "in_reply_to_id": 1024459489,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Somehow I missed the fact the left-shift of negative values is UB.  In retrospect, that makes a bit of sense if you cannot count on two's complement, even if the formal definition of multiplying by 2^n still makes sense for negative numbers.",
      "created_at": "2022-11-16T20:28:01Z",
      "updated_at": "2022-11-16T20:28:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1024476155",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024476155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 45,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024491250",
      "pull_request_review_id": 1183305101,
      "id": 1024491250,
      "node_id": "PRRC_kwDOAP4Jqs49EH7y",
      "diff_hunk": "@@ -230,21 +230,34 @@ static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag)\n     *r = (int)(r_masked | a_masked);\n }\n \n-/* If USE_FORCE_WIDEMUL_{INT128, INT128_STRUCT, INT64} is set, use that wide multiplication implementation.\n- * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n- */\n #if defined(USE_FORCE_WIDEMUL_INT128_STRUCT)\n+/* If USE_FORCE_WIDEMUL_INT128_STRUCT is set, use int128_struct. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_STRUCT 1\n #elif defined(USE_FORCE_WIDEMUL_INT128)\n+/* If USE_FORCE_WIDEMUL_INT128 is set, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n #elif defined(USE_FORCE_WIDEMUL_INT64)\n+/* If USE_FORCE_WIDEMUL_INT64 is set, use int64. */\n # define SECP256K1_WIDEMUL_INT64 1\n #elif defined(UINT128_MAX) || defined(__SIZEOF_INT128__)\n+/* If __int128 exists, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n+#elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_ARM64))\n+/* On 64-bit MSVC targets (x86_64 and arm64), use int128_struct\n+ * (which has special logic to implement using intrinsics on those systems). */\n+# define SECP256K1_WIDEMUL_INT128 1\n+# define SECP256K1_INT128_STRUCT 1\n+#elif UINTPTR_MAX > 0xffffffff",
      "path": "src/util.h",
      "position": null,
      "original_position": 27,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n#elif SIZE_MAX > 0xffffffff\r\n```\r\n\r\nmaybe this is a better heuristic because `uintptr_t` is an optional type. Though even if it's not defined, your code at least won't error because then `UINTPTR_MAX` will be treated as `0` in the preprocessor`. I don't know.",
      "created_at": "2022-11-16T20:46:31Z",
      "updated_at": "2022-11-16T20:46:32Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1024491250",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024491250"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024493445",
      "pull_request_review_id": 1183308195,
      "id": 1024493445,
      "node_id": "PRRC_kwDOAP4Jqs49EIeF",
      "diff_hunk": "@@ -230,21 +230,34 @@ static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag)\n     *r = (int)(r_masked | a_masked);\n }\n \n-/* If USE_FORCE_WIDEMUL_{INT128, INT128_STRUCT, INT64} is set, use that wide multiplication implementation.\n- * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n- */\n #if defined(USE_FORCE_WIDEMUL_INT128_STRUCT)\n+/* If USE_FORCE_WIDEMUL_INT128_STRUCT is set, use int128_struct. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_STRUCT 1\n #elif defined(USE_FORCE_WIDEMUL_INT128)\n+/* If USE_FORCE_WIDEMUL_INT128 is set, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n #elif defined(USE_FORCE_WIDEMUL_INT64)\n+/* If USE_FORCE_WIDEMUL_INT64 is set, use int64. */\n # define SECP256K1_WIDEMUL_INT64 1\n #elif defined(UINT128_MAX) || defined(__SIZEOF_INT128__)\n+/* If __int128 exists, use int128. */",
      "path": "src/util.h",
      "position": null,
      "original_position": 19,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "in_reply_to_id": 1024455806,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2022-11-16T20:49:09Z",
      "updated_at": "2022-11-16T20:49:10Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1024493445",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024493445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024493511",
      "pull_request_review_id": 1183308298,
      "id": 1024493511,
      "node_id": "PRRC_kwDOAP4Jqs49EIfH",
      "diff_hunk": "@@ -230,21 +230,34 @@ static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag)\n     *r = (int)(r_masked | a_masked);\n }\n \n-/* If USE_FORCE_WIDEMUL_{INT128, INT128_STRUCT, INT64} is set, use that wide multiplication implementation.\n- * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n- */\n #if defined(USE_FORCE_WIDEMUL_INT128_STRUCT)\n+/* If USE_FORCE_WIDEMUL_INT128_STRUCT is set, use int128_struct. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_STRUCT 1\n #elif defined(USE_FORCE_WIDEMUL_INT128)\n+/* If USE_FORCE_WIDEMUL_INT128 is set, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n #elif defined(USE_FORCE_WIDEMUL_INT64)\n+/* If USE_FORCE_WIDEMUL_INT64 is set, use int64. */\n # define SECP256K1_WIDEMUL_INT64 1\n #elif defined(UINT128_MAX) || defined(__SIZEOF_INT128__)\n+/* If __int128 exists, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n+#elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_ARM64))\n+/* On 64-bit MSVC targets (x86_64 and arm64), use int128_struct\n+ * (which has special logic to implement using intrinsics on those systems). */\n+# define SECP256K1_WIDEMUL_INT128 1\n+# define SECP256K1_INT128_STRUCT 1\n+#elif UINTPTR_MAX > 0xffffffff",
      "path": "src/util.h",
      "position": null,
      "original_position": 27,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "in_reply_to_id": 1024491250,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2022-11-16T20:49:14Z",
      "updated_at": "2022-11-16T20:49:14Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1024493511",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024493511"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 253,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024493612",
      "pull_request_review_id": 1183308424,
      "id": 1024493612,
      "node_id": "PRRC_kwDOAP4Jqs49EIgs",
      "diff_hunk": "@@ -230,21 +230,34 @@ static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag)\n     *r = (int)(r_masked | a_masked);\n }\n \n-/* If USE_FORCE_WIDEMUL_{INT128, INT128_STRUCT, INT64} is set, use that wide multiplication implementation.\n- * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n- */\n #if defined(USE_FORCE_WIDEMUL_INT128_STRUCT)\n+/* If USE_FORCE_WIDEMUL_INT128_STRUCT is set, use int128_struct. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_STRUCT 1\n #elif defined(USE_FORCE_WIDEMUL_INT128)\n+/* If USE_FORCE_WIDEMUL_INT128 is set, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n #elif defined(USE_FORCE_WIDEMUL_INT64)\n+/* If USE_FORCE_WIDEMUL_INT64 is set, use int64. */\n # define SECP256K1_WIDEMUL_INT64 1\n #elif defined(UINT128_MAX) || defined(__SIZEOF_INT128__)\n+/* If __int128 exists, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n+#elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_ARM64))\n+/* On 64-bit MSVC targets (x86_64 and arm64), use int128_struct\n+ * (which has special logic to implement using intrinsics on those systems). */\n+# define SECP256K1_WIDEMUL_INT128 1\n+# define SECP256K1_INT128_STRUCT 1\n+#elif UINTPTR_MAX > 0xffffffff\n+/* Systems with 64-bit pointers (and thus registers) very likely benefit from\n+ * using 64-bit based arithmetic (even if we need to fall back to 32x32->64 based\n+ * multiplication logic. */",
      "path": "src/util.h",
      "position": null,
      "original_position": 30,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "5b753e4830ce181ad3064c92485e841c1b5be48c",
      "in_reply_to_id": 1024452084,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2022-11-16T20:49:21Z",
      "updated_at": "2022-11-16T20:49:21Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1024493612",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1024493612"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": 254,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025363268",
      "pull_request_review_id": 1184566898,
      "id": 1025363268,
      "node_id": "PRRC_kwDOAP4Jqs49Hc1E",
      "diff_hunk": "@@ -1752,8 +1715,308 @@ void run_modinv_tests(void) {\n     }\n }\n \n-/***** SCALAR TESTS *****/\n+/***** INT128 TESTS *****/\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Add two 256-bit numbers (represented as 16 uint16_t's in LE order) together mod 2^256. */\n+void add256(uint16_t* out, const uint16_t* a, const uint16_t* b) {\n+    int i;\n+    uint32_t carry = 0;\n+    for (i = 0; i < 16; ++i) {\n+        carry += a[i];\n+        carry += b[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Negate a 256-bit number (represented as 16 uint16_t's in LE order) mod 2^256. */\n+void neg256(uint16_t* out, const uint16_t* a) {\n+    int i;\n+    uint32_t carry = 1;\n+    for (i = 0; i < 16; ++i) {\n+        carry += (uint16_t)~a[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Right-shift a 256-bit number (represented as 16 uint16_t's in LE order). */\n+void rshift256(uint16_t* out, const uint16_t* a, int n, int sign_extend) {\n+    uint16_t sign = sign_extend && (a[15] >> 15);\n+    int i, j;\n+    for (i = 15; i >= 0; --i) {\n+        uint16_t v = 0;\n+        for (j = 0; j < 16; ++j) {\n+            int frompos = i*16 + j + n;\n+            if (frompos >= 256) {\n+                v |= sign << j;\n+            } else {\n+                v |= ((uint16_t)((a[frompos >> 4] >> (frompos & 15)) & 1)) << j;\n+            }\n+        }\n+        out[i] = v;\n+    }\n+}\n+\n+/* Load a 64-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256u64(uint16_t* out, uint64_t v, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (v >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = v >> (16 * i);\n+    }\n+    for (i = 4; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Load a 128-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256two64(uint16_t* out, uint64_t hi, uint64_t lo, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (hi >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = lo >> (16 * i);\n+    }\n+    for (i = 4; i < 8; ++i) {\n+        out[i] = hi >> (16 * (i - 4));\n+    }\n+    for (i = 8; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Check whether the 256-bit value represented by array of 16-bit values is in range -2^127 < v < 2^127. */\n+int int256is127(const uint16_t* v) {\n+    int all_0 = ((v[7] & 0x8000) == 0), all_1 = ((v[7] & 0x8000) == 0x8000);\n+    int i;\n+    for (i = 8; i < 16; ++i) {\n+        if (v[i] != 0) all_0 = 0;\n+        if (v[i] != 0xffff) all_1 = 0;\n+    }\n+    return all_0 || all_1;\n+}\n+\n+void load256u128(uint16_t* out, const secp256k1_uint128* v) {\n+    uint64_t lo = secp256k1_u128_to_u64(v), hi = secp256k1_u128_hi_u64(v);\n+    load256two64(out, hi, lo, 0);\n+}\n+\n+void load256i128(uint16_t* out, const secp256k1_int128* v) {\n+    uint64_t lo;\n+    int64_t hi;\n+    secp256k1_int128 c = *v;\n+    lo = secp256k1_i128_to_i64(&c);\n+    secp256k1_i128_rshift(&c, 64);\n+    hi = secp256k1_i128_to_i64(&c);\n+    load256two64(out, hi, lo, 1);\n+}\n \n+void run_int128_test_case(void) {\n+    unsigned char buf[32];\n+    uint64_t v[4];\n+    secp256k1_int128 swa, swz;\n+    secp256k1_uint128 uwa, uwz;\n+    uint64_t ub, uc;\n+    int64_t sb, sc;\n+    uint16_t rswa[16], rswz[32], rswr[32], ruwa[16], ruwz[32], ruwr[32];\n+    uint16_t rub[16], ruc[16], rsb[16], rsc[16];\n+    int i;\n+\n+    /* Generate 32-byte random value. */\n+    secp256k1_testrand256_test(buf);\n+    /* Convert into 4 64-bit integers. */\n+    for (i = 0; i < 4; ++i) {\n+        uint64_t vi = 0;\n+        int j;\n+        for (j = 0; j < 8; ++j) vi = (vi << 8) + buf[8*i + j];\n+        v[i] = vi;\n+    }\n+    /* Convert those into a 128-bit value and two 64-bit values (signed and unsigned). */\n+    secp256k1_u128_load(&uwa, v[1], v[0]);\n+    secp256k1_i128_load(&swa, v[1], v[0]);\n+    ub = v[2];\n+    sb = v[2];\n+    uc = v[3];\n+    sc = v[3];\n+    /* Load those also into 16-bit array representations. */\n+    load256u128(ruwa, &uwa);\n+    load256i128(rswa, &swa);\n+    load256u64(rub, ub, 0);\n+    load256u64(rsb, sb, 1);\n+    load256u64(ruc, uc, 0);\n+    load256u64(rsc, sc, 1);\n+    /* test secp256k1_u128_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    secp256k1_u128_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    add256(ruwr, ruwr, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_u64 */\n+    add256(ruwr, rub, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_rshift */\n+    rshift256(ruwr, ruwa, uc % 128, 0);\n+    uwz = uwa;\n+    secp256k1_u128_rshift(&uwz, uc % 128);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_to_u64 */\n+    CHECK(secp256k1_u128_to_u64(&uwa) == v[0]);\n+    /* test secp256k1_u128_hi_u64 */\n+    CHECK(secp256k1_u128_hi_u64(&uwa) == v[1]);\n+    /* test secp256k1_u128_from_u64 */\n+    secp256k1_u128_from_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(rub, ruwz, 16) == 0);\n+    /* test secp256k1_u128_check_bits */\n+    {\n+        int uwa_bits = 0;\n+        int j;\n+        for (j = 0; j < 128; ++j) {\n+            if (ruwa[j / 16] >> (j % 16)) uwa_bits = 1 + j;\n+        }\n+        for (j = 0; j < 128; ++j) {\n+            CHECK(secp256k1_u128_check_bits(&uwa, j) == (uwa_bits <= j));\n+        }\n+    }\n+    /* test secp256k1_i128_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    secp256k1_i128_mul(&swz, sb, sc);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_accum_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    add256(rswr, rswr, rswa);\n+    if (int256is127(rswr)) {\n+        swz = swa;\n+        secp256k1_i128_accum_mul(&swz, sb, sc);\n+        load256i128(rswz, &swz);\n+        CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    }\n+    /* test secp256k1_i128_det */\n+    {\n+        uint16_t rsd[16], rse[16], rst[32];\n+        int64_t sd = v[0], se = v[1];\n+        load256u64(rsd, sd, 1);\n+        load256u64(rse, se, 1);\n+        mulmod256(rst, rsc, rsd, NULL);\n+        neg256(rst, rst);\n+        mulmod256(rswr, rsb, rse, NULL);\n+        add256(rswr, rswr, rst);\n+        secp256k1_i128_det(&swz, sb, sc, sd, se);\n+        load256i128(rswz, &swz);\n+        CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    }\n+    /* test secp256k1_i128_rshift */\n+    rshift256(rswr, rswa, uc % 127, 1);\n+    swz = swa;\n+    secp256k1_i128_rshift(&swz, uc % 127);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_to_i64 */\n+    CHECK((uint64_t)secp256k1_i128_to_i64(&swa) == v[0]);\n+    /* test secp256k1_i128_from_i64 */\n+    secp256k1_i128_from_i64(&swz, sb);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rsb, rswz, 16) == 0);\n+    /* test secp256k1_i128_eq_var */\n+    {\n+        int expect = (uc & 1);\n+        swz = swa;\n+        if (!expect) {\n+            /* Make sure swz != swa */\n+            uint64_t v0c = v[0], v1c = v[1];\n+            if (ub & 64) {\n+                v1c ^= (((uint64_t)1) << (ub & 63));\n+            } else {\n+                v0c ^= (((uint64_t)1) << (ub & 63));\n+            }\n+            secp256k1_i128_load(&swz, v1c, v0c);\n+        }\n+        CHECK(secp256k1_i128_eq_var(&swa, &swz) == expect);\n+    }\n+    /* test secp256k1_i128_check_pow2 */\n+    {\n+        int expect = (uc & 1);\n+        int pos = ub % 127;\n+        if (expect) {\n+            /* If expect==1, set swz to exactly (2 << pos). */\n+            uint64_t hi = 0;\n+            uint64_t lo = 0;\n+            if (pos & 64) {\n+                hi = (((uint64_t)1) << (pos & 63));\n+            } else {\n+                lo = (((uint64_t)1) << (pos & 63));\n+            }\n+            secp256k1_i128_load(&swz, hi, lo);\n+        } else {\n+            /* If expect==0, set swz = swa, but update expect=1 if swa happens to equal (2 << pos). */\n+            if (pos & 64) {\n+                if ((v[1] == (((uint64_t)1) << (pos & 63))) && v[0] == 0) expect = 1;\n+            } else {\n+                if ((v[0] == (((uint64_t)1) << (pos & 63))) && v[1] == 0) expect = 1;\n+            }\n+            swz = swa;\n+        }\n+        CHECK(secp256k1_i128_check_pow2(&swz, pos) == expect);\n+    }\n+}\n+\n+void run_int128_tests(void) {\n+    {   /* secp256k1_u128_accum_mul */\n+        secp256k1_uint128 res;\n+\n+        /* Check secp256k1_u128_accum_mul overflow */\n+        secp256k1_u128_from_u64(&res, 0);\n+        secp256k1_u128_accum_mul(&res, UINT64_MAX, UINT64_MAX);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 407,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": " maybe just `secp256k1_u128_mul(&res, UINT64_MAX, UINT64_MAX);` without the `secp256k1_u128_from_u64`?\r\nAnd similarly below.\r\n",
      "created_at": "2022-11-17T15:42:46Z",
      "updated_at": "2022-11-17T15:43:13Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1025363268",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025363268"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1981,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025369588",
      "pull_request_review_id": 1184575804,
      "id": 1025369588,
      "node_id": "PRRC_kwDOAP4Jqs49HeX0",
      "diff_hunk": "@@ -1752,8 +1715,308 @@ void run_modinv_tests(void) {\n     }\n }\n \n-/***** SCALAR TESTS *****/\n+/***** INT128 TESTS *****/\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Add two 256-bit numbers (represented as 16 uint16_t's in LE order) together mod 2^256. */\n+void add256(uint16_t* out, const uint16_t* a, const uint16_t* b) {\n+    int i;\n+    uint32_t carry = 0;\n+    for (i = 0; i < 16; ++i) {\n+        carry += a[i];\n+        carry += b[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Negate a 256-bit number (represented as 16 uint16_t's in LE order) mod 2^256. */\n+void neg256(uint16_t* out, const uint16_t* a) {\n+    int i;\n+    uint32_t carry = 1;\n+    for (i = 0; i < 16; ++i) {\n+        carry += (uint16_t)~a[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Right-shift a 256-bit number (represented as 16 uint16_t's in LE order). */\n+void rshift256(uint16_t* out, const uint16_t* a, int n, int sign_extend) {\n+    uint16_t sign = sign_extend && (a[15] >> 15);\n+    int i, j;\n+    for (i = 15; i >= 0; --i) {\n+        uint16_t v = 0;\n+        for (j = 0; j < 16; ++j) {\n+            int frompos = i*16 + j + n;\n+            if (frompos >= 256) {\n+                v |= sign << j;\n+            } else {\n+                v |= ((uint16_t)((a[frompos >> 4] >> (frompos & 15)) & 1)) << j;\n+            }\n+        }\n+        out[i] = v;\n+    }\n+}\n+\n+/* Load a 64-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256u64(uint16_t* out, uint64_t v, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (v >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = v >> (16 * i);\n+    }\n+    for (i = 4; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Load a 128-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256two64(uint16_t* out, uint64_t hi, uint64_t lo, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (hi >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = lo >> (16 * i);\n+    }\n+    for (i = 4; i < 8; ++i) {\n+        out[i] = hi >> (16 * (i - 4));\n+    }\n+    for (i = 8; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Check whether the 256-bit value represented by array of 16-bit values is in range -2^127 < v < 2^127. */\n+int int256is127(const uint16_t* v) {\n+    int all_0 = ((v[7] & 0x8000) == 0), all_1 = ((v[7] & 0x8000) == 0x8000);\n+    int i;\n+    for (i = 8; i < 16; ++i) {\n+        if (v[i] != 0) all_0 = 0;\n+        if (v[i] != 0xffff) all_1 = 0;\n+    }\n+    return all_0 || all_1;\n+}\n+\n+void load256u128(uint16_t* out, const secp256k1_uint128* v) {\n+    uint64_t lo = secp256k1_u128_to_u64(v), hi = secp256k1_u128_hi_u64(v);\n+    load256two64(out, hi, lo, 0);\n+}\n+\n+void load256i128(uint16_t* out, const secp256k1_int128* v) {\n+    uint64_t lo;\n+    int64_t hi;\n+    secp256k1_int128 c = *v;\n+    lo = secp256k1_i128_to_i64(&c);\n+    secp256k1_i128_rshift(&c, 64);\n+    hi = secp256k1_i128_to_i64(&c);\n+    load256two64(out, hi, lo, 1);\n+}\n \n+void run_int128_test_case(void) {\n+    unsigned char buf[32];\n+    uint64_t v[4];\n+    secp256k1_int128 swa, swz;\n+    secp256k1_uint128 uwa, uwz;\n+    uint64_t ub, uc;\n+    int64_t sb, sc;\n+    uint16_t rswa[16], rswz[32], rswr[32], ruwa[16], ruwz[32], ruwr[32];\n+    uint16_t rub[16], ruc[16], rsb[16], rsc[16];\n+    int i;\n+\n+    /* Generate 32-byte random value. */\n+    secp256k1_testrand256_test(buf);\n+    /* Convert into 4 64-bit integers. */\n+    for (i = 0; i < 4; ++i) {\n+        uint64_t vi = 0;\n+        int j;\n+        for (j = 0; j < 8; ++j) vi = (vi << 8) + buf[8*i + j];\n+        v[i] = vi;\n+    }\n+    /* Convert those into a 128-bit value and two 64-bit values (signed and unsigned). */\n+    secp256k1_u128_load(&uwa, v[1], v[0]);\n+    secp256k1_i128_load(&swa, v[1], v[0]);\n+    ub = v[2];\n+    sb = v[2];\n+    uc = v[3];\n+    sc = v[3];\n+    /* Load those also into 16-bit array representations. */\n+    load256u128(ruwa, &uwa);\n+    load256i128(rswa, &swa);\n+    load256u64(rub, ub, 0);\n+    load256u64(rsb, sb, 1);\n+    load256u64(ruc, uc, 0);\n+    load256u64(rsc, sc, 1);\n+    /* test secp256k1_u128_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    secp256k1_u128_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    add256(ruwr, ruwr, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_u64 */\n+    add256(ruwr, rub, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_rshift */\n+    rshift256(ruwr, ruwa, uc % 128, 0);\n+    uwz = uwa;\n+    secp256k1_u128_rshift(&uwz, uc % 128);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_to_u64 */\n+    CHECK(secp256k1_u128_to_u64(&uwa) == v[0]);\n+    /* test secp256k1_u128_hi_u64 */\n+    CHECK(secp256k1_u128_hi_u64(&uwa) == v[1]);\n+    /* test secp256k1_u128_from_u64 */\n+    secp256k1_u128_from_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(rub, ruwz, 16) == 0);\n+    /* test secp256k1_u128_check_bits */\n+    {\n+        int uwa_bits = 0;\n+        int j;\n+        for (j = 0; j < 128; ++j) {\n+            if (ruwa[j / 16] >> (j % 16)) uwa_bits = 1 + j;\n+        }\n+        for (j = 0; j < 128; ++j) {\n+            CHECK(secp256k1_u128_check_bits(&uwa, j) == (uwa_bits <= j));\n+        }\n+    }\n+    /* test secp256k1_i128_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    secp256k1_i128_mul(&swz, sb, sc);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_accum_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    add256(rswr, rswr, rswa);\n+    if (int256is127(rswr)) {\n+        swz = swa;\n+        secp256k1_i128_accum_mul(&swz, sb, sc);\n+        load256i128(rswz, &swz);\n+        CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    }\n+    /* test secp256k1_i128_det */\n+    {\n+        uint16_t rsd[16], rse[16], rst[32];\n+        int64_t sd = v[0], se = v[1];\n+        load256u64(rsd, sd, 1);\n+        load256u64(rse, se, 1);\n+        mulmod256(rst, rsc, rsd, NULL);\n+        neg256(rst, rst);\n+        mulmod256(rswr, rsb, rse, NULL);\n+        add256(rswr, rswr, rst);\n+        secp256k1_i128_det(&swz, sb, sc, sd, se);\n+        load256i128(rswz, &swz);\n+        CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    }\n+    /* test secp256k1_i128_rshift */\n+    rshift256(rswr, rswa, uc % 127, 1);\n+    swz = swa;\n+    secp256k1_i128_rshift(&swz, uc % 127);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_to_i64 */\n+    CHECK((uint64_t)secp256k1_i128_to_i64(&swa) == v[0]);\n+    /* test secp256k1_i128_from_i64 */\n+    secp256k1_i128_from_i64(&swz, sb);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rsb, rswz, 16) == 0);\n+    /* test secp256k1_i128_eq_var */\n+    {\n+        int expect = (uc & 1);\n+        swz = swa;\n+        if (!expect) {\n+            /* Make sure swz != swa */\n+            uint64_t v0c = v[0], v1c = v[1];\n+            if (ub & 64) {\n+                v1c ^= (((uint64_t)1) << (ub & 63));\n+            } else {\n+                v0c ^= (((uint64_t)1) << (ub & 63));\n+            }\n+            secp256k1_i128_load(&swz, v1c, v0c);\n+        }\n+        CHECK(secp256k1_i128_eq_var(&swa, &swz) == expect);\n+    }\n+    /* test secp256k1_i128_check_pow2 */\n+    {\n+        int expect = (uc & 1);\n+        int pos = ub % 127;\n+        if (expect) {\n+            /* If expect==1, set swz to exactly (2 << pos). */\n+            uint64_t hi = 0;\n+            uint64_t lo = 0;\n+            if (pos & 64) {\n+                hi = (((uint64_t)1) << (pos & 63));\n+            } else {\n+                lo = (((uint64_t)1) << (pos & 63));\n+            }\n+            secp256k1_i128_load(&swz, hi, lo);\n+        } else {\n+            /* If expect==0, set swz = swa, but update expect=1 if swa happens to equal (2 << pos). */\n+            if (pos & 64) {\n+                if ((v[1] == (((uint64_t)1) << (pos & 63))) && v[0] == 0) expect = 1;\n+            } else {\n+                if ((v[0] == (((uint64_t)1) << (pos & 63))) && v[1] == 0) expect = 1;\n+            }\n+            swz = swa;\n+        }\n+        CHECK(secp256k1_i128_check_pow2(&swz, pos) == expect);\n+    }\n+}\n+\n+void run_int128_tests(void) {\n+    {   /* secp256k1_u128_accum_mul */\n+        secp256k1_uint128 res;\n+\n+        /* Check secp256k1_u128_accum_mul overflow */\n+        secp256k1_u128_from_u64(&res, 0);\n+        secp256k1_u128_accum_mul(&res, UINT64_MAX, UINT64_MAX);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 407,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "in_reply_to_id": 1025363268,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is code that's already merged (from your PR, even!) and just being moved here. If you have nits on it, I'm happy to make small changes, but it sounds like you're suggesting to change the test from testing `secp256k1_u128_accum_mul` to `secp256k1_u128_mul` instead. Maybe that's better addressed in a separate PR to improve the tests?",
      "created_at": "2022-11-17T15:47:28Z",
      "updated_at": "2022-11-17T15:47:28Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1025369588",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025369588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1981,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025429285",
      "pull_request_review_id": 1184664740,
      "id": 1025429285,
      "node_id": "PRRC_kwDOAP4Jqs49Hs8l",
      "diff_hunk": "@@ -1752,8 +1715,308 @@ void run_modinv_tests(void) {\n     }\n }\n \n-/***** SCALAR TESTS *****/\n+/***** INT128 TESTS *****/\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Add two 256-bit numbers (represented as 16 uint16_t's in LE order) together mod 2^256. */\n+void add256(uint16_t* out, const uint16_t* a, const uint16_t* b) {\n+    int i;\n+    uint32_t carry = 0;\n+    for (i = 0; i < 16; ++i) {\n+        carry += a[i];\n+        carry += b[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Negate a 256-bit number (represented as 16 uint16_t's in LE order) mod 2^256. */\n+void neg256(uint16_t* out, const uint16_t* a) {\n+    int i;\n+    uint32_t carry = 1;\n+    for (i = 0; i < 16; ++i) {\n+        carry += (uint16_t)~a[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Right-shift a 256-bit number (represented as 16 uint16_t's in LE order). */\n+void rshift256(uint16_t* out, const uint16_t* a, int n, int sign_extend) {\n+    uint16_t sign = sign_extend && (a[15] >> 15);\n+    int i, j;\n+    for (i = 15; i >= 0; --i) {\n+        uint16_t v = 0;\n+        for (j = 0; j < 16; ++j) {\n+            int frompos = i*16 + j + n;\n+            if (frompos >= 256) {\n+                v |= sign << j;\n+            } else {\n+                v |= ((uint16_t)((a[frompos >> 4] >> (frompos & 15)) & 1)) << j;\n+            }\n+        }\n+        out[i] = v;\n+    }\n+}\n+\n+/* Load a 64-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256u64(uint16_t* out, uint64_t v, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (v >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = v >> (16 * i);\n+    }\n+    for (i = 4; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Load a 128-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256two64(uint16_t* out, uint64_t hi, uint64_t lo, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (hi >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = lo >> (16 * i);\n+    }\n+    for (i = 4; i < 8; ++i) {\n+        out[i] = hi >> (16 * (i - 4));\n+    }\n+    for (i = 8; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Check whether the 256-bit value represented by array of 16-bit values is in range -2^127 < v < 2^127. */\n+int int256is127(const uint16_t* v) {\n+    int all_0 = ((v[7] & 0x8000) == 0), all_1 = ((v[7] & 0x8000) == 0x8000);\n+    int i;\n+    for (i = 8; i < 16; ++i) {\n+        if (v[i] != 0) all_0 = 0;\n+        if (v[i] != 0xffff) all_1 = 0;\n+    }\n+    return all_0 || all_1;\n+}\n+\n+void load256u128(uint16_t* out, const secp256k1_uint128* v) {\n+    uint64_t lo = secp256k1_u128_to_u64(v), hi = secp256k1_u128_hi_u64(v);\n+    load256two64(out, hi, lo, 0);\n+}\n+\n+void load256i128(uint16_t* out, const secp256k1_int128* v) {\n+    uint64_t lo;\n+    int64_t hi;\n+    secp256k1_int128 c = *v;\n+    lo = secp256k1_i128_to_i64(&c);\n+    secp256k1_i128_rshift(&c, 64);\n+    hi = secp256k1_i128_to_i64(&c);\n+    load256two64(out, hi, lo, 1);\n+}\n \n+void run_int128_test_case(void) {\n+    unsigned char buf[32];\n+    uint64_t v[4];\n+    secp256k1_int128 swa, swz;\n+    secp256k1_uint128 uwa, uwz;\n+    uint64_t ub, uc;\n+    int64_t sb, sc;\n+    uint16_t rswa[16], rswz[32], rswr[32], ruwa[16], ruwz[32], ruwr[32];\n+    uint16_t rub[16], ruc[16], rsb[16], rsc[16];\n+    int i;\n+\n+    /* Generate 32-byte random value. */\n+    secp256k1_testrand256_test(buf);\n+    /* Convert into 4 64-bit integers. */\n+    for (i = 0; i < 4; ++i) {\n+        uint64_t vi = 0;\n+        int j;\n+        for (j = 0; j < 8; ++j) vi = (vi << 8) + buf[8*i + j];\n+        v[i] = vi;\n+    }\n+    /* Convert those into a 128-bit value and two 64-bit values (signed and unsigned). */\n+    secp256k1_u128_load(&uwa, v[1], v[0]);\n+    secp256k1_i128_load(&swa, v[1], v[0]);\n+    ub = v[2];\n+    sb = v[2];\n+    uc = v[3];\n+    sc = v[3];\n+    /* Load those also into 16-bit array representations. */\n+    load256u128(ruwa, &uwa);\n+    load256i128(rswa, &swa);\n+    load256u64(rub, ub, 0);\n+    load256u64(rsb, sb, 1);\n+    load256u64(ruc, uc, 0);\n+    load256u64(rsc, sc, 1);\n+    /* test secp256k1_u128_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    secp256k1_u128_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    add256(ruwr, ruwr, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_u64 */\n+    add256(ruwr, rub, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_rshift */\n+    rshift256(ruwr, ruwa, uc % 128, 0);\n+    uwz = uwa;\n+    secp256k1_u128_rshift(&uwz, uc % 128);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_to_u64 */\n+    CHECK(secp256k1_u128_to_u64(&uwa) == v[0]);\n+    /* test secp256k1_u128_hi_u64 */\n+    CHECK(secp256k1_u128_hi_u64(&uwa) == v[1]);\n+    /* test secp256k1_u128_from_u64 */\n+    secp256k1_u128_from_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(rub, ruwz, 16) == 0);\n+    /* test secp256k1_u128_check_bits */\n+    {\n+        int uwa_bits = 0;\n+        int j;\n+        for (j = 0; j < 128; ++j) {\n+            if (ruwa[j / 16] >> (j % 16)) uwa_bits = 1 + j;\n+        }\n+        for (j = 0; j < 128; ++j) {\n+            CHECK(secp256k1_u128_check_bits(&uwa, j) == (uwa_bits <= j));\n+        }\n+    }\n+    /* test secp256k1_i128_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    secp256k1_i128_mul(&swz, sb, sc);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_accum_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    add256(rswr, rswr, rswa);\n+    if (int256is127(rswr)) {",
      "path": "src/tests.c",
      "position": 326,
      "original_position": 326,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "in_reply_to_id": null,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "how often is this true?",
      "created_at": "2022-11-17T16:36:00Z",
      "updated_at": "2022-11-17T16:36:01Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1025429285",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025429285"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1900,
      "original_line": 1900,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025440595",
      "pull_request_review_id": 1184681398,
      "id": 1025440595,
      "node_id": "PRRC_kwDOAP4Jqs49HvtT",
      "diff_hunk": "@@ -1752,8 +1715,308 @@ void run_modinv_tests(void) {\n     }\n }\n \n-/***** SCALAR TESTS *****/\n+/***** INT128 TESTS *****/\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Add two 256-bit numbers (represented as 16 uint16_t's in LE order) together mod 2^256. */\n+void add256(uint16_t* out, const uint16_t* a, const uint16_t* b) {\n+    int i;\n+    uint32_t carry = 0;\n+    for (i = 0; i < 16; ++i) {\n+        carry += a[i];\n+        carry += b[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Negate a 256-bit number (represented as 16 uint16_t's in LE order) mod 2^256. */\n+void neg256(uint16_t* out, const uint16_t* a) {\n+    int i;\n+    uint32_t carry = 1;\n+    for (i = 0; i < 16; ++i) {\n+        carry += (uint16_t)~a[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Right-shift a 256-bit number (represented as 16 uint16_t's in LE order). */\n+void rshift256(uint16_t* out, const uint16_t* a, int n, int sign_extend) {\n+    uint16_t sign = sign_extend && (a[15] >> 15);\n+    int i, j;\n+    for (i = 15; i >= 0; --i) {\n+        uint16_t v = 0;\n+        for (j = 0; j < 16; ++j) {\n+            int frompos = i*16 + j + n;\n+            if (frompos >= 256) {\n+                v |= sign << j;\n+            } else {\n+                v |= ((uint16_t)((a[frompos >> 4] >> (frompos & 15)) & 1)) << j;\n+            }\n+        }\n+        out[i] = v;\n+    }\n+}\n+\n+/* Load a 64-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256u64(uint16_t* out, uint64_t v, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (v >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = v >> (16 * i);\n+    }\n+    for (i = 4; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Load a 128-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256two64(uint16_t* out, uint64_t hi, uint64_t lo, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (hi >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = lo >> (16 * i);\n+    }\n+    for (i = 4; i < 8; ++i) {\n+        out[i] = hi >> (16 * (i - 4));\n+    }\n+    for (i = 8; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Check whether the 256-bit value represented by array of 16-bit values is in range -2^127 < v < 2^127. */\n+int int256is127(const uint16_t* v) {\n+    int all_0 = ((v[7] & 0x8000) == 0), all_1 = ((v[7] & 0x8000) == 0x8000);\n+    int i;\n+    for (i = 8; i < 16; ++i) {\n+        if (v[i] != 0) all_0 = 0;\n+        if (v[i] != 0xffff) all_1 = 0;\n+    }\n+    return all_0 || all_1;\n+}\n+\n+void load256u128(uint16_t* out, const secp256k1_uint128* v) {\n+    uint64_t lo = secp256k1_u128_to_u64(v), hi = secp256k1_u128_hi_u64(v);\n+    load256two64(out, hi, lo, 0);\n+}\n+\n+void load256i128(uint16_t* out, const secp256k1_int128* v) {\n+    uint64_t lo;\n+    int64_t hi;\n+    secp256k1_int128 c = *v;\n+    lo = secp256k1_i128_to_i64(&c);\n+    secp256k1_i128_rshift(&c, 64);\n+    hi = secp256k1_i128_to_i64(&c);\n+    load256two64(out, hi, lo, 1);\n+}\n \n+void run_int128_test_case(void) {\n+    unsigned char buf[32];\n+    uint64_t v[4];\n+    secp256k1_int128 swa, swz;\n+    secp256k1_uint128 uwa, uwz;\n+    uint64_t ub, uc;\n+    int64_t sb, sc;\n+    uint16_t rswa[16], rswz[32], rswr[32], ruwa[16], ruwz[32], ruwr[32];\n+    uint16_t rub[16], ruc[16], rsb[16], rsc[16];\n+    int i;\n+\n+    /* Generate 32-byte random value. */\n+    secp256k1_testrand256_test(buf);\n+    /* Convert into 4 64-bit integers. */\n+    for (i = 0; i < 4; ++i) {\n+        uint64_t vi = 0;\n+        int j;\n+        for (j = 0; j < 8; ++j) vi = (vi << 8) + buf[8*i + j];\n+        v[i] = vi;\n+    }\n+    /* Convert those into a 128-bit value and two 64-bit values (signed and unsigned). */\n+    secp256k1_u128_load(&uwa, v[1], v[0]);\n+    secp256k1_i128_load(&swa, v[1], v[0]);\n+    ub = v[2];\n+    sb = v[2];\n+    uc = v[3];\n+    sc = v[3];\n+    /* Load those also into 16-bit array representations. */\n+    load256u128(ruwa, &uwa);\n+    load256i128(rswa, &swa);\n+    load256u64(rub, ub, 0);\n+    load256u64(rsb, sb, 1);\n+    load256u64(ruc, uc, 0);\n+    load256u64(rsc, sc, 1);\n+    /* test secp256k1_u128_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    secp256k1_u128_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    add256(ruwr, ruwr, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_u64 */\n+    add256(ruwr, rub, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_rshift */\n+    rshift256(ruwr, ruwa, uc % 128, 0);\n+    uwz = uwa;\n+    secp256k1_u128_rshift(&uwz, uc % 128);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_to_u64 */\n+    CHECK(secp256k1_u128_to_u64(&uwa) == v[0]);\n+    /* test secp256k1_u128_hi_u64 */\n+    CHECK(secp256k1_u128_hi_u64(&uwa) == v[1]);\n+    /* test secp256k1_u128_from_u64 */\n+    secp256k1_u128_from_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(rub, ruwz, 16) == 0);\n+    /* test secp256k1_u128_check_bits */\n+    {\n+        int uwa_bits = 0;\n+        int j;\n+        for (j = 0; j < 128; ++j) {\n+            if (ruwa[j / 16] >> (j % 16)) uwa_bits = 1 + j;\n+        }\n+        for (j = 0; j < 128; ++j) {\n+            CHECK(secp256k1_u128_check_bits(&uwa, j) == (uwa_bits <= j));\n+        }\n+    }\n+    /* test secp256k1_i128_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    secp256k1_i128_mul(&swz, sb, sc);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_accum_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    add256(rswr, rswr, rswa);\n+    if (int256is127(rswr)) {\n+        swz = swa;\n+        secp256k1_i128_accum_mul(&swz, sb, sc);\n+        load256i128(rswz, &swz);\n+        CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    }\n+    /* test secp256k1_i128_det */\n+    {\n+        uint16_t rsd[16], rse[16], rst[32];\n+        int64_t sd = v[0], se = v[1];\n+        load256u64(rsd, sd, 1);\n+        load256u64(rse, se, 1);\n+        mulmod256(rst, rsc, rsd, NULL);\n+        neg256(rst, rst);\n+        mulmod256(rswr, rsb, rse, NULL);\n+        add256(rswr, rswr, rst);\n+        secp256k1_i128_det(&swz, sb, sc, sd, se);\n+        load256i128(rswz, &swz);\n+        CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    }\n+    /* test secp256k1_i128_rshift */\n+    rshift256(rswr, rswa, uc % 127, 1);\n+    swz = swa;\n+    secp256k1_i128_rshift(&swz, uc % 127);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_to_i64 */\n+    CHECK((uint64_t)secp256k1_i128_to_i64(&swa) == v[0]);\n+    /* test secp256k1_i128_from_i64 */\n+    secp256k1_i128_from_i64(&swz, sb);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rsb, rswz, 16) == 0);\n+    /* test secp256k1_i128_eq_var */\n+    {\n+        int expect = (uc & 1);\n+        swz = swa;\n+        if (!expect) {\n+            /* Make sure swz != swa */\n+            uint64_t v0c = v[0], v1c = v[1];\n+            if (ub & 64) {\n+                v1c ^= (((uint64_t)1) << (ub & 63));\n+            } else {\n+                v0c ^= (((uint64_t)1) << (ub & 63));\n+            }\n+            secp256k1_i128_load(&swz, v1c, v0c);\n+        }\n+        CHECK(secp256k1_i128_eq_var(&swa, &swz) == expect);\n+    }\n+    /* test secp256k1_i128_check_pow2 */\n+    {\n+        int expect = (uc & 1);\n+        int pos = ub % 127;\n+        if (expect) {\n+            /* If expect==1, set swz to exactly (2 << pos). */\n+            uint64_t hi = 0;\n+            uint64_t lo = 0;\n+            if (pos & 64) {\n+                hi = (((uint64_t)1) << (pos & 63));\n+            } else {\n+                lo = (((uint64_t)1) << (pos & 63));\n+            }\n+            secp256k1_i128_load(&swz, hi, lo);\n+        } else {\n+            /* If expect==0, set swz = swa, but update expect=1 if swa happens to equal (2 << pos). */\n+            if (pos & 64) {\n+                if ((v[1] == (((uint64_t)1) << (pos & 63))) && v[0] == 0) expect = 1;\n+            } else {\n+                if ((v[0] == (((uint64_t)1) << (pos & 63))) && v[1] == 0) expect = 1;\n+            }\n+            swz = swa;\n+        }\n+        CHECK(secp256k1_i128_check_pow2(&swz, pos) == expect);\n+    }\n+}\n+\n+void run_int128_tests(void) {\n+    {   /* secp256k1_u128_accum_mul */\n+        secp256k1_uint128 res;\n+\n+        /* Check secp256k1_u128_accum_mul overflow */\n+        secp256k1_u128_from_u64(&res, 0);\n+        secp256k1_u128_accum_mul(&res, UINT64_MAX, UINT64_MAX);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 407,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "in_reply_to_id": 1025363268,
      "user": {
        "login": "roconnor-blockstream",
        "id": 21371712,
        "node_id": "MDQ6VXNlcjIxMzcxNzEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/21371712?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roconnor-blockstream",
        "html_url": "https://github.com/roconnor-blockstream",
        "followers_url": "https://api.github.com/users/roconnor-blockstream/followers",
        "following_url": "https://api.github.com/users/roconnor-blockstream/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roconnor-blockstream/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roconnor-blockstream/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roconnor-blockstream/subscriptions",
        "organizations_url": "https://api.github.com/users/roconnor-blockstream/orgs",
        "repos_url": "https://api.github.com/users/roconnor-blockstream/repos",
        "events_url": "https://api.github.com/users/roconnor-blockstream/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roconnor-blockstream/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I believe what I'm proposing is a small change. I'm proposing changing the logic from\r\n\r\n    res = 0\r\n    res += UINT64_MAX*UINT64_MAX\r\n    res += UINT64_MAX*UINT64_MAX\r\n\r\nto\r\n\r\n    res = UINT64_MAX*UINT64_MAX\r\n    res += UINT64_MAX*UINT64_MAX\r\n\r\nIt still tests accumulating multiplication overflow.\r\n\r\nBut maybe it isn't worth changing.",
      "created_at": "2022-11-17T16:45:59Z",
      "updated_at": "2022-11-17T16:46:00Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1025440595",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025440595"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1981,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025480163",
      "pull_request_review_id": 1184740158,
      "id": 1025480163,
      "node_id": "PRRC_kwDOAP4Jqs49H5Xj",
      "diff_hunk": "@@ -1752,8 +1715,308 @@ void run_modinv_tests(void) {\n     }\n }\n \n-/***** SCALAR TESTS *****/\n+/***** INT128 TESTS *****/\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Add two 256-bit numbers (represented as 16 uint16_t's in LE order) together mod 2^256. */\n+void add256(uint16_t* out, const uint16_t* a, const uint16_t* b) {\n+    int i;\n+    uint32_t carry = 0;\n+    for (i = 0; i < 16; ++i) {\n+        carry += a[i];\n+        carry += b[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Negate a 256-bit number (represented as 16 uint16_t's in LE order) mod 2^256. */\n+void neg256(uint16_t* out, const uint16_t* a) {\n+    int i;\n+    uint32_t carry = 1;\n+    for (i = 0; i < 16; ++i) {\n+        carry += (uint16_t)~a[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Right-shift a 256-bit number (represented as 16 uint16_t's in LE order). */\n+void rshift256(uint16_t* out, const uint16_t* a, int n, int sign_extend) {\n+    uint16_t sign = sign_extend && (a[15] >> 15);\n+    int i, j;\n+    for (i = 15; i >= 0; --i) {\n+        uint16_t v = 0;\n+        for (j = 0; j < 16; ++j) {\n+            int frompos = i*16 + j + n;\n+            if (frompos >= 256) {\n+                v |= sign << j;\n+            } else {\n+                v |= ((uint16_t)((a[frompos >> 4] >> (frompos & 15)) & 1)) << j;\n+            }\n+        }\n+        out[i] = v;\n+    }\n+}\n+\n+/* Load a 64-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256u64(uint16_t* out, uint64_t v, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (v >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = v >> (16 * i);\n+    }\n+    for (i = 4; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Load a 128-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256two64(uint16_t* out, uint64_t hi, uint64_t lo, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (hi >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = lo >> (16 * i);\n+    }\n+    for (i = 4; i < 8; ++i) {\n+        out[i] = hi >> (16 * (i - 4));\n+    }\n+    for (i = 8; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Check whether the 256-bit value represented by array of 16-bit values is in range -2^127 < v < 2^127. */\n+int int256is127(const uint16_t* v) {\n+    int all_0 = ((v[7] & 0x8000) == 0), all_1 = ((v[7] & 0x8000) == 0x8000);\n+    int i;\n+    for (i = 8; i < 16; ++i) {\n+        if (v[i] != 0) all_0 = 0;\n+        if (v[i] != 0xffff) all_1 = 0;\n+    }\n+    return all_0 || all_1;\n+}\n+\n+void load256u128(uint16_t* out, const secp256k1_uint128* v) {\n+    uint64_t lo = secp256k1_u128_to_u64(v), hi = secp256k1_u128_hi_u64(v);\n+    load256two64(out, hi, lo, 0);\n+}\n+\n+void load256i128(uint16_t* out, const secp256k1_int128* v) {\n+    uint64_t lo;\n+    int64_t hi;\n+    secp256k1_int128 c = *v;\n+    lo = secp256k1_i128_to_i64(&c);\n+    secp256k1_i128_rshift(&c, 64);\n+    hi = secp256k1_i128_to_i64(&c);\n+    load256two64(out, hi, lo, 1);\n+}\n \n+void run_int128_test_case(void) {\n+    unsigned char buf[32];\n+    uint64_t v[4];\n+    secp256k1_int128 swa, swz;\n+    secp256k1_uint128 uwa, uwz;\n+    uint64_t ub, uc;\n+    int64_t sb, sc;\n+    uint16_t rswa[16], rswz[32], rswr[32], ruwa[16], ruwz[32], ruwr[32];\n+    uint16_t rub[16], ruc[16], rsb[16], rsc[16];\n+    int i;\n+\n+    /* Generate 32-byte random value. */\n+    secp256k1_testrand256_test(buf);\n+    /* Convert into 4 64-bit integers. */\n+    for (i = 0; i < 4; ++i) {\n+        uint64_t vi = 0;\n+        int j;\n+        for (j = 0; j < 8; ++j) vi = (vi << 8) + buf[8*i + j];\n+        v[i] = vi;\n+    }\n+    /* Convert those into a 128-bit value and two 64-bit values (signed and unsigned). */\n+    secp256k1_u128_load(&uwa, v[1], v[0]);\n+    secp256k1_i128_load(&swa, v[1], v[0]);\n+    ub = v[2];\n+    sb = v[2];\n+    uc = v[3];\n+    sc = v[3];\n+    /* Load those also into 16-bit array representations. */\n+    load256u128(ruwa, &uwa);\n+    load256i128(rswa, &swa);\n+    load256u64(rub, ub, 0);\n+    load256u64(rsb, sb, 1);\n+    load256u64(ruc, uc, 0);\n+    load256u64(rsc, sc, 1);\n+    /* test secp256k1_u128_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    secp256k1_u128_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    add256(ruwr, ruwr, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_u64 */\n+    add256(ruwr, rub, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_rshift */\n+    rshift256(ruwr, ruwa, uc % 128, 0);\n+    uwz = uwa;\n+    secp256k1_u128_rshift(&uwz, uc % 128);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_to_u64 */\n+    CHECK(secp256k1_u128_to_u64(&uwa) == v[0]);\n+    /* test secp256k1_u128_hi_u64 */\n+    CHECK(secp256k1_u128_hi_u64(&uwa) == v[1]);\n+    /* test secp256k1_u128_from_u64 */\n+    secp256k1_u128_from_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(rub, ruwz, 16) == 0);\n+    /* test secp256k1_u128_check_bits */\n+    {\n+        int uwa_bits = 0;\n+        int j;\n+        for (j = 0; j < 128; ++j) {\n+            if (ruwa[j / 16] >> (j % 16)) uwa_bits = 1 + j;\n+        }\n+        for (j = 0; j < 128; ++j) {\n+            CHECK(secp256k1_u128_check_bits(&uwa, j) == (uwa_bits <= j));\n+        }\n+    }\n+    /* test secp256k1_i128_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    secp256k1_i128_mul(&swz, sb, sc);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_accum_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    add256(rswr, rswr, rswa);\n+    if (int256is127(rswr)) {\n+        swz = swa;\n+        secp256k1_i128_accum_mul(&swz, sb, sc);\n+        load256i128(rswz, &swz);\n+        CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    }\n+    /* test secp256k1_i128_det */\n+    {\n+        uint16_t rsd[16], rse[16], rst[32];\n+        int64_t sd = v[0], se = v[1];\n+        load256u64(rsd, sd, 1);\n+        load256u64(rse, se, 1);\n+        mulmod256(rst, rsc, rsd, NULL);\n+        neg256(rst, rst);\n+        mulmod256(rswr, rsb, rse, NULL);\n+        add256(rswr, rswr, rst);\n+        secp256k1_i128_det(&swz, sb, sc, sd, se);\n+        load256i128(rswz, &swz);\n+        CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    }\n+    /* test secp256k1_i128_rshift */\n+    rshift256(rswr, rswa, uc % 127, 1);\n+    swz = swa;\n+    secp256k1_i128_rshift(&swz, uc % 127);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_to_i64 */\n+    CHECK((uint64_t)secp256k1_i128_to_i64(&swa) == v[0]);\n+    /* test secp256k1_i128_from_i64 */\n+    secp256k1_i128_from_i64(&swz, sb);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rsb, rswz, 16) == 0);\n+    /* test secp256k1_i128_eq_var */\n+    {\n+        int expect = (uc & 1);\n+        swz = swa;\n+        if (!expect) {\n+            /* Make sure swz != swa */\n+            uint64_t v0c = v[0], v1c = v[1];\n+            if (ub & 64) {\n+                v1c ^= (((uint64_t)1) << (ub & 63));\n+            } else {\n+                v0c ^= (((uint64_t)1) << (ub & 63));\n+            }\n+            secp256k1_i128_load(&swz, v1c, v0c);\n+        }\n+        CHECK(secp256k1_i128_eq_var(&swa, &swz) == expect);\n+    }\n+    /* test secp256k1_i128_check_pow2 */\n+    {\n+        int expect = (uc & 1);\n+        int pos = ub % 127;\n+        if (expect) {\n+            /* If expect==1, set swz to exactly (2 << pos). */\n+            uint64_t hi = 0;\n+            uint64_t lo = 0;\n+            if (pos & 64) {\n+                hi = (((uint64_t)1) << (pos & 63));\n+            } else {\n+                lo = (((uint64_t)1) << (pos & 63));\n+            }\n+            secp256k1_i128_load(&swz, hi, lo);\n+        } else {\n+            /* If expect==0, set swz = swa, but update expect=1 if swa happens to equal (2 << pos). */\n+            if (pos & 64) {\n+                if ((v[1] == (((uint64_t)1) << (pos & 63))) && v[0] == 0) expect = 1;\n+            } else {\n+                if ((v[0] == (((uint64_t)1) << (pos & 63))) && v[1] == 0) expect = 1;\n+            }\n+            swz = swa;\n+        }\n+        CHECK(secp256k1_i128_check_pow2(&swz, pos) == expect);\n+    }\n+}\n+\n+void run_int128_tests(void) {\n+    {   /* secp256k1_u128_accum_mul */\n+        secp256k1_uint128 res;\n+\n+        /* Check secp256k1_u128_accum_mul overflow */\n+        secp256k1_u128_from_u64(&res, 0);\n+        secp256k1_u128_accum_mul(&res, UINT64_MAX, UINT64_MAX);",
      "path": "src/tests.c",
      "position": null,
      "original_position": 407,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "in_reply_to_id": 1025363268,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, in a new commit.",
      "created_at": "2022-11-17T17:22:45Z",
      "updated_at": "2022-11-17T17:22:45Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1025480163",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025480163"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1981,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025483467",
      "pull_request_review_id": 1184745100,
      "id": 1025483467,
      "node_id": "PRRC_kwDOAP4Jqs49H6LL",
      "diff_hunk": "@@ -1752,8 +1715,308 @@ void run_modinv_tests(void) {\n     }\n }\n \n-/***** SCALAR TESTS *****/\n+/***** INT128 TESTS *****/\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Add two 256-bit numbers (represented as 16 uint16_t's in LE order) together mod 2^256. */\n+void add256(uint16_t* out, const uint16_t* a, const uint16_t* b) {\n+    int i;\n+    uint32_t carry = 0;\n+    for (i = 0; i < 16; ++i) {\n+        carry += a[i];\n+        carry += b[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Negate a 256-bit number (represented as 16 uint16_t's in LE order) mod 2^256. */\n+void neg256(uint16_t* out, const uint16_t* a) {\n+    int i;\n+    uint32_t carry = 1;\n+    for (i = 0; i < 16; ++i) {\n+        carry += (uint16_t)~a[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Right-shift a 256-bit number (represented as 16 uint16_t's in LE order). */\n+void rshift256(uint16_t* out, const uint16_t* a, int n, int sign_extend) {\n+    uint16_t sign = sign_extend && (a[15] >> 15);\n+    int i, j;\n+    for (i = 15; i >= 0; --i) {\n+        uint16_t v = 0;\n+        for (j = 0; j < 16; ++j) {\n+            int frompos = i*16 + j + n;\n+            if (frompos >= 256) {\n+                v |= sign << j;\n+            } else {\n+                v |= ((uint16_t)((a[frompos >> 4] >> (frompos & 15)) & 1)) << j;\n+            }\n+        }\n+        out[i] = v;\n+    }\n+}\n+\n+/* Load a 64-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256u64(uint16_t* out, uint64_t v, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (v >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = v >> (16 * i);\n+    }\n+    for (i = 4; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Load a 128-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256two64(uint16_t* out, uint64_t hi, uint64_t lo, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (hi >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = lo >> (16 * i);\n+    }\n+    for (i = 4; i < 8; ++i) {\n+        out[i] = hi >> (16 * (i - 4));\n+    }\n+    for (i = 8; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Check whether the 256-bit value represented by array of 16-bit values is in range -2^127 < v < 2^127. */\n+int int256is127(const uint16_t* v) {\n+    int all_0 = ((v[7] & 0x8000) == 0), all_1 = ((v[7] & 0x8000) == 0x8000);\n+    int i;\n+    for (i = 8; i < 16; ++i) {\n+        if (v[i] != 0) all_0 = 0;\n+        if (v[i] != 0xffff) all_1 = 0;\n+    }\n+    return all_0 || all_1;\n+}\n+\n+void load256u128(uint16_t* out, const secp256k1_uint128* v) {\n+    uint64_t lo = secp256k1_u128_to_u64(v), hi = secp256k1_u128_hi_u64(v);\n+    load256two64(out, hi, lo, 0);\n+}\n+\n+void load256i128(uint16_t* out, const secp256k1_int128* v) {\n+    uint64_t lo;\n+    int64_t hi;\n+    secp256k1_int128 c = *v;\n+    lo = secp256k1_i128_to_i64(&c);\n+    secp256k1_i128_rshift(&c, 64);\n+    hi = secp256k1_i128_to_i64(&c);\n+    load256two64(out, hi, lo, 1);\n+}\n \n+void run_int128_test_case(void) {\n+    unsigned char buf[32];\n+    uint64_t v[4];\n+    secp256k1_int128 swa, swz;\n+    secp256k1_uint128 uwa, uwz;\n+    uint64_t ub, uc;\n+    int64_t sb, sc;\n+    uint16_t rswa[16], rswz[32], rswr[32], ruwa[16], ruwz[32], ruwr[32];\n+    uint16_t rub[16], ruc[16], rsb[16], rsc[16];\n+    int i;\n+\n+    /* Generate 32-byte random value. */\n+    secp256k1_testrand256_test(buf);\n+    /* Convert into 4 64-bit integers. */\n+    for (i = 0; i < 4; ++i) {\n+        uint64_t vi = 0;\n+        int j;\n+        for (j = 0; j < 8; ++j) vi = (vi << 8) + buf[8*i + j];\n+        v[i] = vi;\n+    }\n+    /* Convert those into a 128-bit value and two 64-bit values (signed and unsigned). */\n+    secp256k1_u128_load(&uwa, v[1], v[0]);\n+    secp256k1_i128_load(&swa, v[1], v[0]);\n+    ub = v[2];\n+    sb = v[2];\n+    uc = v[3];\n+    sc = v[3];\n+    /* Load those also into 16-bit array representations. */\n+    load256u128(ruwa, &uwa);\n+    load256i128(rswa, &swa);\n+    load256u64(rub, ub, 0);\n+    load256u64(rsb, sb, 1);\n+    load256u64(ruc, uc, 0);\n+    load256u64(rsc, sc, 1);\n+    /* test secp256k1_u128_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    secp256k1_u128_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    add256(ruwr, ruwr, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_u64 */\n+    add256(ruwr, rub, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_rshift */\n+    rshift256(ruwr, ruwa, uc % 128, 0);\n+    uwz = uwa;\n+    secp256k1_u128_rshift(&uwz, uc % 128);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_to_u64 */\n+    CHECK(secp256k1_u128_to_u64(&uwa) == v[0]);\n+    /* test secp256k1_u128_hi_u64 */\n+    CHECK(secp256k1_u128_hi_u64(&uwa) == v[1]);\n+    /* test secp256k1_u128_from_u64 */\n+    secp256k1_u128_from_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(rub, ruwz, 16) == 0);\n+    /* test secp256k1_u128_check_bits */\n+    {\n+        int uwa_bits = 0;\n+        int j;\n+        for (j = 0; j < 128; ++j) {\n+            if (ruwa[j / 16] >> (j % 16)) uwa_bits = 1 + j;\n+        }\n+        for (j = 0; j < 128; ++j) {\n+            CHECK(secp256k1_u128_check_bits(&uwa, j) == (uwa_bits <= j));\n+        }\n+    }\n+    /* test secp256k1_i128_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    secp256k1_i128_mul(&swz, sb, sc);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_accum_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    add256(rswr, rswr, rswa);\n+    if (int256is127(rswr)) {",
      "path": "src/tests.c",
      "position": 326,
      "original_position": 326,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "in_reply_to_id": 1025429285,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Often, from having tried this before adding this check.",
      "created_at": "2022-11-17T17:26:08Z",
      "updated_at": "2022-11-17T17:26:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1025483467",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025483467"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1900,
      "original_line": 1900,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025529564",
      "pull_request_review_id": 1184812121,
      "id": 1025529564,
      "node_id": "PRRC_kwDOAP4Jqs49IFbc",
      "diff_hunk": "@@ -1752,8 +1715,308 @@ void run_modinv_tests(void) {\n     }\n }\n \n-/***** SCALAR TESTS *****/\n+/***** INT128 TESTS *****/\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Add two 256-bit numbers (represented as 16 uint16_t's in LE order) together mod 2^256. */\n+void add256(uint16_t* out, const uint16_t* a, const uint16_t* b) {\n+    int i;\n+    uint32_t carry = 0;\n+    for (i = 0; i < 16; ++i) {\n+        carry += a[i];\n+        carry += b[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Negate a 256-bit number (represented as 16 uint16_t's in LE order) mod 2^256. */\n+void neg256(uint16_t* out, const uint16_t* a) {\n+    int i;\n+    uint32_t carry = 1;\n+    for (i = 0; i < 16; ++i) {\n+        carry += (uint16_t)~a[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Right-shift a 256-bit number (represented as 16 uint16_t's in LE order). */\n+void rshift256(uint16_t* out, const uint16_t* a, int n, int sign_extend) {\n+    uint16_t sign = sign_extend && (a[15] >> 15);\n+    int i, j;\n+    for (i = 15; i >= 0; --i) {\n+        uint16_t v = 0;\n+        for (j = 0; j < 16; ++j) {\n+            int frompos = i*16 + j + n;\n+            if (frompos >= 256) {\n+                v |= sign << j;\n+            } else {\n+                v |= ((uint16_t)((a[frompos >> 4] >> (frompos & 15)) & 1)) << j;\n+            }\n+        }\n+        out[i] = v;\n+    }\n+}\n+\n+/* Load a 64-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256u64(uint16_t* out, uint64_t v, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (v >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = v >> (16 * i);\n+    }\n+    for (i = 4; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Load a 128-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256two64(uint16_t* out, uint64_t hi, uint64_t lo, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (hi >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = lo >> (16 * i);\n+    }\n+    for (i = 4; i < 8; ++i) {\n+        out[i] = hi >> (16 * (i - 4));\n+    }\n+    for (i = 8; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Check whether the 256-bit value represented by array of 16-bit values is in range -2^127 < v < 2^127. */\n+int int256is127(const uint16_t* v) {\n+    int all_0 = ((v[7] & 0x8000) == 0), all_1 = ((v[7] & 0x8000) == 0x8000);\n+    int i;\n+    for (i = 8; i < 16; ++i) {\n+        if (v[i] != 0) all_0 = 0;\n+        if (v[i] != 0xffff) all_1 = 0;\n+    }\n+    return all_0 || all_1;\n+}\n+\n+void load256u128(uint16_t* out, const secp256k1_uint128* v) {\n+    uint64_t lo = secp256k1_u128_to_u64(v), hi = secp256k1_u128_hi_u64(v);\n+    load256two64(out, hi, lo, 0);\n+}\n+\n+void load256i128(uint16_t* out, const secp256k1_int128* v) {\n+    uint64_t lo;\n+    int64_t hi;\n+    secp256k1_int128 c = *v;\n+    lo = secp256k1_i128_to_i64(&c);\n+    secp256k1_i128_rshift(&c, 64);\n+    hi = secp256k1_i128_to_i64(&c);\n+    load256two64(out, hi, lo, 1);\n+}\n \n+void run_int128_test_case(void) {\n+    unsigned char buf[32];\n+    uint64_t v[4];\n+    secp256k1_int128 swa, swz;\n+    secp256k1_uint128 uwa, uwz;\n+    uint64_t ub, uc;\n+    int64_t sb, sc;\n+    uint16_t rswa[16], rswz[32], rswr[32], ruwa[16], ruwz[32], ruwr[32];\n+    uint16_t rub[16], ruc[16], rsb[16], rsc[16];\n+    int i;\n+\n+    /* Generate 32-byte random value. */\n+    secp256k1_testrand256_test(buf);\n+    /* Convert into 4 64-bit integers. */\n+    for (i = 0; i < 4; ++i) {\n+        uint64_t vi = 0;\n+        int j;\n+        for (j = 0; j < 8; ++j) vi = (vi << 8) + buf[8*i + j];\n+        v[i] = vi;\n+    }\n+    /* Convert those into a 128-bit value and two 64-bit values (signed and unsigned). */\n+    secp256k1_u128_load(&uwa, v[1], v[0]);\n+    secp256k1_i128_load(&swa, v[1], v[0]);\n+    ub = v[2];\n+    sb = v[2];\n+    uc = v[3];\n+    sc = v[3];\n+    /* Load those also into 16-bit array representations. */\n+    load256u128(ruwa, &uwa);\n+    load256i128(rswa, &swa);\n+    load256u64(rub, ub, 0);\n+    load256u64(rsb, sb, 1);\n+    load256u64(ruc, uc, 0);\n+    load256u64(rsc, sc, 1);\n+    /* test secp256k1_u128_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    secp256k1_u128_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    add256(ruwr, ruwr, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_u64 */\n+    add256(ruwr, rub, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_rshift */\n+    rshift256(ruwr, ruwa, uc % 128, 0);\n+    uwz = uwa;\n+    secp256k1_u128_rshift(&uwz, uc % 128);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_to_u64 */\n+    CHECK(secp256k1_u128_to_u64(&uwa) == v[0]);\n+    /* test secp256k1_u128_hi_u64 */\n+    CHECK(secp256k1_u128_hi_u64(&uwa) == v[1]);\n+    /* test secp256k1_u128_from_u64 */\n+    secp256k1_u128_from_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(rub, ruwz, 16) == 0);\n+    /* test secp256k1_u128_check_bits */\n+    {\n+        int uwa_bits = 0;\n+        int j;\n+        for (j = 0; j < 128; ++j) {\n+            if (ruwa[j / 16] >> (j % 16)) uwa_bits = 1 + j;\n+        }\n+        for (j = 0; j < 128; ++j) {\n+            CHECK(secp256k1_u128_check_bits(&uwa, j) == (uwa_bits <= j));\n+        }\n+    }\n+    /* test secp256k1_i128_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    secp256k1_i128_mul(&swz, sb, sc);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_accum_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    add256(rswr, rswr, rswa);\n+    if (int256is127(rswr)) {",
      "path": "src/tests.c",
      "position": 326,
      "original_position": 326,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "in_reply_to_id": 1025429285,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A Monte-Carlo simulation suggests `int256is127()` succeeds with probability ~15/16 (93.75%).",
      "created_at": "2022-11-17T18:05:53Z",
      "updated_at": "2022-11-17T18:05:53Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1025529564",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1025529564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1900,
      "original_line": 1900,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1026830327",
      "pull_request_review_id": 1186703856,
      "id": 1026830327,
      "node_id": "PRRC_kwDOAP4Jqs49NC_3",
      "diff_hunk": "@@ -230,21 +230,34 @@ static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag)\n     *r = (int)(r_masked | a_masked);\n }\n \n-/* If USE_FORCE_WIDEMUL_{INT128, INT128_STRUCT, INT64} is set, use that wide multiplication implementation.\n- * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n- */\n #if defined(USE_FORCE_WIDEMUL_INT128_STRUCT)\n+/* If USE_FORCE_WIDEMUL_INT128_STRUCT is set, use int128_struct. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_STRUCT 1\n #elif defined(USE_FORCE_WIDEMUL_INT128)\n+/* If USE_FORCE_WIDEMUL_INT128 is set, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n #elif defined(USE_FORCE_WIDEMUL_INT64)\n+/* If USE_FORCE_WIDEMUL_INT64 is set, use int64. */\n # define SECP256K1_WIDEMUL_INT64 1\n #elif defined(UINT128_MAX) || defined(__SIZEOF_INT128__)\n+/* If a native 128-bit integer type exists, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n+#elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_ARM64))\n+/* On 64-bit MSVC targets (x86_64 and arm64), use int128_struct\n+ * (which has special logic to implement using intrinsics on those systems). */\n+# define SECP256K1_WIDEMUL_INT128 1\n+# define SECP256K1_INT128_STRUCT 1\n+#elif SIZE_MAX > 0xffffffff\n+/* Systems with 64-bit pointers (and thus registers) very likely benefit from\n+ * using 64-bit based arithmetic (even if we need to fall back to 32x32->64 based\n+ * multiplication logic). */\n+# define SECP256K1_WIDEMUL_INT128 1\n+# define SECP256K1_INT128_STRUCT 1",
      "path": "src/util.h",
      "position": 32,
      "original_position": 32,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we have a benchmark for a system where this is the case? @sipa's [benchmarks](https://github.com/bitcoin-core/secp256k1/pull/1000#issuecomment-1306385135) suggest that on 64 bit aarch64, int64 is faster than int128_struct.",
      "created_at": "2022-11-18T19:59:28Z",
      "updated_at": "2022-11-18T19:59:39Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1026830327",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1026830327"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": 254,
      "original_start_line": 254,
      "start_side": "RIGHT",
      "line": 258,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1026841166",
      "pull_request_review_id": 1186721310,
      "id": 1026841166,
      "node_id": "PRRC_kwDOAP4Jqs49NFpO",
      "diff_hunk": "@@ -230,21 +230,34 @@ static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag)\n     *r = (int)(r_masked | a_masked);\n }\n \n-/* If USE_FORCE_WIDEMUL_{INT128, INT128_STRUCT, INT64} is set, use that wide multiplication implementation.\n- * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n- */\n #if defined(USE_FORCE_WIDEMUL_INT128_STRUCT)\n+/* If USE_FORCE_WIDEMUL_INT128_STRUCT is set, use int128_struct. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_STRUCT 1\n #elif defined(USE_FORCE_WIDEMUL_INT128)\n+/* If USE_FORCE_WIDEMUL_INT128 is set, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n #elif defined(USE_FORCE_WIDEMUL_INT64)\n+/* If USE_FORCE_WIDEMUL_INT64 is set, use int64. */\n # define SECP256K1_WIDEMUL_INT64 1\n #elif defined(UINT128_MAX) || defined(__SIZEOF_INT128__)\n+/* If a native 128-bit integer type exists, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n+#elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_ARM64))\n+/* On 64-bit MSVC targets (x86_64 and arm64), use int128_struct\n+ * (which has special logic to implement using intrinsics on those systems). */\n+# define SECP256K1_WIDEMUL_INT128 1\n+# define SECP256K1_INT128_STRUCT 1\n+#elif SIZE_MAX > 0xffffffff\n+/* Systems with 64-bit pointers (and thus registers) very likely benefit from\n+ * using 64-bit based arithmetic (even if we need to fall back to 32x32->64 based\n+ * multiplication logic). */\n+# define SECP256K1_WIDEMUL_INT128 1\n+# define SECP256K1_INT128_STRUCT 1",
      "path": "src/util.h",
      "position": 32,
      "original_position": 32,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "in_reply_to_id": 1026830327,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> on 64 bit aarch64, int64 is faster than int128_struct.\r\n\r\nYes, but my benchmark also showed int64 is faster than int128, as this was on a system supporting `__int128`. So if there are systems where we want to prefer widemul=int64 over widemul=int128, that's a discussion independent from the int128_struct decision logic.\r\n\r\nTo find an example where this branch here (use int128_struct over int64, because int128 isn't available) matters, we'll need to go outside of gcc/clang/icc/MSVC, because on those we all have access to true 64x64->128 hardware multiplication if it exists. I don't know if there are any vaguely popular C compilers for 64-bit platforms out there... does Borland still exist?\r\n\r\nEDIT: GCC 4.5 and below, or clang 3.0 and below, for x86_64, would be relevant platforms...",
      "created_at": "2022-11-18T20:13:14Z",
      "updated_at": "2022-11-18T20:20:08Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1026841166",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1026841166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": 254,
      "original_start_line": 254,
      "start_side": "RIGHT",
      "line": 258,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1026847111",
      "pull_request_review_id": 1186731235,
      "id": 1026847111,
      "node_id": "PRRC_kwDOAP4Jqs49NHGH",
      "diff_hunk": "@@ -1752,8 +1715,308 @@ void run_modinv_tests(void) {\n     }\n }\n \n-/***** SCALAR TESTS *****/\n+/***** INT128 TESTS *****/\n+\n+#ifdef SECP256K1_WIDEMUL_INT128\n+/* Add two 256-bit numbers (represented as 16 uint16_t's in LE order) together mod 2^256. */\n+void add256(uint16_t* out, const uint16_t* a, const uint16_t* b) {\n+    int i;\n+    uint32_t carry = 0;\n+    for (i = 0; i < 16; ++i) {\n+        carry += a[i];\n+        carry += b[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Negate a 256-bit number (represented as 16 uint16_t's in LE order) mod 2^256. */\n+void neg256(uint16_t* out, const uint16_t* a) {\n+    int i;\n+    uint32_t carry = 1;\n+    for (i = 0; i < 16; ++i) {\n+        carry += (uint16_t)~a[i];\n+        out[i] = carry;\n+        carry >>= 16;\n+    }\n+}\n+\n+/* Right-shift a 256-bit number (represented as 16 uint16_t's in LE order). */\n+void rshift256(uint16_t* out, const uint16_t* a, int n, int sign_extend) {\n+    uint16_t sign = sign_extend && (a[15] >> 15);\n+    int i, j;\n+    for (i = 15; i >= 0; --i) {\n+        uint16_t v = 0;\n+        for (j = 0; j < 16; ++j) {\n+            int frompos = i*16 + j + n;\n+            if (frompos >= 256) {\n+                v |= sign << j;\n+            } else {\n+                v |= ((uint16_t)((a[frompos >> 4] >> (frompos & 15)) & 1)) << j;\n+            }\n+        }\n+        out[i] = v;\n+    }\n+}\n+\n+/* Load a 64-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256u64(uint16_t* out, uint64_t v, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (v >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = v >> (16 * i);\n+    }\n+    for (i = 4; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Load a 128-bit unsigned integer into an array of 16 uint16_t's in LE order representing a 256-bit value. */\n+void load256two64(uint16_t* out, uint64_t hi, uint64_t lo, int is_signed) {\n+    int i;\n+    uint64_t sign = is_signed && (hi >> 63) ? UINT64_MAX : 0;\n+    for (i = 0; i < 4; ++i) {\n+        out[i] = lo >> (16 * i);\n+    }\n+    for (i = 4; i < 8; ++i) {\n+        out[i] = hi >> (16 * (i - 4));\n+    }\n+    for (i = 8; i < 16; ++i) {\n+        out[i] = sign;\n+    }\n+}\n+\n+/* Check whether the 256-bit value represented by array of 16-bit values is in range -2^127 < v < 2^127. */\n+int int256is127(const uint16_t* v) {\n+    int all_0 = ((v[7] & 0x8000) == 0), all_1 = ((v[7] & 0x8000) == 0x8000);\n+    int i;\n+    for (i = 8; i < 16; ++i) {\n+        if (v[i] != 0) all_0 = 0;\n+        if (v[i] != 0xffff) all_1 = 0;\n+    }\n+    return all_0 || all_1;\n+}\n+\n+void load256u128(uint16_t* out, const secp256k1_uint128* v) {\n+    uint64_t lo = secp256k1_u128_to_u64(v), hi = secp256k1_u128_hi_u64(v);\n+    load256two64(out, hi, lo, 0);\n+}\n+\n+void load256i128(uint16_t* out, const secp256k1_int128* v) {\n+    uint64_t lo;\n+    int64_t hi;\n+    secp256k1_int128 c = *v;\n+    lo = secp256k1_i128_to_i64(&c);\n+    secp256k1_i128_rshift(&c, 64);\n+    hi = secp256k1_i128_to_i64(&c);\n+    load256two64(out, hi, lo, 1);\n+}\n \n+void run_int128_test_case(void) {\n+    unsigned char buf[32];\n+    uint64_t v[4];\n+    secp256k1_int128 swa, swz;\n+    secp256k1_uint128 uwa, uwz;\n+    uint64_t ub, uc;\n+    int64_t sb, sc;\n+    uint16_t rswa[16], rswz[32], rswr[32], ruwa[16], ruwz[32], ruwr[32];\n+    uint16_t rub[16], ruc[16], rsb[16], rsc[16];\n+    int i;\n+\n+    /* Generate 32-byte random value. */\n+    secp256k1_testrand256_test(buf);\n+    /* Convert into 4 64-bit integers. */\n+    for (i = 0; i < 4; ++i) {\n+        uint64_t vi = 0;\n+        int j;\n+        for (j = 0; j < 8; ++j) vi = (vi << 8) + buf[8*i + j];\n+        v[i] = vi;\n+    }\n+    /* Convert those into a 128-bit value and two 64-bit values (signed and unsigned). */\n+    secp256k1_u128_load(&uwa, v[1], v[0]);\n+    secp256k1_i128_load(&swa, v[1], v[0]);\n+    ub = v[2];\n+    sb = v[2];\n+    uc = v[3];\n+    sc = v[3];\n+    /* Load those also into 16-bit array representations. */\n+    load256u128(ruwa, &uwa);\n+    load256i128(rswa, &swa);\n+    load256u64(rub, ub, 0);\n+    load256u64(rsb, sb, 1);\n+    load256u64(ruc, uc, 0);\n+    load256u64(rsc, sc, 1);\n+    /* test secp256k1_u128_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    secp256k1_u128_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_mul */\n+    mulmod256(ruwr, rub, ruc, NULL);\n+    add256(ruwr, ruwr, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_mul(&uwz, ub, uc);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_accum_u64 */\n+    add256(ruwr, rub, ruwa);\n+    uwz = uwa;\n+    secp256k1_u128_accum_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_rshift */\n+    rshift256(ruwr, ruwa, uc % 128, 0);\n+    uwz = uwa;\n+    secp256k1_u128_rshift(&uwz, uc % 128);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(ruwr, ruwz, 16) == 0);\n+    /* test secp256k1_u128_to_u64 */\n+    CHECK(secp256k1_u128_to_u64(&uwa) == v[0]);\n+    /* test secp256k1_u128_hi_u64 */\n+    CHECK(secp256k1_u128_hi_u64(&uwa) == v[1]);\n+    /* test secp256k1_u128_from_u64 */\n+    secp256k1_u128_from_u64(&uwz, ub);\n+    load256u128(ruwz, &uwz);\n+    CHECK(secp256k1_memcmp_var(rub, ruwz, 16) == 0);\n+    /* test secp256k1_u128_check_bits */\n+    {\n+        int uwa_bits = 0;\n+        int j;\n+        for (j = 0; j < 128; ++j) {\n+            if (ruwa[j / 16] >> (j % 16)) uwa_bits = 1 + j;\n+        }\n+        for (j = 0; j < 128; ++j) {\n+            CHECK(secp256k1_u128_check_bits(&uwa, j) == (uwa_bits <= j));\n+        }\n+    }\n+    /* test secp256k1_i128_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    secp256k1_i128_mul(&swz, sb, sc);\n+    load256i128(rswz, &swz);\n+    CHECK(secp256k1_memcmp_var(rswr, rswz, 16) == 0);\n+    /* test secp256k1_i128_accum_mul */\n+    mulmod256(rswr, rsb, rsc, NULL);\n+    add256(rswr, rswr, rswa);\n+    if (int256is127(rswr)) {",
      "path": "src/tests.c",
      "position": 326,
      "original_position": 326,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "3afce0af7c00eb4c5ca6d303e36a48c91a800459",
      "in_reply_to_id": 1025429285,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In fact, testing this exhaustively with smaller integer types suggests the probability is *exactly* 15/16.",
      "created_at": "2022-11-18T20:21:57Z",
      "updated_at": "2022-11-18T20:21:58Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1026847111",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1026847111"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1900,
      "original_line": 1900,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1026880846",
      "pull_request_review_id": 1186793669,
      "id": 1026880846,
      "node_id": "PRRC_kwDOAP4Jqs49NPVO",
      "diff_hunk": "@@ -230,21 +230,34 @@ static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag)\n     *r = (int)(r_masked | a_masked);\n }\n \n-/* If USE_FORCE_WIDEMUL_{INT128, INT128_STRUCT, INT64} is set, use that wide multiplication implementation.\n- * Otherwise use the presence of __SIZEOF_INT128__ to decide.\n- */\n #if defined(USE_FORCE_WIDEMUL_INT128_STRUCT)\n+/* If USE_FORCE_WIDEMUL_INT128_STRUCT is set, use int128_struct. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_STRUCT 1\n #elif defined(USE_FORCE_WIDEMUL_INT128)\n+/* If USE_FORCE_WIDEMUL_INT128 is set, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n #elif defined(USE_FORCE_WIDEMUL_INT64)\n+/* If USE_FORCE_WIDEMUL_INT64 is set, use int64. */\n # define SECP256K1_WIDEMUL_INT64 1\n #elif defined(UINT128_MAX) || defined(__SIZEOF_INT128__)\n+/* If a native 128-bit integer type exists, use int128. */\n # define SECP256K1_WIDEMUL_INT128 1\n # define SECP256K1_INT128_NATIVE 1\n+#elif defined(_MSC_VER) && (defined(_M_X64) || defined(_M_ARM64))\n+/* On 64-bit MSVC targets (x86_64 and arm64), use int128_struct\n+ * (which has special logic to implement using intrinsics on those systems). */\n+# define SECP256K1_WIDEMUL_INT128 1\n+# define SECP256K1_INT128_STRUCT 1\n+#elif SIZE_MAX > 0xffffffff\n+/* Systems with 64-bit pointers (and thus registers) very likely benefit from\n+ * using 64-bit based arithmetic (even if we need to fall back to 32x32->64 based\n+ * multiplication logic). */\n+# define SECP256K1_WIDEMUL_INT128 1\n+# define SECP256K1_INT128_STRUCT 1",
      "path": "src/util.h",
      "position": 32,
      "original_position": 32,
      "commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "original_commit_id": "99bd3355994a436e25d148c68e097cca11f3c63e",
      "in_reply_to_id": 1026830327,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ok, if you think that's a significant improvement on these systems, fine with me. ",
      "created_at": "2022-11-18T21:04:26Z",
      "updated_at": "2022-11-18T21:04:27Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/1156#discussion_r1026880846",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/1026880846"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/1156"
        }
      },
      "start_line": 254,
      "original_start_line": 254,
      "start_side": "RIGHT",
      "line": 258,
      "original_line": 258,
      "side": "RIGHT"
    }
  ]
}