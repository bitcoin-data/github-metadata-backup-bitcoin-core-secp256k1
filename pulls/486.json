{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486",
    "id": 152256054,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MTUyMjU2MDU0",
    "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486",
    "diff_url": "https://github.com/bitcoin-core/secp256k1/pull/486.diff",
    "patch_url": "https://github.com/bitcoin-core/secp256k1/pull/486.patch",
    "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486",
    "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
    "number": 486,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Add pippenger_wnaf for multi-multiplication",
    "user": {
      "login": "jonasnick",
      "id": 2582071,
      "node_id": "MDQ6VXNlcjI1ODIwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasnick",
      "html_url": "https://github.com/jonasnick",
      "followers_url": "https://api.github.com/users/jonasnick/followers",
      "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasnick/orgs",
      "repos_url": "https://api.github.com/users/jonasnick/repos",
      "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/jonasnick/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This PR is based on #473 and adds a variant of \"Pippengers algorithm\" (see [Bernstein et al., Faster batch forgery identification](https://eprint.iacr.org/2012/549.pdf), page 15 and https://github.com/scipr-lab/libff/pull/10) for point multi-multiplication that performs better with a large number of points than Strauss' algorithm.\r\n\r\n![aggsig](https://user-images.githubusercontent.com/2582071/32731185-12c0f108-c881-11e7-83c7-c2432b5fadf5.png)\r\n\r\nThanks to @sipa for providing `wnaf_fixed`, benchmarking, and the crucial suggestion to use affine addition.\r\n\r\nThe PR also makes `ecmult_multi` decide which algorithm to use, based on the number of points and the available scratch space.\r\nFor restricted scratch spaces this can be further optimized in the future (f.e. a 35kB scratch space allows batches of 11 points with strauss or 95 points with pippenger; choosing pippenger would be 5% faster).\r\n\r\nAs soon as this PR has received some feedback I'll repeat the benchmarks to determine the optimal `pippenger_bucket_window` with the new benchmarking code in #473.\r\n",
    "labels": [],
    "created_at": "2017-11-13T14:45:03Z",
    "updated_at": "2017-12-08T01:59:47Z",
    "closed_at": "2017-12-08T01:59:47Z",
    "mergeable_state": "unknown",
    "merged_at": "2017-12-08T01:59:47Z",
    "merge_commit_sha": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "jonasnick:pippenger",
      "ref": "pippenger",
      "sha": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 57937974,
        "node_id": "MDEwOlJlcG9zaXRvcnk1NzkzNzk3NA==",
        "name": "secp256k1",
        "full_name": "jonasnick/secp256k1",
        "owner": {
          "login": "jonasnick",
          "id": 2582071,
          "node_id": "MDQ6VXNlcjI1ODIwNzE=",
          "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/jonasnick",
          "html_url": "https://github.com/jonasnick",
          "followers_url": "https://api.github.com/users/jonasnick/followers",
          "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
          "organizations_url": "https://api.github.com/users/jonasnick/orgs",
          "repos_url": "https://api.github.com/users/jonasnick/repos",
          "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/jonasnick/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/jonasnick/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": true,
        "url": "https://api.github.com/repos/jonasnick/secp256k1",
        "archive_url": "https://api.github.com/repos/jonasnick/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/jonasnick/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/jonasnick/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/jonasnick/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/jonasnick/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/jonasnick/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/jonasnick/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/jonasnick/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/jonasnick/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/jonasnick/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/jonasnick/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/jonasnick/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/jonasnick/secp256k1/events",
        "forks_url": "https://api.github.com/repos/jonasnick/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/jonasnick/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/jonasnick/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/jonasnick/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/jonasnick/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/jonasnick/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/jonasnick/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/jonasnick/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/jonasnick/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/jonasnick/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/jonasnick/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/jonasnick/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/jonasnick/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/jonasnick/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/jonasnick/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/jonasnick/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:jonasnick/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/jonasnick/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/jonasnick/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/jonasnick/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/jonasnick/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/jonasnick/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/jonasnick/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/jonasnick/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/jonasnick/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/jonasnick/secp256k1/hooks",
        "svn_url": "https://github.com/jonasnick/secp256k1",
        "language": "C",
        "forks_count": 4,
        "stargazers_count": 3,
        "watchers_count": 3,
        "size": 11430,
        "default_branch": "master",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-05-24T13:49:16Z",
        "created_at": "2016-05-03T03:14:21Z",
        "updated_at": "2023-03-16T11:44:51Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin-core:master",
      "ref": "master",
      "sha": "6ad5cdb42a1a8257289a0423d644dcbdeab0f83c",
      "user": {
        "login": "bitcoin-core",
        "id": 13464320,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin-core",
        "html_url": "https://github.com/bitcoin-core",
        "followers_url": "https://api.github.com/users/bitcoin-core/followers",
        "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
        "repos_url": "https://api.github.com/users/bitcoin-core/repos",
        "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 16648618,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjY0ODYxOA==",
        "name": "secp256k1",
        "full_name": "bitcoin-core/secp256k1",
        "owner": {
          "login": "bitcoin-core",
          "id": 13464320,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjEzNDY0MzIw",
          "avatar_url": "https://avatars.githubusercontent.com/u/13464320?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin-core",
          "html_url": "https://github.com/bitcoin-core",
          "followers_url": "https://api.github.com/users/bitcoin-core/followers",
          "following_url": "https://api.github.com/users/bitcoin-core/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin-core/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin-core/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin-core/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin-core/orgs",
          "repos_url": "https://api.github.com/users/bitcoin-core/repos",
          "events_url": "https://api.github.com/users/bitcoin-core/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin-core/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin-core/secp256k1",
        "description": "Optimized C library for EC operations on curve secp256k1",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1",
        "archive_url": "https://api.github.com/repos/bitcoin-core/secp256k1/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin-core/secp256k1/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin-core/secp256k1/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin-core/secp256k1/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin-core/secp256k1/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin-core/secp256k1/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin-core/secp256k1/downloads",
        "events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/events",
        "forks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin-core/secp256k1.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin-core/secp256k1/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin-core/secp256k1/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin-core/secp256k1/languages",
        "merges_url": "https://api.github.com/repos/bitcoin-core/secp256k1/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin-core/secp256k1/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin-core/secp256k1/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin-core/secp256k1/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin-core/secp256k1.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin-core/secp256k1/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin-core/secp256k1/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin-core/secp256k1/tags",
        "teams_url": "https://api.github.com/repos/bitcoin-core/secp256k1/teams",
        "trees_url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin-core/secp256k1.git",
        "hooks_url": "https://api.github.com/repos/bitcoin-core/secp256k1/hooks",
        "svn_url": "https://github.com/bitcoin-core/secp256k1",
        "language": "C",
        "forks_count": 948,
        "stargazers_count": 1768,
        "watchers_count": 1768,
        "size": 10062,
        "default_branch": "master",
        "open_issues_count": 142,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-12T16:38:48Z",
        "created_at": "2014-02-08T17:30:06Z",
        "updated_at": "2023-06-12T17:38:13Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 1601,
    "deletions": 83,
    "changed_files": 16,
    "commits": 9,
    "review_comments": 38,
    "comments": 12
  },
  "events": [
    {
      "event": "mentioned",
      "id": 1338838426,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTMzODgzODQyNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1338838426",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-13T14:45:04Z"
    },
    {
      "event": "subscribed",
      "id": 1338838428,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDEzMzg4Mzg0Mjg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1338838428",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-13T14:45:04Z"
    },
    {
      "event": "commented",
      "id": 343941123,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM0Mzk0MTEyMw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/343941123",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-13T14:47:45Z",
      "updated_at": "2017-11-13T14:47:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "Hooray!\r\n\r\nPlease rebase -- should be straightforward, we merged only some minor things last week.",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-343941123",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1340577914,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTM0MDU3NzkxNA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1340577914",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-14T10:44:18Z"
    },
    {
      "event": "commented",
      "id": 344218853,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM0NDIxODg1Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/344218853",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-14T10:45:19Z",
      "updated_at": "2017-11-14T10:45:19Z",
      "author_association": "MEMBER",
      "body": "Rebased",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-344218853",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "reviewed",
      "id": 76621287,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY2MjEyODc=",
      "url": null,
      "actor": null,
      "commit_id": "be3248f50ac6a5bab2f3d0ad7279dad760d9489b",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#pullrequestreview-76621287",
      "submitted_at": "2017-11-14T22:39:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1345113753,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTM0NTExMzc1Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1345113753",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-16T13:40:15Z"
    },
    {
      "event": "commented",
      "id": 345004532,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTAwNDUzMg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/345004532",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-16T17:53:31Z",
      "updated_at": "2017-11-16T17:58:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "In `secp256k1_ecmult_multi_split_strauss_wnaf` we immediately convert a `secp256k1_ge` received from the callback to a `secp256k1_gej`. Would be better to change the callback API to just return a gej in the first place, otherwise the caller may be forced to do an expensive and pointless gej->ge conversion.\r\n\r\n**Edit** Oh, I was looking at old code. I see that Strauss does the ge->gej conversion but Pippenger does not (and Pippenger derives a speed benefit from using ge). And our two main applications, aggsig and bulletproofs, don't need to do a gej->ge conversion anyway, at least during verification. Never mind.",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-345004532",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "commented",
      "id": 345151295,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTE1MTI5NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/345151295",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-17T05:45:10Z",
      "updated_at": "2017-11-17T05:45:10Z",
      "author_association": "MEMBER",
      "body": "@apoelstra Yes, I believe it was a conscious choice to making the interface pass affine points because no callers need more.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-345151295",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "mentioned",
      "id": 1346529254,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTM0NjUyOTI1NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1346529254",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-17T05:45:10Z"
    },
    {
      "event": "subscribed",
      "id": 1346529255,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDEzNDY1MjkyNTU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1346529255",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-17T05:45:10Z"
    },
    {
      "event": "reviewed",
      "id": 78806326,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg4MDYzMjY=",
      "url": null,
      "actor": null,
      "commit_id": "be8abb5ad18c334dc2367df1f183e3c00c7d469f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#pullrequestreview-78806326",
      "submitted_at": "2017-11-23T22:46:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
    },
    {
      "event": "mentioned",
      "id": 1356377093,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTM1NjM3NzA5Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1356377093",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-23T22:46:46Z"
    },
    {
      "event": "subscribed",
      "id": 1356377094,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDEzNTYzNzcwOTQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1356377094",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-23T22:46:46Z"
    },
    {
      "event": "reviewed",
      "id": 78994182,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg5OTQxODI=",
      "url": null,
      "actor": null,
      "commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#pullrequestreview-78994182",
      "submitted_at": "2017-11-25T06:59:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
    },
    {
      "event": "reviewed",
      "id": 78996802,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg5OTY4MDI=",
      "url": null,
      "actor": null,
      "commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#pullrequestreview-78996802",
      "submitted_at": "2017-11-25T07:00:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
    },
    {
      "event": "reviewed",
      "id": 78999811,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg5OTk4MTE=",
      "url": null,
      "actor": null,
      "commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#pullrequestreview-78999811",
      "submitted_at": "2017-11-25T10:16:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
    },
    {
      "event": "mentioned",
      "id": 1359964863,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTM1OTk2NDg2Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1359964863",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-27T19:32:55Z"
    },
    {
      "event": "subscribed",
      "id": 1359964865,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDEzNTk5NjQ4NjU=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1359964865",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-27T19:32:55Z"
    },
    {
      "event": "mentioned",
      "id": 1360289493,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTM2MDI4OTQ5Mw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1360289493",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-27T22:47:02Z"
    },
    {
      "event": "subscribed",
      "id": 1360289494,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDEzNjAyODk0OTQ=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1360289494",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-27T22:47:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1365837506,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTM2NTgzNzUwNg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1365837506",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-30T15:14:38Z"
    },
    {
      "event": "commented",
      "id": 348218262,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODIxODI2Mg==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/348218262",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-30T15:16:31Z",
      "updated_at": "2017-11-30T15:16:31Z",
      "author_association": "MEMBER",
      "body": "Pushed fixes",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-348218262",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "commented",
      "id": 348303656,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODMwMzY1Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/348303656",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-30T20:01:11Z",
      "updated_at": "2017-11-30T20:01:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "@jonasnick I opened a PR here: https://github.com/jonasnick/secp256k1/pull/1 for suggested changes to save some additions in each _pippenger_wnaf window.\r\n",
      "user": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-348303656",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "mentioned",
      "id": 1366406525,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTM2NjQwNjUyNQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1366406525",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-30T20:01:11Z"
    },
    {
      "event": "subscribed",
      "id": 1366406528,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDEzNjY0MDY1Mjg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1366406528",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-11-30T20:01:11Z"
    },
    {
      "event": "commented",
      "id": 348545656,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODU0NTY1Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/348545656",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-01T16:46:13Z",
      "updated_at": "2017-12-01T16:47:30Z",
      "author_association": "MEMBER",
      "body": "As expected, @peterdettman delivers. I see about 2% to 4% speedup. Merged the commit into this PR.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-348545656",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "mentioned",
      "id": 1367999421,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTM2Nzk5OTQyMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1367999421",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-01T16:46:13Z"
    },
    {
      "event": "subscribed",
      "id": 1367999422,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDEzNjc5OTk0MjI=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1367999422",
      "actor": {
        "login": "peterdettman",
        "id": 3423981,
        "node_id": "MDQ6VXNlcjM0MjM5ODE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3423981?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/peterdettman",
        "html_url": "https://github.com/peterdettman",
        "followers_url": "https://api.github.com/users/peterdettman/followers",
        "following_url": "https://api.github.com/users/peterdettman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/peterdettman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/peterdettman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/peterdettman/subscriptions",
        "organizations_url": "https://api.github.com/users/peterdettman/orgs",
        "repos_url": "https://api.github.com/users/peterdettman/repos",
        "events_url": "https://api.github.com/users/peterdettman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/peterdettman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-01T16:46:13Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1368017408,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTM2ODAxNzQwOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1368017408",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-01T16:55:54Z"
    },
    {
      "event": "reviewed",
      "id": 81029731,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODEwMjk3MzE=",
      "url": null,
      "actor": null,
      "commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "utACK c7723997941576dd03bb1db77dad8d5dc6255924 tree 6f9376c5ebdfe589593fabde10c5d61f5d07ebcc\r\n\r\nPlease squash fixes.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#pullrequestreview-81029731",
      "submitted_at": "2017-12-04T23:54:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1374918417,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTM3NDkxODQxNw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1374918417",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-06T14:46:29Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1374946608,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTM3NDk0NjYwOA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1374946608",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-06T14:59:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1374973210,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTM3NDk3MzIxMA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1374973210",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-06T15:12:14Z"
    },
    {
      "event": "referenced",
      "id": 1374978120,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDEzNzQ5NzgxMjA=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1374978120",
      "actor": {
        "login": "yeastplume",
        "id": 7074070,
        "node_id": "MDQ6VXNlcjcwNzQwNzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7074070?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yeastplume",
        "html_url": "https://github.com/yeastplume",
        "followers_url": "https://api.github.com/users/yeastplume/followers",
        "following_url": "https://api.github.com/users/yeastplume/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yeastplume/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yeastplume/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yeastplume/subscriptions",
        "organizations_url": "https://api.github.com/users/yeastplume/orgs",
        "repos_url": "https://api.github.com/users/yeastplume/repos",
        "events_url": "https://api.github.com/users/yeastplume/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yeastplume/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "9eb90c9fd925a070fd9c865b1b26df082831e9aa",
      "commit_url": "https://api.github.com/repos/mimblewimble/secp256k1-zkp/commits/9eb90c9fd925a070fd9c865b1b26df082831e9aa",
      "created_at": "2017-12-06T15:14:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1375153004,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTM3NTE1MzAwNA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1375153004",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-06T16:31:39Z"
    },
    {
      "event": "commented",
      "id": 349697577,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTY5NzU3Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/349697577",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-06T16:38:00Z",
      "updated_at": "2017-12-06T16:38:18Z",
      "author_association": "MEMBER",
      "body": "Squashed fixes and updated bucket windows. Previous bucket windows did not not include peterdettman's optimization, did not use bench_ecmult and had a bug where the number of points for a bucket window were twice of what they should have been. The result is that the performance without endomorphism is very similar, with endomorphism it's up to 8% faster for some number of points. The performance graph looks very similar to the one above.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-349697577",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "commented",
      "id": 349814989,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTgxNDk4OQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/349814989",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-06T23:56:33Z",
      "updated_at": "2017-12-06T23:56:33Z",
      "author_association": "MEMBER",
      "body": "ACK 50f0779be9c8d67fc5c8ca3a7a21b17da74cfa33",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-349814989",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "reviewed",
      "id": 81712010,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODE3MTIwMTA=",
      "url": null,
      "actor": null,
      "commit_id": "56fb2ccbe94b8e1a9fd3446e3035e427c378bf71",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#pullrequestreview-81712010",
      "submitted_at": "2017-12-07T00:10:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
    },
    {
      "event": "reviewed",
      "id": 81712415,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODE3MTI0MTU=",
      "url": null,
      "actor": null,
      "commit_id": "56fb2ccbe94b8e1a9fd3446e3035e427c378bf71",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#pullrequestreview-81712415",
      "submitted_at": "2017-12-07T00:13:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
    },
    {
      "event": "reviewed",
      "id": 81715003,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODE3MTUwMDM=",
      "url": null,
      "actor": null,
      "commit_id": "da61b77821a6e01071844902b8d691eb698c8cb9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#pullrequestreview-81715003",
      "submitted_at": "2017-12-07T00:29:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
    },
    {
      "event": "reviewed",
      "id": 81717475,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODE3MTc0NzU=",
      "url": null,
      "actor": null,
      "commit_id": "deabf0d88fdacda3400d67f4f9c5875bea9d3284",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#pullrequestreview-81717475",
      "submitted_at": "2017-12-07T00:45:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1377168745,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTM3NzE2ODc0NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1377168745",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-07T15:48:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1377170354,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTM3NzE3MDM1NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1377170354",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-07T15:49:07Z"
    },
    {
      "event": "commented",
      "id": 350007965,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM1MDAwNzk2NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/350007965",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-07T15:49:38Z",
      "updated_at": "2017-12-07T15:49:38Z",
      "author_association": "MEMBER",
      "body": "Pushed fixes",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-350007965",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "mentioned",
      "id": 1377255464,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTM3NzI1NTQ2NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1377255464",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-07T16:29:02Z"
    },
    {
      "event": "subscribed",
      "id": 1377255467,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDEzNzcyNTU0Njc=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1377255467",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-07T16:29:02Z"
    },
    {
      "event": "reviewed",
      "id": 81912802,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODE5MTI4MDI=",
      "url": null,
      "actor": null,
      "commit_id": "396615f1b5ecb0cb501d9358ee8cef320c9323c3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#pullrequestreview-81912802",
      "submitted_at": "2017-12-07T16:29:02Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
    },
    {
      "event": "commented",
      "id": 350029865,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM1MDAyOTg2NQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/350029865",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-07T17:00:10Z",
      "updated_at": "2017-12-07T17:00:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK https://github.com/bitcoin-core/secp256k1/pull/486/commits/5979a573829b166f05ea8e03747bad9225451919 .. please squash. The only nit is the position of the `secp256k1_ecmult_multi_func` typedef, which I don't care about _that_ much.",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-350029865",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6NTQ4ZGU0MmVjZmMxZDliMDg3YWYwYzNhMTQ0ZDVmMzcxZWUyMTg0Ng==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/548de42ecfc1d9b087af0c3a144d5f371ee21846",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/548de42ecfc1d9b087af0c3a144d5f371ee21846",
      "tree": {
        "sha": "3a9c6f87fcceb20880747f046652c03a43a81818",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/3a9c6f87fcceb20880747f046652c03a43a81818"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/6ad5cdb42a1a8257289a0423d644dcbdeab0f83c",
          "sha": "6ad5cdb42a1a8257289a0423d644dcbdeab0f83c",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/6ad5cdb42a1a8257289a0423d644dcbdeab0f83c"
        }
      ],
      "message": "add resizeable scratch space API\n\nAlignment support by Pieter Wuille.",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-12-07T20:13:04Z"
      },
      "author": {
        "name": "Andrew Poelstra",
        "email": "apoelstra@wpsoftware.net",
        "date": "2017-07-22T18:03:17Z"
      },
      "sha": "548de42ecfc1d9b087af0c3a144d5f371ee21846"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6OGMxYzgzMWJkYjA4M2RmYThiNTBmYWMxNmEwZTE3YTdlMWRmNDA2NA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8c1c831bdb083dfa8b50fac16a0e17a7e1df4064",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8c1c831bdb083dfa8b50fac16a0e17a7e1df4064",
      "tree": {
        "sha": "591a823716d5ae03d971631776d17efdcd830f2a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/591a823716d5ae03d971631776d17efdcd830f2a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/548de42ecfc1d9b087af0c3a144d5f371ee21846",
          "sha": "548de42ecfc1d9b087af0c3a144d5f371ee21846",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/548de42ecfc1d9b087af0c3a144d5f371ee21846"
        }
      ],
      "message": "Generalize Strauss to support multiple points\n\nAPI by Andrew Poelstra.",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-12-07T20:13:04Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-08-16T21:45:27Z"
      },
      "sha": "8c1c831bdb083dfa8b50fac16a0e17a7e1df4064"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6ZGJhNTQ3MWI2OTYwYTMyY2UwNjdlZmYwMzY1ZmM4OTMxYTkzMWJhYQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/dba5471b6960a32ce067eff0365fc8931a931baa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/dba5471b6960a32ce067eff0365fc8931a931baa",
      "tree": {
        "sha": "ed3a035c1983b56d136b967b7a4f310721ab3261",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ed3a035c1983b56d136b967b7a4f310721ab3261"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/8c1c831bdb083dfa8b50fac16a0e17a7e1df4064",
          "sha": "8c1c831bdb083dfa8b50fac16a0e17a7e1df4064",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/8c1c831bdb083dfa8b50fac16a0e17a7e1df4064"
        }
      ],
      "message": "Add ecmult_multi tests",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-12-07T20:13:04Z"
      },
      "author": {
        "name": "Andrew Poelstra",
        "email": "apoelstra@wpsoftware.net",
        "date": "2017-08-16T21:45:48Z"
      },
      "sha": "dba5471b6960a32ce067eff0365fc8931a931baa"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6YmM2NWFhNzk0ZTEwZWU1ZjAyNjE4MjFiZDJmMzc0ODQzYzc0N2Q1YQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/bc65aa794e10ee5f0261821bd2f374843c747d5a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/bc65aa794e10ee5f0261821bd2f374843c747d5a",
      "tree": {
        "sha": "d359fc6b4e6df319c9f26bf421082d63173bf808",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/d359fc6b4e6df319c9f26bf421082d63173bf808"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/dba5471b6960a32ce067eff0365fc8931a931baa",
          "sha": "dba5471b6960a32ce067eff0365fc8931a931baa",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/dba5471b6960a32ce067eff0365fc8931a931baa"
        }
      ],
      "message": "Add bench_ecmult",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-12-07T20:13:04Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-09-13T03:05:39Z"
      },
      "sha": "bc65aa794e10ee5f0261821bd2f374843c747d5a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MzU1YTM4ZjExMzkyNTc5OWYzOGU4YjNkYmUxZTY2ZGIxYzdlNGNmYQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/355a38f113925799f38e8b3dbe1e66db1c7e4cfa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/355a38f113925799f38e8b3dbe1e66db1c7e4cfa",
      "tree": {
        "sha": "cacacb9f00b9663b845ca7499c28daddee119a73",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/cacacb9f00b9663b845ca7499c28daddee119a73"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/bc65aa794e10ee5f0261821bd2f374843c747d5a",
          "sha": "bc65aa794e10ee5f0261821bd2f374843c747d5a",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/bc65aa794e10ee5f0261821bd2f374843c747d5a"
        }
      ],
      "message": "Add pippenger_wnaf ecmult_multi",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-12-07T20:13:04Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-09-14T15:55:13Z"
      },
      "sha": "355a38f113925799f38e8b3dbe1e66db1c7e4cfa"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6MzZiMjJjOTMzN2RiYWEzZGI5M2Q4NzgzMmI2ZmY1MjI3MzEzNTAzMQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/36b22c9337dbaa3db93d87832b6ff52273135031",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/36b22c9337dbaa3db93d87832b6ff52273135031",
      "tree": {
        "sha": "e35f36985f355b7da54aff79affeb376109850ef",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/e35f36985f355b7da54aff79affeb376109850ef"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/355a38f113925799f38e8b3dbe1e66db1c7e4cfa",
          "sha": "355a38f113925799f38e8b3dbe1e66db1c7e4cfa",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/355a38f113925799f38e8b3dbe1e66db1c7e4cfa"
        }
      ],
      "message": "Use scratch space dependent batching in ecmult_multi",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-12-07T20:13:04Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-11-05T19:40:18Z"
      },
      "sha": "36b22c9337dbaa3db93d87832b6ff52273135031"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6YTU4ZjU0M2Y1YWMxMGY4ZmNhNGE2ZTZjMDAyMmUxNzBmOTJiOTZjOQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a58f543f5ac10f8fca4a6e6c0022e170f92b96c9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a58f543f5ac10f8fca4a6e6c0022e170f92b96c9",
      "tree": {
        "sha": "965cd85ce233a344ed846011acba39a7c6e67eb3",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/965cd85ce233a344ed846011acba39a7c6e67eb3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/36b22c9337dbaa3db93d87832b6ff52273135031",
          "sha": "36b22c9337dbaa3db93d87832b6ff52273135031",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/36b22c9337dbaa3db93d87832b6ff52273135031"
        }
      ],
      "message": "Add flags for choosing algorithm in ecmult_multi benchmark",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-12-07T20:13:04Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-11-05T20:17:11Z"
      },
      "sha": "a58f543f5ac10f8fca4a6e6c0022e170f92b96c9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6NGM5NTBiYmVhZmI0Y2JiZWI1ZmZjNzQyYTI5ZTkxNjIyNGZiY2I0ZQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4c950bbeafb4cbbeb5ffc742a29e916224fbcb4e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4c950bbeafb4cbbeb5ffc742a29e916224fbcb4e",
      "tree": {
        "sha": "091692a30b8b8a35836190cb49227c1fa862f38a",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/091692a30b8b8a35836190cb49227c1fa862f38a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/a58f543f5ac10f8fca4a6e6c0022e170f92b96c9",
          "sha": "a58f543f5ac10f8fca4a6e6c0022e170f92b96c9",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/a58f543f5ac10f8fca4a6e6c0022e170f92b96c9"
        }
      ],
      "message": "Save some additions per window in _pippenger_wnaf",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-12-07T20:13:04Z"
      },
      "author": {
        "name": "Peter Dettman",
        "email": "peter.dettman@gmail.com",
        "date": "2017-11-30T19:52:19Z"
      },
      "sha": "4c950bbeafb4cbbeb5ffc742a29e916224fbcb4e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTY2NDg2MTg6ZDJmOWM2YjVkYzhiZDhmZWQyMGYwNDZiMThiMzY4YjE3MTVkNzIwYQ==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin-core/secp256k1/commit/d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "tree": {
        "sha": "ddbe3da06e16b526e27bfd551e76f1ea03b1e55b",
        "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/trees/ddbe3da06e16b526e27bfd551e76f1ea03b1e55b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin-core/secp256k1/git/commits/4c950bbeafb4cbbeb5ffc742a29e916224fbcb4e",
          "sha": "4c950bbeafb4cbbeb5ffc742a29e916224fbcb4e",
          "html_url": "https://github.com/bitcoin-core/secp256k1/commit/4c950bbeafb4cbbeb5ffc742a29e916224fbcb4e"
        }
      ],
      "message": "Use more precise pippenger bucket windows",
      "committer": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-12-07T20:13:04Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2017-12-06T10:24:00Z"
      },
      "sha": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1377660070,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTM3NzY2MDA3MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1377660070",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-07T20:13:09Z"
    },
    {
      "event": "commented",
      "id": 350081257,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM1MDA4MTI1Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/comments/350081257",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-07T20:13:42Z",
      "updated_at": "2017-12-07T20:13:42Z",
      "author_association": "MEMBER",
      "body": "Squashed",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#issuecomment-350081257",
      "issue_url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/486"
    },
    {
      "event": "merged",
      "id": 1378092377,
      "node_id": "MDExOk1lcmdlZEV2ZW50MTM3ODA5MjM3Nw==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1378092377",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "created_at": "2017-12-08T01:59:47Z"
    },
    {
      "event": "closed",
      "id": 1378092380,
      "node_id": "MDExOkNsb3NlZEV2ZW50MTM3ODA5MjM4MA==",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1378092380",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-12-08T01:59:47Z"
    },
    {
      "event": "referenced",
      "id": 1378092388,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDEzNzgwOTIzODg=",
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/issues/events/1378092388",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "c77fc08597960d662eb0df9e4c670c31bdeb227e",
      "commit_url": "https://api.github.com/repos/bitcoin-core/secp256k1/commits/c77fc08597960d662eb0df9e4c670c31bdeb227e",
      "created_at": "2017-12-08T01:59:48Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/150985833",
      "pull_request_review_id": 76621287,
      "id": 150985833,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MDk4NTgzMw==",
      "diff_hunk": "@@ -403,4 +477,538 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {\n+        return 1;\n+    } else if (n <= 8) {\n+        return 2;\n+    } else if (n <= 40) {\n+        return 3;\n+    } else if (n <= 117) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 480) {\n+        return 6;\n+    } else if (n <= 2560) {\n+        return 7;\n+    } else if (n <= 9200) {\n+        return 9;\n+    } else if (n <= 17400) {\n+        return 10;\n+    } else if (n <= 28600) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#else\n+    if (n <= 2) {\n+        return 1;\n+    } else if (n <= 9) {\n+        return 2;\n+    } else if (n <= 42) {\n+        return 3;\n+    } else if (n <= 100) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 610) {\n+        return 6;\n+    } else if (n <= 1920) {\n+        return 7;\n+    } else if (n <= 3400) {\n+        return 8;\n+    } else if (n <= 10240) {\n+        return 9;\n+    } else if (n <= 19000) {\n+        return 10;\n+    } else if (n <= 35000) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#endif\n+}\n+\n+static int secp256k1_pippenger_bucket_window_inv(size_t bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    if(bucket_window == 1) {\n+        return 4;\n+    } else if(bucket_window == 2) {\n+        return 8;\n+    } else if(bucket_window == 3) {\n+        return 40;\n+    } else if(bucket_window == 4) {\n+        return 117;\n+    } else if(bucket_window == 5) {\n+        return 280;\n+    } else if(bucket_window == 6) {\n+        return 480;\n+    } else if(bucket_window == 7) {\n+        return 2560;\n+    } else if(bucket_window == 8) {\n+        return 2560;\n+    } else if(bucket_window == 9) {\n+        return 9200;\n+    } else if(bucket_window == 10) {\n+        return 17400;\n+    } else if(bucket_window == 11) {\n+        return 28600;\n+    } else if(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW) {\n+        return INT_MAX;",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 557,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "be3248f50ac6a5bab2f3d0ad7279dad760d9489b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "INT_MAX is not defined.",
      "created_at": "2017-11-14T22:39:49Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r150985833",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/150985833"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 783,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/151186173",
      "pull_request_review_id": 76853520,
      "id": 151186173,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MTE4NjE3Mw==",
      "diff_hunk": "@@ -403,4 +477,538 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {\n+        return 1;\n+    } else if (n <= 8) {\n+        return 2;\n+    } else if (n <= 40) {\n+        return 3;\n+    } else if (n <= 117) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 480) {\n+        return 6;\n+    } else if (n <= 2560) {\n+        return 7;\n+    } else if (n <= 9200) {\n+        return 9;\n+    } else if (n <= 17400) {\n+        return 10;\n+    } else if (n <= 28600) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#else\n+    if (n <= 2) {\n+        return 1;\n+    } else if (n <= 9) {\n+        return 2;\n+    } else if (n <= 42) {\n+        return 3;\n+    } else if (n <= 100) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 610) {\n+        return 6;\n+    } else if (n <= 1920) {\n+        return 7;\n+    } else if (n <= 3400) {\n+        return 8;\n+    } else if (n <= 10240) {\n+        return 9;\n+    } else if (n <= 19000) {\n+        return 10;\n+    } else if (n <= 35000) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#endif\n+}\n+\n+static int secp256k1_pippenger_bucket_window_inv(size_t bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    if(bucket_window == 1) {\n+        return 4;\n+    } else if(bucket_window == 2) {\n+        return 8;\n+    } else if(bucket_window == 3) {\n+        return 40;\n+    } else if(bucket_window == 4) {\n+        return 117;\n+    } else if(bucket_window == 5) {\n+        return 280;\n+    } else if(bucket_window == 6) {\n+        return 480;\n+    } else if(bucket_window == 7) {\n+        return 2560;\n+    } else if(bucket_window == 8) {\n+        return 2560;\n+    } else if(bucket_window == 9) {\n+        return 9200;\n+    } else if(bucket_window == 10) {\n+        return 17400;\n+    } else if(bucket_window == 11) {\n+        return 28600;\n+    } else if(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW) {\n+        return INT_MAX;",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 557,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "be3248f50ac6a5bab2f3d0ad7279dad760d9489b",
      "in_reply_to_id": 150985833,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`#include <limits.h>`  ?",
      "created_at": "2017-11-15T16:52:38Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r151186173",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/151186173"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 783,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/152877036",
      "pull_request_review_id": 78806326,
      "id": 152877036,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1Mjg3NzAzNg==",
      "diff_hunk": "@@ -243,6 +256,28 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n     const void* data\n ) SECP256K1_ARG_NONNULL(1);\n \n+/** Create a secp256k1 scratch space object.\n+ *\n+ *  Returns: a newly created scratch space.\n+ *  Args: ctx:  an existing context object (cannot be NULL)\n+ *  In:  init_size: initial amount of memory to allocate\n+ *        max_size: maximum amount of memory to allocat",
      "path": "include/secp256k1.h",
      "position": null,
      "original_position": 29,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "be8abb5ad18c334dc2367df1f183e3c00c7d469f",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: allocat",
      "created_at": "2017-11-23T22:19:58Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r152877036",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/152877036"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/152877180",
      "pull_request_review_id": 78806326,
      "id": 152877180,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1Mjg3NzE4MA==",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCRATCH_IMPL_H_\n+#define _SECP256K1_SCRATCH_IMPL_H_\n+\n+#include \"scratch.h\"\n+\n+#define ALIGNMENT 16",
      "path": "src/scratch_impl.h",
      "position": null,
      "original_position": 12,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "be8abb5ad18c334dc2367df1f183e3c00c7d469f",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Add a comment to explain that we assume that common architectures never have alignment requirements above 8 for any of the types we care about (and make it 16 because who cares about a few byes)?",
      "created_at": "2017-11-23T22:22:06Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r152877180",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/152877180"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/152877963",
      "pull_request_review_id": 78806326,
      "id": 152877963,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1Mjg3Nzk2Mw==",
      "diff_hunk": "@@ -403,4 +457,94 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static int secp256k1_ecmult_multi_split_strauss_wnaf(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    secp256k1_gej acc;\n+    size_t in_pos = 0, out_pos = 0;\n+    int first = 1;\n+\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (sizeof(secp256k1_gej) + sizeof(secp256k1_fe) + sizeof(secp256k1_ge) * 2) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_gej) + sizeof(secp256k1_fe) + sizeof(secp256k1_ge)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+\n+    size_t max_points = secp256k1_scratch_max_allocation(scratch, 6) / point_size;\n+    size_t n_batches, points_per_batch;\n+    struct secp256k1_strauss_state state;\n+\n+    if (max_points == 0) return 0;\n+    if (max_points > 160) max_points = 160; /* At this point, gains are not longer compensating for locality degradation */\n+    n_batches = (n + max_points - 1) / max_points;\n+    points_per_batch = (n + n_batches - 1) / n_batches;\n+\n+    /* Attempt to allocate sufficient space for Strauss */",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 266,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "541ea3fc14efd79dedb7bc3dcb36e2e7f5f30e7d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@apoelstra Is this halving loop still necessary? The max allocation call above should be perfect, so I think we can just assert that this never fails.",
      "created_at": "2017-11-23T22:36:05Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r152877963",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/152877963"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 502,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153036782",
      "pull_request_review_id": 78994182,
      "id": 153036782,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzAzNjc4Mg==",
      "diff_hunk": "@@ -1,5 +1,5 @@\n /**********************************************************************\n- * Copyright (c) 2013, 2014 Pieter Wuille                             *\n+ * Copyright (c) 2013, 2014, 2017 Pieter Wuille, Andrew Poelstra      *",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 3,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This needs a \"Jonas Nick\", I think.",
      "created_at": "2017-11-25T03:17:15Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153036782",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153036782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039101",
      "pull_request_review_id": 78994182,
      "id": 153039101,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzAzOTEwMQ==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {",
      "path": "src/ecmult_impl.h",
      "position": 273,
      "original_position": 268,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "At some point this should be renamed to `_var` as well, but let's leave that for later.",
      "created_at": "2017-11-25T06:27:09Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153039101",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 487,
      "original_line": 487,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039163",
      "pull_request_review_id": 78994182,
      "id": 153039163,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzAzOTE2Mw==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 345,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "These two lines are more accurately and correctly written as `each wnaf[i] is either zero or an odd integer between -(1 << w) and (1 << w)`.",
      "created_at": "2017-11-25T06:31:26Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153039163",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039163"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 564,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039266",
      "pull_request_review_id": 78994182,
      "id": 153039266,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzAzOTI2Ng==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 494,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe write this in a tree structure rather than linear (as in: top level is is a bisection for first half/second half) etc.",
      "created_at": "2017-11-25T06:40:10Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153039266",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039266"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 719,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039286",
      "pull_request_review_id": 78994182,
      "id": 153039286,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzAzOTI4Ng==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {\n+        return 1;\n+    } else if (n <= 8) {\n+        return 2;\n+    } else if (n <= 40) {\n+        return 3;\n+    } else if (n <= 117) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 480) {\n+        return 6;\n+    } else if (n <= 2560) {\n+        return 7;\n+    } else if (n <= 9200) {\n+        return 9;\n+    } else if (n <= 17400) {\n+        return 10;\n+    } else if (n <= 28600) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#else\n+    if (n <= 2) {\n+        return 1;\n+    } else if (n <= 9) {\n+        return 2;\n+    } else if (n <= 42) {\n+        return 3;\n+    } else if (n <= 100) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 610) {\n+        return 6;\n+    } else if (n <= 1920) {\n+        return 7;\n+    } else if (n <= 3400) {\n+        return 8;\n+    } else if (n <= 10240) {\n+        return 9;\n+    } else if (n <= 19000) {\n+        return 10;\n+    } else if (n <= 35000) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#endif\n+}\n+\n+static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    if(bucket_window == 1) {",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 548,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: space after `if`.",
      "created_at": "2017-11-25T06:41:42Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153039286",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039286"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 767,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039380",
      "pull_request_review_id": 78994182,
      "id": 153039380,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzAzOTM4MA==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 474,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do you need a separate variable for `walking_sum`? Can't you reuse `r` for this?",
      "created_at": "2017-11-25T06:51:23Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153039380",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039380"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 692,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039433",
      "pull_request_review_id": 78994182,
      "id": 153039433,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzAzOTQzMw==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {\n+        return 1;\n+    } else if (n <= 8) {\n+        return 2;\n+    } else if (n <= 40) {\n+        return 3;\n+    } else if (n <= 117) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 480) {\n+        return 6;\n+    } else if (n <= 2560) {\n+        return 7;\n+    } else if (n <= 9200) {\n+        return 9;\n+    } else if (n <= 17400) {\n+        return 10;\n+    } else if (n <= 28600) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#else\n+    if (n <= 2) {\n+        return 1;\n+    } else if (n <= 9) {\n+        return 2;\n+    } else if (n <= 42) {\n+        return 3;\n+    } else if (n <= 100) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 610) {\n+        return 6;\n+    } else if (n <= 1920) {\n+        return 7;\n+    } else if (n <= 3400) {\n+        return 8;\n+    } else if (n <= 10240) {\n+        return 9;\n+    } else if (n <= 19000) {\n+        return 10;\n+    } else if (n <= 35000) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#endif\n+}\n+\n+static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    if(bucket_window == 1) {\n+        return 4;\n+    } else if(bucket_window == 2) {\n+        return 8;\n+    } else if(bucket_window == 3) {\n+        return 40;\n+    } else if(bucket_window == 4) {\n+        return 117;\n+    } else if(bucket_window == 5) {\n+        return 280;\n+    } else if(bucket_window == 6) {\n+        return 480;\n+    } else if(bucket_window == 7) {\n+        return 2560;\n+    } else if(bucket_window == 8) {\n+        return 2560;\n+    } else if(bucket_window == 9) {\n+        return 9200;\n+    } else if(bucket_window == 10) {\n+        return 17400;\n+    } else if(bucket_window == 11) {\n+        return 28600;\n+    } else if(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW) {\n+        return SIZE_MAX;\n+    }\n+#else\n+    if(bucket_window == 1) {\n+        return 2;\n+    } else if(bucket_window == 2) {\n+        return 9;\n+    } else if(bucket_window == 3) {\n+        return 42;\n+    } else if(bucket_window == 4) {\n+        return 100;\n+    } else if(bucket_window == 5) {\n+        return 280;\n+    } else if(bucket_window == 6) {\n+        return 610;\n+    } else if(bucket_window == 7) {\n+        return 1920;\n+    } else if(bucket_window == 8) {\n+        return 3400;\n+    } else if(bucket_window == 9) {\n+        return 10240;\n+    } else if(bucket_window == 10) {\n+        return 19000;\n+    } else if(bucket_window == 11) {\n+        return 35000;\n+    } else if(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW) {\n+        return SIZE_MAX;\n+    }\n+#endif\n+    return 0;\n+}\n+\n+\n+#ifdef USE_ENDOMORPHISM\n+SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, secp256k1_scalar *s2, secp256k1_ge *p1, secp256k1_ge *p2) {\n+    secp256k1_scalar tmp = *s1;\n+    secp256k1_scalar_split_lambda(s1, s2, &tmp);\n+    secp256k1_ge_mul_lambda(p2, p1);\n+\n+    if (secp256k1_scalar_is_high(s1)) {\n+        secp256k1_scalar_negate(s1, s1);\n+        secp256k1_ge_neg(p1, p1);\n+    }\n+    if (secp256k1_scalar_is_high(s2)) {\n+        secp256k1_scalar_negate(s2, s2);\n+        secp256k1_ge_neg(p2, p2);\n+    }\n+}\n+#endif\n+\n+/**\n+ * Returns the scratch size required for a given number of points (excluding\n+ * base point G) without considering alignment.\n+ */\n+static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+    return ((1<<bucket_window) * sizeof(secp256k1_gej) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size);\n+}\n+\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n+     * sizes. The reason for +1 is that we add the G scalar to the list of\n+     * other scalars. */\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    secp256k1_ge *points;\n+    secp256k1_scalar *scalars;\n+    secp256k1_gej *buckets;\n+    struct secp256k1_pippenger_state *state_space;\n+    size_t idx = 0;\n+    size_t point_idx = 0;\n+    int i, j;\n+    int bucket_window;\n+\n+    (void)ctx;\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, (1<<bucket_window) * sizeof(*buckets));\n+\n+    if (inp_g_sc != NULL) {\n+        scalars[0] = *inp_g_sc;\n+        points[0] = secp256k1_ge_const_g;\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n+        idx++;\n+#endif\n+    }\n+\n+    while (point_idx < n_points) {\n+        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n+            return 0;\n+        }\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n+        idx++;\n+#endif\n+        point_idx++;\n+    }\n+\n+    secp256k1_ecmult_pippenger_wnaf(buckets, bucket_window, state_space, r, scalars, points, idx);\n+\n+    /* Clear data */\n+    for(i = 0; (size_t)i < idx; i++) {\n+        secp256k1_scalar_clear(&scalars[i]);\n+        state_space->ps[i].skew_na = 0;\n+        for(j = 0; j < WNAF_SIZE(bucket_window+1); j++) {\n+            state_space->wnaf_na[i * WNAF_SIZE(bucket_window+1) + j] = 0;\n+        }\n+    }\n+    for(i = 0; i < 1<<bucket_window; i++) {\n+        secp256k1_gej_clear(&buckets[i]);\n+    }\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+/**\n+ * Returns the maximum number of points in addition to G that can be used with\n+ * a given scratch space. The function ensures that fewer points may also be\n+ * used.\n+ */\n+static size_t secp256k1_pippenger_max_points(secp256k1_scratch *scratch) {\n+    ssize_t max_alloc = secp256k1_scratch_max_allocation(scratch, PIPPENGER_SCRATCH_OBJECTS);\n+    int bucket_window;\n+    size_t res = 0;\n+\n+    for (bucket_window = 1; bucket_window <= PIPPENGER_MAX_BUCKET_WINDOW; bucket_window++) {\n+        size_t n_points;\n+        size_t max_points = secp256k1_pippenger_bucket_window_inv(bucket_window);\n+        ssize_t space_for_points;\n+        size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+\n+#ifdef USE_ENDOMORPHISM\n+        entry_size = 2*entry_size;\n+#endif\n+        space_for_points = max_alloc - ((1<<bucket_window) * sizeof(secp256k1_gej) + entry_size + sizeof(struct secp256k1_pippenger_state));\n+        if (space_for_points < 0) {\n+            break;\n+        }\n+        n_points = space_for_points/entry_size;\n+        n_points = n_points > max_points ? max_points : n_points;\n+        if (n_points > res) {\n+            res = n_points;\n+        }\n+        if(n_points < max_points) {",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 742,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: space after `if`.",
      "created_at": "2017-11-25T06:55:25Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153039433",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039433"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 961,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039440",
      "pull_request_review_id": 78994182,
      "id": 153039440,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzAzOTQ0MA==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {\n+        return 1;\n+    } else if (n <= 8) {\n+        return 2;\n+    } else if (n <= 40) {\n+        return 3;\n+    } else if (n <= 117) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 480) {\n+        return 6;\n+    } else if (n <= 2560) {\n+        return 7;\n+    } else if (n <= 9200) {\n+        return 9;\n+    } else if (n <= 17400) {\n+        return 10;\n+    } else if (n <= 28600) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#else\n+    if (n <= 2) {\n+        return 1;\n+    } else if (n <= 9) {\n+        return 2;\n+    } else if (n <= 42) {\n+        return 3;\n+    } else if (n <= 100) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 610) {\n+        return 6;\n+    } else if (n <= 1920) {\n+        return 7;\n+    } else if (n <= 3400) {\n+        return 8;\n+    } else if (n <= 10240) {\n+        return 9;\n+    } else if (n <= 19000) {\n+        return 10;\n+    } else if (n <= 35000) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#endif\n+}\n+\n+static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    if(bucket_window == 1) {\n+        return 4;\n+    } else if(bucket_window == 2) {\n+        return 8;\n+    } else if(bucket_window == 3) {\n+        return 40;\n+    } else if(bucket_window == 4) {\n+        return 117;\n+    } else if(bucket_window == 5) {\n+        return 280;\n+    } else if(bucket_window == 6) {\n+        return 480;\n+    } else if(bucket_window == 7) {\n+        return 2560;\n+    } else if(bucket_window == 8) {\n+        return 2560;\n+    } else if(bucket_window == 9) {\n+        return 9200;\n+    } else if(bucket_window == 10) {\n+        return 17400;\n+    } else if(bucket_window == 11) {\n+        return 28600;\n+    } else if(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW) {\n+        return SIZE_MAX;\n+    }\n+#else\n+    if(bucket_window == 1) {\n+        return 2;\n+    } else if(bucket_window == 2) {\n+        return 9;\n+    } else if(bucket_window == 3) {\n+        return 42;\n+    } else if(bucket_window == 4) {\n+        return 100;\n+    } else if(bucket_window == 5) {\n+        return 280;\n+    } else if(bucket_window == 6) {\n+        return 610;\n+    } else if(bucket_window == 7) {\n+        return 1920;\n+    } else if(bucket_window == 8) {\n+        return 3400;\n+    } else if(bucket_window == 9) {\n+        return 10240;\n+    } else if(bucket_window == 10) {\n+        return 19000;\n+    } else if(bucket_window == 11) {\n+        return 35000;\n+    } else if(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW) {\n+        return SIZE_MAX;\n+    }\n+#endif\n+    return 0;\n+}\n+\n+\n+#ifdef USE_ENDOMORPHISM\n+SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, secp256k1_scalar *s2, secp256k1_ge *p1, secp256k1_ge *p2) {\n+    secp256k1_scalar tmp = *s1;\n+    secp256k1_scalar_split_lambda(s1, s2, &tmp);\n+    secp256k1_ge_mul_lambda(p2, p1);\n+\n+    if (secp256k1_scalar_is_high(s1)) {\n+        secp256k1_scalar_negate(s1, s1);\n+        secp256k1_ge_neg(p1, p1);\n+    }\n+    if (secp256k1_scalar_is_high(s2)) {\n+        secp256k1_scalar_negate(s2, s2);\n+        secp256k1_ge_neg(p2, p2);\n+    }\n+}\n+#endif\n+\n+/**\n+ * Returns the scratch size required for a given number of points (excluding\n+ * base point G) without considering alignment.\n+ */\n+static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+    return ((1<<bucket_window) * sizeof(secp256k1_gej) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size);\n+}\n+\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n+     * sizes. The reason for +1 is that we add the G scalar to the list of\n+     * other scalars. */\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    secp256k1_ge *points;\n+    secp256k1_scalar *scalars;\n+    secp256k1_gej *buckets;\n+    struct secp256k1_pippenger_state *state_space;\n+    size_t idx = 0;\n+    size_t point_idx = 0;\n+    int i, j;\n+    int bucket_window;\n+\n+    (void)ctx;\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, (1<<bucket_window) * sizeof(*buckets));\n+\n+    if (inp_g_sc != NULL) {\n+        scalars[0] = *inp_g_sc;\n+        points[0] = secp256k1_ge_const_g;\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n+        idx++;\n+#endif\n+    }\n+\n+    while (point_idx < n_points) {\n+        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n+            return 0;\n+        }\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n+        idx++;\n+#endif\n+        point_idx++;\n+    }\n+\n+    secp256k1_ecmult_pippenger_wnaf(buckets, bucket_window, state_space, r, scalars, points, idx);\n+\n+    /* Clear data */\n+    for(i = 0; (size_t)i < idx; i++) {\n+        secp256k1_scalar_clear(&scalars[i]);\n+        state_space->ps[i].skew_na = 0;\n+        for(j = 0; j < WNAF_SIZE(bucket_window+1); j++) {\n+            state_space->wnaf_na[i * WNAF_SIZE(bucket_window+1) + j] = 0;\n+        }\n+    }\n+    for(i = 0; i < 1<<bucket_window; i++) {\n+        secp256k1_gej_clear(&buckets[i]);\n+    }\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+/**\n+ * Returns the maximum number of points in addition to G that can be used with\n+ * a given scratch space. The function ensures that fewer points may also be\n+ * used.\n+ */\n+static size_t secp256k1_pippenger_max_points(secp256k1_scratch *scratch) {\n+    ssize_t max_alloc = secp256k1_scratch_max_allocation(scratch, PIPPENGER_SCRATCH_OBJECTS);\n+    int bucket_window;\n+    size_t res = 0;\n+\n+    for (bucket_window = 1; bucket_window <= PIPPENGER_MAX_BUCKET_WINDOW; bucket_window++) {\n+        size_t n_points;\n+        size_t max_points = secp256k1_pippenger_bucket_window_inv(bucket_window);\n+        ssize_t space_for_points;\n+        size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+\n+#ifdef USE_ENDOMORPHISM\n+        entry_size = 2*entry_size;\n+#endif\n+        space_for_points = max_alloc - ((1<<bucket_window) * sizeof(secp256k1_gej) + entry_size + sizeof(struct secp256k1_pippenger_state));\n+        if (space_for_points < 0) {\n+            break;\n+        }\n+        n_points = space_for_points/entry_size;\n+        n_points = n_points > max_points ? max_points : n_points;\n+        if (n_points > res) {\n+            res = n_points;\n+        }\n+        if(n_points < max_points) {\n+            /* A larger bucket_window may support even more points. But if we\n+             * would choose that then the caller couldn't safely use any number\n+             * smaller than what this function returns */\n+            break;\n+        }\n+    }\n+    return res;\n+}\n+\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_ecmult_context*, secp256k1_scratch*, const secp256k1_callback*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    size_t i;\n+\n+    int (*f)(const secp256k1_ecmult_context*, secp256k1_scratch*, const secp256k1_callback*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    size_t max_points;\n+    size_t n_batches;\n+    size_t n_batch_points;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n == 0) {\n+        return 1;\n+    } else if (n == 0) {\n+        secp256k1_scalar szero;\n+        secp256k1_scalar_set_int(&szero, 0);\n+        secp256k1_ecmult(ctx, r, r, &szero, inp_g_sc);\n+        return 1;\n+    }\n+\n+    max_points = secp256k1_pippenger_max_points(scratch);\n+    if (max_points == 0) {\n+        return 0;\n+    } else if (max_points > ECMULT_MAX_POINTS_PER_BATCH) {\n+        max_points = ECMULT_MAX_POINTS_PER_BATCH;\n+    }\n+    n_batches = (n+max_points-1)/max_points;\n+    n_batch_points = (n+n_batches-1)/n_batches;\n+\n+    if(n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 780,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: space after `if`.",
      "created_at": "2017-11-25T06:56:20Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153039440",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039440"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 999,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039452",
      "pull_request_review_id": 78994182,
      "id": 153039452,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzAzOTQ1Mg==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {\n+        return 1;\n+    } else if (n <= 8) {\n+        return 2;\n+    } else if (n <= 40) {\n+        return 3;\n+    } else if (n <= 117) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 480) {\n+        return 6;\n+    } else if (n <= 2560) {\n+        return 7;\n+    } else if (n <= 9200) {\n+        return 9;\n+    } else if (n <= 17400) {\n+        return 10;\n+    } else if (n <= 28600) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#else\n+    if (n <= 2) {\n+        return 1;\n+    } else if (n <= 9) {\n+        return 2;\n+    } else if (n <= 42) {\n+        return 3;\n+    } else if (n <= 100) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 610) {\n+        return 6;\n+    } else if (n <= 1920) {\n+        return 7;\n+    } else if (n <= 3400) {\n+        return 8;\n+    } else if (n <= 10240) {\n+        return 9;\n+    } else if (n <= 19000) {\n+        return 10;\n+    } else if (n <= 35000) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#endif\n+}\n+\n+static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    if(bucket_window == 1) {\n+        return 4;\n+    } else if(bucket_window == 2) {\n+        return 8;\n+    } else if(bucket_window == 3) {\n+        return 40;\n+    } else if(bucket_window == 4) {\n+        return 117;\n+    } else if(bucket_window == 5) {\n+        return 280;\n+    } else if(bucket_window == 6) {\n+        return 480;\n+    } else if(bucket_window == 7) {\n+        return 2560;\n+    } else if(bucket_window == 8) {\n+        return 2560;\n+    } else if(bucket_window == 9) {\n+        return 9200;\n+    } else if(bucket_window == 10) {\n+        return 17400;\n+    } else if(bucket_window == 11) {\n+        return 28600;\n+    } else if(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW) {\n+        return SIZE_MAX;\n+    }\n+#else\n+    if(bucket_window == 1) {\n+        return 2;\n+    } else if(bucket_window == 2) {\n+        return 9;\n+    } else if(bucket_window == 3) {\n+        return 42;\n+    } else if(bucket_window == 4) {\n+        return 100;\n+    } else if(bucket_window == 5) {\n+        return 280;\n+    } else if(bucket_window == 6) {\n+        return 610;\n+    } else if(bucket_window == 7) {\n+        return 1920;\n+    } else if(bucket_window == 8) {\n+        return 3400;\n+    } else if(bucket_window == 9) {\n+        return 10240;\n+    } else if(bucket_window == 10) {\n+        return 19000;\n+    } else if(bucket_window == 11) {\n+        return 35000;\n+    } else if(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW) {\n+        return SIZE_MAX;\n+    }\n+#endif\n+    return 0;\n+}\n+\n+\n+#ifdef USE_ENDOMORPHISM\n+SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, secp256k1_scalar *s2, secp256k1_ge *p1, secp256k1_ge *p2) {\n+    secp256k1_scalar tmp = *s1;\n+    secp256k1_scalar_split_lambda(s1, s2, &tmp);\n+    secp256k1_ge_mul_lambda(p2, p1);\n+\n+    if (secp256k1_scalar_is_high(s1)) {\n+        secp256k1_scalar_negate(s1, s1);\n+        secp256k1_ge_neg(p1, p1);\n+    }\n+    if (secp256k1_scalar_is_high(s2)) {\n+        secp256k1_scalar_negate(s2, s2);\n+        secp256k1_ge_neg(p2, p2);\n+    }\n+}\n+#endif\n+\n+/**\n+ * Returns the scratch size required for a given number of points (excluding\n+ * base point G) without considering alignment.\n+ */\n+static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+    return ((1<<bucket_window) * sizeof(secp256k1_gej) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size);\n+}\n+\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n+     * sizes. The reason for +1 is that we add the G scalar to the list of\n+     * other scalars. */\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    secp256k1_ge *points;\n+    secp256k1_scalar *scalars;\n+    secp256k1_gej *buckets;\n+    struct secp256k1_pippenger_state *state_space;\n+    size_t idx = 0;\n+    size_t point_idx = 0;\n+    int i, j;\n+    int bucket_window;\n+\n+    (void)ctx;\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, (1<<bucket_window) * sizeof(*buckets));\n+\n+    if (inp_g_sc != NULL) {\n+        scalars[0] = *inp_g_sc;\n+        points[0] = secp256k1_ge_const_g;\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n+        idx++;\n+#endif\n+    }\n+\n+    while (point_idx < n_points) {\n+        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n+            return 0;\n+        }\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n+        idx++;\n+#endif\n+        point_idx++;\n+    }\n+\n+    secp256k1_ecmult_pippenger_wnaf(buckets, bucket_window, state_space, r, scalars, points, idx);\n+\n+    /* Clear data */\n+    for(i = 0; (size_t)i < idx; i++) {\n+        secp256k1_scalar_clear(&scalars[i]);\n+        state_space->ps[i].skew_na = 0;\n+        for(j = 0; j < WNAF_SIZE(bucket_window+1); j++) {\n+            state_space->wnaf_na[i * WNAF_SIZE(bucket_window+1) + j] = 0;\n+        }\n+    }\n+    for(i = 0; i < 1<<bucket_window; i++) {\n+        secp256k1_gej_clear(&buckets[i]);\n+    }\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+/**\n+ * Returns the maximum number of points in addition to G that can be used with\n+ * a given scratch space. The function ensures that fewer points may also be\n+ * used.\n+ */\n+static size_t secp256k1_pippenger_max_points(secp256k1_scratch *scratch) {\n+    ssize_t max_alloc = secp256k1_scratch_max_allocation(scratch, PIPPENGER_SCRATCH_OBJECTS);\n+    int bucket_window;\n+    size_t res = 0;\n+\n+    for (bucket_window = 1; bucket_window <= PIPPENGER_MAX_BUCKET_WINDOW; bucket_window++) {\n+        size_t n_points;\n+        size_t max_points = secp256k1_pippenger_bucket_window_inv(bucket_window);\n+        ssize_t space_for_points;\n+        size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+\n+#ifdef USE_ENDOMORPHISM\n+        entry_size = 2*entry_size;\n+#endif\n+        space_for_points = max_alloc - ((1<<bucket_window) * sizeof(secp256k1_gej) + entry_size + sizeof(struct secp256k1_pippenger_state));\n+        if (space_for_points < 0) {\n+            break;\n+        }\n+        n_points = space_for_points/entry_size;\n+        n_points = n_points > max_points ? max_points : n_points;\n+        if (n_points > res) {\n+            res = n_points;\n+        }\n+        if(n_points < max_points) {\n+            /* A larger bucket_window may support even more points. But if we\n+             * would choose that then the caller couldn't safely use any number\n+             * smaller than what this function returns */\n+            break;\n+        }\n+    }\n+    return res;\n+}\n+\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_ecmult_context*, secp256k1_scratch*, const secp256k1_callback*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    size_t i;\n+\n+    int (*f)(const secp256k1_ecmult_context*, secp256k1_scratch*, const secp256k1_callback*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    size_t max_points;\n+    size_t n_batches;\n+    size_t n_batch_points;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n == 0) {\n+        return 1;\n+    } else if (n == 0) {\n+        secp256k1_scalar szero;\n+        secp256k1_scalar_set_int(&szero, 0);\n+        secp256k1_ecmult(ctx, r, r, &szero, inp_g_sc);\n+        return 1;\n+    }\n+\n+    max_points = secp256k1_pippenger_max_points(scratch);\n+    if (max_points == 0) {\n+        return 0;\n+    } else if (max_points > ECMULT_MAX_POINTS_PER_BATCH) {\n+        max_points = ECMULT_MAX_POINTS_PER_BATCH;\n+    }\n+    n_batches = (n+max_points-1)/max_points;\n+    n_batch_points = (n+n_batches-1)/n_batches;\n+\n+    if(n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n+        f = &secp256k1_ecmult_pippenger_batch;\n+    } else {\n+        max_points = secp256k1_strauss_max_points(scratch);\n+        if (max_points == 0) {\n+            return 0;\n+        }\n+        n_batches = (n+max_points-1)/max_points;\n+        n_batch_points = (n+n_batches-1)/n_batches;\n+        f = &secp256k1_ecmult_strauss_batch;\n+    }\n+    for(i = 0; i < n_batches; i++) {\n+        size_t nbp = n < n_batch_points ? n : n_batch_points;\n+        size_t offset = n_batch_points*i;\n+        secp256k1_gej tmp;\n+        if(!(*f)(ctx, scratch, error_callback, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 795,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: you can just use `f(...)` instead of `(*f)(...)`.",
      "created_at": "2017-11-25T06:56:48Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153039452",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039452"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1014,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039464",
      "pull_request_review_id": 78994182,
      "id": 153039464,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzAzOTQ2NA==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {\n+        return 1;\n+    } else if (n <= 8) {\n+        return 2;\n+    } else if (n <= 40) {\n+        return 3;\n+    } else if (n <= 117) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 480) {\n+        return 6;\n+    } else if (n <= 2560) {\n+        return 7;\n+    } else if (n <= 9200) {\n+        return 9;\n+    } else if (n <= 17400) {\n+        return 10;\n+    } else if (n <= 28600) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#else\n+    if (n <= 2) {\n+        return 1;\n+    } else if (n <= 9) {\n+        return 2;\n+    } else if (n <= 42) {\n+        return 3;\n+    } else if (n <= 100) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 610) {\n+        return 6;\n+    } else if (n <= 1920) {\n+        return 7;\n+    } else if (n <= 3400) {\n+        return 8;\n+    } else if (n <= 10240) {\n+        return 9;\n+    } else if (n <= 19000) {\n+        return 10;\n+    } else if (n <= 35000) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#endif\n+}\n+\n+static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    if(bucket_window == 1) {\n+        return 4;\n+    } else if(bucket_window == 2) {\n+        return 8;\n+    } else if(bucket_window == 3) {\n+        return 40;\n+    } else if(bucket_window == 4) {\n+        return 117;\n+    } else if(bucket_window == 5) {\n+        return 280;\n+    } else if(bucket_window == 6) {\n+        return 480;\n+    } else if(bucket_window == 7) {\n+        return 2560;\n+    } else if(bucket_window == 8) {\n+        return 2560;\n+    } else if(bucket_window == 9) {\n+        return 9200;\n+    } else if(bucket_window == 10) {\n+        return 17400;\n+    } else if(bucket_window == 11) {\n+        return 28600;\n+    } else if(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW) {\n+        return SIZE_MAX;\n+    }\n+#else\n+    if(bucket_window == 1) {\n+        return 2;\n+    } else if(bucket_window == 2) {\n+        return 9;\n+    } else if(bucket_window == 3) {\n+        return 42;\n+    } else if(bucket_window == 4) {\n+        return 100;\n+    } else if(bucket_window == 5) {\n+        return 280;\n+    } else if(bucket_window == 6) {\n+        return 610;\n+    } else if(bucket_window == 7) {\n+        return 1920;\n+    } else if(bucket_window == 8) {\n+        return 3400;\n+    } else if(bucket_window == 9) {\n+        return 10240;\n+    } else if(bucket_window == 10) {\n+        return 19000;\n+    } else if(bucket_window == 11) {\n+        return 35000;\n+    } else if(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW) {\n+        return SIZE_MAX;\n+    }\n+#endif\n+    return 0;\n+}\n+\n+\n+#ifdef USE_ENDOMORPHISM\n+SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, secp256k1_scalar *s2, secp256k1_ge *p1, secp256k1_ge *p2) {\n+    secp256k1_scalar tmp = *s1;\n+    secp256k1_scalar_split_lambda(s1, s2, &tmp);\n+    secp256k1_ge_mul_lambda(p2, p1);\n+\n+    if (secp256k1_scalar_is_high(s1)) {\n+        secp256k1_scalar_negate(s1, s1);\n+        secp256k1_ge_neg(p1, p1);\n+    }\n+    if (secp256k1_scalar_is_high(s2)) {\n+        secp256k1_scalar_negate(s2, s2);\n+        secp256k1_ge_neg(p2, p2);\n+    }\n+}\n+#endif\n+\n+/**\n+ * Returns the scratch size required for a given number of points (excluding\n+ * base point G) without considering alignment.\n+ */\n+static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+    return ((1<<bucket_window) * sizeof(secp256k1_gej) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size);\n+}\n+\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n+     * sizes. The reason for +1 is that we add the G scalar to the list of\n+     * other scalars. */\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    secp256k1_ge *points;\n+    secp256k1_scalar *scalars;\n+    secp256k1_gej *buckets;\n+    struct secp256k1_pippenger_state *state_space;\n+    size_t idx = 0;\n+    size_t point_idx = 0;\n+    int i, j;\n+    int bucket_window;\n+\n+    (void)ctx;\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, (1<<bucket_window) * sizeof(*buckets));\n+\n+    if (inp_g_sc != NULL) {\n+        scalars[0] = *inp_g_sc;\n+        points[0] = secp256k1_ge_const_g;\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n+        idx++;\n+#endif\n+    }\n+\n+    while (point_idx < n_points) {\n+        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n+            return 0;\n+        }\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n+        idx++;\n+#endif\n+        point_idx++;\n+    }\n+\n+    secp256k1_ecmult_pippenger_wnaf(buckets, bucket_window, state_space, r, scalars, points, idx);\n+\n+    /* Clear data */\n+    for(i = 0; (size_t)i < idx; i++) {\n+        secp256k1_scalar_clear(&scalars[i]);\n+        state_space->ps[i].skew_na = 0;\n+        for(j = 0; j < WNAF_SIZE(bucket_window+1); j++) {\n+            state_space->wnaf_na[i * WNAF_SIZE(bucket_window+1) + j] = 0;\n+        }\n+    }\n+    for(i = 0; i < 1<<bucket_window; i++) {\n+        secp256k1_gej_clear(&buckets[i]);\n+    }\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+/**\n+ * Returns the maximum number of points in addition to G that can be used with\n+ * a given scratch space. The function ensures that fewer points may also be\n+ * used.\n+ */\n+static size_t secp256k1_pippenger_max_points(secp256k1_scratch *scratch) {\n+    ssize_t max_alloc = secp256k1_scratch_max_allocation(scratch, PIPPENGER_SCRATCH_OBJECTS);\n+    int bucket_window;\n+    size_t res = 0;\n+\n+    for (bucket_window = 1; bucket_window <= PIPPENGER_MAX_BUCKET_WINDOW; bucket_window++) {\n+        size_t n_points;\n+        size_t max_points = secp256k1_pippenger_bucket_window_inv(bucket_window);\n+        ssize_t space_for_points;\n+        size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+\n+#ifdef USE_ENDOMORPHISM\n+        entry_size = 2*entry_size;\n+#endif\n+        space_for_points = max_alloc - ((1<<bucket_window) * sizeof(secp256k1_gej) + entry_size + sizeof(struct secp256k1_pippenger_state));\n+        if (space_for_points < 0) {\n+            break;\n+        }\n+        n_points = space_for_points/entry_size;\n+        n_points = n_points > max_points ? max_points : n_points;\n+        if (n_points > res) {\n+            res = n_points;\n+        }\n+        if(n_points < max_points) {\n+            /* A larger bucket_window may support even more points. But if we\n+             * would choose that then the caller couldn't safely use any number\n+             * smaller than what this function returns */\n+            break;\n+        }\n+    }\n+    return res;\n+}\n+\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_ecmult_context*, secp256k1_scratch*, const secp256k1_callback*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    size_t i;\n+\n+    int (*f)(const secp256k1_ecmult_context*, secp256k1_scratch*, const secp256k1_callback*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    size_t max_points;\n+    size_t n_batches;\n+    size_t n_batch_points;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n == 0) {\n+        return 1;\n+    } else if (n == 0) {\n+        secp256k1_scalar szero;\n+        secp256k1_scalar_set_int(&szero, 0);\n+        secp256k1_ecmult(ctx, r, r, &szero, inp_g_sc);\n+        return 1;\n+    }\n+\n+    max_points = secp256k1_pippenger_max_points(scratch);\n+    if (max_points == 0) {\n+        return 0;\n+    } else if (max_points > ECMULT_MAX_POINTS_PER_BATCH) {\n+        max_points = ECMULT_MAX_POINTS_PER_BATCH;\n+    }\n+    n_batches = (n+max_points-1)/max_points;\n+    n_batch_points = (n+n_batches-1)/n_batches;\n+\n+    if(n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n+        f = &secp256k1_ecmult_pippenger_batch;\n+    } else {\n+        max_points = secp256k1_strauss_max_points(scratch);\n+        if (max_points == 0) {\n+            return 0;\n+        }\n+        n_batches = (n+max_points-1)/max_points;\n+        n_batch_points = (n+n_batches-1)/n_batches;\n+        f = &secp256k1_ecmult_strauss_batch;",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 789,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: ampersand is optional here.",
      "created_at": "2017-11-25T06:57:58Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153039464",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039464"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1008,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039502",
      "pull_request_review_id": 78996802,
      "id": 153039502,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzAzOTUwMg==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {\n+        return 1;\n+    } else if (n <= 8) {\n+        return 2;\n+    } else if (n <= 40) {\n+        return 3;\n+    } else if (n <= 117) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 480) {\n+        return 6;\n+    } else if (n <= 2560) {\n+        return 7;\n+    } else if (n <= 9200) {\n+        return 9;\n+    } else if (n <= 17400) {\n+        return 10;\n+    } else if (n <= 28600) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#else\n+    if (n <= 2) {\n+        return 1;\n+    } else if (n <= 9) {\n+        return 2;\n+    } else if (n <= 42) {\n+        return 3;\n+    } else if (n <= 100) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 610) {\n+        return 6;\n+    } else if (n <= 1920) {\n+        return 7;\n+    } else if (n <= 3400) {\n+        return 8;\n+    } else if (n <= 10240) {\n+        return 9;\n+    } else if (n <= 19000) {\n+        return 10;\n+    } else if (n <= 35000) {\n+        return 11;\n+    } else {\n+        return PIPPENGER_MAX_BUCKET_WINDOW;\n+    }\n+#endif\n+}\n+\n+static size_t secp256k1_pippenger_bucket_window_inv(int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    if(bucket_window == 1) {",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 548,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this can be written more efficiently using a switch case.",
      "created_at": "2017-11-25T07:00:54Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153039502",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153039502"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 767,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153042639",
      "pull_request_review_id": 78999811,
      "id": 153042639,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzA0MjYzOQ==",
      "diff_hunk": "@@ -0,0 +1,35 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra\t                              *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCRATCH_\n+#define _SECP256K1_SCRATCH_\n+#include <sys/types.h>\n+\n+/* The typedef is used internally; the struct name is used in the public API\n+ * (where it is exposed as a different typedef) */",
      "path": "src/scratch.h",
      "position": null,
      "original_position": 12,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The typedef and struct name are the same publicly; the struct is just not defined there.",
      "created_at": "2017-11-25T10:16:25Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153042639",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153042639"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153042768",
      "pull_request_review_id": 78999940,
      "id": 153042768,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzA0Mjc2OA==",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCRATCH_IMPL_H_\n+#define _SECP256K1_SCRATCH_IMPL_H_\n+\n+#include \"scratch.h\"\n+\n+#define ALIGNMENT 16",
      "path": "src/scratch_impl.h",
      "position": null,
      "original_position": 12,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "be8abb5ad18c334dc2367df1f183e3c00c7d469f",
      "in_reply_to_id": 152877180,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps add a TODO that we should try to determine this at configure time (using sizeof(max_align_t), if available, for example).",
      "created_at": "2017-11-25T10:19:52Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153042768",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153042768"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153198997",
      "pull_request_review_id": 79169309,
      "id": 153198997,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzE5ODk5Nw==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 345,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153039163,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Specifically, do you suggest to replace\r\n```\r\n *  - each wnaf[i] is an odd integer between -(1 << w) and (1 << w)\r\n *  - each wnaf[i] is nonzero, unless the given number is 0\r\n```\r\nwith \r\n```\r\n* wnaf[i] is either zero or an odd integer between -(1 << w) and (1 << w)\r\n```\r\n?\r\nIf so, that sounds just as accurate but less helpful.",
      "created_at": "2017-11-27T13:43:51Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153198997",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153198997"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 564,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153202537",
      "pull_request_review_id": 79173575,
      "id": 153202537,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzIwMjUzNw==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 474,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153039380,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't see how. If `r` stores the result of previous iterations it can't be used in the addition ladder.",
      "created_at": "2017-11-27T13:58:15Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153202537",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153202537"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 692,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153203134",
      "pull_request_review_id": 79174310,
      "id": 153203134,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzIwMzEzNA==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 494,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153039266,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What's the goal of this?",
      "created_at": "2017-11-27T14:00:47Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153203134",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153203134"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 719,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153220570",
      "pull_request_review_id": 79194701,
      "id": 153220570,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzIyMDU3MA==",
      "diff_hunk": "@@ -0,0 +1,35 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra\t                              *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCRATCH_\n+#define _SECP256K1_SCRATCH_\n+#include <sys/types.h>\n+\n+/* The typedef is used internally; the struct name is used in the public API\n+ * (where it is exposed as a different typedef) */",
      "path": "src/scratch.h",
      "position": null,
      "original_position": 12,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153042639,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not sure what you mean, the typedef here is `secp256k1_scratch`, the public one is `secp256k1_scratch_space`.",
      "created_at": "2017-11-27T15:02:38Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153220570",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153220570"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153222015",
      "pull_request_review_id": 79196382,
      "id": 153222015,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzIyMjAxNQ==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 345,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153039163,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To be clear: is it possible for a nonzero number to have 0 wnaf digits in our representation? I believe the answer is yes, though for wnaf_const (for example) it is not, so this is an important distinction.",
      "created_at": "2017-11-27T15:07:42Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153222015",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153222015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 564,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153298443",
      "pull_request_review_id": 79284248,
      "id": 153298443,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzI5ODQ0Mw==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 494,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153039266,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Only having a logarithmic number of conditionals on average.",
      "created_at": "2017-11-27T19:30:57Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153298443",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153298443"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 719,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153298990",
      "pull_request_review_id": 79284870,
      "id": 153298990,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzI5ODk5MA==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 345,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153039163,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@jonasnick The first statement \"each wnaf[i] is an odd integer between -(1 << w) and (1 << w)\" is just incorrect. 0 is not an odd integer, and 0 is possible in case the input is 0.",
      "created_at": "2017-11-27T19:32:55Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153298990",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153298990"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 564,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153300445",
      "pull_request_review_id": 79286559,
      "id": 153300445,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzMwMDQ0NQ==",
      "diff_hunk": "@@ -0,0 +1,35 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra\t                              *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCRATCH_\n+#define _SECP256K1_SCRATCH_\n+#include <sys/types.h>\n+\n+/* The typedef is used internally; the struct name is used in the public API\n+ * (where it is exposed as a different typedef) */",
      "path": "src/scratch.h",
      "position": null,
      "original_position": 12,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153042639,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oops, ignore me!",
      "created_at": "2017-11-27T19:38:18Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153300445",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153300445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153347425",
      "pull_request_review_id": 79339323,
      "id": 153347425,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzM0NzQyNQ==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 345,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153039163,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh, of course 0 is even. But I believe the second statement should stay because at least empirically it doesn't happen that a nonzero number has 0 wnaf digits (we test for this, copied from wnaf_const). @sipa can you confirm?",
      "created_at": "2017-11-27T22:47:02Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153347425",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153347425"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 564,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153378310",
      "pull_request_review_id": 79373639,
      "id": 153378310,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzM3ODMxMA==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 345,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153039163,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't care that it doesn't happen often. The first sentence is stated as a condition which is always true, and it is not. You could say \"There result satisfies one of the two following conditions:\" and leave the two in. But leaving them as-is is just wrong.",
      "created_at": "2017-11-28T02:10:01Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r153378310",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/153378310"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 564,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/154093237",
      "pull_request_review_id": 80203500,
      "id": 154093237,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NDA5MzIzNw==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 494,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153039266,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "While being better in the average case I think this is worse for small batches (where this code has more impact compared to larger batches) and looks ugly. Maybe that's something for another PR. ",
      "created_at": "2017-11-30T14:43:32Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r154093237",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/154093237"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 719,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/154810541",
      "pull_request_review_id": 81029731,
      "id": 154810541,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NDgxMDU0MQ==",
      "diff_hunk": "@@ -403,4 +484,540 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+#else\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+#endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+}\n+\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] an odd integer between -(1 << w) and (1 << w)\n+ *  - each wnaf[i] is nonzero, unless the given number is 0\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n+        }\n+        return 0;\n+    }\n+\n+    if (secp256k1_scalar_is_even(s)) {\n+#ifdef USE_ENDOMORPHISM\n+        skew = 1;\n+#else\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n+#endif\n+    }\n+\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n+        return 1;\n+    }\n+\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+            if (i == 0) {\n+#ifdef USE_ENDOMORPHISM\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+#endif\n+            }\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n+            }\n+        }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n+    }\n+    return 1;\n+}\n+\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 494,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "118ad20838d237fea71f0805e9c0d22bef5019e6",
      "in_reply_to_id": 153039266,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fair enough.",
      "created_at": "2017-12-04T23:49:43Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r154810541",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/154810541"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 719,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155398792",
      "pull_request_review_id": 81712010,
      "id": 155398792,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NTM5ODc5Mg==",
      "diff_hunk": "@@ -0,0 +1,35 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra\t                              *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCRATCH_\n+#define _SECP256K1_SCRATCH_\n+#include <sys/types.h>",
      "path": "src/scratch.h",
      "position": null,
      "original_position": 9,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "56fb2ccbe94b8e1a9fd3446e3035e427c378bf71",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We can remove this #include. There are two places that `ssize_t` are used in `ecmult_impl.h` which need to be removed. The first, `ssize_t max_alloc =` can be changed to `size_t` because it is assigned a `size_t` anyway (we changed `secp256k1_scratch_max_allocation` to not return a sign value).\r\n\r\nThe second use is `ssize_t space_for_points`. This can also be made into a `size_t`. The check on line 938, `if (space_for_points < 0)`, will need to be rearranged to compare the two things that are subtracted on line 937 to get `space_for_points`.",
      "created_at": "2017-12-07T00:10:52Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r155398792",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155398792"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 9,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155399117",
      "pull_request_review_id": 81712415,
      "id": 155399117,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NTM5OTExNw==",
      "diff_hunk": "@@ -0,0 +1,35 @@\n+/**********************************************************************\n+ * Copyright (c) 2017 Andrew Poelstra\t                              *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCRATCH_\n+#define _SECP256K1_SCRATCH_\n+#include <sys/types.h>\n+\n+/* The typedef is used internally; the struct name is used in the public API\n+ * (where it is exposed as a different typedef) */\n+typedef struct secp256k1_scratch_space_struct {\n+    void *data;\n+    size_t offset;\n+    size_t init_size;\n+    size_t max_size;",
      "path": "src/scratch.h",
      "position": 16,
      "original_position": 17,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "56fb2ccbe94b8e1a9fd3446e3035e427c378bf71",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can we add an `error_callback` pointer to this structure and remove it from the arguments of `secp256k1_scratch_resize`? It would avoid the need to pass error callbacks into a bunch of higher level functions.",
      "created_at": "2017-12-07T00:13:10Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r155399117",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155399117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 16,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155401397",
      "pull_request_review_id": 81715003,
      "id": 155401397,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NTQwMTM5Nw==",
      "diff_hunk": "@@ -28,4 +30,9 @@ static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx\n /** Double multiply: R = na*A + ng*G */\n static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng);\n \n+typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *data);\n+\n+/** Multi-multiply: R = inp_g_sc * G + sum_i ni * Ai. */",
      "path": "src/ecmult.h",
      "position": null,
      "original_position": 22,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "da61b77821a6e01071844902b8d691eb698c8cb9",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Update comment to say that this function will clobber the scratch space that gets passed in? I've nearly been burned by that in the Bulletproofs code a couple times.",
      "created_at": "2017-12-07T00:29:22Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r155401397",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155401397"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155401550",
      "pull_request_review_id": 81715159,
      "id": 155401550,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NTQwMTU1MA==",
      "diff_hunk": "@@ -403,4 +457,94 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static int secp256k1_ecmult_multi_split_strauss_wnaf(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    secp256k1_gej acc;\n+    size_t in_pos = 0, out_pos = 0;\n+    int first = 1;\n+\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (sizeof(secp256k1_gej) + sizeof(secp256k1_fe) + sizeof(secp256k1_ge) * 2) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_gej) + sizeof(secp256k1_fe) + sizeof(secp256k1_ge)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+\n+    size_t max_points = secp256k1_scratch_max_allocation(scratch, 6) / point_size;\n+    size_t n_batches, points_per_batch;\n+    struct secp256k1_strauss_state state;\n+\n+    if (max_points == 0) return 0;\n+    if (max_points > 160) max_points = 160; /* At this point, gains are not longer compensating for locality degradation */\n+    n_batches = (n + max_points - 1) / max_points;\n+    points_per_batch = (n + n_batches - 1) / n_batches;\n+\n+    /* Attempt to allocate sufficient space for Strauss */",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 266,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "541ea3fc14efd79dedb7bc3dcb36e2e7f5f30e7d",
      "in_reply_to_id": 152877963,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agreed, please change this to a `CHECK` on the return value of `secp256k1_scratch_resize`.",
      "created_at": "2017-12-07T00:30:26Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r155401550",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155401550"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 502,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155403665",
      "pull_request_review_id": 81717475,
      "id": 155403665,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NTQwMzY2NQ==",
      "diff_hunk": "@@ -2522,6 +2522,243 @@ void run_ecmult_const_tests(void) {\n     ecmult_const_chain_multiply();\n }\n \n+typedef struct {\n+    secp256k1_scalar *sc;\n+    secp256k1_ge *pt;\n+} ecmult_multi_data;\n+\n+static int ecmult_multi_callback(secp256k1_scalar *sc, secp256k1_ge *pt, size_t idx, void *cbdata) {\n+    ecmult_multi_data *data = (ecmult_multi_data*) cbdata;\n+    *sc = data->sc[idx];\n+    *pt = data->pt[idx];\n+    return 1;\n+}\n+\n+void run_ecmult_multi_tests(void) {\n+    int ncount;\n+    secp256k1_scalar szero;\n+    secp256k1_scalar sc[32];\n+    secp256k1_ge pt[32];\n+    secp256k1_gej r;\n+    secp256k1_gej r2;\n+    ecmult_multi_data data;\n+    secp256k1_scratch *scratch = secp256k1_scratch_create(&ctx->error_callback, 1024, 8192);\n+\n+    data.sc = sc;\n+    data.pt = pt;\n+\n+    secp256k1_scalar_set_int(&szero, 0);\n+\n+    /* Check 1- and 2-point multiplies against ecmult */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        secp256k1_ge ptg;\n+        secp256k1_gej ptgj;\n+        random_scalar_order(&sc[0]);\n+        random_scalar_order(&sc[1]);\n+\n+        random_group_element_test(&ptg);\n+        secp256k1_gej_set_ge(&ptgj, &ptg);\n+        pt[0] = ptg;\n+        pt[1] = secp256k1_ge_const_g;\n+\n+        /* 1-point */\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n+        CHECK(secp256k1_ecmult_multi(&ctx->ecmult_ctx, scratch, &ctx->error_callback, &r, &szero, ecmult_multi_callback, &data, 1));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+\n+        /* 2-point */\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(secp256k1_ecmult_multi(&ctx->ecmult_ctx, scratch, &ctx->error_callback, &r, &szero, ecmult_multi_callback, &data, 2));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+\n+        /* 2-point with G scalar */\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n+        CHECK(secp256k1_ecmult_multi(&ctx->ecmult_ctx, scratch, &ctx->error_callback, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Check infinite outputs of various forms */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        secp256k1_ge ptg;\n+        size_t i, j;\n+        size_t sizes[] = { 2, 10, 32 };\n+\n+        for (j = 0; j < 3; j++) {\n+            for (i = 0; i < 32; i++) {\n+                random_scalar_order(&sc[i]);\n+                secp256k1_ge_set_infinity(&pt[i]);\n+            }\n+            CHECK(secp256k1_ecmult_multi(&ctx->ecmult_ctx, scratch, &ctx->error_callback, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+        }\n+\n+        for (j = 0; j < 3; j++) {\n+            for (i = 0; i < 32; i++) {\n+                random_group_element_test(&ptg);\n+                pt[i] = ptg;\n+                secp256k1_scalar_set_int(&sc[i], 0);\n+            }\n+            CHECK(secp256k1_ecmult_multi(&ctx->ecmult_ctx, scratch, &ctx->error_callback, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+        }\n+\n+        for (j = 0; j < 3; j++) {\n+            random_group_element_test(&ptg);\n+            for (i = 0; i < 16; i++) {\n+                random_scalar_order(&sc[2*i]);\n+                secp256k1_scalar_negate(&sc[2*i + 1], &sc[2*i]);\n+                pt[2 * i] = ptg;\n+                pt[2 * i + 1] = ptg;\n+            }\n+\n+            CHECK(secp256k1_ecmult_multi(&ctx->ecmult_ctx, scratch, &ctx->error_callback, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+\n+            random_scalar_order(&sc[0]);\n+            for (i = 0; i < 16; i++) {\n+                random_group_element_test(&ptg);\n+\n+                sc[2*i] = sc[0];\n+                sc[2*i+1] = sc[0];\n+                pt[2 * i] = ptg;\n+                secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n+            }\n+\n+            CHECK(secp256k1_ecmult_multi(&ctx->ecmult_ctx, scratch, &ctx->error_callback, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(secp256k1_gej_is_infinity(&r));\n+        }\n+\n+        random_group_element_test(&ptg);\n+        secp256k1_scalar_set_int(&sc[0], 0);\n+        pt[0] = ptg;\n+        for (i = 1; i < 32; i++) {\n+            pt[i] = ptg;\n+\n+            random_scalar_order(&sc[i]);\n+            secp256k1_scalar_add(&sc[0], &sc[0], &sc[i]);\n+            secp256k1_scalar_negate(&sc[i], &sc[i]);\n+        }\n+\n+        CHECK(secp256k1_ecmult_multi(&ctx->ecmult_ctx, scratch, &ctx->error_callback, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Check random points, constant scalar */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        size_t i;\n+        secp256k1_gej_set_infinity(&r);\n+\n+        random_scalar_order(&sc[0]);\n+        for (i = 0; i < 20; i++) {\n+            secp256k1_ge ptg;\n+            sc[i] = sc[0];\n+            random_group_element_test(&ptg);\n+            pt[i] = ptg;\n+            secp256k1_gej_add_ge_var(&r, &r, &pt[i], NULL);\n+        }\n+\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n+        CHECK(secp256k1_ecmult_multi(&ctx->ecmult_ctx, scratch, &ctx->error_callback, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Check random scalars, constant point */\n+    for (ncount = 0; ncount < count; ncount++) {\n+        size_t i;\n+        secp256k1_ge ptg;\n+        secp256k1_gej p0j;\n+        secp256k1_scalar rs;\n+        secp256k1_scalar_set_int(&rs, 0);\n+\n+        random_group_element_test(&ptg);\n+        for (i = 0; i < 20; i++) {\n+            random_scalar_order(&sc[i]);\n+            pt[i] = ptg;\n+            secp256k1_scalar_add(&rs, &rs, &sc[i]);\n+        }\n+\n+        secp256k1_gej_set_ge(&p0j, &pt[0]);\n+        secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n+        CHECK(secp256k1_ecmult_multi(&ctx->ecmult_ctx, scratch, &ctx->error_callback, &r, &szero, ecmult_multi_callback, &data, 20));\n+        secp256k1_gej_neg(&r2, &r2);\n+        secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+        CHECK(secp256k1_gej_is_infinity(&r));\n+    }\n+\n+    /* Sanity check that zero scalars don't cause problems */\n+    memset(&sc[0], 0, sizeof(sc[0]));\n+    CHECK(secp256k1_ecmult_multi(&ctx->ecmult_ctx, scratch, &ctx->error_callback, &r, &szero, ecmult_multi_callback, &data, 20));\n+    memset(&sc[1], 0, sizeof(sc[0]));\n+    memset(&sc[2], 0, sizeof(sc[0]));\n+    memset(&sc[3], 0, sizeof(sc[0]));\n+    memset(&sc[4], 0, sizeof(sc[0]));",
      "path": "src/tests.c",
      "position": null,
      "original_position": 181,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "deabf0d88fdacda3400d67f4f9c5875bea9d3284",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can we use `secp256k1_scalar_clear` instead of memsetting?",
      "created_at": "2017-12-07T00:45:10Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r155403665",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155403665"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2702,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155561938",
      "pull_request_review_id": 81901496,
      "id": 155561938,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NTU2MTkzOA==",
      "diff_hunk": "@@ -403,4 +457,94 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static int secp256k1_ecmult_multi_split_strauss_wnaf(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    secp256k1_gej acc;\n+    size_t in_pos = 0, out_pos = 0;\n+    int first = 1;\n+\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (sizeof(secp256k1_gej) + sizeof(secp256k1_fe) + sizeof(secp256k1_ge) * 2) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_gej) + sizeof(secp256k1_fe) + sizeof(secp256k1_ge)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+\n+    size_t max_points = secp256k1_scratch_max_allocation(scratch, 6) / point_size;\n+    size_t n_batches, points_per_batch;\n+    struct secp256k1_strauss_state state;\n+\n+    if (max_points == 0) return 0;\n+    if (max_points > 160) max_points = 160; /* At this point, gains are not longer compensating for locality degradation */\n+    n_batches = (n + max_points - 1) / max_points;\n+    points_per_batch = (n + n_batches - 1) / n_batches;\n+\n+    /* Attempt to allocate sufficient space for Strauss */",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 266,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "541ea3fc14efd79dedb7bc3dcb36e2e7f5f30e7d",
      "in_reply_to_id": 152877963,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh, derp, Jonas points out that this is fixed in a later commit. Never mind.",
      "created_at": "2017-12-07T15:57:10Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r155561938",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155561938"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 502,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155563262",
      "pull_request_review_id": 81903056,
      "id": 155563262,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NTU2MzI2Mg==",
      "diff_hunk": "@@ -403,4 +457,94 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     }\n }\n \n+static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_scalar *na, const secp256k1_scalar *ng) {\n+    secp256k1_gej prej[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_fe zr[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    secp256k1_ge pre_a[ECMULT_TABLE_SIZE(WINDOW_A)];\n+    struct secp256k1_strauss_point_state ps[1];\n+#ifdef USE_ENDOMORPHISM\n+    secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n+#endif\n+    struct secp256k1_strauss_state state;\n+\n+    state.prej = prej;\n+    state.zr = zr;\n+    state.pre_a = pre_a;\n+#ifdef USE_ENDOMORPHISM\n+    state.pre_a_lam = pre_a_lam;\n+#endif\n+    state.ps = ps;\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n+}\n+\n+static int secp256k1_ecmult_multi_split_strauss_wnaf(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    secp256k1_gej* points;\n+    secp256k1_scalar* scalars;\n+    secp256k1_gej acc;\n+    size_t in_pos = 0, out_pos = 0;\n+    int first = 1;\n+\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (sizeof(secp256k1_gej) + sizeof(secp256k1_fe) + sizeof(secp256k1_ge) * 2) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_gej) + sizeof(secp256k1_fe) + sizeof(secp256k1_ge)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+\n+    size_t max_points = secp256k1_scratch_max_allocation(scratch, 6) / point_size;\n+    size_t n_batches, points_per_batch;\n+    struct secp256k1_strauss_state state;\n+\n+    if (max_points == 0) return 0;\n+    if (max_points > 160) max_points = 160; /* At this point, gains are not longer compensating for locality degradation */\n+    n_batches = (n + max_points - 1) / max_points;\n+    points_per_batch = (n + n_batches - 1) / n_batches;\n+\n+    /* Attempt to allocate sufficient space for Strauss */",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 266,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "541ea3fc14efd79dedb7bc3dcb36e2e7f5f30e7d",
      "in_reply_to_id": 152877963,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is outdated by \"Add pippenger_wnaf ecmult_multi\": if resize fails then return 0. ",
      "created_at": "2017-12-07T16:01:25Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r155563262",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155563262"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 502,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155571595",
      "pull_request_review_id": 81912802,
      "id": 155571595,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NTU3MTU5NQ==",
      "diff_hunk": "@@ -477,74 +495,414 @@ static void secp256k1_ecmult(const secp256k1_ecmult_context *ctx, secp256k1_gej\n     secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 1, a, na, ng);\n }\n \n-static int secp256k1_ecmult_multi_split_strauss_wnaf(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n+#ifdef USE_ENDOMORPHISM\n+    static const size_t point_size = (2 * sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#else\n+    static const size_t point_size = (sizeof(secp256k1_ge) + sizeof(secp256k1_gej) + sizeof(secp256k1_fe)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+#endif\n+    return n_points*point_size;\n+}\n+\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     secp256k1_gej* points;\n     secp256k1_scalar* scalars;\n-    secp256k1_gej acc;\n-    size_t in_pos = 0, out_pos = 0;\n-    int first = 1;\n+    struct secp256k1_strauss_state state;\n+    size_t i;\n+\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n \n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n #ifdef USE_ENDOMORPHISM\n-    static const size_t point_size = (sizeof(secp256k1_gej) + sizeof(secp256k1_fe) + sizeof(secp256k1_ge) * 2) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n #else\n-    static const size_t point_size = (sizeof(secp256k1_gej) + sizeof(secp256k1_fe) + sizeof(secp256k1_ge)) * ECMULT_TABLE_SIZE(WINDOW_A) + sizeof(struct secp256k1_strauss_point_state) + sizeof(secp256k1_gej) + sizeof(secp256k1_scalar);\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n #endif\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n \n-    size_t max_points = secp256k1_scratch_max_allocation(scratch, 6) / point_size;\n-    size_t n_batches, points_per_batch;\n-    struct secp256k1_strauss_state state;\n+    for (i = 0; i < n_points; i++) {\n+        secp256k1_ge point;\n+        if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) return 0;\n+        secp256k1_gej_set_ge(&points[i], &point);\n+    }\n+    secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n+    return 1;\n+}\n \n-    if (max_points == 0) return 0;\n-    if (max_points > 160) max_points = 160; /* At this point, gains are not longer compensating for locality degradation */\n-    n_batches = (n + max_points - 1) / max_points;\n-    points_per_batch = (n + n_batches - 1) / n_batches;\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n \n-    /* Attempt to allocate sufficient space for Strauss */\n-    while (!secp256k1_scratch_resize(scratch, error_callback, max_points * point_size, 6)) {\n-        max_points /= 2;\n-        if (max_points == 0) {\n-            return 0;\n+/** Convert a number to WNAF notation.\n+ *  The number becomes represented by sum(2^{wi} * wnaf[i], i=0..WNAF_SIZE(w)+1) - return_val.\n+ *  It has the following guarantees:\n+ *  - each wnaf[i] is either 0 or an odd integer between -(1 << w) and (1 << w)\n+ *  - the number of words set is always WNAF_SIZE(w)\n+ *  - the returned skew is 0 without endomorphism, or 0 or 1 with endomorphism\n+ */\n+static int secp256k1_wnaf_fixed(int *wnaf, const secp256k1_scalar *s, int w) {\n+    int sign = 0;\n+    int skew = 0;\n+    int pos = 1;\n+#ifndef USE_ENDOMORPHISM\n+    secp256k1_scalar neg_s;\n+#endif\n+    const secp256k1_scalar *work = s;\n+\n+    if (secp256k1_scalar_is_zero(s)) {\n+        while (pos * w < WNAF_BITS) {\n+            wnaf[pos] = 0;\n+            ++pos;\n         }\n+        return 0;\n     }\n \n-    secp256k1_scratch_reset(scratch);\n-    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, max_points * sizeof(secp256k1_gej));\n-    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, max_points * sizeof(secp256k1_scalar));\n-    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, max_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n-    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, max_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+    if (secp256k1_scalar_is_even(s)) {\n #ifdef USE_ENDOMORPHISM\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, max_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n-    state.pre_a_lam = state.pre_a + max_points * ECMULT_TABLE_SIZE(WINDOW_A);\n+        skew = 1;\n #else\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, max_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+        secp256k1_scalar_negate(&neg_s, s);\n+        work = &neg_s;\n+        sign = -1;\n #endif\n-    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, max_points * sizeof(struct secp256k1_strauss_point_state));\n+    }\n \n-    if (n == 0 && inp_g_sc) {\n-        secp256k1_ecmult_strauss_wnaf(ctx, &state, r, 0, NULL, NULL, inp_g_sc);\n+    wnaf[0] = (secp256k1_scalar_get_bits_var(work, 0, w) + skew + sign) ^ sign;\n+\n+    while (pos * w < WNAF_BITS) {\n+        int now = w;\n+        int val;\n+        if (now + pos * w > WNAF_BITS) {\n+            now = WNAF_BITS - pos * w;\n+        }\n+        val = secp256k1_scalar_get_bits_var(work, pos * w, now);\n+        if ((val & 1) == 0) {\n+            wnaf[pos - 1] -= ((1 << w) + sign) ^ sign;\n+            wnaf[pos] = (val + 1 + sign) ^ sign;\n+        } else {\n+            wnaf[pos] = (val + sign) ^ sign;\n+        }\n+        ++pos;\n+    }\n+    VERIFY_CHECK(pos == WNAF_SIZE(w));\n+\n+    return skew;\n+}\n+\n+struct secp256k1_pippenger_point_state {\n+    int skew_na;\n+    size_t input_pos;\n+};\n+\n+struct secp256k1_pippenger_state {\n+    int *wnaf_na;\n+    struct secp256k1_pippenger_point_state* ps;\n+};\n+\n+/*\n+ * pippenger_wnaf computes the result of a multi-point multiplication as\n+ * follows: The scalars are brought into wnaf with n_wnaf elements each. Then\n+ * for every i < n_wnaf, first each point is added to a \"bucket\" corresponding\n+ * to the point's wnaf[i]. Second, the buckets are added together such that\n+ * r += 1*bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+ */\n+static int secp256k1_ecmult_pippenger_wnaf(secp256k1_gej *buckets, int bucket_window, struct secp256k1_pippenger_state *state, secp256k1_gej *r, secp256k1_scalar *sc, secp256k1_ge *pt, size_t num) {\n+    size_t n_wnaf = WNAF_SIZE(bucket_window+1);\n+    size_t np;\n+    size_t no = 0;\n+    int i;\n+    int j;\n+\n+    for (np = 0; np < num; ++np) {\n+        if (secp256k1_scalar_is_zero(&sc[np]) || secp256k1_ge_is_infinity(&pt[np])) {\n+            continue;\n+        }\n+        state->ps[no].input_pos = np;\n+        state->ps[no].skew_na = secp256k1_wnaf_fixed(&state->wnaf_na[no*n_wnaf], &sc[np], bucket_window+1);\n+        no++;\n+    }\n+    secp256k1_gej_set_infinity(r);\n+\n+    if (no == 0) {\n         return 1;\n     }\n \n-    while (in_pos < n) {\n-        secp256k1_ge point;\n-        if (!cb(&scalars[out_pos], &point, in_pos, cbdata)) return 0;\n-        secp256k1_gej_set_ge(&points[out_pos], &point);\n-        ++in_pos;\n-        ++out_pos;\n-        if (out_pos == points_per_batch || in_pos == n) {\n-            secp256k1_ecmult_strauss_wnaf(ctx, &state, first ? r : &acc, out_pos, points, scalars, first ? inp_g_sc : NULL);\n-            if (!first) {\n-                secp256k1_gej_add_var(r, r, &acc, NULL);\n+    for (i = n_wnaf - 1; i >= 0; i--) {\n+        secp256k1_gej running_sum;\n+        secp256k1_gej walking_sum;\n+\n+        for(j = 0; j < ECMULT_TABLE_SIZE(bucket_window+2); j++) {\n+            secp256k1_gej_set_infinity(&buckets[j]);\n+        }\n+        for(j = 0; j < bucket_window+1; j++) {\n+            secp256k1_gej_double_var(r, r, NULL);\n+        }\n+\n+        for (np = 0; np < no; ++np) {\n+            int n = state->wnaf_na[np*n_wnaf + i];\n+            struct secp256k1_pippenger_point_state point_state = state->ps[np];\n+            secp256k1_ge tmp;\n+            int idx;\n+\n+#ifdef USE_ENDOMORPHISM\n+            if (i == 0) {\n+                /* correct for wnaf skew */\n+                int skew = point_state.skew_na;\n+                if (skew) {\n+                    secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                    secp256k1_gej_add_ge_var(&buckets[0], &buckets[0], &tmp, NULL);\n+                }\n+            }\n+#endif\n+            if (n > 0) {\n+                idx = (n - 1)/2;\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &pt[point_state.input_pos], NULL);\n+            } else if (n < 0) {\n+                idx = -(n + 1)/2;\n+                secp256k1_ge_neg(&tmp, &pt[point_state.input_pos]);\n+                secp256k1_gej_add_ge_var(&buckets[idx], &buckets[idx], &tmp, NULL);\n             }\n-            first = 0;\n-            out_pos = 0;\n         }\n+        secp256k1_gej_set_infinity(&running_sum);\n+        secp256k1_gej_set_infinity(&walking_sum);\n+        /* Compute walking_sum as bucket[0] + 3*bucket[1] + 5*bucket[2] + ...\n+         * by first setting\n+         * running_sum = bucket[0] +   bucket[1] +   bucket[2] + ...\n+         * walking_sum = bucket[0] + 2*bucket[1] + 3*bucket[2] + ...\n+         * and then computing\n+         * walking_sum = 2*walking_sum - running_sum\n+         */\n+        for(j = ECMULT_TABLE_SIZE(bucket_window+2) - 1; j >= 0; j--) {\n+            secp256k1_gej_add_var(&running_sum, &running_sum, &buckets[j], NULL);\n+            secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        }\n+\n+        secp256k1_gej_double_var(&walking_sum, &walking_sum, NULL);\n+        secp256k1_gej_neg(&running_sum, &running_sum);\n+        secp256k1_gej_add_var(&walking_sum, &walking_sum, &running_sum, NULL);\n+        secp256k1_gej_add_var(r, r, &walking_sum, NULL);\n     }\n     return 1;\n }\n \n-static int secp256k1_ecmult_multi(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_multi_split_strauss_wnaf(ctx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n);\n+/**\n+ * Returns optimal bucket_window (number of bits of a scalar represented by a\n+ * set of buckets) for a given number of points.\n+ */\n+static int secp256k1_pippenger_bucket_window(size_t n) {\n+#ifdef USE_ENDOMORPHISM\n+    if (n <= 4) {\n+        return 1;\n+    } else if (n <= 8) {\n+        return 2;\n+    } else if (n <= 40) {\n+        return 3;\n+    } else if (n <= 117) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 480) {\n+        return 6;\n+    } else if (n <= 2560) {\n+        return 7;\n+    } else if (n <= 9200) {\n+        return 9;\n+    } else if (n <= 17400) {\n+        return 10;\n+    } else if (n <= 28600) {\n+        return 11;\n+    } else {\n+        return 12;\n+    }\n+#else\n+    if (n <= 2) {\n+        return 1;\n+    } else if (n <= 9) {\n+        return 2;\n+    } else if (n <= 42) {\n+        return 3;\n+    } else if (n <= 100) {\n+        return 4;\n+    } else if (n <= 280) {\n+        return 5;\n+    } else if (n <= 610) {\n+        return 6;\n+    } else if (n <= 1920) {\n+        return 7;\n+    } else if (n <= 3400) {\n+        return 8;\n+    } else if (n <= 10240) {\n+        return 9;\n+    } else if (n <= 19000) {\n+        return 10;\n+    } else if (n <= 35000) {\n+        return 11;\n+    } else {\n+        return 12;\n+    }\n+#endif\n+}\n+\n+#ifdef USE_ENDOMORPHISM\n+SECP256K1_INLINE static void secp256k1_ecmult_endo_split(secp256k1_scalar *s1, secp256k1_scalar *s2, secp256k1_ge *p1, secp256k1_ge *p2) {\n+    secp256k1_scalar tmp = *s1;\n+    secp256k1_scalar_split_lambda(s1, s2, &tmp);\n+    secp256k1_ge_mul_lambda(p2, p1);\n+\n+    if (secp256k1_scalar_is_high(s1)) {\n+        secp256k1_scalar_negate(s1, s1);\n+        secp256k1_ge_neg(p1, p1);\n+    }\n+    if (secp256k1_scalar_is_high(s2)) {\n+        secp256k1_scalar_negate(s2, s2);\n+        secp256k1_ge_neg(p2, p2);\n+    }\n+}\n+#endif\n+\n+/**\n+ * Returns the scratch size required for a given number of points (excluding\n+ * base point G) without considering alignment.\n+ */\n+static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_window) {\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    size_t entry_size = sizeof(secp256k1_ge) + sizeof(secp256k1_scalar) + sizeof(struct secp256k1_pippenger_point_state) + (WNAF_SIZE(bucket_window+1)+1)*sizeof(int);\n+    return ((1<<bucket_window) * sizeof(secp256k1_gej) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size);\n+}\n+\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n+     * sizes. The reason for +1 is that we add the G scalar to the list of\n+     * other scalars. */\n+#ifdef USE_ENDOMORPHISM\n+    size_t entries = 2*n_points + 2;\n+#else\n+    size_t entries = n_points + 1;\n+#endif\n+    secp256k1_ge *points;\n+    secp256k1_scalar *scalars;\n+    secp256k1_gej *buckets;\n+    struct secp256k1_pippenger_state *state_space;\n+    size_t idx = 0;\n+    size_t point_idx = 0;\n+    int i, j;\n+    int bucket_window;\n+\n+    (void)ctx;\n+    secp256k1_gej_set_infinity(r);\n+    if (inp_g_sc == NULL && n_points == 0) {\n+        return 1;\n+    }\n+\n+    bucket_window = secp256k1_pippenger_bucket_window(n_points);\n+    if (!secp256k1_scratch_resize(scratch, error_callback, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+        return 0;\n+    }\n+    secp256k1_scratch_reset(scratch);\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, (1<<bucket_window) * sizeof(*buckets));\n+\n+    if (inp_g_sc != NULL) {\n+        scalars[0] = *inp_g_sc;\n+        points[0] = secp256k1_ge_const_g;\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[0], &scalars[1], &points[0], &points[1]);\n+        idx++;\n+#endif\n+    }\n+\n+    while (point_idx < n_points) {\n+        if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n+            return 0;\n+        }\n+        idx++;\n+#ifdef USE_ENDOMORPHISM\n+        secp256k1_ecmult_endo_split(&scalars[idx - 1], &scalars[idx], &points[idx - 1], &points[idx]);\n+        idx++;\n+#endif\n+        point_idx++;\n+    }\n+\n+    secp256k1_ecmult_pippenger_wnaf(buckets, bucket_window, state_space, r, scalars, points, idx);\n+\n+    /* Clear data */\n+    for(i = 0; (size_t)i < idx; i++) {\n+        secp256k1_scalar_clear(&scalars[i]);\n+        state_space->ps[i].skew_na = 0;\n+        for(j = 0; j < WNAF_SIZE(bucket_window+1); j++) {\n+            state_space->wnaf_na[i * WNAF_SIZE(bucket_window+1) + j] = 0;\n+        }\n+    }\n+    for(i = 0; i < 1<<bucket_window; i++) {\n+        secp256k1_gej_clear(&buckets[i]);\n+    }\n+    return 1;\n+}\n+\n+/* Wrapper for secp256k1_ecmult_multi_func interface */\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, const secp256k1_callback* error_callback, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(actx, scratch, error_callback, r, inp_g_sc, cb, cbdata, n, 0);\n+}\n+\n+#define MAX_BATCH_SIZE 1024\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_ecmult_context*, secp256k1_scratch*, const secp256k1_callback*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);",
      "path": "src/ecmult_impl.h",
      "position": null,
      "original_position": 460,
      "commit_id": "d2f9c6b5dc8bd8fed20f046b18b368b1715d720a",
      "original_commit_id": "396615f1b5ecb0cb501d9358ee8cef320c9323c3",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd like this definition and the two wrapper functions to be moved to `src/ecmult.h` rather than the `_impl` file. @sipa do you have thoughts on that? These are used (only) in bench_ecmult.c and tests.c.",
      "created_at": "2017-12-07T16:29:02Z",
      "updated_at": "2017-12-07T20:13:09Z",
      "html_url": "https://github.com/bitcoin-core/secp256k1/pull/486#discussion_r155571595",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/comments/155571595"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin-core/secp256k1/pulls/486"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 869,
      "side": "RIGHT"
    }
  ]
}